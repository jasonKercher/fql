
// Generated from TSqlParser.g4 by ANTLR 4.7.2


#include "TSqlParserListener.h"

#include "TSqlParser.h"


using namespace antlrcpp;
using namespace antlr4;

TSqlParser::TSqlParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

TSqlParser::~TSqlParser() {
  delete _interpreter;
}

std::string TSqlParser::getGrammarFileName() const {
  return "TSqlParser.g4";
}

const std::vector<std::string>& TSqlParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& TSqlParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- Tsql_fileContext ------------------------------------------------------------------

TSqlParser::Tsql_fileContext::Tsql_fileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Tsql_fileContext::EOF() {
  return getToken(TSqlParser::EOF, 0);
}

std::vector<TSqlParser::BatchContext *> TSqlParser::Tsql_fileContext::batch() {
  return getRuleContexts<TSqlParser::BatchContext>();
}

TSqlParser::BatchContext* TSqlParser::Tsql_fileContext::batch(size_t i) {
  return getRuleContext<TSqlParser::BatchContext>(i);
}


size_t TSqlParser::Tsql_fileContext::getRuleIndex() const {
  return TSqlParser::RuleTsql_file;
}

void TSqlParser::Tsql_fileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsql_file(this);
}

void TSqlParser::Tsql_fileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsql_file(this);
}

TSqlParser::Tsql_fileContext* TSqlParser::tsql_file() {
  Tsql_fileContext *_localctx = _tracker.createInstance<Tsql_fileContext>(_ctx, getState());
  enterRule(_localctx, 0, TSqlParser::RuleTsql_file);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(511);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << TSqlParser::ABS)
      | (1ULL << TSqlParser::ALTER)
      | (1ULL << TSqlParser::ASCII)
      | (1ULL << TSqlParser::BEGIN)
      | (1ULL << TSqlParser::BLOCKING_HIERARCHY)
      | (1ULL << TSqlParser::BREAK)
      | (1ULL << TSqlParser::CALLED)
      | (1ULL << TSqlParser::CASE)
      | (1ULL << TSqlParser::CEILING)
      | (1ULL << TSqlParser::CHARINDEX)
      | (1ULL << TSqlParser::CLOSE)
      | (1ULL << TSqlParser::COALESCE)
      | (1ULL << TSqlParser::COMMIT))) != 0) || ((((_la - 69) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 69)) & ((1ULL << (TSqlParser::CONTINUE - 69))
      | (1ULL << (TSqlParser::CONVERT - 69))
      | (1ULL << (TSqlParser::CREATE - 69))
      | (1ULL << (TSqlParser::CURRENT_TIMESTAMP - 69))
      | (1ULL << (TSqlParser::CURRENT_USER - 69))
      | (1ULL << (TSqlParser::DATA_COMPRESSION - 69))
      | (1ULL << (TSqlParser::DBCC - 69))
      | (1ULL << (TSqlParser::DEALLOCATE - 69))
      | (1ULL << (TSqlParser::DECLARE - 69))
      | (1ULL << (TSqlParser::DEFAULT - 69))
      | (1ULL << (TSqlParser::DELETE - 69))
      | (1ULL << (TSqlParser::DROP - 69))
      | (1ULL << (TSqlParser::END - 69))
      | (1ULL << (TSqlParser::EVENTDATA - 69))
      | (1ULL << (TSqlParser::EXECUTE - 69))
      | (1ULL << (TSqlParser::FETCH - 69)))) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & ((1ULL << (TSqlParser::FILENAME - 133))
      | (1ULL << (TSqlParser::FILLFACTOR - 133))
      | (1ULL << (TSqlParser::FLOOR - 133))
      | (1ULL << (TSqlParser::FORCESEEK - 133))
      | (1ULL << (TSqlParser::GET - 133))
      | (1ULL << (TSqlParser::GOTO - 133))
      | (1ULL << (TSqlParser::IDENTITY - 133))
      | (1ULL << (TSqlParser::IF - 133))
      | (1ULL << (TSqlParser::IIF - 133))
      | (1ULL << (TSqlParser::INIT - 133))
      | (1ULL << (TSqlParser::INSERT - 133))
      | (1ULL << (TSqlParser::ISDATE - 133))
      | (1ULL << (TSqlParser::ISNULL - 133))
      | (1ULL << (TSqlParser::ISNUMERIC - 133))
      | (1ULL << (TSqlParser::KEY - 133))
      | (1ULL << (TSqlParser::KILL - 133))
      | (1ULL << (TSqlParser::LEFT - 133))
      | (1ULL << (TSqlParser::LEN - 133))
      | (1ULL << (TSqlParser::LOWER - 133))
      | (1ULL << (TSqlParser::LTRIM - 133)))) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 198)) & ((1ULL << (TSqlParser::MASTER - 198))
      | (1ULL << (TSqlParser::MAX_MEMORY - 198))
      | (1ULL << (TSqlParser::MERGE - 198))
      | (1ULL << (TSqlParser::MONTH - 198))
      | (1ULL << (TSqlParser::NCHAR - 198))
      | (1ULL << (TSqlParser::null - 198))
      | (1ULL << (TSqlParser::NULLIF - 198))
      | (1ULL << (TSqlParser::OFFSETS - 198))
      | (1ULL << (TSqlParser::OPEN - 198))
      | (1ULL << (TSqlParser::OVER - 198))
      | (1ULL << (TSqlParser::PAGE - 198))
      | (1ULL << (TSqlParser::PATINDEX - 198)))) != 0) || ((((_la - 269) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 269)) & ((1ULL << (TSqlParser::PRINT - 269))
      | (1ULL << (TSqlParser::PUBLIC - 269))
      | (1ULL << (TSqlParser::R - 269))
      | (1ULL << (TSqlParser::RAISERROR - 269))
      | (1ULL << (TSqlParser::RAND - 269))
      | (1ULL << (TSqlParser::RAW - 269))
      | (1ULL << (TSqlParser::RECONFIGURE - 269))
      | (1ULL << (TSqlParser::REPLACE - 269))
      | (1ULL << (TSqlParser::RETURN - 269))
      | (1ULL << (TSqlParser::RETURNS - 269))
      | (1ULL << (TSqlParser::RIGHT - 269))
      | (1ULL << (TSqlParser::ROLLBACK - 269))
      | (1ULL << (TSqlParser::ROUND - 269))
      | (1ULL << (TSqlParser::ROWCOUNT - 269))
      | (1ULL << (TSqlParser::RTRIM - 269))
      | (1ULL << (TSqlParser::SAFETY - 269))
      | (1ULL << (TSqlParser::SAVE - 269))
      | (1ULL << (TSqlParser::SELECT - 269))
      | (1ULL << (TSqlParser::SERVER - 269))
      | (1ULL << (TSqlParser::SESSION_USER - 269))
      | (1ULL << (TSqlParser::SET - 269)))) != 0) || ((((_la - 333) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 333)) & ((1ULL << (TSqlParser::SETUSER - 333))
      | (1ULL << (TSqlParser::SIGN - 333))
      | (1ULL << (TSqlParser::SHUTDOWN - 333))
      | (1ULL << (TSqlParser::SID - 333))
      | (1ULL << (TSqlParser::SOURCE - 333))
      | (1ULL << (TSqlParser::SPACE - 333))
      | (1ULL << (TSqlParser::SPLIT - 333))
      | (1ULL << (TSqlParser::STATE - 333))
      | (1ULL << (TSqlParser::START - 333))
      | (1ULL << (TSqlParser::STR - 333))
      | (1ULL << (TSqlParser::SYSTEM_USER - 333))
      | (1ULL << (TSqlParser::TARGET - 333))
      | (1ULL << (TSqlParser::TRUNCATE - 333))
      | (1ULL << (TSqlParser::UPDATE - 333))
      | (1ULL << (TSqlParser::UPPER - 333))
      | (1ULL << (TSqlParser::USE - 333))
      | (1ULL << (TSqlParser::USER_NAME - 333))
      | (1ULL << (TSqlParser::WAITFOR - 333)))) != 0) || ((((_la - 397) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 397)) & ((1ULL << (TSqlParser::WHILE - 397))
      | (1ULL << (TSqlParser::WITH - 397))
      | (1ULL << (TSqlParser::YEAR - 397))
      | (1ULL << (TSqlParser::ABSOLUTE - 397))
      | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 397))
      | (1ULL << (TSqlParser::ACTION - 397))
      | (1ULL << (TSqlParser::ACTIVATION - 397))
      | (1ULL << (TSqlParser::ACTIVE - 397))
      | (1ULL << (TSqlParser::ADDRESS - 397))
      | (1ULL << (TSqlParser::AES_128 - 397))
      | (1ULL << (TSqlParser::AES_192 - 397))
      | (1ULL << (TSqlParser::AES_256 - 397))
      | (1ULL << (TSqlParser::AFFINITY - 397))
      | (1ULL << (TSqlParser::AFTER - 397))
      | (1ULL << (TSqlParser::AGGREGATE - 397))
      | (1ULL << (TSqlParser::ALGORITHM - 397))
      | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 397))
      | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 397))
      | (1ULL << (TSqlParser::ALLOWED - 397))
      | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 397))
      | (1ULL << (TSqlParser::ANSI_NULLS - 397))
      | (1ULL << (TSqlParser::ANSI_PADDING - 397))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 397))
      | (1ULL << (TSqlParser::APPLICATION_LOG - 397))
      | (1ULL << (TSqlParser::APPLY - 397))
      | (1ULL << (TSqlParser::ARITHABORT - 397))
      | (1ULL << (TSqlParser::ASSEMBLY - 397))
      | (1ULL << (TSqlParser::AUDIT - 397))
      | (1ULL << (TSqlParser::AUDIT_GUID - 397))
      | (1ULL << (TSqlParser::AUTO - 397))
      | (1ULL << (TSqlParser::AUTO_CLEANUP - 397))
      | (1ULL << (TSqlParser::AUTO_CLOSE - 397))
      | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 397))
      | (1ULL << (TSqlParser::AUTO_SHRINK - 397))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 397))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 397))
      | (1ULL << (TSqlParser::AVAILABILITY - 397))
      | (1ULL << (TSqlParser::AVG - 397))
      | (1ULL << (TSqlParser::BACKUP_PRIORITY - 397))
      | (1ULL << (TSqlParser::BEGIN_DIALOG - 397))
      | (1ULL << (TSqlParser::BIGINT - 397))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 397))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 397))
      | (1ULL << (TSqlParser::BINDING - 397))
      | (1ULL << (TSqlParser::BLOB_STORAGE - 397))
      | (1ULL << (TSqlParser::BROKER - 397))
      | (1ULL << (TSqlParser::BROKER_INSTANCE - 397))
      | (1ULL << (TSqlParser::BULK_LOGGED - 397))
      | (1ULL << (TSqlParser::CALLER - 397))
      | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 397))
      | (1ULL << (TSqlParser::CAST - 397))
      | (1ULL << (TSqlParser::CATALOG - 397))
      | (1ULL << (TSqlParser::CATCH - 397))
      | (1ULL << (TSqlParser::CHANGE_RETENTION - 397))
      | (1ULL << (TSqlParser::CHANGE_TRACKING - 397))
      | (1ULL << (TSqlParser::CHECKSUM - 397))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 397))
      | (1ULL << (TSqlParser::CLEANUP - 397))
      | (1ULL << (TSqlParser::COLLECTION - 397)))) != 0) || ((((_la - 461) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 461)) & ((1ULL << (TSqlParser::COLUMN_MASTER_KEY - 461))
      | (1ULL << (TSqlParser::COMMITTED - 461))
      | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 461))
      | (1ULL << (TSqlParser::CONCAT - 461))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 461))
      | (1ULL << (TSqlParser::CONTENT - 461))
      | (1ULL << (TSqlParser::CONTROL - 461))
      | (1ULL << (TSqlParser::COOKIE - 461))
      | (1ULL << (TSqlParser::COUNT - 461))
      | (1ULL << (TSqlParser::COUNT_BIG - 461))
      | (1ULL << (TSqlParser::COUNTER - 461))
      | (1ULL << (TSqlParser::CPU - 461))
      | (1ULL << (TSqlParser::CREATE_NEW - 461))
      | (1ULL << (TSqlParser::CREATION_DISPOSITION - 461))
      | (1ULL << (TSqlParser::CREDENTIAL - 461))
      | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 461))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 461))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 461))
      | (1ULL << (TSqlParser::DATA - 461))
      | (1ULL << (TSqlParser::DATALENGTH - 461))
      | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 461))
      | (1ULL << (TSqlParser::DATEADD - 461))
      | (1ULL << (TSqlParser::DATEDIFF - 461))
      | (1ULL << (TSqlParser::DATENAME - 461))
      | (1ULL << (TSqlParser::DATEPART - 461))
      | (1ULL << (TSqlParser::DAY - 461))
      | (1ULL << (TSqlParser::DAYS - 461))
      | (1ULL << (TSqlParser::DB_CHAINING - 461))
      | (1ULL << (TSqlParser::DB_FAILOVER - 461))
      | (1ULL << (TSqlParser::DECRYPTION - 461))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 461))
      | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 461))
      | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 461))
      | (1ULL << (TSqlParser::DELAY - 461))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 461))
      | (1ULL << (TSqlParser::DELETED - 461))
      | (1ULL << (TSqlParser::DENSE_RANK - 461))
      | (1ULL << (TSqlParser::DEPENDENTS - 461))
      | (1ULL << (TSqlParser::DES - 461))
      | (1ULL << (TSqlParser::DESCRIPTION - 461))
      | (1ULL << (TSqlParser::DESX - 461))
      | (1ULL << (TSqlParser::DHCP - 461))
      | (1ULL << (TSqlParser::DIALOG - 461))
      | (1ULL << (TSqlParser::DIRECTORY_NAME - 461))
      | (1ULL << (TSqlParser::DISABLE - 461))
      | (1ULL << (TSqlParser::DISABLE_BROKER - 461))
      | (1ULL << (TSqlParser::DISABLED - 461))
      | (1ULL << (TSqlParser::DISK_DRIVE - 461))
      | (1ULL << (TSqlParser::DOCUMENT - 461))
      | (1ULL << (TSqlParser::DYNAMIC - 461))
      | (1ULL << (TSqlParser::EMERGENCY - 461))
      | (1ULL << (TSqlParser::EMPTY - 461))
      | (1ULL << (TSqlParser::ENABLE - 461))
      | (1ULL << (TSqlParser::ENABLE_BROKER - 461))
      | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 461))
      | (1ULL << (TSqlParser::ENCRYPTION - 461))
      | (1ULL << (TSqlParser::ENDPOINT_URL - 461))
      | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 461))
      | (1ULL << (TSqlParser::EXCLUSIVE - 461))
      | (1ULL << (TSqlParser::EXECUTABLE - 461))
      | (1ULL << (TSqlParser::EXIST - 461))
      | (1ULL << (TSqlParser::EXPAND - 461))
      | (1ULL << (TSqlParser::EXPIRY_DATE - 461)))) != 0) || ((((_la - 525) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 525)) & ((1ULL << (TSqlParser::EXPLICIT - 525))
      | (1ULL << (TSqlParser::FAIL_OPERATION - 525))
      | (1ULL << (TSqlParser::FAILOVER_MODE - 525))
      | (1ULL << (TSqlParser::FAILURE - 525))
      | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 525))
      | (1ULL << (TSqlParser::FAST - 525))
      | (1ULL << (TSqlParser::FAST_FORWARD - 525))
      | (1ULL << (TSqlParser::FILEGROUP - 525))
      | (1ULL << (TSqlParser::FILEGROWTH - 525))
      | (1ULL << (TSqlParser::FILEPATH - 525))
      | (1ULL << (TSqlParser::FILESTREAM - 525))
      | (1ULL << (TSqlParser::FILTER - 525))
      | (1ULL << (TSqlParser::FIRST - 525))
      | (1ULL << (TSqlParser::FIRST_VALUE - 525))
      | (1ULL << (TSqlParser::FOLLOWING - 525))
      | (1ULL << (TSqlParser::FORCE - 525))
      | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 525))
      | (1ULL << (TSqlParser::FORCED - 525))
      | (1ULL << (TSqlParser::FORMAT - 525))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 525))
      | (1ULL << (TSqlParser::FULLSCAN - 525))
      | (1ULL << (TSqlParser::FULLTEXT - 525))
      | (1ULL << (TSqlParser::GB - 525))
      | (1ULL << (TSqlParser::GETDATE - 525))
      | (1ULL << (TSqlParser::GETUTCDATE - 525))
      | (1ULL << (TSqlParser::GLOBAL - 525))
      | (1ULL << (TSqlParser::GO - 525))
      | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 525))
      | (1ULL << (TSqlParser::GROUPING - 525))
      | (1ULL << (TSqlParser::GROUPING_ID - 525))
      | (1ULL << (TSqlParser::HADR - 525))
      | (1ULL << (TSqlParser::HASH - 525))
      | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 525))
      | (1ULL << (TSqlParser::HIGH - 525))
      | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 525))
      | (1ULL << (TSqlParser::HOURS - 525))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 525))
      | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 525))
      | (1ULL << (TSqlParser::IMMEDIATE - 525))
      | (1ULL << (TSqlParser::IMPERSONATE - 525))
      | (1ULL << (TSqlParser::IMPORTANCE - 525))
      | (1ULL << (TSqlParser::INCREMENTAL - 525))
      | (1ULL << (TSqlParser::INITIATOR - 525))
      | (1ULL << (TSqlParser::INPUT - 525))
      | (1ULL << (TSqlParser::INSENSITIVE - 525))
      | (1ULL << (TSqlParser::INSERTED - 525))
      | (1ULL << (TSqlParser::INT - 525))
      | (1ULL << (TSqlParser::IP - 525))
      | (1ULL << (TSqlParser::ISOLATION - 525))
      | (1ULL << (TSqlParser::KB - 525))
      | (1ULL << (TSqlParser::KEEP - 525))
      | (1ULL << (TSqlParser::KEEPFIXED - 525))
      | (1ULL << (TSqlParser::KEY_SOURCE - 525))
      | (1ULL << (TSqlParser::KEYS - 525))
      | (1ULL << (TSqlParser::KEYSET - 525))
      | (1ULL << (TSqlParser::LAG - 525))
      | (1ULL << (TSqlParser::LAST - 525))
      | (1ULL << (TSqlParser::LAST_VALUE - 525))
      | (1ULL << (TSqlParser::LEAD - 525))
      | (1ULL << (TSqlParser::LEVEL - 525))
      | (1ULL << (TSqlParser::LIST - 525)))) != 0) || ((((_la - 589) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 589)) & ((1ULL << (TSqlParser::LISTENER - 589))
      | (1ULL << (TSqlParser::LISTENER_URL - 589))
      | (1ULL << (TSqlParser::LOB_COMPACTION - 589))
      | (1ULL << (TSqlParser::LOCAL - 589))
      | (1ULL << (TSqlParser::LOCATION - 589))
      | (1ULL << (TSqlParser::LOCK - 589))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 589))
      | (1ULL << (TSqlParser::LOGIN - 589))
      | (1ULL << (TSqlParser::LOOP - 589))
      | (1ULL << (TSqlParser::LOW - 589))
      | (1ULL << (TSqlParser::MANUAL - 589))
      | (1ULL << (TSqlParser::MARK - 589))
      | (1ULL << (TSqlParser::MATERIALIZED - 589))
      | (1ULL << (TSqlParser::MAX - 589))
      | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 589))
      | (1ULL << (TSqlParser::MAX_DOP - 589))
      | (1ULL << (TSqlParser::MAX_FILES - 589))
      | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 589))
      | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 589))
      | (1ULL << (TSqlParser::MAX_PROCESSES - 589))
      | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 589))
      | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 589))
      | (1ULL << (TSqlParser::MAXDOP - 589))
      | (1ULL << (TSqlParser::MAXRECURSION - 589))
      | (1ULL << (TSqlParser::MAXSIZE - 589))
      | (1ULL << (TSqlParser::MB - 589))
      | (1ULL << (TSqlParser::MEDIUM - 589))
      | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 589))
      | (1ULL << (TSqlParser::MESSAGE - 589))
      | (1ULL << (TSqlParser::MIN - 589))
      | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 589))
      | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 589))
      | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 589))
      | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 589))
      | (1ULL << (TSqlParser::MINUTES - 589))
      | (1ULL << (TSqlParser::MIRROR_ADDRESS - 589))
      | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 589))
      | (1ULL << (TSqlParser::MODE - 589))
      | (1ULL << (TSqlParser::MODIFY - 589))
      | (1ULL << (TSqlParser::MOVE - 589))
      | (1ULL << (TSqlParser::MULTI_USER - 589))
      | (1ULL << (TSqlParser::NAME - 589))
      | (1ULL << (TSqlParser::NESTED_TRIGGERS - 589))
      | (1ULL << (TSqlParser::NEW_ACCOUNT - 589))
      | (1ULL << (TSqlParser::NEW_BROKER - 589))
      | (1ULL << (TSqlParser::NEW_PASSWORD - 589))
      | (1ULL << (TSqlParser::NEXT - 589))
      | (1ULL << (TSqlParser::NO - 589))
      | (1ULL << (TSqlParser::NO_TRUNCATE - 589))
      | (1ULL << (TSqlParser::NO_WAIT - 589))
      | (1ULL << (TSqlParser::NOCOUNT - 589))
      | (1ULL << (TSqlParser::NODES - 589))
      | (1ULL << (TSqlParser::NOEXPAND - 589))
      | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 589))
      | (1ULL << (TSqlParser::NORECOMPUTE - 589))
      | (1ULL << (TSqlParser::NORECOVERY - 589))
      | (1ULL << (TSqlParser::NOWAIT - 589))
      | (1ULL << (TSqlParser::NTILE - 589))
      | (1ULL << (TSqlParser::NUMANODE - 589))
      | (1ULL << (TSqlParser::NUMBER - 589))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 589))
      | (1ULL << (TSqlParser::OBJECT - 589))
      | (1ULL << (TSqlParser::OFFLINE - 589))
      | (1ULL << (TSqlParser::OFFSET - 589)))) != 0) || ((((_la - 653) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 653)) & ((1ULL << (TSqlParser::OLD_ACCOUNT - 653))
      | (1ULL << (TSqlParser::ONLINE - 653))
      | (1ULL << (TSqlParser::ONLY - 653))
      | (1ULL << (TSqlParser::OPEN_EXISTING - 653))
      | (1ULL << (TSqlParser::OPTIMISTIC - 653))
      | (1ULL << (TSqlParser::OPTIMIZE - 653))
      | (1ULL << (TSqlParser::OUT - 653))
      | (1ULL << (TSqlParser::OUTPUT - 653))
      | (1ULL << (TSqlParser::OWNER - 653))
      | (1ULL << (TSqlParser::PAGE_VERIFY - 653))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 653))
      | (1ULL << (TSqlParser::PARTITION - 653))
      | (1ULL << (TSqlParser::PARTITIONS - 653))
      | (1ULL << (TSqlParser::PARTNER - 653))
      | (1ULL << (TSqlParser::PATH - 653))
      | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 653))
      | (1ULL << (TSqlParser::POOL - 653))
      | (1ULL << (TSqlParser::PORT - 653))
      | (1ULL << (TSqlParser::PRECEDING - 653))
      | (1ULL << (TSqlParser::PRIMARY_ROLE - 653))
      | (1ULL << (TSqlParser::PRIOR - 653))
      | (1ULL << (TSqlParser::PRIORITY - 653))
      | (1ULL << (TSqlParser::PRIORITY_LEVEL - 653))
      | (1ULL << (TSqlParser::PRIVATE - 653))
      | (1ULL << (TSqlParser::PRIVATE_KEY - 653))
      | (1ULL << (TSqlParser::PRIVILEGES - 653))
      | (1ULL << (TSqlParser::PROCEDURE_NAME - 653))
      | (1ULL << (TSqlParser::PROPERTY - 653))
      | (1ULL << (TSqlParser::PROVIDER - 653))
      | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 653))
      | (1ULL << (TSqlParser::QUERY - 653))
      | (1ULL << (TSqlParser::QUEUE - 653))
      | (1ULL << (TSqlParser::QUEUE_DELAY - 653))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 653))
      | (1ULL << (TSqlParser::RANGE - 653))
      | (1ULL << (TSqlParser::RANK - 653))
      | (1ULL << (TSqlParser::RC2 - 653))
      | (1ULL << (TSqlParser::RC4 - 653))
      | (1ULL << (TSqlParser::RC4_128 - 653))
      | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 653))
      | (1ULL << (TSqlParser::READ_ONLY - 653))
      | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 653))
      | (1ULL << (TSqlParser::READ_WRITE - 653))
      | (1ULL << (TSqlParser::READONLY - 653))
      | (1ULL << (TSqlParser::REBUILD - 653))
      | (1ULL << (TSqlParser::RECEIVE - 653))
      | (1ULL << (TSqlParser::RECOMPILE - 653))
      | (1ULL << (TSqlParser::RECOVERY - 653))
      | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 653))
      | (1ULL << (TSqlParser::RELATIVE - 653))
      | (1ULL << (TSqlParser::REMOTE - 653))
      | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 653))
      | (1ULL << (TSqlParser::REMOVE - 653))
      | (1ULL << (TSqlParser::REORGANIZE - 653))
      | (1ULL << (TSqlParser::REPEATABLE - 653))
      | (1ULL << (TSqlParser::REPLICA - 653))
      | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 653))
      | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 653))
      | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 653))
      | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 653))
      | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 653))
      | (1ULL << (TSqlParser::RESOURCE - 653))
      | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 653)))) != 0) || ((((_la - 717) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 717)) & ((1ULL << (TSqlParser::RESTRICTED_USER - 717))
      | (1ULL << (TSqlParser::RETENTION - 717))
      | (1ULL << (TSqlParser::ROBUST - 717))
      | (1ULL << (TSqlParser::ROOT - 717))
      | (1ULL << (TSqlParser::ROUTE - 717))
      | (1ULL << (TSqlParser::ROW - 717))
      | (1ULL << (TSqlParser::ROW_NUMBER - 717))
      | (1ULL << (TSqlParser::ROWGUID - 717))
      | (1ULL << (TSqlParser::ROWS - 717))
      | (1ULL << (TSqlParser::SAMPLE - 717))
      | (1ULL << (TSqlParser::SCHEMABINDING - 717))
      | (1ULL << (TSqlParser::SCOPED - 717))
      | (1ULL << (TSqlParser::SCROLL - 717))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 717))
      | (1ULL << (TSqlParser::SEARCH - 717))
      | (1ULL << (TSqlParser::SECONDARY - 717))
      | (1ULL << (TSqlParser::SECONDARY_ONLY - 717))
      | (1ULL << (TSqlParser::SECONDARY_ROLE - 717))
      | (1ULL << (TSqlParser::SECONDS - 717))
      | (1ULL << (TSqlParser::SECRET - 717))
      | (1ULL << (TSqlParser::SECURITY - 717))
      | (1ULL << (TSqlParser::SECURITY_LOG - 717))
      | (1ULL << (TSqlParser::SEEDING_MODE - 717))
      | (1ULL << (TSqlParser::SELF - 717))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 717))
      | (1ULL << (TSqlParser::SEND - 717))
      | (1ULL << (TSqlParser::SENT - 717))
      | (1ULL << (TSqlParser::SEQUENCE - 717))
      | (1ULL << (TSqlParser::SERIALIZABLE - 717))
      | (1ULL << (TSqlParser::SESSION_TIMEOUT - 717))
      | (1ULL << (TSqlParser::SETERROR - 717))
      | (1ULL << (TSqlParser::SHARE - 717))
      | (1ULL << (TSqlParser::SHOWPLAN - 717))
      | (1ULL << (TSqlParser::SIGNATURE - 717))
      | (1ULL << (TSqlParser::SIMPLE - 717))
      | (1ULL << (TSqlParser::SINGLE_USER - 717))
      | (1ULL << (TSqlParser::SIZE - 717))
      | (1ULL << (TSqlParser::SMALLINT - 717))
      | (1ULL << (TSqlParser::SNAPSHOT - 717))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 717))
      | (1ULL << (TSqlParser::STANDBY - 717))
      | (1ULL << (TSqlParser::START_DATE - 717))
      | (1ULL << (TSqlParser::STATIC - 717))
      | (1ULL << (TSqlParser::STATS_STREAM - 717))
      | (1ULL << (TSqlParser::STATUS - 717))
      | (1ULL << (TSqlParser::STDEV - 717))
      | (1ULL << (TSqlParser::STDEVP - 717))
      | (1ULL << (TSqlParser::STOPLIST - 717))
      | (1ULL << (TSqlParser::STRING_AGG - 717))
      | (1ULL << (TSqlParser::STUFF - 717))
      | (1ULL << (TSqlParser::SUBJECT - 717))
      | (1ULL << (TSqlParser::SUBSTRING - 717))
      | (1ULL << (TSqlParser::SUM - 717))
      | (1ULL << (TSqlParser::SUSPEND - 717))
      | (1ULL << (TSqlParser::SYMMETRIC - 717))
      | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 717))
      | (1ULL << (TSqlParser::SYNONYM - 717))
      | (1ULL << (TSqlParser::SYSTEM - 717))
      | (1ULL << (TSqlParser::TAKE - 717))
      | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 717))
      | (1ULL << (TSqlParser::TB - 717))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 717)))) != 0) || ((((_la - 781) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 781)) & ((1ULL << (TSqlParser::THROW - 781))
      | (1ULL << (TSqlParser::TIES - 781))
      | (1ULL << (TSqlParser::TIME - 781))
      | (1ULL << (TSqlParser::TIMEOUT - 781))
      | (1ULL << (TSqlParser::TIMER - 781))
      | (1ULL << (TSqlParser::TINYINT - 781))
      | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 781))
      | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 781))
      | (1ULL << (TSqlParser::TRIPLE_DES - 781))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 781))
      | (1ULL << (TSqlParser::TRUSTWORTHY - 781))
      | (1ULL << (TSqlParser::TRY - 781))
      | (1ULL << (TSqlParser::TSQL - 781))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 781))
      | (1ULL << (TSqlParser::TYPE - 781))
      | (1ULL << (TSqlParser::TYPE_WARNING - 781))
      | (1ULL << (TSqlParser::UNBOUNDED - 781))
      | (1ULL << (TSqlParser::UNCOMMITTED - 781))
      | (1ULL << (TSqlParser::UNKNOWN - 781))
      | (1ULL << (TSqlParser::UNLIMITED - 781))
      | (1ULL << (TSqlParser::USING - 781))
      | (1ULL << (TSqlParser::VALID_XML - 781))
      | (1ULL << (TSqlParser::VALIDATION - 781))
      | (1ULL << (TSqlParser::VALUE - 781))
      | (1ULL << (TSqlParser::VAR - 781))
      | (1ULL << (TSqlParser::VARP - 781))
      | (1ULL << (TSqlParser::VIEW_METADATA - 781))
      | (1ULL << (TSqlParser::VIEWS - 781))
      | (1ULL << (TSqlParser::WAIT - 781))
      | (1ULL << (TSqlParser::WELL_FORMED_XML - 781))
      | (1ULL << (TSqlParser::WORK - 781))
      | (1ULL << (TSqlParser::WORKLOAD - 781))
      | (1ULL << (TSqlParser::XML - 781))
      | (1ULL << (TSqlParser::XMLNAMESPACES - 781))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 781))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 781))
      | (1ULL << (TSqlParser::LOCAL_ID - 781))
      | (1ULL << (TSqlParser::DECIMAL - 781))
      | (1ULL << (TSqlParser::ID - 781))
      | (1ULL << (TSqlParser::STRING - 781))
      | (1ULL << (TSqlParser::BINARY - 781))
      | (1ULL << (TSqlParser::FLOAT - 781))
      | (1ULL << (TSqlParser::REAL - 781)))) != 0) || ((((_la - 853) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 853)) & ((1ULL << (TSqlParser::DOLLAR - 853))
      | (1ULL << (TSqlParser::LR_BRACKET - 853))
      | (1ULL << (TSqlParser::SEMI - 853))
      | (1ULL << (TSqlParser::PLUS - 853))
      | (1ULL << (TSqlParser::MINUS - 853))
      | (1ULL << (TSqlParser::BIT_NOT - 853)))) != 0)) {
      setState(508);
      batch();
      setState(513);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(514);
    match(TSqlParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BatchContext ------------------------------------------------------------------

TSqlParser::BatchContext::BatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Execute_bodyContext* TSqlParser::BatchContext::execute_body() {
  return getRuleContext<TSqlParser::Execute_bodyContext>(0);
}

std::vector<TSqlParser::Go_statementContext *> TSqlParser::BatchContext::go_statement() {
  return getRuleContexts<TSqlParser::Go_statementContext>();
}

TSqlParser::Go_statementContext* TSqlParser::BatchContext::go_statement(size_t i) {
  return getRuleContext<TSqlParser::Go_statementContext>(i);
}

TSqlParser::Sql_clausesContext* TSqlParser::BatchContext::sql_clauses() {
  return getRuleContext<TSqlParser::Sql_clausesContext>(0);
}


size_t TSqlParser::BatchContext::getRuleIndex() const {
  return TSqlParser::RuleBatch;
}

void TSqlParser::BatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBatch(this);
}

void TSqlParser::BatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBatch(this);
}

TSqlParser::BatchContext* TSqlParser::batch() {
  BatchContext *_localctx = _tracker.createInstance<BatchContext>(_ctx, getState());
  enterRule(_localctx, 2, TSqlParser::RuleBatch);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(533);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(516);
      execute_body();
      setState(520);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(517);
          go_statement(); 
        }
        setState(522);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(524);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
      case 1: {
        setState(523);
        execute_body();
        break;
      }

      }
      setState(526);
      sql_clauses();
      setState(530);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(527);
          go_statement(); 
        }
        setState(532);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_clausesContext ------------------------------------------------------------------

TSqlParser::Sql_clausesContext::Sql_clausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Sql_clauseContext *> TSqlParser::Sql_clausesContext::sql_clause() {
  return getRuleContexts<TSqlParser::Sql_clauseContext>();
}

TSqlParser::Sql_clauseContext* TSqlParser::Sql_clausesContext::sql_clause(size_t i) {
  return getRuleContext<TSqlParser::Sql_clauseContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Sql_clausesContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Sql_clausesContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}


size_t TSqlParser::Sql_clausesContext::getRuleIndex() const {
  return TSqlParser::RuleSql_clauses;
}

void TSqlParser::Sql_clausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_clauses(this);
}

void TSqlParser::Sql_clausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_clauses(this);
}

TSqlParser::Sql_clausesContext* TSqlParser::sql_clauses() {
  Sql_clausesContext *_localctx = _tracker.createInstance<Sql_clausesContext>(_ctx, getState());
  enterRule(_localctx, 4, TSqlParser::RuleSql_clauses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(539); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(535);
              sql_clause();
              setState(537);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
              case 1: {
                setState(536);
                match(TSqlParser::SEMI);
                break;
              }

              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(541); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_clauseContext ------------------------------------------------------------------

TSqlParser::Sql_clauseContext::Sql_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Dml_clauseContext* TSqlParser::Sql_clauseContext::dml_clause() {
  return getRuleContext<TSqlParser::Dml_clauseContext>(0);
}

TSqlParser::Ddl_clauseContext* TSqlParser::Sql_clauseContext::ddl_clause() {
  return getRuleContext<TSqlParser::Ddl_clauseContext>(0);
}

TSqlParser::Cfl_statementContext* TSqlParser::Sql_clauseContext::cfl_statement() {
  return getRuleContext<TSqlParser::Cfl_statementContext>(0);
}

TSqlParser::Dbcc_clauseContext* TSqlParser::Sql_clauseContext::dbcc_clause() {
  return getRuleContext<TSqlParser::Dbcc_clauseContext>(0);
}

TSqlParser::Empty_statementContext* TSqlParser::Sql_clauseContext::empty_statement() {
  return getRuleContext<TSqlParser::Empty_statementContext>(0);
}

TSqlParser::Another_statementContext* TSqlParser::Sql_clauseContext::another_statement() {
  return getRuleContext<TSqlParser::Another_statementContext>(0);
}


size_t TSqlParser::Sql_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleSql_clause;
}

void TSqlParser::Sql_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_clause(this);
}

void TSqlParser::Sql_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_clause(this);
}

TSqlParser::Sql_clauseContext* TSqlParser::sql_clause() {
  Sql_clauseContext *_localctx = _tracker.createInstance<Sql_clauseContext>(_ctx, getState());
  enterRule(_localctx, 6, TSqlParser::RuleSql_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(549);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(543);
      dml_clause();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(544);
      ddl_clause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(545);
      cfl_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(546);
      dbcc_clause();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(547);
      empty_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(548);
      another_statement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dml_clauseContext ------------------------------------------------------------------

TSqlParser::Dml_clauseContext::Dml_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Merge_statementContext* TSqlParser::Dml_clauseContext::merge_statement() {
  return getRuleContext<TSqlParser::Merge_statementContext>(0);
}

TSqlParser::Delete_statementContext* TSqlParser::Dml_clauseContext::delete_statement() {
  return getRuleContext<TSqlParser::Delete_statementContext>(0);
}

TSqlParser::Insert_statementContext* TSqlParser::Dml_clauseContext::insert_statement() {
  return getRuleContext<TSqlParser::Insert_statementContext>(0);
}

TSqlParser::Select_statementContext* TSqlParser::Dml_clauseContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

TSqlParser::Update_statementContext* TSqlParser::Dml_clauseContext::update_statement() {
  return getRuleContext<TSqlParser::Update_statementContext>(0);
}


size_t TSqlParser::Dml_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDml_clause;
}

void TSqlParser::Dml_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDml_clause(this);
}

void TSqlParser::Dml_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDml_clause(this);
}

TSqlParser::Dml_clauseContext* TSqlParser::dml_clause() {
  Dml_clauseContext *_localctx = _tracker.createInstance<Dml_clauseContext>(_ctx, getState());
  enterRule(_localctx, 8, TSqlParser::RuleDml_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(556);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(551);
      merge_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(552);
      delete_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(553);
      insert_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(554);
      select_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(555);
      update_statement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_clauseContext ------------------------------------------------------------------

TSqlParser::Ddl_clauseContext::Ddl_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Alter_schema_sqlContext* TSqlParser::Ddl_clauseContext::alter_schema_sql() {
  return getRuleContext<TSqlParser::Alter_schema_sqlContext>(0);
}

TSqlParser::Alter_tableContext* TSqlParser::Ddl_clauseContext::alter_table() {
  return getRuleContext<TSqlParser::Alter_tableContext>(0);
}

TSqlParser::Create_indexContext* TSqlParser::Ddl_clauseContext::create_index() {
  return getRuleContext<TSqlParser::Create_indexContext>(0);
}

TSqlParser::Create_or_alter_functionContext* TSqlParser::Ddl_clauseContext::create_or_alter_function() {
  return getRuleContext<TSqlParser::Create_or_alter_functionContext>(0);
}

TSqlParser::Create_or_alter_procedureContext* TSqlParser::Ddl_clauseContext::create_or_alter_procedure() {
  return getRuleContext<TSqlParser::Create_or_alter_procedureContext>(0);
}

TSqlParser::Create_schemaContext* TSqlParser::Ddl_clauseContext::create_schema() {
  return getRuleContext<TSqlParser::Create_schemaContext>(0);
}

TSqlParser::Create_tableContext* TSqlParser::Ddl_clauseContext::create_table() {
  return getRuleContext<TSqlParser::Create_tableContext>(0);
}

TSqlParser::Create_typeContext* TSqlParser::Ddl_clauseContext::create_type() {
  return getRuleContext<TSqlParser::Create_typeContext>(0);
}

TSqlParser::Create_viewContext* TSqlParser::Ddl_clauseContext::create_view() {
  return getRuleContext<TSqlParser::Create_viewContext>(0);
}

TSqlParser::Drop_aggregateContext* TSqlParser::Ddl_clauseContext::drop_aggregate() {
  return getRuleContext<TSqlParser::Drop_aggregateContext>(0);
}

TSqlParser::Drop_functionContext* TSqlParser::Ddl_clauseContext::drop_function() {
  return getRuleContext<TSqlParser::Drop_functionContext>(0);
}

TSqlParser::Drop_indexContext* TSqlParser::Ddl_clauseContext::drop_index() {
  return getRuleContext<TSqlParser::Drop_indexContext>(0);
}

TSqlParser::Drop_procedureContext* TSqlParser::Ddl_clauseContext::drop_procedure() {
  return getRuleContext<TSqlParser::Drop_procedureContext>(0);
}

TSqlParser::Drop_schemaContext* TSqlParser::Ddl_clauseContext::drop_schema() {
  return getRuleContext<TSqlParser::Drop_schemaContext>(0);
}

TSqlParser::Drop_tableContext* TSqlParser::Ddl_clauseContext::drop_table() {
  return getRuleContext<TSqlParser::Drop_tableContext>(0);
}

TSqlParser::Drop_typeContext* TSqlParser::Ddl_clauseContext::drop_type() {
  return getRuleContext<TSqlParser::Drop_typeContext>(0);
}

TSqlParser::Drop_viewContext* TSqlParser::Ddl_clauseContext::drop_view() {
  return getRuleContext<TSqlParser::Drop_viewContext>(0);
}

TSqlParser::Lock_tableContext* TSqlParser::Ddl_clauseContext::lock_table() {
  return getRuleContext<TSqlParser::Lock_tableContext>(0);
}

TSqlParser::Truncate_tableContext* TSqlParser::Ddl_clauseContext::truncate_table() {
  return getRuleContext<TSqlParser::Truncate_tableContext>(0);
}


size_t TSqlParser::Ddl_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDdl_clause;
}

void TSqlParser::Ddl_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDdl_clause(this);
}

void TSqlParser::Ddl_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDdl_clause(this);
}

TSqlParser::Ddl_clauseContext* TSqlParser::ddl_clause() {
  Ddl_clauseContext *_localctx = _tracker.createInstance<Ddl_clauseContext>(_ctx, getState());
  enterRule(_localctx, 10, TSqlParser::RuleDdl_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(577);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(558);
      alter_schema_sql();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(559);
      alter_table();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(560);
      create_index();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(561);
      create_or_alter_function();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(562);
      create_or_alter_procedure();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(563);
      create_schema();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(564);
      create_table();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(565);
      create_type();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(566);
      create_view();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(567);
      drop_aggregate();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(568);
      drop_function();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(569);
      drop_index();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(570);
      drop_procedure();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(571);
      drop_schema();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(572);
      drop_table();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(573);
      drop_type();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(574);
      drop_view();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(575);
      lock_table();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(576);
      truncate_table();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cfl_statementContext ------------------------------------------------------------------

TSqlParser::Cfl_statementContext::Cfl_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Block_statementContext* TSqlParser::Cfl_statementContext::block_statement() {
  return getRuleContext<TSqlParser::Block_statementContext>(0);
}

TSqlParser::Break_statementContext* TSqlParser::Cfl_statementContext::break_statement() {
  return getRuleContext<TSqlParser::Break_statementContext>(0);
}

TSqlParser::Continue_statementContext* TSqlParser::Cfl_statementContext::continue_statement() {
  return getRuleContext<TSqlParser::Continue_statementContext>(0);
}

TSqlParser::Goto_statementContext* TSqlParser::Cfl_statementContext::goto_statement() {
  return getRuleContext<TSqlParser::Goto_statementContext>(0);
}

TSqlParser::If_statementContext* TSqlParser::Cfl_statementContext::if_statement() {
  return getRuleContext<TSqlParser::If_statementContext>(0);
}

TSqlParser::Return_statementContext* TSqlParser::Cfl_statementContext::return_statement() {
  return getRuleContext<TSqlParser::Return_statementContext>(0);
}

TSqlParser::Throw_statementContext* TSqlParser::Cfl_statementContext::throw_statement() {
  return getRuleContext<TSqlParser::Throw_statementContext>(0);
}

TSqlParser::Try_catch_statementContext* TSqlParser::Cfl_statementContext::try_catch_statement() {
  return getRuleContext<TSqlParser::Try_catch_statementContext>(0);
}

TSqlParser::Waitfor_statementContext* TSqlParser::Cfl_statementContext::waitfor_statement() {
  return getRuleContext<TSqlParser::Waitfor_statementContext>(0);
}

TSqlParser::While_statementContext* TSqlParser::Cfl_statementContext::while_statement() {
  return getRuleContext<TSqlParser::While_statementContext>(0);
}

TSqlParser::Print_statementContext* TSqlParser::Cfl_statementContext::print_statement() {
  return getRuleContext<TSqlParser::Print_statementContext>(0);
}

TSqlParser::Raiseerror_statementContext* TSqlParser::Cfl_statementContext::raiseerror_statement() {
  return getRuleContext<TSqlParser::Raiseerror_statementContext>(0);
}


size_t TSqlParser::Cfl_statementContext::getRuleIndex() const {
  return TSqlParser::RuleCfl_statement;
}

void TSqlParser::Cfl_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCfl_statement(this);
}

void TSqlParser::Cfl_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCfl_statement(this);
}

TSqlParser::Cfl_statementContext* TSqlParser::cfl_statement() {
  Cfl_statementContext *_localctx = _tracker.createInstance<Cfl_statementContext>(_ctx, getState());
  enterRule(_localctx, 12, TSqlParser::RuleCfl_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(591);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(579);
      block_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(580);
      break_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(581);
      continue_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(582);
      goto_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(583);
      if_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(584);
      return_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(585);
      throw_statement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(586);
      try_catch_statement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(587);
      waitfor_statement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(588);
      while_statement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(589);
      print_statement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(590);
      raiseerror_statement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_statementContext ------------------------------------------------------------------

TSqlParser::Block_statementContext::Block_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Block_statementContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Block_statementContext::END() {
  return getToken(TSqlParser::END, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Block_statementContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Block_statementContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

TSqlParser::Sql_clausesContext* TSqlParser::Block_statementContext::sql_clauses() {
  return getRuleContext<TSqlParser::Sql_clausesContext>(0);
}


size_t TSqlParser::Block_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBlock_statement;
}

void TSqlParser::Block_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_statement(this);
}

void TSqlParser::Block_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_statement(this);
}

TSqlParser::Block_statementContext* TSqlParser::block_statement() {
  Block_statementContext *_localctx = _tracker.createInstance<Block_statementContext>(_ctx, getState());
  enterRule(_localctx, 14, TSqlParser::RuleBlock_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(593);
    match(TSqlParser::BEGIN);
    setState(595);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(594);
      match(TSqlParser::SEMI);
      break;
    }

    }
    setState(598);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(597);
      sql_clauses();
      break;
    }

    }
    setState(600);
    match(TSqlParser::END);
    setState(602);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      setState(601);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_statementContext ------------------------------------------------------------------

TSqlParser::Break_statementContext::Break_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Break_statementContext::BREAK() {
  return getToken(TSqlParser::BREAK, 0);
}

tree::TerminalNode* TSqlParser::Break_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Break_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBreak_statement;
}

void TSqlParser::Break_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_statement(this);
}

void TSqlParser::Break_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_statement(this);
}

TSqlParser::Break_statementContext* TSqlParser::break_statement() {
  Break_statementContext *_localctx = _tracker.createInstance<Break_statementContext>(_ctx, getState());
  enterRule(_localctx, 16, TSqlParser::RuleBreak_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(604);
    match(TSqlParser::BREAK);
    setState(606);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      setState(605);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continue_statementContext ------------------------------------------------------------------

TSqlParser::Continue_statementContext::Continue_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Continue_statementContext::CONTINUE() {
  return getToken(TSqlParser::CONTINUE, 0);
}

tree::TerminalNode* TSqlParser::Continue_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Continue_statementContext::getRuleIndex() const {
  return TSqlParser::RuleContinue_statement;
}

void TSqlParser::Continue_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinue_statement(this);
}

void TSqlParser::Continue_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinue_statement(this);
}

TSqlParser::Continue_statementContext* TSqlParser::continue_statement() {
  Continue_statementContext *_localctx = _tracker.createInstance<Continue_statementContext>(_ctx, getState());
  enterRule(_localctx, 18, TSqlParser::RuleContinue_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    match(TSqlParser::CONTINUE);
    setState(610);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      setState(609);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Goto_statementContext ------------------------------------------------------------------

TSqlParser::Goto_statementContext::Goto_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Goto_statementContext::GOTO() {
  return getToken(TSqlParser::GOTO, 0);
}

TSqlParser::IdContext* TSqlParser::Goto_statementContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Goto_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Goto_statementContext::COLON() {
  return getToken(TSqlParser::COLON, 0);
}


size_t TSqlParser::Goto_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGoto_statement;
}

void TSqlParser::Goto_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoto_statement(this);
}

void TSqlParser::Goto_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoto_statement(this);
}

TSqlParser::Goto_statementContext* TSqlParser::goto_statement() {
  Goto_statementContext *_localctx = _tracker.createInstance<Goto_statementContext>(_ctx, getState());
  enterRule(_localctx, 20, TSqlParser::RuleGoto_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(622);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::GOTO: {
        enterOuterAlt(_localctx, 1);
        setState(612);
        match(TSqlParser::GOTO);
        setState(613);
        id();
        setState(615);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
        case 1: {
          setState(614);
          match(TSqlParser::SEMI);
          break;
        }

        }
        break;
      }

      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 2);
        setState(617);
        id();
        setState(618);
        match(TSqlParser::COLON);
        setState(620);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
        case 1: {
          setState(619);
          match(TSqlParser::SEMI);
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_statementContext ------------------------------------------------------------------

TSqlParser::Return_statementContext::Return_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Return_statementContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Return_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Return_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Return_statementContext::getRuleIndex() const {
  return TSqlParser::RuleReturn_statement;
}

void TSqlParser::Return_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_statement(this);
}

void TSqlParser::Return_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_statement(this);
}

TSqlParser::Return_statementContext* TSqlParser::return_statement() {
  Return_statementContext *_localctx = _tracker.createInstance<Return_statementContext>(_ctx, getState());
  enterRule(_localctx, 22, TSqlParser::RuleReturn_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(624);
    match(TSqlParser::RETURN);
    setState(626);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(625);
      expression(0);
      break;
    }

    }
    setState(629);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(628);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_statementContext ------------------------------------------------------------------

TSqlParser::If_statementContext::If_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::If_statementContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::If_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

std::vector<TSqlParser::Sql_clauseContext *> TSqlParser::If_statementContext::sql_clause() {
  return getRuleContexts<TSqlParser::Sql_clauseContext>();
}

TSqlParser::Sql_clauseContext* TSqlParser::If_statementContext::sql_clause(size_t i) {
  return getRuleContext<TSqlParser::Sql_clauseContext>(i);
}

tree::TerminalNode* TSqlParser::If_statementContext::ELSE() {
  return getToken(TSqlParser::ELSE, 0);
}

tree::TerminalNode* TSqlParser::If_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::If_statementContext::getRuleIndex() const {
  return TSqlParser::RuleIf_statement;
}

void TSqlParser::If_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_statement(this);
}

void TSqlParser::If_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_statement(this);
}

TSqlParser::If_statementContext* TSqlParser::if_statement() {
  If_statementContext *_localctx = _tracker.createInstance<If_statementContext>(_ctx, getState());
  enterRule(_localctx, 24, TSqlParser::RuleIf_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(631);
    match(TSqlParser::IF);
    setState(632);
    search_condition();
    setState(633);
    sql_clause();
    setState(636);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(634);
      match(TSqlParser::ELSE);
      setState(635);
      sql_clause();
      break;
    }

    }
    setState(639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(638);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_statementContext ------------------------------------------------------------------

TSqlParser::Throw_statementContext::Throw_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_statementContext::THROW() {
  return getToken(TSqlParser::THROW, 0);
}

TSqlParser::Throw_error_numberContext* TSqlParser::Throw_statementContext::throw_error_number() {
  return getRuleContext<TSqlParser::Throw_error_numberContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Throw_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Throw_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Throw_messageContext* TSqlParser::Throw_statementContext::throw_message() {
  return getRuleContext<TSqlParser::Throw_messageContext>(0);
}

TSqlParser::Throw_stateContext* TSqlParser::Throw_statementContext::throw_state() {
  return getRuleContext<TSqlParser::Throw_stateContext>(0);
}

tree::TerminalNode* TSqlParser::Throw_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Throw_statementContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_statement;
}

void TSqlParser::Throw_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_statement(this);
}

void TSqlParser::Throw_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_statement(this);
}

TSqlParser::Throw_statementContext* TSqlParser::throw_statement() {
  Throw_statementContext *_localctx = _tracker.createInstance<Throw_statementContext>(_ctx, getState());
  enterRule(_localctx, 26, TSqlParser::RuleThrow_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(TSqlParser::THROW);
    setState(648);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(642);
      throw_error_number();
      setState(643);
      match(TSqlParser::COMMA);
      setState(644);
      throw_message();
      setState(645);
      match(TSqlParser::COMMA);
      setState(646);
      throw_state();
      break;
    }

    }
    setState(651);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(650);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_error_numberContext ------------------------------------------------------------------

TSqlParser::Throw_error_numberContext::Throw_error_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_error_numberContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Throw_error_numberContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_error_numberContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_error_number;
}

void TSqlParser::Throw_error_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_error_number(this);
}

void TSqlParser::Throw_error_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_error_number(this);
}

TSqlParser::Throw_error_numberContext* TSqlParser::throw_error_number() {
  Throw_error_numberContext *_localctx = _tracker.createInstance<Throw_error_numberContext>(_ctx, getState());
  enterRule(_localctx, 28, TSqlParser::RuleThrow_error_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_messageContext ------------------------------------------------------------------

TSqlParser::Throw_messageContext::Throw_messageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_messageContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Throw_messageContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_messageContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_message;
}

void TSqlParser::Throw_messageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_message(this);
}

void TSqlParser::Throw_messageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_message(this);
}

TSqlParser::Throw_messageContext* TSqlParser::throw_message() {
  Throw_messageContext *_localctx = _tracker.createInstance<Throw_messageContext>(_ctx, getState());
  enterRule(_localctx, 30, TSqlParser::RuleThrow_message);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(655);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_stateContext ------------------------------------------------------------------

TSqlParser::Throw_stateContext::Throw_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_stateContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Throw_stateContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_stateContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_state;
}

void TSqlParser::Throw_stateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_state(this);
}

void TSqlParser::Throw_stateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_state(this);
}

TSqlParser::Throw_stateContext* TSqlParser::throw_state() {
  Throw_stateContext *_localctx = _tracker.createInstance<Throw_stateContext>(_ctx, getState());
  enterRule(_localctx, 32, TSqlParser::RuleThrow_state);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(657);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Try_catch_statementContext ------------------------------------------------------------------

TSqlParser::Try_catch_statementContext::Try_catch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::BEGIN() {
  return getTokens(TSqlParser::BEGIN);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::BEGIN(size_t i) {
  return getToken(TSqlParser::BEGIN, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::TRY() {
  return getTokens(TSqlParser::TRY);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::TRY(size_t i) {
  return getToken(TSqlParser::TRY, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::END() {
  return getTokens(TSqlParser::END);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::END(size_t i) {
  return getToken(TSqlParser::END, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::CATCH() {
  return getTokens(TSqlParser::CATCH);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::CATCH(size_t i) {
  return getToken(TSqlParser::CATCH, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Try_catch_statementContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Try_catch_statementContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}


size_t TSqlParser::Try_catch_statementContext::getRuleIndex() const {
  return TSqlParser::RuleTry_catch_statement;
}

void TSqlParser::Try_catch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTry_catch_statement(this);
}

void TSqlParser::Try_catch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTry_catch_statement(this);
}

TSqlParser::Try_catch_statementContext* TSqlParser::try_catch_statement() {
  Try_catch_statementContext *_localctx = _tracker.createInstance<Try_catch_statementContext>(_ctx, getState());
  enterRule(_localctx, 34, TSqlParser::RuleTry_catch_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(659);
    match(TSqlParser::BEGIN);
    setState(660);
    match(TSqlParser::TRY);
    setState(662);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      setState(661);
      match(TSqlParser::SEMI);
      break;
    }

    }
    setState(665);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(664);
      dynamic_cast<Try_catch_statementContext *>(_localctx)->try_clauses = sql_clauses();
      break;
    }

    }
    setState(667);
    match(TSqlParser::END);
    setState(668);
    match(TSqlParser::TRY);
    setState(670);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(669);
      match(TSqlParser::SEMI);
    }
    setState(672);
    match(TSqlParser::BEGIN);
    setState(673);
    match(TSqlParser::CATCH);
    setState(675);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(674);
      match(TSqlParser::SEMI);
      break;
    }

    }
    setState(678);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      setState(677);
      dynamic_cast<Try_catch_statementContext *>(_localctx)->catch_clauses = sql_clauses();
      break;
    }

    }
    setState(680);
    match(TSqlParser::END);
    setState(681);
    match(TSqlParser::CATCH);
    setState(683);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(682);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Waitfor_statementContext ------------------------------------------------------------------

TSqlParser::Waitfor_statementContext::Waitfor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::WAITFOR() {
  return getToken(TSqlParser::WAITFOR, 0);
}

TSqlParser::Receive_statementContext* TSqlParser::Waitfor_statementContext::receive_statement() {
  return getRuleContext<TSqlParser::Receive_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

TSqlParser::TimeContext* TSqlParser::Waitfor_statementContext::time() {
  return getRuleContext<TSqlParser::TimeContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Waitfor_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::DELAY() {
  return getToken(TSqlParser::DELAY, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}


size_t TSqlParser::Waitfor_statementContext::getRuleIndex() const {
  return TSqlParser::RuleWaitfor_statement;
}

void TSqlParser::Waitfor_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWaitfor_statement(this);
}

void TSqlParser::Waitfor_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWaitfor_statement(this);
}

TSqlParser::Waitfor_statementContext* TSqlParser::waitfor_statement() {
  Waitfor_statementContext *_localctx = _tracker.createInstance<Waitfor_statementContext>(_ctx, getState());
  enterRule(_localctx, 36, TSqlParser::RuleWaitfor_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(685);
    match(TSqlParser::WAITFOR);
    setState(687);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(686);
      receive_statement();
      break;
    }

    }
    setState(690);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(689);
      match(TSqlParser::COMMA);
    }
    setState(694);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      setState(692);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DELAY || _la == TSqlParser::TIME

      || _la == TSqlParser::TIMEOUT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(693);
      time();
      break;
    }

    }
    setState(697);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(696);
      expression(0);
      break;
    }

    }
    setState(700);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(699);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_statementContext ------------------------------------------------------------------

TSqlParser::While_statementContext::While_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::While_statementContext::WHILE() {
  return getToken(TSqlParser::WHILE, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::While_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

TSqlParser::Sql_clauseContext* TSqlParser::While_statementContext::sql_clause() {
  return getRuleContext<TSqlParser::Sql_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::While_statementContext::BREAK() {
  return getToken(TSqlParser::BREAK, 0);
}

tree::TerminalNode* TSqlParser::While_statementContext::CONTINUE() {
  return getToken(TSqlParser::CONTINUE, 0);
}

tree::TerminalNode* TSqlParser::While_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::While_statementContext::getRuleIndex() const {
  return TSqlParser::RuleWhile_statement;
}

void TSqlParser::While_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_statement(this);
}

void TSqlParser::While_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_statement(this);
}

TSqlParser::While_statementContext* TSqlParser::while_statement() {
  While_statementContext *_localctx = _tracker.createInstance<While_statementContext>(_ctx, getState());
  enterRule(_localctx, 38, TSqlParser::RuleWhile_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(702);
    match(TSqlParser::WHILE);
    setState(703);
    search_condition();
    setState(713);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      setState(704);
      sql_clause();
      break;
    }

    case 2: {
      setState(705);
      match(TSqlParser::BREAK);
      setState(707);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
      case 1: {
        setState(706);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 3: {
      setState(709);
      match(TSqlParser::CONTINUE);
      setState(711);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
      case 1: {
        setState(710);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Print_statementContext ------------------------------------------------------------------

TSqlParser::Print_statementContext::Print_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Print_statementContext::PRINT() {
  return getToken(TSqlParser::PRINT, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Print_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Print_statementContext::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Print_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Print_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Print_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Print_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Print_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Print_statementContext::getRuleIndex() const {
  return TSqlParser::RulePrint_statement;
}

void TSqlParser::Print_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrint_statement(this);
}

void TSqlParser::Print_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrint_statement(this);
}

TSqlParser::Print_statementContext* TSqlParser::print_statement() {
  Print_statementContext *_localctx = _tracker.createInstance<Print_statementContext>(_ctx, getState());
  enterRule(_localctx, 40, TSqlParser::RulePrint_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(715);
    match(TSqlParser::PRINT);
    setState(718);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(716);
      expression(0);
      break;
    }

    case 2: {
      setState(717);
      match(TSqlParser::DOUBLE_QUOTE_ID);
      break;
    }

    }
    setState(724);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(720);
      match(TSqlParser::COMMA);
      setState(721);
      match(TSqlParser::LOCAL_ID);
      setState(726);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(728);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(727);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raiseerror_statementContext ------------------------------------------------------------------

TSqlParser::Raiseerror_statementContext::Raiseerror_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::RAISERROR() {
  return getToken(TSqlParser::RAISERROR, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Constant_LOCAL_IDContext *> TSqlParser::Raiseerror_statementContext::constant_LOCAL_ID() {
  return getRuleContexts<TSqlParser::Constant_LOCAL_IDContext>();
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::Raiseerror_statementContext::constant_LOCAL_ID(size_t i) {
  return getRuleContext<TSqlParser::Constant_LOCAL_IDContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LOG() {
  return getToken(TSqlParser::LOG, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::SETERROR() {
  return getToken(TSqlParser::SETERROR, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}


size_t TSqlParser::Raiseerror_statementContext::getRuleIndex() const {
  return TSqlParser::RuleRaiseerror_statement;
}

void TSqlParser::Raiseerror_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaiseerror_statement(this);
}

void TSqlParser::Raiseerror_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaiseerror_statement(this);
}

TSqlParser::Raiseerror_statementContext* TSqlParser::raiseerror_statement() {
  Raiseerror_statementContext *_localctx = _tracker.createInstance<Raiseerror_statementContext>(_ctx, getState());
  enterRule(_localctx, 42, TSqlParser::RuleRaiseerror_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(762);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(730);
      match(TSqlParser::RAISERROR);
      setState(731);
      match(TSqlParser::LR_BRACKET);
      setState(732);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->msg = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 827) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 827)) & ((1ULL << (TSqlParser::LOCAL_ID - 827))
        | (1ULL << (TSqlParser::DECIMAL - 827))
        | (1ULL << (TSqlParser::STRING - 827)))) != 0))) {
        dynamic_cast<Raiseerror_statementContext *>(_localctx)->msg = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(733);
      match(TSqlParser::COMMA);
      setState(734);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->severity = constant_LOCAL_ID();
      setState(735);
      match(TSqlParser::COMMA);
      setState(736);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->state = constant_LOCAL_ID();
      setState(741);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(737);
        match(TSqlParser::COMMA);
        setState(738);
        constant_LOCAL_ID();
        setState(743);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(744);
      match(TSqlParser::RR_BRACKET);
      setState(747);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
      case 1: {
        setState(745);
        match(TSqlParser::WITH);
        setState(746);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::LOG || _la == TSqlParser::SETERROR)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(750);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
      case 1: {
        setState(749);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(752);
      match(TSqlParser::RAISERROR);
      setState(753);
      match(TSqlParser::DECIMAL);
      setState(754);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->formatstring = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 824) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 824)) & ((1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 824))
        | (1ULL << (TSqlParser::LOCAL_ID - 824))
        | (1ULL << (TSqlParser::STRING - 824)))) != 0))) {
        dynamic_cast<Raiseerror_statementContext *>(_localctx)->formatstring = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(759);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(755);
        match(TSqlParser::COMMA);
        setState(756);
        dynamic_cast<Raiseerror_statementContext *>(_localctx)->argument = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 827) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 827)) & ((1ULL << (TSqlParser::LOCAL_ID - 827))
          | (1ULL << (TSqlParser::DECIMAL - 827))
          | (1ULL << (TSqlParser::STRING - 827)))) != 0))) {
          dynamic_cast<Raiseerror_statementContext *>(_localctx)->argument = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(761);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Empty_statementContext ------------------------------------------------------------------

TSqlParser::Empty_statementContext::Empty_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Empty_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Empty_statementContext::getRuleIndex() const {
  return TSqlParser::RuleEmpty_statement;
}

void TSqlParser::Empty_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmpty_statement(this);
}

void TSqlParser::Empty_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmpty_statement(this);
}

TSqlParser::Empty_statementContext* TSqlParser::empty_statement() {
  Empty_statementContext *_localctx = _tracker.createInstance<Empty_statementContext>(_ctx, getState());
  enterRule(_localctx, 44, TSqlParser::RuleEmpty_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(764);
    match(TSqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Another_statementContext ------------------------------------------------------------------

TSqlParser::Another_statementContext::Another_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Declare_statementContext* TSqlParser::Another_statementContext::declare_statement() {
  return getRuleContext<TSqlParser::Declare_statementContext>(0);
}

TSqlParser::Cursor_statementContext* TSqlParser::Another_statementContext::cursor_statement() {
  return getRuleContext<TSqlParser::Cursor_statementContext>(0);
}

TSqlParser::Conversation_statementContext* TSqlParser::Another_statementContext::conversation_statement() {
  return getRuleContext<TSqlParser::Conversation_statementContext>(0);
}

TSqlParser::Create_queueContext* TSqlParser::Another_statementContext::create_queue() {
  return getRuleContext<TSqlParser::Create_queueContext>(0);
}

TSqlParser::Alter_queueContext* TSqlParser::Another_statementContext::alter_queue() {
  return getRuleContext<TSqlParser::Alter_queueContext>(0);
}

TSqlParser::Execute_statementContext* TSqlParser::Another_statementContext::execute_statement() {
  return getRuleContext<TSqlParser::Execute_statementContext>(0);
}

TSqlParser::Kill_statementContext* TSqlParser::Another_statementContext::kill_statement() {
  return getRuleContext<TSqlParser::Kill_statementContext>(0);
}

TSqlParser::Message_statementContext* TSqlParser::Another_statementContext::message_statement() {
  return getRuleContext<TSqlParser::Message_statementContext>(0);
}

TSqlParser::Set_statementContext* TSqlParser::Another_statementContext::set_statement() {
  return getRuleContext<TSqlParser::Set_statementContext>(0);
}

TSqlParser::Transaction_statementContext* TSqlParser::Another_statementContext::transaction_statement() {
  return getRuleContext<TSqlParser::Transaction_statementContext>(0);
}

TSqlParser::Use_statementContext* TSqlParser::Another_statementContext::use_statement() {
  return getRuleContext<TSqlParser::Use_statementContext>(0);
}

TSqlParser::Setuser_statementContext* TSqlParser::Another_statementContext::setuser_statement() {
  return getRuleContext<TSqlParser::Setuser_statementContext>(0);
}

TSqlParser::Reconfigure_statementContext* TSqlParser::Another_statementContext::reconfigure_statement() {
  return getRuleContext<TSqlParser::Reconfigure_statementContext>(0);
}

TSqlParser::Shutdown_statementContext* TSqlParser::Another_statementContext::shutdown_statement() {
  return getRuleContext<TSqlParser::Shutdown_statementContext>(0);
}


size_t TSqlParser::Another_statementContext::getRuleIndex() const {
  return TSqlParser::RuleAnother_statement;
}

void TSqlParser::Another_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnother_statement(this);
}

void TSqlParser::Another_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnother_statement(this);
}

TSqlParser::Another_statementContext* TSqlParser::another_statement() {
  Another_statementContext *_localctx = _tracker.createInstance<Another_statementContext>(_ctx, getState());
  enterRule(_localctx, 46, TSqlParser::RuleAnother_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(780);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(766);
      declare_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(767);
      cursor_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(768);
      conversation_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(769);
      create_queue();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(770);
      alter_queue();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(771);
      execute_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(772);
      kill_statement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(773);
      message_statement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(774);
      set_statement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(775);
      transaction_statement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(776);
      use_statement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(777);
      setuser_statement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(778);
      reconfigure_statement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(779);
      shutdown_statement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_aggregateContext ------------------------------------------------------------------

TSqlParser::Drop_aggregateContext::Drop_aggregateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_aggregateContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_aggregateContext::AGGREGATE() {
  return getToken(TSqlParser::AGGREGATE, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Drop_aggregateContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Drop_aggregateContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_aggregateContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_aggregateContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::Drop_aggregateContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Drop_aggregateContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_aggregate;
}

void TSqlParser::Drop_aggregateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_aggregate(this);
}

void TSqlParser::Drop_aggregateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_aggregate(this);
}

TSqlParser::Drop_aggregateContext* TSqlParser::drop_aggregate() {
  Drop_aggregateContext *_localctx = _tracker.createInstance<Drop_aggregateContext>(_ctx, getState());
  enterRule(_localctx, 48, TSqlParser::RuleDrop_aggregate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(782);
    match(TSqlParser::DROP);
    setState(783);
    match(TSqlParser::AGGREGATE);
    setState(786);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(784);
      match(TSqlParser::IF);
      setState(785);
      match(TSqlParser::EXISTS);
    }
    setState(791);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      setState(788);
      dynamic_cast<Drop_aggregateContext *>(_localctx)->schema_name = id();
      setState(789);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(793);
    dynamic_cast<Drop_aggregateContext *>(_localctx)->aggregate_name = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_toContext ------------------------------------------------------------------

TSqlParser::Entity_toContext::Entity_toContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Entity_toContext::TO() {
  return getToken(TSqlParser::TO, 0);
}


size_t TSqlParser::Entity_toContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_to;
}

void TSqlParser::Entity_toContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_to(this);
}

void TSqlParser::Entity_toContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_to(this);
}

TSqlParser::Entity_toContext* TSqlParser::entity_to() {
  Entity_toContext *_localctx = _tracker.createInstance<Entity_toContext>(_ctx, getState());
  enterRule(_localctx, 50, TSqlParser::RuleEntity_to);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    match(TSqlParser::TO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Colon_colonContext ------------------------------------------------------------------

TSqlParser::Colon_colonContext::Colon_colonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Colon_colonContext::COLON() {
  return getTokens(TSqlParser::COLON);
}

tree::TerminalNode* TSqlParser::Colon_colonContext::COLON(size_t i) {
  return getToken(TSqlParser::COLON, i);
}


size_t TSqlParser::Colon_colonContext::getRuleIndex() const {
  return TSqlParser::RuleColon_colon;
}

void TSqlParser::Colon_colonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColon_colon(this);
}

void TSqlParser::Colon_colonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColon_colon(this);
}

TSqlParser::Colon_colonContext* TSqlParser::colon_colon() {
  Colon_colonContext *_localctx = _tracker.createInstance<Colon_colonContext>(_ctx, getState());
  enterRule(_localctx, 52, TSqlParser::RuleColon_colon);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(797);
    match(TSqlParser::COLON);
    setState(798);
    match(TSqlParser::COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_typeContext ------------------------------------------------------------------

TSqlParser::Class_typeContext::Class_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_typeContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Class_typeContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Class_typeContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}


size_t TSqlParser::Class_typeContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type;
}

void TSqlParser::Class_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type(this);
}

void TSqlParser::Class_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type(this);
}

TSqlParser::Class_typeContext* TSqlParser::class_type() {
  Class_typeContext *_localctx = _tracker.createInstance<Class_typeContext>(_ctx, getState());
  enterRule(_localctx, 54, TSqlParser::RuleClass_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(800);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT || _la == TSqlParser::TYPE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_sql_databaseContext ------------------------------------------------------------------

TSqlParser::Class_type_for_sql_databaseContext::Class_type_for_sql_databaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}


size_t TSqlParser::Class_type_for_sql_databaseContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_sql_database;
}

void TSqlParser::Class_type_for_sql_databaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_sql_database(this);
}

void TSqlParser::Class_type_for_sql_databaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_sql_database(this);
}

TSqlParser::Class_type_for_sql_databaseContext* TSqlParser::class_type_for_sql_database() {
  Class_type_for_sql_databaseContext *_localctx = _tracker.createInstance<Class_type_for_sql_databaseContext>(_ctx, getState());
  enterRule(_localctx, 56, TSqlParser::RuleClass_type_for_sql_database);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(802);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT || _la == TSqlParser::TYPE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_parallel_dwContext ------------------------------------------------------------------

TSqlParser::Class_type_for_parallel_dwContext::Class_type_for_parallel_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::DATABASE() {
  return getToken(TSqlParser::DATABASE, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}


size_t TSqlParser::Class_type_for_parallel_dwContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_parallel_dw;
}

void TSqlParser::Class_type_for_parallel_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_parallel_dw(this);
}

void TSqlParser::Class_type_for_parallel_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_parallel_dw(this);
}

TSqlParser::Class_type_for_parallel_dwContext* TSqlParser::class_type_for_parallel_dw() {
  Class_type_for_parallel_dwContext *_localctx = _tracker.createInstance<Class_type_for_parallel_dwContext>(_ctx, getState());
  enterRule(_localctx, 58, TSqlParser::RuleClass_type_for_parallel_dw);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(804);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::DATABASE || _la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_schemaContext ------------------------------------------------------------------

TSqlParser::Drop_schemaContext::Drop_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_schemaContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_schemaContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

TSqlParser::IdContext* TSqlParser::Drop_schemaContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Drop_schemaContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_schemaContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}


size_t TSqlParser::Drop_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_schema;
}

void TSqlParser::Drop_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_schema(this);
}

void TSqlParser::Drop_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_schema(this);
}

TSqlParser::Drop_schemaContext* TSqlParser::drop_schema() {
  Drop_schemaContext *_localctx = _tracker.createInstance<Drop_schemaContext>(_ctx, getState());
  enterRule(_localctx, 60, TSqlParser::RuleDrop_schema);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(806);
    match(TSqlParser::DROP);
    setState(807);
    match(TSqlParser::SCHEMA);
    setState(810);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(808);
      match(TSqlParser::IF);
      setState(809);
      match(TSqlParser::EXISTS);
    }
    setState(812);
    dynamic_cast<Drop_schemaContext *>(_localctx)->schema_name = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lock_tableContext ------------------------------------------------------------------

TSqlParser::Lock_tableContext::Lock_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Lock_tableContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Lock_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::MODE() {
  return getToken(TSqlParser::MODE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::SHARE() {
  return getToken(TSqlParser::SHARE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::EXCLUSIVE() {
  return getToken(TSqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::WAIT() {
  return getToken(TSqlParser::WAIT, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Lock_tableContext::getRuleIndex() const {
  return TSqlParser::RuleLock_table;
}

void TSqlParser::Lock_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLock_table(this);
}

void TSqlParser::Lock_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLock_table(this);
}

TSqlParser::Lock_tableContext* TSqlParser::lock_table() {
  Lock_tableContext *_localctx = _tracker.createInstance<Lock_tableContext>(_ctx, getState());
  enterRule(_localctx, 62, TSqlParser::RuleLock_table);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(814);
    match(TSqlParser::LOCK);
    setState(815);
    match(TSqlParser::TABLE);
    setState(816);
    table_name();
    setState(817);
    match(TSqlParser::IN);
    setState(818);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::EXCLUSIVE || _la == TSqlParser::SHARE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(819);
    match(TSqlParser::MODE);
    setState(823);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      setState(820);
      match(TSqlParser::WAIT);
      setState(821);
      dynamic_cast<Lock_tableContext *>(_localctx)->seconds = match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(822);
      match(TSqlParser::NOWAIT);
      break;
    }

    }
    setState(826);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      setState(825);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Truncate_tableContext ------------------------------------------------------------------

TSqlParser::Truncate_tableContext::Truncate_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TRUNCATE() {
  return getToken(TSqlParser::TRUNCATE, 0);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Truncate_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::PARTITIONS() {
  return getToken(TSqlParser::PARTITIONS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::TO() {
  return getTokens(TSqlParser::TO);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TO(size_t i) {
  return getToken(TSqlParser::TO, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Truncate_tableContext::getRuleIndex() const {
  return TSqlParser::RuleTruncate_table;
}

void TSqlParser::Truncate_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncate_table(this);
}

void TSqlParser::Truncate_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncate_table(this);
}

TSqlParser::Truncate_tableContext* TSqlParser::truncate_table() {
  Truncate_tableContext *_localctx = _tracker.createInstance<Truncate_tableContext>(_ctx, getState());
  enterRule(_localctx, 64, TSqlParser::RuleTruncate_table);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(828);
    match(TSqlParser::TRUNCATE);
    setState(829);
    match(TSqlParser::TABLE);
    setState(830);
    table_name();
    setState(850);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      setState(831);
      match(TSqlParser::WITH);
      setState(832);
      match(TSqlParser::LR_BRACKET);
      setState(833);
      match(TSqlParser::PARTITIONS);
      setState(834);
      match(TSqlParser::LR_BRACKET);
      setState(844); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(836);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(835);
          match(TSqlParser::COMMA);
        }
        setState(842);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
        case 1: {
          setState(838);
          match(TSqlParser::DECIMAL);
          break;
        }

        case 2: {
          setState(839);
          match(TSqlParser::DECIMAL);
          setState(840);
          match(TSqlParser::TO);
          setState(841);
          match(TSqlParser::DECIMAL);
          break;
        }

        }
        setState(846); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::DECIMAL

      || _la == TSqlParser::COMMA);
      setState(848);
      match(TSqlParser::RR_BRACKET);
      setState(849);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_session_predicate_expressionContext ------------------------------------------------------------------

TSqlParser::Event_session_predicate_expressionContext::Event_session_predicate_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Event_session_predicate_factorContext *> TSqlParser::Event_session_predicate_expressionContext::event_session_predicate_factor() {
  return getRuleContexts<TSqlParser::Event_session_predicate_factorContext>();
}

TSqlParser::Event_session_predicate_factorContext* TSqlParser::Event_session_predicate_expressionContext::event_session_predicate_factor(size_t i) {
  return getRuleContext<TSqlParser::Event_session_predicate_factorContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Event_session_predicate_expressionContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_expressionContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<TSqlParser::Event_session_predicate_expressionContext *> TSqlParser::Event_session_predicate_expressionContext::event_session_predicate_expression() {
  return getRuleContexts<TSqlParser::Event_session_predicate_expressionContext>();
}

TSqlParser::Event_session_predicate_expressionContext* TSqlParser::Event_session_predicate_expressionContext::event_session_predicate_expression(size_t i) {
  return getRuleContext<TSqlParser::Event_session_predicate_expressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Event_session_predicate_expressionContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_expressionContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Event_session_predicate_expressionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_expressionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Event_session_predicate_expressionContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_expressionContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Event_session_predicate_expressionContext::AND() {
  return getTokens(TSqlParser::AND);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_expressionContext::AND(size_t i) {
  return getToken(TSqlParser::AND, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Event_session_predicate_expressionContext::OR() {
  return getTokens(TSqlParser::OR);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_expressionContext::OR(size_t i) {
  return getToken(TSqlParser::OR, i);
}


size_t TSqlParser::Event_session_predicate_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleEvent_session_predicate_expression;
}

void TSqlParser::Event_session_predicate_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_session_predicate_expression(this);
}

void TSqlParser::Event_session_predicate_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_session_predicate_expression(this);
}

TSqlParser::Event_session_predicate_expressionContext* TSqlParser::event_session_predicate_expression() {
  Event_session_predicate_expressionContext *_localctx = _tracker.createInstance<Event_session_predicate_expressionContext>(_ctx, getState());
  enterRule(_localctx, 66, TSqlParser::RuleEvent_session_predicate_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(868); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(853);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(852);
        match(TSqlParser::COMMA);
      }
      setState(856);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AND || _la == TSqlParser::OR) {
        setState(855);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::AND || _la == TSqlParser::OR)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(859);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::NOT) {
        setState(858);
        match(TSqlParser::NOT);
      }
      setState(866);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
      case 1: {
        setState(861);
        event_session_predicate_factor();
        break;
      }

      case 2: {
        setState(862);
        match(TSqlParser::LR_BRACKET);
        setState(863);
        event_session_predicate_expression();
        setState(864);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      }
      setState(870); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == TSqlParser::AND

    || _la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
      | (1ULL << (TSqlParser::EVENTDATA - 85))
      | (1ULL << (TSqlParser::FILENAME - 85))
      | (1ULL << (TSqlParser::FILLFACTOR - 85))
      | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
      | (1ULL << (TSqlParser::KEY - 164))
      | (1ULL << (TSqlParser::MASTER - 164))
      | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 231) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 231)) & ((1ULL << (TSqlParser::NOT - 231))
      | (1ULL << (TSqlParser::OFFSETS - 231))
      | (1ULL << (TSqlParser::OR - 231))
      | (1ULL << (TSqlParser::PAGE - 231))
      | (1ULL << (TSqlParser::PUBLIC - 231))
      | (1ULL << (TSqlParser::R - 231))
      | (1ULL << (TSqlParser::RAW - 231)))) != 0) || ((((_la - 296) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 296)) & ((1ULL << (TSqlParser::RETURN - 296))
      | (1ULL << (TSqlParser::RETURNS - 296))
      | (1ULL << (TSqlParser::ROWCOUNT - 296))
      | (1ULL << (TSqlParser::SAFETY - 296))
      | (1ULL << (TSqlParser::SERVER - 296))
      | (1ULL << (TSqlParser::SID - 296))
      | (1ULL << (TSqlParser::SOURCE - 296))
      | (1ULL << (TSqlParser::SPLIT - 296))
      | (1ULL << (TSqlParser::STATE - 296))
      | (1ULL << (TSqlParser::START - 296)))) != 0) || ((((_la - 362) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 362)) & ((1ULL << (TSqlParser::TARGET - 362))
      | (1ULL << (TSqlParser::ABSOLUTE - 362))
      | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 362))
      | (1ULL << (TSqlParser::ACTION - 362))
      | (1ULL << (TSqlParser::ACTIVATION - 362))
      | (1ULL << (TSqlParser::ACTIVE - 362))
      | (1ULL << (TSqlParser::ADDRESS - 362))
      | (1ULL << (TSqlParser::AES_128 - 362))
      | (1ULL << (TSqlParser::AES_192 - 362))
      | (1ULL << (TSqlParser::AES_256 - 362))
      | (1ULL << (TSqlParser::AFFINITY - 362))
      | (1ULL << (TSqlParser::AFTER - 362))
      | (1ULL << (TSqlParser::AGGREGATE - 362))
      | (1ULL << (TSqlParser::ALGORITHM - 362))
      | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 362))
      | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 362))
      | (1ULL << (TSqlParser::ALLOWED - 362))
      | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 362))
      | (1ULL << (TSqlParser::ANSI_NULLS - 362))
      | (1ULL << (TSqlParser::ANSI_PADDING - 362))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 362))
      | (1ULL << (TSqlParser::APPLICATION_LOG - 362)))) != 0) || ((((_la - 426) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 426)) & ((1ULL << (TSqlParser::APPLY - 426))
      | (1ULL << (TSqlParser::ARITHABORT - 426))
      | (1ULL << (TSqlParser::ASSEMBLY - 426))
      | (1ULL << (TSqlParser::AUDIT - 426))
      | (1ULL << (TSqlParser::AUDIT_GUID - 426))
      | (1ULL << (TSqlParser::AUTO - 426))
      | (1ULL << (TSqlParser::AUTO_CLEANUP - 426))
      | (1ULL << (TSqlParser::AUTO_CLOSE - 426))
      | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 426))
      | (1ULL << (TSqlParser::AUTO_SHRINK - 426))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 426))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 426))
      | (1ULL << (TSqlParser::AVAILABILITY - 426))
      | (1ULL << (TSqlParser::AVG - 426))
      | (1ULL << (TSqlParser::BACKUP_PRIORITY - 426))
      | (1ULL << (TSqlParser::BEGIN_DIALOG - 426))
      | (1ULL << (TSqlParser::BIGINT - 426))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 426))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 426))
      | (1ULL << (TSqlParser::BINDING - 426))
      | (1ULL << (TSqlParser::BLOB_STORAGE - 426))
      | (1ULL << (TSqlParser::BROKER - 426))
      | (1ULL << (TSqlParser::BROKER_INSTANCE - 426))
      | (1ULL << (TSqlParser::BULK_LOGGED - 426))
      | (1ULL << (TSqlParser::CALLER - 426))
      | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 426))
      | (1ULL << (TSqlParser::CAST - 426))
      | (1ULL << (TSqlParser::CATALOG - 426))
      | (1ULL << (TSqlParser::CATCH - 426))
      | (1ULL << (TSqlParser::CHANGE_RETENTION - 426))
      | (1ULL << (TSqlParser::CHANGE_TRACKING - 426))
      | (1ULL << (TSqlParser::CHECKSUM - 426))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 426))
      | (1ULL << (TSqlParser::CLEANUP - 426))
      | (1ULL << (TSqlParser::COLLECTION - 426))
      | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 426))
      | (1ULL << (TSqlParser::COMMITTED - 426))
      | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 426))
      | (1ULL << (TSqlParser::CONCAT - 426))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 426))
      | (1ULL << (TSqlParser::CONTENT - 426))
      | (1ULL << (TSqlParser::CONTROL - 426))
      | (1ULL << (TSqlParser::COOKIE - 426))
      | (1ULL << (TSqlParser::COUNT - 426))
      | (1ULL << (TSqlParser::COUNT_BIG - 426))
      | (1ULL << (TSqlParser::COUNTER - 426))
      | (1ULL << (TSqlParser::CPU - 426))
      | (1ULL << (TSqlParser::CREATE_NEW - 426))
      | (1ULL << (TSqlParser::CREATION_DISPOSITION - 426))
      | (1ULL << (TSqlParser::CREDENTIAL - 426))
      | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 426))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 426))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 426))
      | (1ULL << (TSqlParser::DATA - 426))
      | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 426))
      | (1ULL << (TSqlParser::DATEADD - 426))
      | (1ULL << (TSqlParser::DATEDIFF - 426))
      | (1ULL << (TSqlParser::DATENAME - 426))
      | (1ULL << (TSqlParser::DATEPART - 426))
      | (1ULL << (TSqlParser::DAYS - 426))
      | (1ULL << (TSqlParser::DB_CHAINING - 426))
      | (1ULL << (TSqlParser::DB_FAILOVER - 426)))) != 0) || ((((_la - 490) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 490)) & ((1ULL << (TSqlParser::DECRYPTION - 490))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 490))
      | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 490))
      | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 490))
      | (1ULL << (TSqlParser::DELAY - 490))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 490))
      | (1ULL << (TSqlParser::DELETED - 490))
      | (1ULL << (TSqlParser::DENSE_RANK - 490))
      | (1ULL << (TSqlParser::DEPENDENTS - 490))
      | (1ULL << (TSqlParser::DES - 490))
      | (1ULL << (TSqlParser::DESCRIPTION - 490))
      | (1ULL << (TSqlParser::DESX - 490))
      | (1ULL << (TSqlParser::DHCP - 490))
      | (1ULL << (TSqlParser::DIALOG - 490))
      | (1ULL << (TSqlParser::DIRECTORY_NAME - 490))
      | (1ULL << (TSqlParser::DISABLE - 490))
      | (1ULL << (TSqlParser::DISABLE_BROKER - 490))
      | (1ULL << (TSqlParser::DISABLED - 490))
      | (1ULL << (TSqlParser::DISK_DRIVE - 490))
      | (1ULL << (TSqlParser::DOCUMENT - 490))
      | (1ULL << (TSqlParser::DYNAMIC - 490))
      | (1ULL << (TSqlParser::EMERGENCY - 490))
      | (1ULL << (TSqlParser::EMPTY - 490))
      | (1ULL << (TSqlParser::ENABLE - 490))
      | (1ULL << (TSqlParser::ENABLE_BROKER - 490))
      | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 490))
      | (1ULL << (TSqlParser::ENCRYPTION - 490))
      | (1ULL << (TSqlParser::ENDPOINT_URL - 490))
      | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 490))
      | (1ULL << (TSqlParser::EXCLUSIVE - 490))
      | (1ULL << (TSqlParser::EXECUTABLE - 490))
      | (1ULL << (TSqlParser::EXIST - 490))
      | (1ULL << (TSqlParser::EXPAND - 490))
      | (1ULL << (TSqlParser::EXPIRY_DATE - 490))
      | (1ULL << (TSqlParser::EXPLICIT - 490))
      | (1ULL << (TSqlParser::FAIL_OPERATION - 490))
      | (1ULL << (TSqlParser::FAILOVER_MODE - 490))
      | (1ULL << (TSqlParser::FAILURE - 490))
      | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 490))
      | (1ULL << (TSqlParser::FAST - 490))
      | (1ULL << (TSqlParser::FAST_FORWARD - 490))
      | (1ULL << (TSqlParser::FILEGROUP - 490))
      | (1ULL << (TSqlParser::FILEGROWTH - 490))
      | (1ULL << (TSqlParser::FILEPATH - 490))
      | (1ULL << (TSqlParser::FILESTREAM - 490))
      | (1ULL << (TSqlParser::FILTER - 490))
      | (1ULL << (TSqlParser::FIRST - 490))
      | (1ULL << (TSqlParser::FIRST_VALUE - 490))
      | (1ULL << (TSqlParser::FOLLOWING - 490))
      | (1ULL << (TSqlParser::FORCE - 490))
      | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 490))
      | (1ULL << (TSqlParser::FORCED - 490))
      | (1ULL << (TSqlParser::FORMAT - 490))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 490))
      | (1ULL << (TSqlParser::FULLSCAN - 490))
      | (1ULL << (TSqlParser::FULLTEXT - 490))
      | (1ULL << (TSqlParser::GB - 490))
      | (1ULL << (TSqlParser::GETDATE - 490))
      | (1ULL << (TSqlParser::GETUTCDATE - 490))
      | (1ULL << (TSqlParser::GLOBAL - 490))
      | (1ULL << (TSqlParser::GO - 490))
      | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 490))
      | (1ULL << (TSqlParser::GROUPING - 490)))) != 0) || ((((_la - 554) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 554)) & ((1ULL << (TSqlParser::GROUPING_ID - 554))
      | (1ULL << (TSqlParser::HADR - 554))
      | (1ULL << (TSqlParser::HASH - 554))
      | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 554))
      | (1ULL << (TSqlParser::HIGH - 554))
      | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 554))
      | (1ULL << (TSqlParser::HOURS - 554))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 554))
      | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 554))
      | (1ULL << (TSqlParser::IMMEDIATE - 554))
      | (1ULL << (TSqlParser::IMPERSONATE - 554))
      | (1ULL << (TSqlParser::IMPORTANCE - 554))
      | (1ULL << (TSqlParser::INCREMENTAL - 554))
      | (1ULL << (TSqlParser::INITIATOR - 554))
      | (1ULL << (TSqlParser::INPUT - 554))
      | (1ULL << (TSqlParser::INSENSITIVE - 554))
      | (1ULL << (TSqlParser::INSERTED - 554))
      | (1ULL << (TSqlParser::INT - 554))
      | (1ULL << (TSqlParser::IP - 554))
      | (1ULL << (TSqlParser::ISOLATION - 554))
      | (1ULL << (TSqlParser::KB - 554))
      | (1ULL << (TSqlParser::KEEP - 554))
      | (1ULL << (TSqlParser::KEEPFIXED - 554))
      | (1ULL << (TSqlParser::KEY_SOURCE - 554))
      | (1ULL << (TSqlParser::KEYS - 554))
      | (1ULL << (TSqlParser::KEYSET - 554))
      | (1ULL << (TSqlParser::LAG - 554))
      | (1ULL << (TSqlParser::LAST - 554))
      | (1ULL << (TSqlParser::LAST_VALUE - 554))
      | (1ULL << (TSqlParser::LEAD - 554))
      | (1ULL << (TSqlParser::LEVEL - 554))
      | (1ULL << (TSqlParser::LIST - 554))
      | (1ULL << (TSqlParser::LISTENER - 554))
      | (1ULL << (TSqlParser::LISTENER_URL - 554))
      | (1ULL << (TSqlParser::LOB_COMPACTION - 554))
      | (1ULL << (TSqlParser::LOCAL - 554))
      | (1ULL << (TSqlParser::LOCATION - 554))
      | (1ULL << (TSqlParser::LOCK - 554))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 554))
      | (1ULL << (TSqlParser::LOGIN - 554))
      | (1ULL << (TSqlParser::LOOP - 554))
      | (1ULL << (TSqlParser::LOW - 554))
      | (1ULL << (TSqlParser::MANUAL - 554))
      | (1ULL << (TSqlParser::MARK - 554))
      | (1ULL << (TSqlParser::MATERIALIZED - 554))
      | (1ULL << (TSqlParser::MAX - 554))
      | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 554))
      | (1ULL << (TSqlParser::MAX_DOP - 554))
      | (1ULL << (TSqlParser::MAX_FILES - 554))
      | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 554))
      | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 554))
      | (1ULL << (TSqlParser::MAX_PROCESSES - 554))
      | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 554))
      | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 554))
      | (1ULL << (TSqlParser::MAXDOP - 554))
      | (1ULL << (TSqlParser::MAXRECURSION - 554))
      | (1ULL << (TSqlParser::MAXSIZE - 554))
      | (1ULL << (TSqlParser::MB - 554))
      | (1ULL << (TSqlParser::MEDIUM - 554))
      | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 554))
      | (1ULL << (TSqlParser::MESSAGE - 554)))) != 0) || ((((_la - 618) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 618)) & ((1ULL << (TSqlParser::MIN - 618))
      | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 618))
      | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 618))
      | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 618))
      | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 618))
      | (1ULL << (TSqlParser::MINUTES - 618))
      | (1ULL << (TSqlParser::MIRROR_ADDRESS - 618))
      | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 618))
      | (1ULL << (TSqlParser::MODE - 618))
      | (1ULL << (TSqlParser::MODIFY - 618))
      | (1ULL << (TSqlParser::MOVE - 618))
      | (1ULL << (TSqlParser::MULTI_USER - 618))
      | (1ULL << (TSqlParser::NAME - 618))
      | (1ULL << (TSqlParser::NESTED_TRIGGERS - 618))
      | (1ULL << (TSqlParser::NEW_ACCOUNT - 618))
      | (1ULL << (TSqlParser::NEW_BROKER - 618))
      | (1ULL << (TSqlParser::NEW_PASSWORD - 618))
      | (1ULL << (TSqlParser::NEXT - 618))
      | (1ULL << (TSqlParser::NO - 618))
      | (1ULL << (TSqlParser::NO_TRUNCATE - 618))
      | (1ULL << (TSqlParser::NO_WAIT - 618))
      | (1ULL << (TSqlParser::NOCOUNT - 618))
      | (1ULL << (TSqlParser::NODES - 618))
      | (1ULL << (TSqlParser::NOEXPAND - 618))
      | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 618))
      | (1ULL << (TSqlParser::NORECOMPUTE - 618))
      | (1ULL << (TSqlParser::NORECOVERY - 618))
      | (1ULL << (TSqlParser::NOWAIT - 618))
      | (1ULL << (TSqlParser::NTILE - 618))
      | (1ULL << (TSqlParser::NUMANODE - 618))
      | (1ULL << (TSqlParser::NUMBER - 618))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 618))
      | (1ULL << (TSqlParser::OBJECT - 618))
      | (1ULL << (TSqlParser::OFFLINE - 618))
      | (1ULL << (TSqlParser::OFFSET - 618))
      | (1ULL << (TSqlParser::OLD_ACCOUNT - 618))
      | (1ULL << (TSqlParser::ONLINE - 618))
      | (1ULL << (TSqlParser::ONLY - 618))
      | (1ULL << (TSqlParser::OPEN_EXISTING - 618))
      | (1ULL << (TSqlParser::OPTIMISTIC - 618))
      | (1ULL << (TSqlParser::OPTIMIZE - 618))
      | (1ULL << (TSqlParser::OUT - 618))
      | (1ULL << (TSqlParser::OUTPUT - 618))
      | (1ULL << (TSqlParser::OWNER - 618))
      | (1ULL << (TSqlParser::PAGE_VERIFY - 618))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 618))
      | (1ULL << (TSqlParser::PARTITION - 618))
      | (1ULL << (TSqlParser::PARTITIONS - 618))
      | (1ULL << (TSqlParser::PARTNER - 618))
      | (1ULL << (TSqlParser::PATH - 618))
      | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 618))
      | (1ULL << (TSqlParser::POOL - 618))
      | (1ULL << (TSqlParser::PORT - 618))
      | (1ULL << (TSqlParser::PRECEDING - 618))
      | (1ULL << (TSqlParser::PRIMARY_ROLE - 618))
      | (1ULL << (TSqlParser::PRIOR - 618))
      | (1ULL << (TSqlParser::PRIORITY - 618))
      | (1ULL << (TSqlParser::PRIORITY_LEVEL - 618))
      | (1ULL << (TSqlParser::PRIVATE - 618))
      | (1ULL << (TSqlParser::PRIVATE_KEY - 618))
      | (1ULL << (TSqlParser::PRIVILEGES - 618))
      | (1ULL << (TSqlParser::PROCEDURE_NAME - 618))
      | (1ULL << (TSqlParser::PROPERTY - 618)))) != 0) || ((((_la - 682) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 682)) & ((1ULL << (TSqlParser::PROVIDER - 682))
      | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 682))
      | (1ULL << (TSqlParser::QUERY - 682))
      | (1ULL << (TSqlParser::QUEUE - 682))
      | (1ULL << (TSqlParser::QUEUE_DELAY - 682))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 682))
      | (1ULL << (TSqlParser::RANGE - 682))
      | (1ULL << (TSqlParser::RANK - 682))
      | (1ULL << (TSqlParser::RC2 - 682))
      | (1ULL << (TSqlParser::RC4 - 682))
      | (1ULL << (TSqlParser::RC4_128 - 682))
      | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 682))
      | (1ULL << (TSqlParser::READ_ONLY - 682))
      | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 682))
      | (1ULL << (TSqlParser::READ_WRITE - 682))
      | (1ULL << (TSqlParser::READONLY - 682))
      | (1ULL << (TSqlParser::REBUILD - 682))
      | (1ULL << (TSqlParser::RECEIVE - 682))
      | (1ULL << (TSqlParser::RECOMPILE - 682))
      | (1ULL << (TSqlParser::RECOVERY - 682))
      | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 682))
      | (1ULL << (TSqlParser::RELATIVE - 682))
      | (1ULL << (TSqlParser::REMOTE - 682))
      | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 682))
      | (1ULL << (TSqlParser::REMOVE - 682))
      | (1ULL << (TSqlParser::REORGANIZE - 682))
      | (1ULL << (TSqlParser::REPEATABLE - 682))
      | (1ULL << (TSqlParser::REPLICA - 682))
      | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 682))
      | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 682))
      | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 682))
      | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 682))
      | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 682))
      | (1ULL << (TSqlParser::RESOURCE - 682))
      | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 682))
      | (1ULL << (TSqlParser::RESTRICTED_USER - 682))
      | (1ULL << (TSqlParser::RETENTION - 682))
      | (1ULL << (TSqlParser::ROBUST - 682))
      | (1ULL << (TSqlParser::ROOT - 682))
      | (1ULL << (TSqlParser::ROUTE - 682))
      | (1ULL << (TSqlParser::ROW - 682))
      | (1ULL << (TSqlParser::ROW_NUMBER - 682))
      | (1ULL << (TSqlParser::ROWGUID - 682))
      | (1ULL << (TSqlParser::ROWS - 682))
      | (1ULL << (TSqlParser::SAMPLE - 682))
      | (1ULL << (TSqlParser::SCHEMABINDING - 682))
      | (1ULL << (TSqlParser::SCOPED - 682))
      | (1ULL << (TSqlParser::SCROLL - 682))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 682))
      | (1ULL << (TSqlParser::SEARCH - 682))
      | (1ULL << (TSqlParser::SECONDARY - 682))
      | (1ULL << (TSqlParser::SECONDARY_ONLY - 682))
      | (1ULL << (TSqlParser::SECONDARY_ROLE - 682))
      | (1ULL << (TSqlParser::SECONDS - 682))
      | (1ULL << (TSqlParser::SECRET - 682))
      | (1ULL << (TSqlParser::SECURITY - 682))
      | (1ULL << (TSqlParser::SECURITY_LOG - 682))
      | (1ULL << (TSqlParser::SEEDING_MODE - 682))
      | (1ULL << (TSqlParser::SELF - 682))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 682))
      | (1ULL << (TSqlParser::SEND - 682))
      | (1ULL << (TSqlParser::SENT - 682))
      | (1ULL << (TSqlParser::SEQUENCE - 682))
      | (1ULL << (TSqlParser::SERIALIZABLE - 682)))) != 0) || ((((_la - 746) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 746)) & ((1ULL << (TSqlParser::SESSION_TIMEOUT - 746))
      | (1ULL << (TSqlParser::SETERROR - 746))
      | (1ULL << (TSqlParser::SHARE - 746))
      | (1ULL << (TSqlParser::SHOWPLAN - 746))
      | (1ULL << (TSqlParser::SIGNATURE - 746))
      | (1ULL << (TSqlParser::SIMPLE - 746))
      | (1ULL << (TSqlParser::SINGLE_USER - 746))
      | (1ULL << (TSqlParser::SIZE - 746))
      | (1ULL << (TSqlParser::SMALLINT - 746))
      | (1ULL << (TSqlParser::SNAPSHOT - 746))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 746))
      | (1ULL << (TSqlParser::STANDBY - 746))
      | (1ULL << (TSqlParser::START_DATE - 746))
      | (1ULL << (TSqlParser::STATIC - 746))
      | (1ULL << (TSqlParser::STATS_STREAM - 746))
      | (1ULL << (TSqlParser::STATUS - 746))
      | (1ULL << (TSqlParser::STDEV - 746))
      | (1ULL << (TSqlParser::STDEVP - 746))
      | (1ULL << (TSqlParser::STOPLIST - 746))
      | (1ULL << (TSqlParser::STRING_AGG - 746))
      | (1ULL << (TSqlParser::STUFF - 746))
      | (1ULL << (TSqlParser::SUBJECT - 746))
      | (1ULL << (TSqlParser::SUM - 746))
      | (1ULL << (TSqlParser::SUSPEND - 746))
      | (1ULL << (TSqlParser::SYMMETRIC - 746))
      | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 746))
      | (1ULL << (TSqlParser::SYNONYM - 746))
      | (1ULL << (TSqlParser::SYSTEM - 746))
      | (1ULL << (TSqlParser::TAKE - 746))
      | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 746))
      | (1ULL << (TSqlParser::TB - 746))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 746))
      | (1ULL << (TSqlParser::THROW - 746))
      | (1ULL << (TSqlParser::TIES - 746))
      | (1ULL << (TSqlParser::TIME - 746))
      | (1ULL << (TSqlParser::TIMEOUT - 746))
      | (1ULL << (TSqlParser::TIMER - 746))
      | (1ULL << (TSqlParser::TINYINT - 746))
      | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 746))
      | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 746))
      | (1ULL << (TSqlParser::TRIPLE_DES - 746))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 746))
      | (1ULL << (TSqlParser::TRUSTWORTHY - 746))
      | (1ULL << (TSqlParser::TRY - 746))
      | (1ULL << (TSqlParser::TSQL - 746))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 746))
      | (1ULL << (TSqlParser::TYPE - 746))
      | (1ULL << (TSqlParser::TYPE_WARNING - 746))
      | (1ULL << (TSqlParser::UNBOUNDED - 746))
      | (1ULL << (TSqlParser::UNCOMMITTED - 746))
      | (1ULL << (TSqlParser::UNKNOWN - 746))
      | (1ULL << (TSqlParser::UNLIMITED - 746))
      | (1ULL << (TSqlParser::USING - 746))
      | (1ULL << (TSqlParser::VALID_XML - 746))
      | (1ULL << (TSqlParser::VALIDATION - 746))
      | (1ULL << (TSqlParser::VALUE - 746))
      | (1ULL << (TSqlParser::VAR - 746))
      | (1ULL << (TSqlParser::VARP - 746))
      | (1ULL << (TSqlParser::VIEW_METADATA - 746))
      | (1ULL << (TSqlParser::VIEWS - 746)))) != 0) || ((((_la - 810) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 810)) & ((1ULL << (TSqlParser::WAIT - 810))
      | (1ULL << (TSqlParser::WELL_FORMED_XML - 810))
      | (1ULL << (TSqlParser::WORK - 810))
      | (1ULL << (TSqlParser::WORKLOAD - 810))
      | (1ULL << (TSqlParser::XML - 810))
      | (1ULL << (TSqlParser::XMLNAMESPACES - 810))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 810))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 810))
      | (1ULL << (TSqlParser::ID - 810))
      | (1ULL << (TSqlParser::LR_BRACKET - 810))
      | (1ULL << (TSqlParser::COMMA - 810)))) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_session_predicate_factorContext ------------------------------------------------------------------

TSqlParser::Event_session_predicate_factorContext::Event_session_predicate_factorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Event_session_predicate_leafContext* TSqlParser::Event_session_predicate_factorContext::event_session_predicate_leaf() {
  return getRuleContext<TSqlParser::Event_session_predicate_leafContext>(0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_factorContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Event_session_predicate_expressionContext* TSqlParser::Event_session_predicate_factorContext::event_session_predicate_expression() {
  return getRuleContext<TSqlParser::Event_session_predicate_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_factorContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Event_session_predicate_factorContext::getRuleIndex() const {
  return TSqlParser::RuleEvent_session_predicate_factor;
}

void TSqlParser::Event_session_predicate_factorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_session_predicate_factor(this);
}

void TSqlParser::Event_session_predicate_factorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_session_predicate_factor(this);
}

TSqlParser::Event_session_predicate_factorContext* TSqlParser::event_session_predicate_factor() {
  Event_session_predicate_factorContext *_localctx = _tracker.createInstance<Event_session_predicate_factorContext>(_ctx, getState());
  enterRule(_localctx, 68, TSqlParser::RuleEvent_session_predicate_factor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(877);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(872);
        event_session_predicate_leaf();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(873);
        match(TSqlParser::LR_BRACKET);
        setState(874);
        event_session_predicate_expression();
        setState(875);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_session_predicate_leafContext ------------------------------------------------------------------

TSqlParser::Event_session_predicate_leafContext::Event_session_predicate_leafContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Event_session_predicate_leafContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Event_session_predicate_leafContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::GREATER() {
  return getToken(TSqlParser::GREATER, 0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::LESS() {
  return getToken(TSqlParser::LESS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Event_session_predicate_leafContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::EXCLAMATION() {
  return getToken(TSqlParser::EXCLAMATION, 0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Event_session_predicate_leafContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}


size_t TSqlParser::Event_session_predicate_leafContext::getRuleIndex() const {
  return TSqlParser::RuleEvent_session_predicate_leaf;
}

void TSqlParser::Event_session_predicate_leafContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_session_predicate_leaf(this);
}

void TSqlParser::Event_session_predicate_leafContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_session_predicate_leaf(this);
}

TSqlParser::Event_session_predicate_leafContext* TSqlParser::event_session_predicate_leaf() {
  Event_session_predicate_leafContext *_localctx = _tracker.createInstance<Event_session_predicate_leafContext>(_ctx, getState());
  enterRule(_localctx, 70, TSqlParser::RuleEvent_session_predicate_leaf);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(935);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(907);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
      case 1: {
        setState(879);
        dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_field_name = id();
        break;
      }

      case 2: {
        setState(890);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
        case 1: {
          setState(880);
          dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_field_name = id();
          break;
        }

        case 2: {
          setState(884);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
          case 1: {
            setState(881);
            dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_module_guid = id();
            setState(882);
            match(TSqlParser::DOT);
            break;
          }

          }
          setState(886);
          dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_package_name = id();
          setState(887);
          match(TSqlParser::DOT);
          setState(888);
          dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->predicate_source_name = id();
          break;
        }

        }
        setState(903);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
        case 1: {
          setState(892);
          match(TSqlParser::EQUAL);
          break;
        }

        case 2: {
          setState(893);
          match(TSqlParser::LESS);
          setState(894);
          match(TSqlParser::GREATER);
          break;
        }

        case 3: {
          setState(895);
          match(TSqlParser::EXCLAMATION);
          setState(896);
          match(TSqlParser::EQUAL);
          break;
        }

        case 4: {
          setState(897);
          match(TSqlParser::GREATER);
          break;
        }

        case 5: {
          setState(898);
          match(TSqlParser::GREATER);
          setState(899);
          match(TSqlParser::EQUAL);
          break;
        }

        case 6: {
          setState(900);
          match(TSqlParser::LESS);
          break;
        }

        case 7: {
          setState(901);
          match(TSqlParser::LESS);
          setState(902);
          match(TSqlParser::EQUAL);
          break;
        }

        }
        setState(905);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DECIMAL

        || _la == TSqlParser::STRING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(912);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
      case 1: {
        setState(909);
        dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_module_guid = id();
        setState(910);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(914);
      dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_package_name = id();
      setState(915);
      match(TSqlParser::DOT);
      setState(916);
      dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->predicate_compare_name = id();
      setState(917);
      match(TSqlParser::LR_BRACKET);
      setState(931);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
      case 1: {
        setState(918);
        dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_field_name = id();
        break;
      }

      case 2: {
        setState(922);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
        case 1: {
          setState(919);
          dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_module_guid = id();
          setState(920);
          match(TSqlParser::DOT);
          break;
        }

        }
        setState(924);
        dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->event_package_name = id();
        setState(925);
        match(TSqlParser::DOT);
        setState(926);
        dynamic_cast<Event_session_predicate_leafContext *>(_localctx)->predicate_source_name = id();
        setState(928);
        match(TSqlParser::COMMA);
        setState(929);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DECIMAL

        || _la == TSqlParser::STRING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(933);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_schema_sqlContext ------------------------------------------------------------------

TSqlParser::Alter_schema_sqlContext::Alter_schema_sqlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_schema_sqlContext::SCHEMA() {
  return getTokens(TSqlParser::SCHEMA);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::SCHEMA(size_t i) {
  return getToken(TSqlParser::SCHEMA, i);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::TRANSFER() {
  return getToken(TSqlParser::TRANSFER, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Alter_schema_sqlContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Alter_schema_sqlContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_schema_sqlContext::COLON() {
  return getTokens(TSqlParser::COLON);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::COLON(size_t i) {
  return getToken(TSqlParser::COLON, i);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::XML() {
  return getToken(TSqlParser::XML, 0);
}

tree::TerminalNode* TSqlParser::Alter_schema_sqlContext::COLLECTION() {
  return getToken(TSqlParser::COLLECTION, 0);
}


size_t TSqlParser::Alter_schema_sqlContext::getRuleIndex() const {
  return TSqlParser::RuleAlter_schema_sql;
}

void TSqlParser::Alter_schema_sqlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_schema_sql(this);
}

void TSqlParser::Alter_schema_sqlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_schema_sql(this);
}

TSqlParser::Alter_schema_sqlContext* TSqlParser::alter_schema_sql() {
  Alter_schema_sqlContext *_localctx = _tracker.createInstance<Alter_schema_sqlContext>(_ctx, getState());
  enterRule(_localctx, 72, TSqlParser::RuleAlter_schema_sql);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(937);
    match(TSqlParser::ALTER);
    setState(938);
    match(TSqlParser::SCHEMA);
    setState(939);
    dynamic_cast<Alter_schema_sqlContext *>(_localctx)->schema_name = id();
    setState(940);
    match(TSqlParser::TRANSFER);
    setState(950);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(946);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::OBJECT: {
          setState(941);
          match(TSqlParser::OBJECT);
          break;
        }

        case TSqlParser::TYPE: {
          setState(942);
          match(TSqlParser::TYPE);
          break;
        }

        case TSqlParser::XML: {
          setState(943);
          match(TSqlParser::XML);
          setState(944);
          match(TSqlParser::SCHEMA);
          setState(945);
          match(TSqlParser::COLLECTION);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(948);
      match(TSqlParser::COLON);
      setState(949);
      match(TSqlParser::COLON);
      break;
    }

    }
    setState(952);
    id();
    setState(955);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::DOT) {
      setState(953);
      match(TSqlParser::DOT);
      setState(954);
      id();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_schemaContext ------------------------------------------------------------------

TSqlParser::Create_schemaContext::Create_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_schemaContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::SCHEMA() {
  return getTokens(TSqlParser::SCHEMA);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::SCHEMA(size_t i) {
  return getToken(TSqlParser::SCHEMA, i);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::AUTHORIZATION() {
  return getToken(TSqlParser::AUTHORIZATION, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Create_schemaContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Create_schemaContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<TSqlParser::Create_tableContext *> TSqlParser::Create_schemaContext::create_table() {
  return getRuleContexts<TSqlParser::Create_tableContext>();
}

TSqlParser::Create_tableContext* TSqlParser::Create_schemaContext::create_table(size_t i) {
  return getRuleContext<TSqlParser::Create_tableContext>(i);
}

std::vector<TSqlParser::Create_viewContext *> TSqlParser::Create_schemaContext::create_view() {
  return getRuleContexts<TSqlParser::Create_viewContext>();
}

TSqlParser::Create_viewContext* TSqlParser::Create_schemaContext::create_view(size_t i) {
  return getRuleContext<TSqlParser::Create_viewContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::ON() {
  return getTokens(TSqlParser::ON);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::ON(size_t i) {
  return getToken(TSqlParser::ON, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::TO() {
  return getTokens(TSqlParser::TO);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::TO(size_t i) {
  return getToken(TSqlParser::TO, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::REVOKE() {
  return getTokens(TSqlParser::REVOKE);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::REVOKE(size_t i) {
  return getToken(TSqlParser::REVOKE, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::FROM() {
  return getTokens(TSqlParser::FROM);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::FROM(size_t i) {
  return getToken(TSqlParser::FROM, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::GRANT() {
  return getTokens(TSqlParser::GRANT);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::GRANT(size_t i) {
  return getToken(TSqlParser::GRANT, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::DENY() {
  return getTokens(TSqlParser::DENY);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::DENY(size_t i) {
  return getToken(TSqlParser::DENY, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::SELECT() {
  return getTokens(TSqlParser::SELECT);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::SELECT(size_t i) {
  return getToken(TSqlParser::SELECT, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::INSERT() {
  return getTokens(TSqlParser::INSERT);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::INSERT(size_t i) {
  return getToken(TSqlParser::INSERT, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::DELETE() {
  return getTokens(TSqlParser::DELETE);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::DELETE(size_t i) {
  return getToken(TSqlParser::DELETE, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::UPDATE() {
  return getTokens(TSqlParser::UPDATE);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::UPDATE(size_t i) {
  return getToken(TSqlParser::UPDATE, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_schemaContext::COLON() {
  return getTokens(TSqlParser::COLON);
}

tree::TerminalNode* TSqlParser::Create_schemaContext::COLON(size_t i) {
  return getToken(TSqlParser::COLON, i);
}


size_t TSqlParser::Create_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_schema;
}

void TSqlParser::Create_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_schema(this);
}

void TSqlParser::Create_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_schema(this);
}

TSqlParser::Create_schemaContext* TSqlParser::create_schema() {
  Create_schemaContext *_localctx = _tracker.createInstance<Create_schemaContext>(_ctx, getState());
  enterRule(_localctx, 74, TSqlParser::RuleCreate_schema);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(957);
    match(TSqlParser::CREATE);
    setState(958);
    match(TSqlParser::SCHEMA);
    setState(966);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      setState(959);
      dynamic_cast<Create_schemaContext *>(_localctx)->schema_name = id();
      break;
    }

    case 2: {
      setState(960);
      match(TSqlParser::AUTHORIZATION);
      setState(961);
      dynamic_cast<Create_schemaContext *>(_localctx)->owner_name = id();
      break;
    }

    case 3: {
      setState(962);
      dynamic_cast<Create_schemaContext *>(_localctx)->schema_name = id();
      setState(963);
      match(TSqlParser::AUTHORIZATION);
      setState(964);
      dynamic_cast<Create_schemaContext *>(_localctx)->owner_name = id();
      break;
    }

    }
    setState(996);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(994);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
        case 1: {
          setState(968);
          create_table();
          break;
        }

        case 2: {
          setState(969);
          create_view();
          break;
        }

        case 3: {
          setState(970);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::DENY

          || _la == TSqlParser::GRANT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(971);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::DELETE || _la == TSqlParser::INSERT || _la == TSqlParser::SELECT

          || _la == TSqlParser::UPDATE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(972);
          match(TSqlParser::ON);
          setState(976);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::SCHEMA) {
            setState(973);
            match(TSqlParser::SCHEMA);
            setState(974);
            match(TSqlParser::COLON);
            setState(975);
            match(TSqlParser::COLON);
          }
          setState(978);
          dynamic_cast<Create_schemaContext *>(_localctx)->object_name = id();
          setState(979);
          match(TSqlParser::TO);
          setState(980);
          dynamic_cast<Create_schemaContext *>(_localctx)->owner_name = id();
          break;
        }

        case 4: {
          setState(982);
          match(TSqlParser::REVOKE);
          setState(983);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::DELETE || _la == TSqlParser::INSERT || _la == TSqlParser::SELECT

          || _la == TSqlParser::UPDATE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(984);
          match(TSqlParser::ON);
          setState(988);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::SCHEMA) {
            setState(985);
            match(TSqlParser::SCHEMA);
            setState(986);
            match(TSqlParser::COLON);
            setState(987);
            match(TSqlParser::COLON);
          }
          setState(990);
          dynamic_cast<Create_schemaContext *>(_localctx)->object_name = id();
          setState(991);
          match(TSqlParser::FROM);
          setState(992);
          dynamic_cast<Create_schemaContext *>(_localctx)->owner_name = id();
          break;
        }

        } 
      }
      setState(998);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_xml_schema_collectionContext ------------------------------------------------------------------

TSqlParser::Create_xml_schema_collectionContext::Create_xml_schema_collectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::XML() {
  return getToken(TSqlParser::XML, 0);
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::COLLECTION() {
  return getToken(TSqlParser::COLLECTION, 0);
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Create_xml_schema_collectionContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Create_xml_schema_collectionContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Create_xml_schema_collectionContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Create_xml_schema_collectionContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_xml_schema_collection;
}

void TSqlParser::Create_xml_schema_collectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_xml_schema_collection(this);
}

void TSqlParser::Create_xml_schema_collectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_xml_schema_collection(this);
}

TSqlParser::Create_xml_schema_collectionContext* TSqlParser::create_xml_schema_collection() {
  Create_xml_schema_collectionContext *_localctx = _tracker.createInstance<Create_xml_schema_collectionContext>(_ctx, getState());
  enterRule(_localctx, 76, TSqlParser::RuleCreate_xml_schema_collection);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(999);
    match(TSqlParser::CREATE);
    setState(1000);
    match(TSqlParser::XML);
    setState(1001);
    match(TSqlParser::SCHEMA);
    setState(1002);
    match(TSqlParser::COLLECTION);
    setState(1006);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(1003);
      dynamic_cast<Create_xml_schema_collectionContext *>(_localctx)->relational_schema = id();
      setState(1004);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(1008);
    dynamic_cast<Create_xml_schema_collectionContext *>(_localctx)->sql_identifier = id();
    setState(1009);
    match(TSqlParser::AS);
    setState(1013);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::STRING: {
        setState(1010);
        match(TSqlParser::STRING);
        break;
      }

      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(1011);
        id();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        setState(1012);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_queueContext ------------------------------------------------------------------

TSqlParser::Create_queueContext::Create_queueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_queueContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_queueContext::QUEUE() {
  return getToken(TSqlParser::QUEUE, 0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Create_queueContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Create_queueContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Create_queueContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

TSqlParser::Queue_settingsContext* TSqlParser::Create_queueContext::queue_settings() {
  return getRuleContext<TSqlParser::Queue_settingsContext>(0);
}

tree::TerminalNode* TSqlParser::Create_queueContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Create_queueContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}


size_t TSqlParser::Create_queueContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_queue;
}

void TSqlParser::Create_queueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_queue(this);
}

void TSqlParser::Create_queueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_queue(this);
}

TSqlParser::Create_queueContext* TSqlParser::create_queue() {
  Create_queueContext *_localctx = _tracker.createInstance<Create_queueContext>(_ctx, getState());
  enterRule(_localctx, 78, TSqlParser::RuleCreate_queue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1015);
    match(TSqlParser::CREATE);
    setState(1016);
    match(TSqlParser::QUEUE);
    setState(1019);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      setState(1017);
      full_table_name();
      break;
    }

    case 2: {
      setState(1018);
      dynamic_cast<Create_queueContext *>(_localctx)->queue_name = id();
      break;
    }

    }
    setState(1022);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(1021);
      queue_settings();
      break;
    }

    }
    setState(1027);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      setState(1024);
      match(TSqlParser::ON);
      setState(1025);
      dynamic_cast<Create_queueContext *>(_localctx)->filegroup = id();
      break;
    }

    case 2: {
      setState(1026);
      match(TSqlParser::DEFAULT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Queue_settingsContext ------------------------------------------------------------------

TSqlParser::Queue_settingsContext::Queue_settingsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_settingsContext::STATUS() {
  return getTokens(TSqlParser::STATUS);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::STATUS(size_t i) {
  return getToken(TSqlParser::STATUS, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_settingsContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::RETENTION() {
  return getToken(TSqlParser::RETENTION, 0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::ACTIVATION() {
  return getToken(TSqlParser::ACTIVATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_settingsContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_settingsContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::POISON_MESSAGE_HANDLING() {
  return getToken(TSqlParser::POISON_MESSAGE_HANDLING, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_settingsContext::ON() {
  return getTokens(TSqlParser::ON);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::ON(size_t i) {
  return getToken(TSqlParser::ON, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_settingsContext::OFF() {
  return getTokens(TSqlParser::OFF);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::OFF(size_t i) {
  return getToken(TSqlParser::OFF, i);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_settingsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::PROCEDURE_NAME() {
  return getToken(TSqlParser::PROCEDURE_NAME, 0);
}

TSqlParser::Func_proc_name_database_schemaContext* TSqlParser::Queue_settingsContext::func_proc_name_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_database_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::MAX_QUEUE_READERS() {
  return getToken(TSqlParser::MAX_QUEUE_READERS, 0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::EXECUTE() {
  return getToken(TSqlParser::EXECUTE, 0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::SELF() {
  return getToken(TSqlParser::SELF, 0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::OWNER() {
  return getToken(TSqlParser::OWNER, 0);
}

tree::TerminalNode* TSqlParser::Queue_settingsContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Queue_settingsContext::getRuleIndex() const {
  return TSqlParser::RuleQueue_settings;
}

void TSqlParser::Queue_settingsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueue_settings(this);
}

void TSqlParser::Queue_settingsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueue_settings(this);
}

TSqlParser::Queue_settingsContext* TSqlParser::queue_settings() {
  Queue_settingsContext *_localctx = _tracker.createInstance<Queue_settingsContext>(_ctx, getState());
  enterRule(_localctx, 80, TSqlParser::RuleQueue_settings);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1029);
    match(TSqlParser::WITH);
    setState(1036);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      setState(1030);
      match(TSqlParser::STATUS);
      setState(1031);
      match(TSqlParser::EQUAL);
      setState(1032);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::OFF

      || _la == TSqlParser::ON)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1034);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(1033);
        match(TSqlParser::COMMA);
      }
      break;
    }

    }
    setState(1044);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(1038);
      match(TSqlParser::RETENTION);
      setState(1039);
      match(TSqlParser::EQUAL);
      setState(1040);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::OFF

      || _la == TSqlParser::ON)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1042);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(1041);
        match(TSqlParser::COMMA);
      }
      break;
    }

    }
    setState(1091);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
    case 1: {
      setState(1046);
      match(TSqlParser::ACTIVATION);
      setState(1047);
      match(TSqlParser::LR_BRACKET);
      setState(1085);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EXECUTE:
        case TSqlParser::MAX_QUEUE_READERS:
        case TSqlParser::PROCEDURE_NAME:
        case TSqlParser::STATUS:
        case TSqlParser::RR_BRACKET: {
          setState(1054);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::STATUS) {
            setState(1048);
            match(TSqlParser::STATUS);
            setState(1049);
            match(TSqlParser::EQUAL);
            setState(1050);
            _la = _input->LA(1);
            if (!(_la == TSqlParser::OFF

            || _la == TSqlParser::ON)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(1052);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == TSqlParser::COMMA) {
              setState(1051);
              match(TSqlParser::COMMA);
            }
          }
          setState(1062);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::PROCEDURE_NAME) {
            setState(1056);
            match(TSqlParser::PROCEDURE_NAME);
            setState(1057);
            match(TSqlParser::EQUAL);
            setState(1058);
            func_proc_name_database_schema();
            setState(1060);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == TSqlParser::COMMA) {
              setState(1059);
              match(TSqlParser::COMMA);
            }
          }
          setState(1070);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::MAX_QUEUE_READERS) {
            setState(1064);
            match(TSqlParser::MAX_QUEUE_READERS);
            setState(1065);
            match(TSqlParser::EQUAL);
            setState(1066);
            dynamic_cast<Queue_settingsContext *>(_localctx)->max_readers = match(TSqlParser::DECIMAL);
            setState(1068);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == TSqlParser::COMMA) {
              setState(1067);
              match(TSqlParser::COMMA);
            }
          }
          setState(1082);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::EXECUTE) {
            setState(1072);
            match(TSqlParser::EXECUTE);
            setState(1073);
            match(TSqlParser::AS);
            setState(1077);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case TSqlParser::SELF: {
                setState(1074);
                match(TSqlParser::SELF);
                break;
              }

              case TSqlParser::STRING: {
                setState(1075);
                dynamic_cast<Queue_settingsContext *>(_localctx)->user_name = match(TSqlParser::STRING);
                break;
              }

              case TSqlParser::OWNER: {
                setState(1076);
                match(TSqlParser::OWNER);
                break;
              }

            default:
              throw NoViableAltException(this);
            }
            setState(1080);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == TSqlParser::COMMA) {
              setState(1079);
              match(TSqlParser::COMMA);
            }
          }
          break;
        }

        case TSqlParser::DROP: {
          setState(1084);
          match(TSqlParser::DROP);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1087);
      match(TSqlParser::RR_BRACKET);
      setState(1089);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(1088);
        match(TSqlParser::COMMA);
      }
      break;
    }

    }
    setState(1100);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      setState(1093);
      match(TSqlParser::POISON_MESSAGE_HANDLING);
      setState(1094);
      match(TSqlParser::LR_BRACKET);

      setState(1095);
      match(TSqlParser::STATUS);
      setState(1096);
      match(TSqlParser::EQUAL);
      setState(1097);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::OFF

      || _la == TSqlParser::ON)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1099);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_queueContext ------------------------------------------------------------------

TSqlParser::Alter_queueContext::Alter_queueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Alter_queueContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Alter_queueContext::QUEUE() {
  return getToken(TSqlParser::QUEUE, 0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Alter_queueContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

TSqlParser::Queue_settingsContext* TSqlParser::Alter_queueContext::queue_settings() {
  return getRuleContext<TSqlParser::Queue_settingsContext>(0);
}

TSqlParser::Queue_actionContext* TSqlParser::Alter_queueContext::queue_action() {
  return getRuleContext<TSqlParser::Queue_actionContext>(0);
}

TSqlParser::IdContext* TSqlParser::Alter_queueContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}


size_t TSqlParser::Alter_queueContext::getRuleIndex() const {
  return TSqlParser::RuleAlter_queue;
}

void TSqlParser::Alter_queueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_queue(this);
}

void TSqlParser::Alter_queueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_queue(this);
}

TSqlParser::Alter_queueContext* TSqlParser::alter_queue() {
  Alter_queueContext *_localctx = _tracker.createInstance<Alter_queueContext>(_ctx, getState());
  enterRule(_localctx, 82, TSqlParser::RuleAlter_queue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1102);
    match(TSqlParser::ALTER);
    setState(1103);
    match(TSqlParser::QUEUE);
    setState(1106);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(1104);
      full_table_name();
      break;
    }

    case 2: {
      setState(1105);
      dynamic_cast<Alter_queueContext *>(_localctx)->queue_name = id();
      break;
    }

    }
    setState(1110);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::WITH: {
        setState(1108);
        queue_settings();
        break;
      }

      case TSqlParser::MOVE:
      case TSqlParser::REBUILD:
      case TSqlParser::REORGANIZE: {
        setState(1109);
        queue_action();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Queue_actionContext ------------------------------------------------------------------

TSqlParser::Queue_actionContext::Queue_actionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Queue_actionContext::REBUILD() {
  return getToken(TSqlParser::REBUILD, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Queue_rebuild_optionsContext* TSqlParser::Queue_actionContext::queue_rebuild_options() {
  return getRuleContext<TSqlParser::Queue_rebuild_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::REORGANIZE() {
  return getToken(TSqlParser::REORGANIZE, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::LOB_COMPACTION() {
  return getToken(TSqlParser::LOB_COMPACTION, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::MOVE() {
  return getToken(TSqlParser::MOVE, 0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::TO() {
  return getToken(TSqlParser::TO, 0);
}

TSqlParser::IdContext* TSqlParser::Queue_actionContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Queue_actionContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}


size_t TSqlParser::Queue_actionContext::getRuleIndex() const {
  return TSqlParser::RuleQueue_action;
}

void TSqlParser::Queue_actionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueue_action(this);
}

void TSqlParser::Queue_actionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueue_action(this);
}

TSqlParser::Queue_actionContext* TSqlParser::queue_action() {
  Queue_actionContext *_localctx = _tracker.createInstance<Queue_actionContext>(_ctx, getState());
  enterRule(_localctx, 84, TSqlParser::RuleQueue_action);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1133);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::REBUILD: {
        enterOuterAlt(_localctx, 1);
        setState(1112);
        match(TSqlParser::REBUILD);
        setState(1118);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
        case 1: {
          setState(1113);
          match(TSqlParser::WITH);
          setState(1114);
          match(TSqlParser::LR_BRACKET);
          setState(1115);
          queue_rebuild_options();
          setState(1116);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        }
        break;
      }

      case TSqlParser::REORGANIZE: {
        enterOuterAlt(_localctx, 2);
        setState(1120);
        match(TSqlParser::REORGANIZE);
        setState(1125);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
        case 1: {
          setState(1121);
          match(TSqlParser::WITH);
          setState(1122);
          match(TSqlParser::LOB_COMPACTION);
          setState(1123);
          match(TSqlParser::EQUAL);
          setState(1124);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::OFF

          || _la == TSqlParser::ON)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        }
        break;
      }

      case TSqlParser::MOVE: {
        enterOuterAlt(_localctx, 3);
        setState(1127);
        match(TSqlParser::MOVE);
        setState(1128);
        match(TSqlParser::TO);
        setState(1131);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CALLED:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::INIT:
          case TSqlParser::KEY:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::OFFSETS:
          case TSqlParser::PAGE:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAW:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(1129);
            id();
            break;
          }

          case TSqlParser::DEFAULT: {
            setState(1130);
            match(TSqlParser::DEFAULT);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Queue_rebuild_optionsContext ------------------------------------------------------------------

TSqlParser::Queue_rebuild_optionsContext::Queue_rebuild_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Queue_rebuild_optionsContext::MAXDOP() {
  return getToken(TSqlParser::MAXDOP, 0);
}

tree::TerminalNode* TSqlParser::Queue_rebuild_optionsContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Queue_rebuild_optionsContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Queue_rebuild_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleQueue_rebuild_options;
}

void TSqlParser::Queue_rebuild_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueue_rebuild_options(this);
}

void TSqlParser::Queue_rebuild_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueue_rebuild_options(this);
}

TSqlParser::Queue_rebuild_optionsContext* TSqlParser::queue_rebuild_options() {
  Queue_rebuild_optionsContext *_localctx = _tracker.createInstance<Queue_rebuild_optionsContext>(_ctx, getState());
  enterRule(_localctx, 86, TSqlParser::RuleQueue_rebuild_options);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1135);
    match(TSqlParser::MAXDOP);
    setState(1136);
    match(TSqlParser::EQUAL);
    setState(1137);
    match(TSqlParser::DECIMAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conversation_statementContext ------------------------------------------------------------------

TSqlParser::Conversation_statementContext::Conversation_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Begin_conversation_timerContext* TSqlParser::Conversation_statementContext::begin_conversation_timer() {
  return getRuleContext<TSqlParser::Begin_conversation_timerContext>(0);
}

TSqlParser::Begin_conversation_dialogContext* TSqlParser::Conversation_statementContext::begin_conversation_dialog() {
  return getRuleContext<TSqlParser::Begin_conversation_dialogContext>(0);
}

TSqlParser::End_conversationContext* TSqlParser::Conversation_statementContext::end_conversation() {
  return getRuleContext<TSqlParser::End_conversationContext>(0);
}

TSqlParser::Get_conversationContext* TSqlParser::Conversation_statementContext::get_conversation() {
  return getRuleContext<TSqlParser::Get_conversationContext>(0);
}

TSqlParser::Send_conversationContext* TSqlParser::Conversation_statementContext::send_conversation() {
  return getRuleContext<TSqlParser::Send_conversationContext>(0);
}

TSqlParser::Waitfor_conversationContext* TSqlParser::Conversation_statementContext::waitfor_conversation() {
  return getRuleContext<TSqlParser::Waitfor_conversationContext>(0);
}


size_t TSqlParser::Conversation_statementContext::getRuleIndex() const {
  return TSqlParser::RuleConversation_statement;
}

void TSqlParser::Conversation_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConversation_statement(this);
}

void TSqlParser::Conversation_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConversation_statement(this);
}

TSqlParser::Conversation_statementContext* TSqlParser::conversation_statement() {
  Conversation_statementContext *_localctx = _tracker.createInstance<Conversation_statementContext>(_ctx, getState());
  enterRule(_localctx, 88, TSqlParser::RuleConversation_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1145);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1139);
      begin_conversation_timer();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1140);
      begin_conversation_dialog();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1141);
      end_conversation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1142);
      get_conversation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1143);
      send_conversation();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1144);
      waitfor_conversation();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Message_statementContext ------------------------------------------------------------------

TSqlParser::Message_statementContext::Message_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Message_statementContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::MESSAGE() {
  return getToken(TSqlParser::MESSAGE, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Message_statementContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Message_statementContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Message_statementContext::VALIDATION() {
  return getToken(TSqlParser::VALIDATION, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::AUTHORIZATION() {
  return getToken(TSqlParser::AUTHORIZATION, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::NONE() {
  return getToken(TSqlParser::NONE, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::EMPTY() {
  return getToken(TSqlParser::EMPTY, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::WELL_FORMED_XML() {
  return getToken(TSqlParser::WELL_FORMED_XML, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::VALID_XML() {
  return getToken(TSqlParser::VALID_XML, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

tree::TerminalNode* TSqlParser::Message_statementContext::COLLECTION() {
  return getToken(TSqlParser::COLLECTION, 0);
}


size_t TSqlParser::Message_statementContext::getRuleIndex() const {
  return TSqlParser::RuleMessage_statement;
}

void TSqlParser::Message_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMessage_statement(this);
}

void TSqlParser::Message_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMessage_statement(this);
}

TSqlParser::Message_statementContext* TSqlParser::message_statement() {
  Message_statementContext *_localctx = _tracker.createInstance<Message_statementContext>(_ctx, getState());
  enterRule(_localctx, 90, TSqlParser::RuleMessage_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1147);
    match(TSqlParser::CREATE);
    setState(1148);
    match(TSqlParser::MESSAGE);
    setState(1149);
    match(TSqlParser::TYPE);
    setState(1150);
    dynamic_cast<Message_statementContext *>(_localctx)->message_type_name = id();
    setState(1153);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AUTHORIZATION) {
      setState(1151);
      match(TSqlParser::AUTHORIZATION);
      setState(1152);
      dynamic_cast<Message_statementContext *>(_localctx)->owner_name = id();
    }

    setState(1155);
    match(TSqlParser::VALIDATION);
    setState(1156);
    match(TSqlParser::EQUAL);
    setState(1165);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NONE: {
        setState(1157);
        match(TSqlParser::NONE);
        break;
      }

      case TSqlParser::EMPTY: {
        setState(1158);
        match(TSqlParser::EMPTY);
        break;
      }

      case TSqlParser::WELL_FORMED_XML: {
        setState(1159);
        match(TSqlParser::WELL_FORMED_XML);
        break;
      }

      case TSqlParser::VALID_XML: {
        setState(1160);
        match(TSqlParser::VALID_XML);
        setState(1161);
        match(TSqlParser::WITH);
        setState(1162);
        match(TSqlParser::SCHEMA);
        setState(1163);
        match(TSqlParser::COLLECTION);
        setState(1164);
        dynamic_cast<Message_statementContext *>(_localctx)->schema_collection_name = id();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_statementContext ------------------------------------------------------------------

TSqlParser::Merge_statementContext::Merge_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_statementContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

TSqlParser::Ddl_objectContext* TSqlParser::Merge_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::USING() {
  return getToken(TSqlParser::USING, 0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Merge_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::Merge_statementContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::Merge_statementContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::With_expressionContext* TSqlParser::Merge_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Merge_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Merge_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::Merge_statementContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_statementContext::WHEN() {
  return getTokens(TSqlParser::WHEN);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::WHEN(size_t i) {
  return getToken(TSqlParser::WHEN, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_statementContext::MATCHED() {
  return getTokens(TSqlParser::MATCHED);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::MATCHED(size_t i) {
  return getToken(TSqlParser::MATCHED, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_statementContext::THEN() {
  return getTokens(TSqlParser::THEN);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::THEN(size_t i) {
  return getToken(TSqlParser::THEN, i);
}

std::vector<TSqlParser::Merge_matchedContext *> TSqlParser::Merge_statementContext::merge_matched() {
  return getRuleContexts<TSqlParser::Merge_matchedContext>();
}

TSqlParser::Merge_matchedContext* TSqlParser::Merge_statementContext::merge_matched(size_t i) {
  return getRuleContext<TSqlParser::Merge_matchedContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_statementContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

TSqlParser::Merge_not_matchedContext* TSqlParser::Merge_statementContext::merge_not_matched() {
  return getRuleContext<TSqlParser::Merge_not_matchedContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_statementContext::BY() {
  return getTokens(TSqlParser::BY);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::BY(size_t i) {
  return getToken(TSqlParser::BY, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_statementContext::SOURCE() {
  return getTokens(TSqlParser::SOURCE);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::SOURCE(size_t i) {
  return getToken(TSqlParser::SOURCE, i);
}

TSqlParser::Output_clauseContext* TSqlParser::Merge_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Merge_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_statementContext::AND() {
  return getTokens(TSqlParser::AND);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::AND(size_t i) {
  return getToken(TSqlParser::AND, i);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::TARGET() {
  return getToken(TSqlParser::TARGET, 0);
}


size_t TSqlParser::Merge_statementContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_statement;
}

void TSqlParser::Merge_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_statement(this);
}

void TSqlParser::Merge_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_statement(this);
}

TSqlParser::Merge_statementContext* TSqlParser::merge_statement() {
  Merge_statementContext *_localctx = _tracker.createInstance<Merge_statementContext>(_ctx, getState());
  enterRule(_localctx, 92, TSqlParser::RuleMerge_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1168);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1167);
      with_expression();
    }
    setState(1170);
    match(TSqlParser::MERGE);
    setState(1178);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(1171);
      match(TSqlParser::TOP);
      setState(1172);
      match(TSqlParser::LR_BRACKET);
      setState(1173);
      expression(0);
      setState(1174);
      match(TSqlParser::RR_BRACKET);
      setState(1176);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1175);
        match(TSqlParser::PERCENT);
      }
    }
    setState(1181);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1180);
      match(TSqlParser::INTO);
    }
    setState(1183);
    ddl_object();
    setState(1185);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1184);
      insert_with_table_hints();
    }
    setState(1188);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      setState(1187);
      as_table_alias();
      break;
    }

    }
    setState(1190);
    match(TSqlParser::USING);
    setState(1191);
    table_sources();
    setState(1192);
    match(TSqlParser::ON);
    setState(1193);
    search_condition();
    setState(1204);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1194);
        match(TSqlParser::WHEN);
        setState(1195);
        match(TSqlParser::MATCHED);
        setState(1198);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::AND) {
          setState(1196);
          match(TSqlParser::AND);
          setState(1197);
          search_condition();
        }
        setState(1200);
        match(TSqlParser::THEN);
        setState(1201);
        merge_matched(); 
      }
      setState(1206);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
    }
    setState(1220);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      setState(1207);
      match(TSqlParser::WHEN);
      setState(1208);
      match(TSqlParser::NOT);
      setState(1209);
      match(TSqlParser::MATCHED);
      setState(1212);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::BY) {
        setState(1210);
        match(TSqlParser::BY);
        setState(1211);
        match(TSqlParser::TARGET);
      }
      setState(1216);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AND) {
        setState(1214);
        match(TSqlParser::AND);
        setState(1215);
        search_condition();
      }
      setState(1218);
      match(TSqlParser::THEN);
      setState(1219);
      merge_not_matched();
      break;
    }

    }
    setState(1235);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::WHEN) {
      setState(1222);
      match(TSqlParser::WHEN);
      setState(1223);
      match(TSqlParser::NOT);
      setState(1224);
      match(TSqlParser::MATCHED);
      setState(1225);
      match(TSqlParser::BY);
      setState(1226);
      match(TSqlParser::SOURCE);
      setState(1229);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AND) {
        setState(1227);
        match(TSqlParser::AND);
        setState(1228);
        search_condition();
      }
      setState(1231);
      match(TSqlParser::THEN);
      setState(1232);
      merge_matched();
      setState(1237);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1239);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OUTPUT) {
      setState(1238);
      output_clause();
    }
    setState(1242);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1241);
      option_clause();
    }
    setState(1244);
    match(TSqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_matchedContext ------------------------------------------------------------------

TSqlParser::Merge_matchedContext::Merge_matchedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Update_elemContext *> TSqlParser::Merge_matchedContext::update_elem() {
  return getRuleContexts<TSqlParser::Update_elemContext>();
}

TSqlParser::Update_elemContext* TSqlParser::Merge_matchedContext::update_elem(size_t i) {
  return getRuleContext<TSqlParser::Update_elemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_matchedContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::DELETE() {
  return getToken(TSqlParser::DELETE, 0);
}


size_t TSqlParser::Merge_matchedContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_matched;
}

void TSqlParser::Merge_matchedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_matched(this);
}

void TSqlParser::Merge_matchedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_matched(this);
}

TSqlParser::Merge_matchedContext* TSqlParser::merge_matched() {
  Merge_matchedContext *_localctx = _tracker.createInstance<Merge_matchedContext>(_ctx, getState());
  enterRule(_localctx, 94, TSqlParser::RuleMerge_matched);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1257);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UPDATE: {
        enterOuterAlt(_localctx, 1);
        setState(1246);
        match(TSqlParser::UPDATE);
        setState(1247);
        match(TSqlParser::SET);
        setState(1248);
        update_elem();
        setState(1253);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(1249);
          match(TSqlParser::COMMA);
          setState(1250);
          update_elem();
          setState(1255);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case TSqlParser::DELETE: {
        enterOuterAlt(_localctx, 2);
        setState(1256);
        match(TSqlParser::DELETE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_not_matchedContext ------------------------------------------------------------------

TSqlParser::Merge_not_matchedContext::Merge_not_matchedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::INSERT() {
  return getToken(TSqlParser::INSERT, 0);
}

TSqlParser::Table_value_constructorContext* TSqlParser::Merge_not_matchedContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Merge_not_matchedContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Merge_not_matchedContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_not_matched;
}

void TSqlParser::Merge_not_matchedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_not_matched(this);
}

void TSqlParser::Merge_not_matchedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_not_matched(this);
}

TSqlParser::Merge_not_matchedContext* TSqlParser::merge_not_matched() {
  Merge_not_matchedContext *_localctx = _tracker.createInstance<Merge_not_matchedContext>(_ctx, getState());
  enterRule(_localctx, 96, TSqlParser::RuleMerge_not_matched);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1259);
    match(TSqlParser::INSERT);
    setState(1264);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(1260);
      match(TSqlParser::LR_BRACKET);
      setState(1261);
      column_name_list();
      setState(1262);
      match(TSqlParser::RR_BRACKET);
    }
    setState(1269);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::VALUES: {
        setState(1266);
        table_value_constructor();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(1267);
        match(TSqlParser::DEFAULT);
        setState(1268);
        match(TSqlParser::VALUES);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statementContext ------------------------------------------------------------------

TSqlParser::Delete_statementContext::Delete_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Delete_statementContext::DELETE() {
  return getToken(TSqlParser::DELETE, 0);
}

TSqlParser::Delete_statement_fromContext* TSqlParser::Delete_statementContext::delete_statement_from() {
  return getRuleContext<TSqlParser::Delete_statement_fromContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Delete_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Delete_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Delete_statementContext::FROM() {
  return getTokens(TSqlParser::FROM);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::FROM(size_t i) {
  return getToken(TSqlParser::FROM, i);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Delete_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::Output_clauseContext* TSqlParser::Delete_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Delete_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

TSqlParser::For_clauseContext* TSqlParser::Delete_statementContext::for_clause() {
  return getRuleContext<TSqlParser::For_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Delete_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Delete_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Delete_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Delete_statementContext::getRuleIndex() const {
  return TSqlParser::RuleDelete_statement;
}

void TSqlParser::Delete_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_statement(this);
}

void TSqlParser::Delete_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_statement(this);
}

TSqlParser::Delete_statementContext* TSqlParser::delete_statement() {
  Delete_statementContext *_localctx = _tracker.createInstance<Delete_statementContext>(_ctx, getState());
  enterRule(_localctx, 98, TSqlParser::RuleDelete_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1272);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1271);
      with_expression();
    }
    setState(1274);
    match(TSqlParser::DELETE);
    setState(1284);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
    case 1: {
      setState(1275);
      match(TSqlParser::TOP);
      setState(1276);
      match(TSqlParser::LR_BRACKET);
      setState(1277);
      expression(0);
      setState(1278);
      match(TSqlParser::RR_BRACKET);
      setState(1280);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1279);
        match(TSqlParser::PERCENT);
      }
      break;
    }

    case 2: {
      setState(1282);
      match(TSqlParser::TOP);
      setState(1283);
      match(TSqlParser::DECIMAL);
      break;
    }

    }
    setState(1287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1286);
      match(TSqlParser::FROM);
    }
    setState(1289);
    delete_statement_from();
    setState(1291);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      setState(1290);
      insert_with_table_hints();
      break;
    }

    }
    setState(1294);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      setState(1293);
      output_clause();
      break;
    }

    }
    setState(1298);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1296);
      match(TSqlParser::FROM);
      setState(1297);
      table_sources();
    }
    setState(1313);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(1300);
      match(TSqlParser::WHERE);
      setState(1311);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::ABS:
        case TSqlParser::ASCII:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CALLED:
        case TSqlParser::CASE:
        case TSqlParser::CEILING:
        case TSqlParser::CHARINDEX:
        case TSqlParser::COALESCE:
        case TSqlParser::CONVERT:
        case TSqlParser::CURRENT_TIMESTAMP:
        case TSqlParser::CURRENT_USER:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::DEFAULT:
        case TSqlParser::EVENTDATA:
        case TSqlParser::EXISTS:
        case TSqlParser::FILENAME:
        case TSqlParser::FILLFACTOR:
        case TSqlParser::FLOOR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IDENTITY:
        case TSqlParser::IIF:
        case TSqlParser::INIT:
        case TSqlParser::ISDATE:
        case TSqlParser::ISNULL:
        case TSqlParser::ISNUMERIC:
        case TSqlParser::KEY:
        case TSqlParser::LEFT:
        case TSqlParser::LEN:
        case TSqlParser::LOWER:
        case TSqlParser::LTRIM:
        case TSqlParser::MASTER:
        case TSqlParser::MAX_MEMORY:
        case TSqlParser::MONTH:
        case TSqlParser::NCHAR:
        case TSqlParser::NOT:
        case TSqlParser::null:
        case TSqlParser::NULLIF:
        case TSqlParser::OFFSETS:
        case TSqlParser::OVER:
        case TSqlParser::PAGE:
        case TSqlParser::PATINDEX:
        case TSqlParser::PUBLIC:
        case TSqlParser::R:
        case TSqlParser::RAND:
        case TSqlParser::RAW:
        case TSqlParser::REPLACE:
        case TSqlParser::RETURN:
        case TSqlParser::RETURNS:
        case TSqlParser::RIGHT:
        case TSqlParser::ROUND:
        case TSqlParser::ROWCOUNT:
        case TSqlParser::RTRIM:
        case TSqlParser::SAFETY:
        case TSqlParser::SERVER:
        case TSqlParser::SESSION_USER:
        case TSqlParser::SIGN:
        case TSqlParser::SID:
        case TSqlParser::SOURCE:
        case TSqlParser::SPACE:
        case TSqlParser::SPLIT:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::STR:
        case TSqlParser::SYSTEM_USER:
        case TSqlParser::TARGET:
        case TSqlParser::UPPER:
        case TSqlParser::USER_NAME:
        case TSqlParser::YEAR:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::ACCENT_SENSITIVITY:
        case TSqlParser::ACTION:
        case TSqlParser::ACTIVATION:
        case TSqlParser::ACTIVE:
        case TSqlParser::ADDRESS:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::AFFINITY:
        case TSqlParser::AFTER:
        case TSqlParser::AGGREGATE:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
        case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
        case TSqlParser::ALLOWED:
        case TSqlParser::ANSI_NULL_DEFAULT:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLICATION_LOG:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::ASSEMBLY:
        case TSqlParser::AUDIT:
        case TSqlParser::AUDIT_GUID:
        case TSqlParser::AUTO:
        case TSqlParser::AUTO_CLEANUP:
        case TSqlParser::AUTO_CLOSE:
        case TSqlParser::AUTO_CREATE_STATISTICS:
        case TSqlParser::AUTO_SHRINK:
        case TSqlParser::AUTO_UPDATE_STATISTICS:
        case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
        case TSqlParser::AVAILABILITY:
        case TSqlParser::AVG:
        case TSqlParser::BACKUP_PRIORITY:
        case TSqlParser::BEGIN_DIALOG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::BINDING:
        case TSqlParser::BLOB_STORAGE:
        case TSqlParser::BROKER:
        case TSqlParser::BROKER_INSTANCE:
        case TSqlParser::BULK_LOGGED:
        case TSqlParser::CALLER:
        case TSqlParser::CAP_CPU_PERCENT:
        case TSqlParser::CAST:
        case TSqlParser::CATALOG:
        case TSqlParser::CATCH:
        case TSqlParser::CHANGE_RETENTION:
        case TSqlParser::CHANGE_TRACKING:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::CLEANUP:
        case TSqlParser::COLLECTION:
        case TSqlParser::COLUMN_MASTER_KEY:
        case TSqlParser::COMMITTED:
        case TSqlParser::COMPATIBILITY_LEVEL:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::CONTENT:
        case TSqlParser::CONTROL:
        case TSqlParser::COOKIE:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::COUNTER:
        case TSqlParser::CPU:
        case TSqlParser::CREATE_NEW:
        case TSqlParser::CREATION_DISPOSITION:
        case TSqlParser::CREDENTIAL:
        case TSqlParser::CRYPTOGRAPHIC:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATALENGTH:
        case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAY:
        case TSqlParser::DAYS:
        case TSqlParser::DB_CHAINING:
        case TSqlParser::DB_FAILOVER:
        case TSqlParser::DECRYPTION:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
        case TSqlParser::DEFAULT_LANGUAGE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DEPENDENTS:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DHCP:
        case TSqlParser::DIALOG:
        case TSqlParser::DIRECTORY_NAME:
        case TSqlParser::DISABLE:
        case TSqlParser::DISABLE_BROKER:
        case TSqlParser::DISABLED:
        case TSqlParser::DISK_DRIVE:
        case TSqlParser::DOCUMENT:
        case TSqlParser::DYNAMIC:
        case TSqlParser::EMERGENCY:
        case TSqlParser::EMPTY:
        case TSqlParser::ENABLE:
        case TSqlParser::ENABLE_BROKER:
        case TSqlParser::ENCRYPTED_VALUE:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::ENDPOINT_URL:
        case TSqlParser::ERROR_BROKER_CONVERSATIONS:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::EXECUTABLE:
        case TSqlParser::EXIST:
        case TSqlParser::EXPAND:
        case TSqlParser::EXPIRY_DATE:
        case TSqlParser::EXPLICIT:
        case TSqlParser::FAIL_OPERATION:
        case TSqlParser::FAILOVER_MODE:
        case TSqlParser::FAILURE:
        case TSqlParser::FAILURE_CONDITION_LEVEL:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FILEGROUP:
        case TSqlParser::FILEGROWTH:
        case TSqlParser::FILEPATH:
        case TSqlParser::FILESTREAM:
        case TSqlParser::FILTER:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
        case TSqlParser::FORCED:
        case TSqlParser::FORMAT:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::FULLSCAN:
        case TSqlParser::FULLTEXT:
        case TSqlParser::GB:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO:
        case TSqlParser::GROUP_MAX_REQUESTS:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HADR:
        case TSqlParser::HASH:
        case TSqlParser::HEALTH_CHECK_TIMEOUT:
        case TSqlParser::HIGH:
        case TSqlParser::HONOR_BROKER_PRIORITY:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case TSqlParser::IMMEDIATE:
        case TSqlParser::IMPERSONATE:
        case TSqlParser::IMPORTANCE:
        case TSqlParser::INCREMENTAL:
        case TSqlParser::INITIATOR:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::IP:
        case TSqlParser::ISOLATION:
        case TSqlParser::KB:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEY_SOURCE:
        case TSqlParser::KEYS:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LIST:
        case TSqlParser::LISTENER:
        case TSqlParser::LISTENER_URL:
        case TSqlParser::LOB_COMPACTION:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOGIN:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MATERIALIZED:
        case TSqlParser::MAX:
        case TSqlParser::MAX_CPU_PERCENT:
        case TSqlParser::MAX_DOP:
        case TSqlParser::MAX_FILES:
        case TSqlParser::MAX_IOPS_PER_VOLUME:
        case TSqlParser::MAX_MEMORY_PERCENT:
        case TSqlParser::MAX_PROCESSES:
        case TSqlParser::MAX_QUEUE_READERS:
        case TSqlParser::MAX_ROLLOVER_FILES:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MAXSIZE:
        case TSqlParser::MB:
        case TSqlParser::MEDIUM:
        case TSqlParser::MEMORY_OPTIMIZED_DATA:
        case TSqlParser::MESSAGE:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MIN_CPU_PERCENT:
        case TSqlParser::MIN_IOPS_PER_VOLUME:
        case TSqlParser::MIN_MEMORY_PERCENT:
        case TSqlParser::MINUTES:
        case TSqlParser::MIRROR_ADDRESS:
        case TSqlParser::MIXED_PAGE_ALLOCATION:
        case TSqlParser::MODE:
        case TSqlParser::MODIFY:
        case TSqlParser::MOVE:
        case TSqlParser::MULTI_USER:
        case TSqlParser::NAME:
        case TSqlParser::NESTED_TRIGGERS:
        case TSqlParser::NEW_ACCOUNT:
        case TSqlParser::NEW_BROKER:
        case TSqlParser::NEW_PASSWORD:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NO_TRUNCATE:
        case TSqlParser::NO_WAIT:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NON_TRANSACTED_ACCESS:
        case TSqlParser::NORECOMPUTE:
        case TSqlParser::NORECOVERY:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMBER:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFLINE:
        case TSqlParser::OFFSET:
        case TSqlParser::OLD_ACCOUNT:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPEN_EXISTING:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PAGE_VERIFY:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PARTNER:
        case TSqlParser::PATH:
        case TSqlParser::POISON_MESSAGE_HANDLING:
        case TSqlParser::POOL:
        case TSqlParser::PORT:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIMARY_ROLE:
        case TSqlParser::PRIOR:
        case TSqlParser::PRIORITY:
        case TSqlParser::PRIORITY_LEVEL:
        case TSqlParser::PRIVATE:
        case TSqlParser::PRIVATE_KEY:
        case TSqlParser::PRIVILEGES:
        case TSqlParser::PROCEDURE_NAME:
        case TSqlParser::PROPERTY:
        case TSqlParser::PROVIDER:
        case TSqlParser::PROVIDER_KEY_NAME:
        case TSqlParser::QUERY:
        case TSqlParser::QUEUE:
        case TSqlParser::QUEUE_DELAY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_COMMITTED_SNAPSHOT:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READ_ONLY_ROUTING_LIST:
        case TSqlParser::READ_WRITE:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECEIVE:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RECOVERY:
        case TSqlParser::RECURSIVE_TRIGGERS:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REMOTE_SERVICE_NAME:
        case TSqlParser::REMOVE:
        case TSqlParser::REORGANIZE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::REPLICA:
        case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
        case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
        case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
        case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
        case TSqlParser::RESERVE_DISK_SPACE:
        case TSqlParser::RESOURCE:
        case TSqlParser::RESOURCE_MANAGER_LOCATION:
        case TSqlParser::RESTRICTED_USER:
        case TSqlParser::RETENTION:
        case TSqlParser::ROBUST:
        case TSqlParser::ROOT:
        case TSqlParser::ROUTE:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SAMPLE:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCOPED:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SEARCH:
        case TSqlParser::SECONDARY:
        case TSqlParser::SECONDARY_ONLY:
        case TSqlParser::SECONDARY_ROLE:
        case TSqlParser::SECONDS:
        case TSqlParser::SECRET:
        case TSqlParser::SECURITY:
        case TSqlParser::SECURITY_LOG:
        case TSqlParser::SEEDING_MODE:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEND:
        case TSqlParser::SENT:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SESSION_TIMEOUT:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SHOWPLAN:
        case TSqlParser::SIGNATURE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SINGLE_USER:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STANDBY:
        case TSqlParser::START_DATE:
        case TSqlParser::STATIC:
        case TSqlParser::STATS_STREAM:
        case TSqlParser::STATUS:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STOPLIST:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBJECT:
        case TSqlParser::SUBSTRING:
        case TSqlParser::SUM:
        case TSqlParser::SUSPEND:
        case TSqlParser::SYMMETRIC:
        case TSqlParser::SYNCHRONOUS_COMMIT:
        case TSqlParser::SYNONYM:
        case TSqlParser::SYSTEM:
        case TSqlParser::TAKE:
        case TSqlParser::TARGET_RECOVERY_TIME:
        case TSqlParser::TB:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TIMER:
        case TSqlParser::TINYINT:
        case TSqlParser::TORN_PAGE_DETECTION:
        case TSqlParser::TRANSFORM_NOISE_WORDS:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRUSTWORTHY:
        case TSqlParser::TRY:
        case TSqlParser::TSQL:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UNLIMITED:
        case TSqlParser::USING:
        case TSqlParser::VALID_XML:
        case TSqlParser::VALIDATION:
        case TSqlParser::VALUE:
        case TSqlParser::VAR:
        case TSqlParser::VARP:
        case TSqlParser::VIEW_METADATA:
        case TSqlParser::VIEWS:
        case TSqlParser::WAIT:
        case TSqlParser::WELL_FORMED_XML:
        case TSqlParser::WORK:
        case TSqlParser::WORKLOAD:
        case TSqlParser::XML:
        case TSqlParser::XMLNAMESPACES:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOLLAR:
        case TSqlParser::LR_BRACKET:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS:
        case TSqlParser::BIT_NOT: {
          setState(1301);
          search_condition();
          break;
        }

        case TSqlParser::CURRENT: {
          setState(1302);
          match(TSqlParser::CURRENT);
          setState(1303);
          match(TSqlParser::OF);
          setState(1309);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
          case 1: {
            setState(1305);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
            case 1: {
              setState(1304);
              match(TSqlParser::GLOBAL);
              break;
            }

            }
            setState(1307);
            cursor_name();
            break;
          }

          case 2: {
            setState(1308);
            dynamic_cast<Delete_statementContext *>(_localctx)->cursor_var = match(TSqlParser::LOCAL_ID);
            break;
          }

          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(1316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FOR) {
      setState(1315);
      for_clause();
    }
    setState(1319);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1318);
      option_clause();
    }
    setState(1322);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      setState(1321);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statement_fromContext ------------------------------------------------------------------

TSqlParser::Delete_statement_fromContext::Delete_statement_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Ddl_objectContext* TSqlParser::Delete_statement_fromContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::Table_aliasContext* TSqlParser::Delete_statement_fromContext::table_alias() {
  return getRuleContext<TSqlParser::Table_aliasContext>(0);
}

TSqlParser::Rowset_function_limitedContext* TSqlParser::Delete_statement_fromContext::rowset_function_limited() {
  return getRuleContext<TSqlParser::Rowset_function_limitedContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statement_fromContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Delete_statement_fromContext::getRuleIndex() const {
  return TSqlParser::RuleDelete_statement_from;
}

void TSqlParser::Delete_statement_fromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_statement_from(this);
}

void TSqlParser::Delete_statement_fromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_statement_from(this);
}

TSqlParser::Delete_statement_fromContext* TSqlParser::delete_statement_from() {
  Delete_statement_fromContext *_localctx = _tracker.createInstance<Delete_statement_fromContext>(_ctx, getState());
  enterRule(_localctx, 100, TSqlParser::RuleDelete_statement_from);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1324);
      ddl_object();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1325);
      table_alias();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1326);
      rowset_function_limited();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1327);
      dynamic_cast<Delete_statement_fromContext *>(_localctx)->table_var = match(TSqlParser::LOCAL_ID);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statementContext ------------------------------------------------------------------

TSqlParser::Insert_statementContext::Insert_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Insert_statementContext::INSERT() {
  return getToken(TSqlParser::INSERT, 0);
}

TSqlParser::Insert_statement_valueContext* TSqlParser::Insert_statementContext::insert_statement_value() {
  return getRuleContext<TSqlParser::Insert_statement_valueContext>(0);
}

TSqlParser::Ddl_objectContext* TSqlParser::Insert_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::Rowset_function_limitedContext* TSqlParser::Insert_statementContext::rowset_function_limited() {
  return getRuleContext<TSqlParser::Rowset_function_limitedContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Insert_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_statementContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::ExpressionContext* TSqlParser::Insert_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_statementContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Insert_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::Column_name_listContext* TSqlParser::Insert_statementContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

TSqlParser::Output_clauseContext* TSqlParser::Insert_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

TSqlParser::For_clauseContext* TSqlParser::Insert_statementContext::for_clause() {
  return getRuleContext<TSqlParser::For_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Insert_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}


size_t TSqlParser::Insert_statementContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_statement;
}

void TSqlParser::Insert_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_statement(this);
}

void TSqlParser::Insert_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_statement(this);
}

TSqlParser::Insert_statementContext* TSqlParser::insert_statement() {
  Insert_statementContext *_localctx = _tracker.createInstance<Insert_statementContext>(_ctx, getState());
  enterRule(_localctx, 102, TSqlParser::RuleInsert_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1331);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1330);
      with_expression();
    }
    setState(1333);
    match(TSqlParser::INSERT);
    setState(1341);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(1334);
      match(TSqlParser::TOP);
      setState(1335);
      match(TSqlParser::LR_BRACKET);
      setState(1336);
      expression(0);
      setState(1337);
      match(TSqlParser::RR_BRACKET);
      setState(1339);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1338);
        match(TSqlParser::PERCENT);
      }
    }
    setState(1344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1343);
      match(TSqlParser::INTO);
    }
    setState(1348);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::LOCAL_ID:
      case TSqlParser::ID: {
        setState(1346);
        ddl_object();
        break;
      }

      case TSqlParser::OPENDATASOURCE:
      case TSqlParser::OPENQUERY: {
        setState(1347);
        rowset_function_limited();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1351);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
    case 1: {
      setState(1350);
      insert_with_table_hints();
      break;
    }

    }
    setState(1357);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
    case 1: {
      setState(1353);
      match(TSqlParser::LR_BRACKET);
      setState(1354);
      column_name_list();
      setState(1355);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
    setState(1360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OUTPUT) {
      setState(1359);
      output_clause();
    }
    setState(1362);
    insert_statement_value();
    setState(1364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FOR) {
      setState(1363);
      for_clause();
    }
    setState(1367);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1366);
      option_clause();
    }
    setState(1370);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1369);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statement_valueContext ------------------------------------------------------------------

TSqlParser::Insert_statement_valueContext::Insert_statement_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_value_constructorContext* TSqlParser::Insert_statement_valueContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}

TSqlParser::Derived_tableContext* TSqlParser::Insert_statement_valueContext::derived_table() {
  return getRuleContext<TSqlParser::Derived_tableContext>(0);
}

TSqlParser::Execute_statementContext* TSqlParser::Insert_statement_valueContext::execute_statement() {
  return getRuleContext<TSqlParser::Execute_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statement_valueContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Insert_statement_valueContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}


size_t TSqlParser::Insert_statement_valueContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_statement_value;
}

void TSqlParser::Insert_statement_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_statement_value(this);
}

void TSqlParser::Insert_statement_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_statement_value(this);
}

TSqlParser::Insert_statement_valueContext* TSqlParser::insert_statement_value() {
  Insert_statement_valueContext *_localctx = _tracker.createInstance<Insert_statement_valueContext>(_ctx, getState());
  enterRule(_localctx, 104, TSqlParser::RuleInsert_statement_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1377);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1372);
      table_value_constructor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1373);
      derived_table();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1374);
      execute_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1375);
      match(TSqlParser::DEFAULT);
      setState(1376);
      match(TSqlParser::VALUES);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Receive_statementContext ------------------------------------------------------------------

TSqlParser::Receive_statementContext::Receive_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Receive_statementContext::RECEIVE() {
  return getToken(TSqlParser::RECEIVE, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Receive_statementContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}

TSqlParser::Top_clauseContext* TSqlParser::Receive_statementContext::top_clause() {
  return getRuleContext<TSqlParser::Top_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Receive_statementContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Receive_statementContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::IdContext* TSqlParser::Receive_statementContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Search_conditionContext* TSqlParser::Receive_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}


size_t TSqlParser::Receive_statementContext::getRuleIndex() const {
  return TSqlParser::RuleReceive_statement;
}

void TSqlParser::Receive_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReceive_statement(this);
}

void TSqlParser::Receive_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReceive_statement(this);
}

TSqlParser::Receive_statementContext* TSqlParser::receive_statement() {
  Receive_statementContext *_localctx = _tracker.createInstance<Receive_statementContext>(_ctx, getState());
  enterRule(_localctx, 106, TSqlParser::RuleReceive_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(1379);
      match(TSqlParser::LR_BRACKET);
    }
    setState(1382);
    match(TSqlParser::RECEIVE);
    setState(1387);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ALL: {
        setState(1383);
        match(TSqlParser::ALL);
        break;
      }

      case TSqlParser::DISTINCT: {
        setState(1384);
        match(TSqlParser::DISTINCT);
        break;
      }

      case TSqlParser::TOP: {
        setState(1385);
        top_clause();
        break;
      }

      case TSqlParser::STAR: {
        setState(1386);
        match(TSqlParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1397);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::LOCAL_ID) {
      setState(1389);
      match(TSqlParser::LOCAL_ID);
      setState(1390);
      match(TSqlParser::EQUAL);
      setState(1391);
      expression(0);
      setState(1393);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(1392);
        match(TSqlParser::COMMA);
      }
      setState(1399);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1400);
    match(TSqlParser::FROM);
    setState(1401);
    full_table_name();
    setState(1407);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1402);
      match(TSqlParser::INTO);
      setState(1403);
      dynamic_cast<Receive_statementContext *>(_localctx)->table_variable = id();

      setState(1404);
      match(TSqlParser::WHERE);
      setState(1405);
      dynamic_cast<Receive_statementContext *>(_localctx)->where = search_condition();
    }
    setState(1410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::RR_BRACKET) {
      setState(1409);
      match(TSqlParser::RR_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_statementContext ------------------------------------------------------------------

TSqlParser::Select_statementContext::Select_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Query_expressionContext* TSqlParser::Select_statementContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Select_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Select_statementContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::For_clauseContext* TSqlParser::Select_statementContext::for_clause() {
  return getRuleContext<TSqlParser::For_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Select_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Select_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Select_statementContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_statement;
}

void TSqlParser::Select_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_statement(this);
}

void TSqlParser::Select_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_statement(this);
}

TSqlParser::Select_statementContext* TSqlParser::select_statement() {
  Select_statementContext *_localctx = _tracker.createInstance<Select_statementContext>(_ctx, getState());
  enterRule(_localctx, 108, TSqlParser::RuleSelect_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1413);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1412);
      with_expression();
    }
    setState(1415);
    query_expression();
    setState(1417);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
    case 1: {
      setState(1416);
      order_by_clause();
      break;
    }

    }
    setState(1420);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
    case 1: {
      setState(1419);
      for_clause();
      break;
    }

    }
    setState(1423);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      setState(1422);
      option_clause();
      break;
    }

    }
    setState(1426);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      setState(1425);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeContext ------------------------------------------------------------------

TSqlParser::TimeContext::TimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::TimeContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ConstantContext* TSqlParser::TimeContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::TimeContext::getRuleIndex() const {
  return TSqlParser::RuleTime;
}

void TSqlParser::TimeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime(this);
}

void TSqlParser::TimeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime(this);
}

TSqlParser::TimeContext* TSqlParser::time() {
  TimeContext *_localctx = _tracker.createInstance<TimeContext>(_ctx, getState());
  enterRule(_localctx, 110, TSqlParser::RuleTime);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1430);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LOCAL_ID: {
        setState(1428);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        setState(1429);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_statementContext ------------------------------------------------------------------

TSqlParser::Update_statementContext::Update_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Update_statementContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Update_elemContext *> TSqlParser::Update_statementContext::update_elem() {
  return getRuleContexts<TSqlParser::Update_elemContext>();
}

TSqlParser::Update_elemContext* TSqlParser::Update_statementContext::update_elem(size_t i) {
  return getRuleContext<TSqlParser::Update_elemContext>(i);
}

TSqlParser::Ddl_objectContext* TSqlParser::Update_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::Rowset_function_limitedContext* TSqlParser::Update_statementContext::rowset_function_limited() {
  return getRuleContext<TSqlParser::Rowset_function_limitedContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Update_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Update_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Update_statementContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Update_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Update_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Output_clauseContext* TSqlParser::Update_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Update_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

TSqlParser::For_clauseContext* TSqlParser::Update_statementContext::for_clause() {
  return getRuleContext<TSqlParser::For_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Update_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Search_condition_listContext* TSqlParser::Update_statementContext::search_condition_list() {
  return getRuleContext<TSqlParser::Search_condition_listContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Update_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Update_statementContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_statement;
}

void TSqlParser::Update_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_statement(this);
}

void TSqlParser::Update_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_statement(this);
}

TSqlParser::Update_statementContext* TSqlParser::update_statement() {
  Update_statementContext *_localctx = _tracker.createInstance<Update_statementContext>(_ctx, getState());
  enterRule(_localctx, 112, TSqlParser::RuleUpdate_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1433);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1432);
      with_expression();
    }
    setState(1435);
    match(TSqlParser::UPDATE);
    setState(1443);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(1436);
      match(TSqlParser::TOP);
      setState(1437);
      match(TSqlParser::LR_BRACKET);
      setState(1438);
      expression(0);
      setState(1439);
      match(TSqlParser::RR_BRACKET);
      setState(1441);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1440);
        match(TSqlParser::PERCENT);
      }
    }
    setState(1447);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::LOCAL_ID:
      case TSqlParser::ID: {
        setState(1445);
        ddl_object();
        break;
      }

      case TSqlParser::OPENDATASOURCE:
      case TSqlParser::OPENQUERY: {
        setState(1446);
        rowset_function_limited();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1450);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH || _la == TSqlParser::LR_BRACKET) {
      setState(1449);
      with_table_hints();
    }
    setState(1452);
    match(TSqlParser::SET);
    setState(1453);
    update_elem();
    setState(1458);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1454);
      match(TSqlParser::COMMA);
      setState(1455);
      update_elem();
      setState(1460);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1462);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
    case 1: {
      setState(1461);
      output_clause();
      break;
    }

    }
    setState(1466);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1464);
      match(TSqlParser::FROM);
      setState(1465);
      table_sources();
    }
    setState(1481);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(1468);
      match(TSqlParser::WHERE);
      setState(1479);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::ABS:
        case TSqlParser::ASCII:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CALLED:
        case TSqlParser::CASE:
        case TSqlParser::CEILING:
        case TSqlParser::CHARINDEX:
        case TSqlParser::COALESCE:
        case TSqlParser::CONVERT:
        case TSqlParser::CURRENT_TIMESTAMP:
        case TSqlParser::CURRENT_USER:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::DEFAULT:
        case TSqlParser::EVENTDATA:
        case TSqlParser::EXISTS:
        case TSqlParser::FILENAME:
        case TSqlParser::FILLFACTOR:
        case TSqlParser::FLOOR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IDENTITY:
        case TSqlParser::IIF:
        case TSqlParser::INIT:
        case TSqlParser::ISDATE:
        case TSqlParser::ISNULL:
        case TSqlParser::ISNUMERIC:
        case TSqlParser::KEY:
        case TSqlParser::LEFT:
        case TSqlParser::LEN:
        case TSqlParser::LOWER:
        case TSqlParser::LTRIM:
        case TSqlParser::MASTER:
        case TSqlParser::MAX_MEMORY:
        case TSqlParser::MONTH:
        case TSqlParser::NCHAR:
        case TSqlParser::NOT:
        case TSqlParser::null:
        case TSqlParser::NULLIF:
        case TSqlParser::OFFSETS:
        case TSqlParser::OVER:
        case TSqlParser::PAGE:
        case TSqlParser::PATINDEX:
        case TSqlParser::PUBLIC:
        case TSqlParser::R:
        case TSqlParser::RAND:
        case TSqlParser::RAW:
        case TSqlParser::REPLACE:
        case TSqlParser::RETURN:
        case TSqlParser::RETURNS:
        case TSqlParser::RIGHT:
        case TSqlParser::ROUND:
        case TSqlParser::ROWCOUNT:
        case TSqlParser::RTRIM:
        case TSqlParser::SAFETY:
        case TSqlParser::SERVER:
        case TSqlParser::SESSION_USER:
        case TSqlParser::SIGN:
        case TSqlParser::SID:
        case TSqlParser::SOURCE:
        case TSqlParser::SPACE:
        case TSqlParser::SPLIT:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::STR:
        case TSqlParser::SYSTEM_USER:
        case TSqlParser::TARGET:
        case TSqlParser::UPPER:
        case TSqlParser::USER_NAME:
        case TSqlParser::YEAR:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::ACCENT_SENSITIVITY:
        case TSqlParser::ACTION:
        case TSqlParser::ACTIVATION:
        case TSqlParser::ACTIVE:
        case TSqlParser::ADDRESS:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::AFFINITY:
        case TSqlParser::AFTER:
        case TSqlParser::AGGREGATE:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
        case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
        case TSqlParser::ALLOWED:
        case TSqlParser::ANSI_NULL_DEFAULT:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLICATION_LOG:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::ASSEMBLY:
        case TSqlParser::AUDIT:
        case TSqlParser::AUDIT_GUID:
        case TSqlParser::AUTO:
        case TSqlParser::AUTO_CLEANUP:
        case TSqlParser::AUTO_CLOSE:
        case TSqlParser::AUTO_CREATE_STATISTICS:
        case TSqlParser::AUTO_SHRINK:
        case TSqlParser::AUTO_UPDATE_STATISTICS:
        case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
        case TSqlParser::AVAILABILITY:
        case TSqlParser::AVG:
        case TSqlParser::BACKUP_PRIORITY:
        case TSqlParser::BEGIN_DIALOG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::BINDING:
        case TSqlParser::BLOB_STORAGE:
        case TSqlParser::BROKER:
        case TSqlParser::BROKER_INSTANCE:
        case TSqlParser::BULK_LOGGED:
        case TSqlParser::CALLER:
        case TSqlParser::CAP_CPU_PERCENT:
        case TSqlParser::CAST:
        case TSqlParser::CATALOG:
        case TSqlParser::CATCH:
        case TSqlParser::CHANGE_RETENTION:
        case TSqlParser::CHANGE_TRACKING:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::CLEANUP:
        case TSqlParser::COLLECTION:
        case TSqlParser::COLUMN_MASTER_KEY:
        case TSqlParser::COMMITTED:
        case TSqlParser::COMPATIBILITY_LEVEL:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::CONTENT:
        case TSqlParser::CONTROL:
        case TSqlParser::COOKIE:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::COUNTER:
        case TSqlParser::CPU:
        case TSqlParser::CREATE_NEW:
        case TSqlParser::CREATION_DISPOSITION:
        case TSqlParser::CREDENTIAL:
        case TSqlParser::CRYPTOGRAPHIC:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATALENGTH:
        case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAY:
        case TSqlParser::DAYS:
        case TSqlParser::DB_CHAINING:
        case TSqlParser::DB_FAILOVER:
        case TSqlParser::DECRYPTION:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
        case TSqlParser::DEFAULT_LANGUAGE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DEPENDENTS:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DHCP:
        case TSqlParser::DIALOG:
        case TSqlParser::DIRECTORY_NAME:
        case TSqlParser::DISABLE:
        case TSqlParser::DISABLE_BROKER:
        case TSqlParser::DISABLED:
        case TSqlParser::DISK_DRIVE:
        case TSqlParser::DOCUMENT:
        case TSqlParser::DYNAMIC:
        case TSqlParser::EMERGENCY:
        case TSqlParser::EMPTY:
        case TSqlParser::ENABLE:
        case TSqlParser::ENABLE_BROKER:
        case TSqlParser::ENCRYPTED_VALUE:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::ENDPOINT_URL:
        case TSqlParser::ERROR_BROKER_CONVERSATIONS:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::EXECUTABLE:
        case TSqlParser::EXIST:
        case TSqlParser::EXPAND:
        case TSqlParser::EXPIRY_DATE:
        case TSqlParser::EXPLICIT:
        case TSqlParser::FAIL_OPERATION:
        case TSqlParser::FAILOVER_MODE:
        case TSqlParser::FAILURE:
        case TSqlParser::FAILURE_CONDITION_LEVEL:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FILEGROUP:
        case TSqlParser::FILEGROWTH:
        case TSqlParser::FILEPATH:
        case TSqlParser::FILESTREAM:
        case TSqlParser::FILTER:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
        case TSqlParser::FORCED:
        case TSqlParser::FORMAT:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::FULLSCAN:
        case TSqlParser::FULLTEXT:
        case TSqlParser::GB:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO:
        case TSqlParser::GROUP_MAX_REQUESTS:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HADR:
        case TSqlParser::HASH:
        case TSqlParser::HEALTH_CHECK_TIMEOUT:
        case TSqlParser::HIGH:
        case TSqlParser::HONOR_BROKER_PRIORITY:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case TSqlParser::IMMEDIATE:
        case TSqlParser::IMPERSONATE:
        case TSqlParser::IMPORTANCE:
        case TSqlParser::INCREMENTAL:
        case TSqlParser::INITIATOR:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::IP:
        case TSqlParser::ISOLATION:
        case TSqlParser::KB:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEY_SOURCE:
        case TSqlParser::KEYS:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LIST:
        case TSqlParser::LISTENER:
        case TSqlParser::LISTENER_URL:
        case TSqlParser::LOB_COMPACTION:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOGIN:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MATERIALIZED:
        case TSqlParser::MAX:
        case TSqlParser::MAX_CPU_PERCENT:
        case TSqlParser::MAX_DOP:
        case TSqlParser::MAX_FILES:
        case TSqlParser::MAX_IOPS_PER_VOLUME:
        case TSqlParser::MAX_MEMORY_PERCENT:
        case TSqlParser::MAX_PROCESSES:
        case TSqlParser::MAX_QUEUE_READERS:
        case TSqlParser::MAX_ROLLOVER_FILES:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MAXSIZE:
        case TSqlParser::MB:
        case TSqlParser::MEDIUM:
        case TSqlParser::MEMORY_OPTIMIZED_DATA:
        case TSqlParser::MESSAGE:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MIN_CPU_PERCENT:
        case TSqlParser::MIN_IOPS_PER_VOLUME:
        case TSqlParser::MIN_MEMORY_PERCENT:
        case TSqlParser::MINUTES:
        case TSqlParser::MIRROR_ADDRESS:
        case TSqlParser::MIXED_PAGE_ALLOCATION:
        case TSqlParser::MODE:
        case TSqlParser::MODIFY:
        case TSqlParser::MOVE:
        case TSqlParser::MULTI_USER:
        case TSqlParser::NAME:
        case TSqlParser::NESTED_TRIGGERS:
        case TSqlParser::NEW_ACCOUNT:
        case TSqlParser::NEW_BROKER:
        case TSqlParser::NEW_PASSWORD:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NO_TRUNCATE:
        case TSqlParser::NO_WAIT:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NON_TRANSACTED_ACCESS:
        case TSqlParser::NORECOMPUTE:
        case TSqlParser::NORECOVERY:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMBER:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFLINE:
        case TSqlParser::OFFSET:
        case TSqlParser::OLD_ACCOUNT:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPEN_EXISTING:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PAGE_VERIFY:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PARTNER:
        case TSqlParser::PATH:
        case TSqlParser::POISON_MESSAGE_HANDLING:
        case TSqlParser::POOL:
        case TSqlParser::PORT:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIMARY_ROLE:
        case TSqlParser::PRIOR:
        case TSqlParser::PRIORITY:
        case TSqlParser::PRIORITY_LEVEL:
        case TSqlParser::PRIVATE:
        case TSqlParser::PRIVATE_KEY:
        case TSqlParser::PRIVILEGES:
        case TSqlParser::PROCEDURE_NAME:
        case TSqlParser::PROPERTY:
        case TSqlParser::PROVIDER:
        case TSqlParser::PROVIDER_KEY_NAME:
        case TSqlParser::QUERY:
        case TSqlParser::QUEUE:
        case TSqlParser::QUEUE_DELAY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_COMMITTED_SNAPSHOT:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READ_ONLY_ROUTING_LIST:
        case TSqlParser::READ_WRITE:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECEIVE:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RECOVERY:
        case TSqlParser::RECURSIVE_TRIGGERS:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REMOTE_SERVICE_NAME:
        case TSqlParser::REMOVE:
        case TSqlParser::REORGANIZE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::REPLICA:
        case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
        case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
        case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
        case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
        case TSqlParser::RESERVE_DISK_SPACE:
        case TSqlParser::RESOURCE:
        case TSqlParser::RESOURCE_MANAGER_LOCATION:
        case TSqlParser::RESTRICTED_USER:
        case TSqlParser::RETENTION:
        case TSqlParser::ROBUST:
        case TSqlParser::ROOT:
        case TSqlParser::ROUTE:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SAMPLE:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCOPED:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SEARCH:
        case TSqlParser::SECONDARY:
        case TSqlParser::SECONDARY_ONLY:
        case TSqlParser::SECONDARY_ROLE:
        case TSqlParser::SECONDS:
        case TSqlParser::SECRET:
        case TSqlParser::SECURITY:
        case TSqlParser::SECURITY_LOG:
        case TSqlParser::SEEDING_MODE:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEND:
        case TSqlParser::SENT:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SESSION_TIMEOUT:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SHOWPLAN:
        case TSqlParser::SIGNATURE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SINGLE_USER:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STANDBY:
        case TSqlParser::START_DATE:
        case TSqlParser::STATIC:
        case TSqlParser::STATS_STREAM:
        case TSqlParser::STATUS:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STOPLIST:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBJECT:
        case TSqlParser::SUBSTRING:
        case TSqlParser::SUM:
        case TSqlParser::SUSPEND:
        case TSqlParser::SYMMETRIC:
        case TSqlParser::SYNCHRONOUS_COMMIT:
        case TSqlParser::SYNONYM:
        case TSqlParser::SYSTEM:
        case TSqlParser::TAKE:
        case TSqlParser::TARGET_RECOVERY_TIME:
        case TSqlParser::TB:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TIMER:
        case TSqlParser::TINYINT:
        case TSqlParser::TORN_PAGE_DETECTION:
        case TSqlParser::TRANSFORM_NOISE_WORDS:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRUSTWORTHY:
        case TSqlParser::TRY:
        case TSqlParser::TSQL:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UNLIMITED:
        case TSqlParser::USING:
        case TSqlParser::VALID_XML:
        case TSqlParser::VALIDATION:
        case TSqlParser::VALUE:
        case TSqlParser::VAR:
        case TSqlParser::VARP:
        case TSqlParser::VIEW_METADATA:
        case TSqlParser::VIEWS:
        case TSqlParser::WAIT:
        case TSqlParser::WELL_FORMED_XML:
        case TSqlParser::WORK:
        case TSqlParser::WORKLOAD:
        case TSqlParser::XML:
        case TSqlParser::XMLNAMESPACES:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOLLAR:
        case TSqlParser::LR_BRACKET:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS:
        case TSqlParser::BIT_NOT: {
          setState(1469);
          search_condition_list();
          break;
        }

        case TSqlParser::CURRENT: {
          setState(1470);
          match(TSqlParser::CURRENT);
          setState(1471);
          match(TSqlParser::OF);
          setState(1477);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
          case 1: {
            setState(1473);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
            case 1: {
              setState(1472);
              match(TSqlParser::GLOBAL);
              break;
            }

            }
            setState(1475);
            cursor_name();
            break;
          }

          case 2: {
            setState(1476);
            dynamic_cast<Update_statementContext *>(_localctx)->cursor_var = match(TSqlParser::LOCAL_ID);
            break;
          }

          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(1484);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FOR) {
      setState(1483);
      for_clause();
    }
    setState(1487);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1486);
      option_clause();
    }
    setState(1490);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(1489);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_clauseContext ------------------------------------------------------------------

TSqlParser::Output_clauseContext::Output_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Output_clauseContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

std::vector<TSqlParser::Output_dml_list_elemContext *> TSqlParser::Output_clauseContext::output_dml_list_elem() {
  return getRuleContexts<TSqlParser::Output_dml_list_elemContext>();
}

TSqlParser::Output_dml_list_elemContext* TSqlParser::Output_clauseContext::output_dml_list_elem(size_t i) {
  return getRuleContext<TSqlParser::Output_dml_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Output_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Output_clauseContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Output_clauseContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Output_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOutput_clause;
}

void TSqlParser::Output_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_clause(this);
}

void TSqlParser::Output_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_clause(this);
}

TSqlParser::Output_clauseContext* TSqlParser::output_clause() {
  Output_clauseContext *_localctx = _tracker.createInstance<Output_clauseContext>(_ctx, getState());
  enterRule(_localctx, 114, TSqlParser::RuleOutput_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1492);
    match(TSqlParser::OUTPUT);
    setState(1493);
    output_dml_list_elem();
    setState(1498);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1494);
      match(TSqlParser::COMMA);
      setState(1495);
      output_dml_list_elem();
      setState(1500);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1512);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1501);
      match(TSqlParser::INTO);
      setState(1504);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::LOCAL_ID: {
          setState(1502);
          match(TSqlParser::LOCAL_ID);
          break;
        }

        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CALLED:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::EVENTDATA:
        case TSqlParser::FILENAME:
        case TSqlParser::FILLFACTOR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::INIT:
        case TSqlParser::KEY:
        case TSqlParser::MASTER:
        case TSqlParser::MAX_MEMORY:
        case TSqlParser::OFFSETS:
        case TSqlParser::PAGE:
        case TSqlParser::PUBLIC:
        case TSqlParser::R:
        case TSqlParser::RAW:
        case TSqlParser::RETURN:
        case TSqlParser::RETURNS:
        case TSqlParser::ROWCOUNT:
        case TSqlParser::SAFETY:
        case TSqlParser::SERVER:
        case TSqlParser::SID:
        case TSqlParser::SOURCE:
        case TSqlParser::SPLIT:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::ACCENT_SENSITIVITY:
        case TSqlParser::ACTION:
        case TSqlParser::ACTIVATION:
        case TSqlParser::ACTIVE:
        case TSqlParser::ADDRESS:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::AFFINITY:
        case TSqlParser::AFTER:
        case TSqlParser::AGGREGATE:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
        case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
        case TSqlParser::ALLOWED:
        case TSqlParser::ANSI_NULL_DEFAULT:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLICATION_LOG:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::ASSEMBLY:
        case TSqlParser::AUDIT:
        case TSqlParser::AUDIT_GUID:
        case TSqlParser::AUTO:
        case TSqlParser::AUTO_CLEANUP:
        case TSqlParser::AUTO_CLOSE:
        case TSqlParser::AUTO_CREATE_STATISTICS:
        case TSqlParser::AUTO_SHRINK:
        case TSqlParser::AUTO_UPDATE_STATISTICS:
        case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
        case TSqlParser::AVAILABILITY:
        case TSqlParser::AVG:
        case TSqlParser::BACKUP_PRIORITY:
        case TSqlParser::BEGIN_DIALOG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::BINDING:
        case TSqlParser::BLOB_STORAGE:
        case TSqlParser::BROKER:
        case TSqlParser::BROKER_INSTANCE:
        case TSqlParser::BULK_LOGGED:
        case TSqlParser::CALLER:
        case TSqlParser::CAP_CPU_PERCENT:
        case TSqlParser::CAST:
        case TSqlParser::CATALOG:
        case TSqlParser::CATCH:
        case TSqlParser::CHANGE_RETENTION:
        case TSqlParser::CHANGE_TRACKING:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::CLEANUP:
        case TSqlParser::COLLECTION:
        case TSqlParser::COLUMN_MASTER_KEY:
        case TSqlParser::COMMITTED:
        case TSqlParser::COMPATIBILITY_LEVEL:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::CONTENT:
        case TSqlParser::CONTROL:
        case TSqlParser::COOKIE:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::COUNTER:
        case TSqlParser::CPU:
        case TSqlParser::CREATE_NEW:
        case TSqlParser::CREATION_DISPOSITION:
        case TSqlParser::CREDENTIAL:
        case TSqlParser::CRYPTOGRAPHIC:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DB_CHAINING:
        case TSqlParser::DB_FAILOVER:
        case TSqlParser::DECRYPTION:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
        case TSqlParser::DEFAULT_LANGUAGE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DEPENDENTS:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DHCP:
        case TSqlParser::DIALOG:
        case TSqlParser::DIRECTORY_NAME:
        case TSqlParser::DISABLE:
        case TSqlParser::DISABLE_BROKER:
        case TSqlParser::DISABLED:
        case TSqlParser::DISK_DRIVE:
        case TSqlParser::DOCUMENT:
        case TSqlParser::DYNAMIC:
        case TSqlParser::EMERGENCY:
        case TSqlParser::EMPTY:
        case TSqlParser::ENABLE:
        case TSqlParser::ENABLE_BROKER:
        case TSqlParser::ENCRYPTED_VALUE:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::ENDPOINT_URL:
        case TSqlParser::ERROR_BROKER_CONVERSATIONS:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::EXECUTABLE:
        case TSqlParser::EXIST:
        case TSqlParser::EXPAND:
        case TSqlParser::EXPIRY_DATE:
        case TSqlParser::EXPLICIT:
        case TSqlParser::FAIL_OPERATION:
        case TSqlParser::FAILOVER_MODE:
        case TSqlParser::FAILURE:
        case TSqlParser::FAILURE_CONDITION_LEVEL:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FILEGROUP:
        case TSqlParser::FILEGROWTH:
        case TSqlParser::FILEPATH:
        case TSqlParser::FILESTREAM:
        case TSqlParser::FILTER:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
        case TSqlParser::FORCED:
        case TSqlParser::FORMAT:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::FULLSCAN:
        case TSqlParser::FULLTEXT:
        case TSqlParser::GB:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO:
        case TSqlParser::GROUP_MAX_REQUESTS:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HADR:
        case TSqlParser::HASH:
        case TSqlParser::HEALTH_CHECK_TIMEOUT:
        case TSqlParser::HIGH:
        case TSqlParser::HONOR_BROKER_PRIORITY:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case TSqlParser::IMMEDIATE:
        case TSqlParser::IMPERSONATE:
        case TSqlParser::IMPORTANCE:
        case TSqlParser::INCREMENTAL:
        case TSqlParser::INITIATOR:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::IP:
        case TSqlParser::ISOLATION:
        case TSqlParser::KB:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEY_SOURCE:
        case TSqlParser::KEYS:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LIST:
        case TSqlParser::LISTENER:
        case TSqlParser::LISTENER_URL:
        case TSqlParser::LOB_COMPACTION:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOGIN:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MATERIALIZED:
        case TSqlParser::MAX:
        case TSqlParser::MAX_CPU_PERCENT:
        case TSqlParser::MAX_DOP:
        case TSqlParser::MAX_FILES:
        case TSqlParser::MAX_IOPS_PER_VOLUME:
        case TSqlParser::MAX_MEMORY_PERCENT:
        case TSqlParser::MAX_PROCESSES:
        case TSqlParser::MAX_QUEUE_READERS:
        case TSqlParser::MAX_ROLLOVER_FILES:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MAXSIZE:
        case TSqlParser::MB:
        case TSqlParser::MEDIUM:
        case TSqlParser::MEMORY_OPTIMIZED_DATA:
        case TSqlParser::MESSAGE:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MIN_CPU_PERCENT:
        case TSqlParser::MIN_IOPS_PER_VOLUME:
        case TSqlParser::MIN_MEMORY_PERCENT:
        case TSqlParser::MINUTES:
        case TSqlParser::MIRROR_ADDRESS:
        case TSqlParser::MIXED_PAGE_ALLOCATION:
        case TSqlParser::MODE:
        case TSqlParser::MODIFY:
        case TSqlParser::MOVE:
        case TSqlParser::MULTI_USER:
        case TSqlParser::NAME:
        case TSqlParser::NESTED_TRIGGERS:
        case TSqlParser::NEW_ACCOUNT:
        case TSqlParser::NEW_BROKER:
        case TSqlParser::NEW_PASSWORD:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NO_TRUNCATE:
        case TSqlParser::NO_WAIT:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NON_TRANSACTED_ACCESS:
        case TSqlParser::NORECOMPUTE:
        case TSqlParser::NORECOVERY:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMBER:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFLINE:
        case TSqlParser::OFFSET:
        case TSqlParser::OLD_ACCOUNT:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPEN_EXISTING:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PAGE_VERIFY:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PARTNER:
        case TSqlParser::PATH:
        case TSqlParser::POISON_MESSAGE_HANDLING:
        case TSqlParser::POOL:
        case TSqlParser::PORT:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIMARY_ROLE:
        case TSqlParser::PRIOR:
        case TSqlParser::PRIORITY:
        case TSqlParser::PRIORITY_LEVEL:
        case TSqlParser::PRIVATE:
        case TSqlParser::PRIVATE_KEY:
        case TSqlParser::PRIVILEGES:
        case TSqlParser::PROCEDURE_NAME:
        case TSqlParser::PROPERTY:
        case TSqlParser::PROVIDER:
        case TSqlParser::PROVIDER_KEY_NAME:
        case TSqlParser::QUERY:
        case TSqlParser::QUEUE:
        case TSqlParser::QUEUE_DELAY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_COMMITTED_SNAPSHOT:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READ_ONLY_ROUTING_LIST:
        case TSqlParser::READ_WRITE:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECEIVE:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RECOVERY:
        case TSqlParser::RECURSIVE_TRIGGERS:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REMOTE_SERVICE_NAME:
        case TSqlParser::REMOVE:
        case TSqlParser::REORGANIZE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::REPLICA:
        case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
        case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
        case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
        case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
        case TSqlParser::RESERVE_DISK_SPACE:
        case TSqlParser::RESOURCE:
        case TSqlParser::RESOURCE_MANAGER_LOCATION:
        case TSqlParser::RESTRICTED_USER:
        case TSqlParser::RETENTION:
        case TSqlParser::ROBUST:
        case TSqlParser::ROOT:
        case TSqlParser::ROUTE:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SAMPLE:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCOPED:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SEARCH:
        case TSqlParser::SECONDARY:
        case TSqlParser::SECONDARY_ONLY:
        case TSqlParser::SECONDARY_ROLE:
        case TSqlParser::SECONDS:
        case TSqlParser::SECRET:
        case TSqlParser::SECURITY:
        case TSqlParser::SECURITY_LOG:
        case TSqlParser::SEEDING_MODE:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEND:
        case TSqlParser::SENT:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SESSION_TIMEOUT:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SHOWPLAN:
        case TSqlParser::SIGNATURE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SINGLE_USER:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STANDBY:
        case TSqlParser::START_DATE:
        case TSqlParser::STATIC:
        case TSqlParser::STATS_STREAM:
        case TSqlParser::STATUS:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STOPLIST:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBJECT:
        case TSqlParser::SUM:
        case TSqlParser::SUSPEND:
        case TSqlParser::SYMMETRIC:
        case TSqlParser::SYNCHRONOUS_COMMIT:
        case TSqlParser::SYNONYM:
        case TSqlParser::SYSTEM:
        case TSqlParser::TAKE:
        case TSqlParser::TARGET_RECOVERY_TIME:
        case TSqlParser::TB:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TIMER:
        case TSqlParser::TINYINT:
        case TSqlParser::TORN_PAGE_DETECTION:
        case TSqlParser::TRANSFORM_NOISE_WORDS:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRUSTWORTHY:
        case TSqlParser::TRY:
        case TSqlParser::TSQL:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UNLIMITED:
        case TSqlParser::USING:
        case TSqlParser::VALID_XML:
        case TSqlParser::VALIDATION:
        case TSqlParser::VALUE:
        case TSqlParser::VAR:
        case TSqlParser::VARP:
        case TSqlParser::VIEW_METADATA:
        case TSqlParser::VIEWS:
        case TSqlParser::WAIT:
        case TSqlParser::WELL_FORMED_XML:
        case TSqlParser::WORK:
        case TSqlParser::WORKLOAD:
        case TSqlParser::XML:
        case TSqlParser::XMLNAMESPACES:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID: {
          setState(1503);
          table_name();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1510);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx)) {
      case 1: {
        setState(1506);
        match(TSqlParser::LR_BRACKET);
        setState(1507);
        column_name_list();
        setState(1508);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_dml_list_elemContext ------------------------------------------------------------------

TSqlParser::Output_dml_list_elemContext::Output_dml_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Output_column_nameContext* TSqlParser::Output_dml_list_elemContext::output_column_name() {
  return getRuleContext<TSqlParser::Output_column_nameContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Output_dml_list_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Output_dml_list_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Output_dml_list_elemContext::getRuleIndex() const {
  return TSqlParser::RuleOutput_dml_list_elem;
}

void TSqlParser::Output_dml_list_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_dml_list_elem(this);
}

void TSqlParser::Output_dml_list_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_dml_list_elem(this);
}

TSqlParser::Output_dml_list_elemContext* TSqlParser::output_dml_list_elem() {
  Output_dml_list_elemContext *_localctx = _tracker.createInstance<Output_dml_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 116, TSqlParser::RuleOutput_dml_list_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1516);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
    case 1: {
      setState(1514);
      output_column_name();
      break;
    }

    case 2: {
      setState(1515);
      expression(0);
      break;
    }

    }
    setState(1519);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {
    case 1: {
      setState(1518);
      as_column_alias();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_column_nameContext ------------------------------------------------------------------

TSqlParser::Output_column_nameContext::Output_column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Output_column_nameContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Output_column_nameContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}

tree::TerminalNode* TSqlParser::Output_column_nameContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Output_column_nameContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Output_column_nameContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

TSqlParser::IdContext* TSqlParser::Output_column_nameContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Output_column_nameContext::DOLLAR_ACTION() {
  return getToken(TSqlParser::DOLLAR_ACTION, 0);
}


size_t TSqlParser::Output_column_nameContext::getRuleIndex() const {
  return TSqlParser::RuleOutput_column_name;
}

void TSqlParser::Output_column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_column_name(this);
}

void TSqlParser::Output_column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_column_name(this);
}

TSqlParser::Output_column_nameContext* TSqlParser::output_column_name() {
  Output_column_nameContext *_localctx = _tracker.createInstance<Output_column_nameContext>(_ctx, getState());
  enterRule(_localctx, 118, TSqlParser::RuleOutput_column_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1532);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1524);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx)) {
        case 1: {
          setState(1521);
          match(TSqlParser::DELETED);
          break;
        }

        case 2: {
          setState(1522);
          match(TSqlParser::INSERTED);
          break;
        }

        case 3: {
          setState(1523);
          table_name();
          break;
        }

        }
        setState(1526);
        match(TSqlParser::DOT);
        setState(1529);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::STAR: {
            setState(1527);
            match(TSqlParser::STAR);
            break;
          }

          case TSqlParser::CALLED:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::INIT:
          case TSqlParser::KEY:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::OFFSETS:
          case TSqlParser::PAGE:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAW:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(1528);
            id();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case TSqlParser::DOLLAR_ACTION: {
        enterOuterAlt(_localctx, 2);
        setState(1531);
        match(TSqlParser::DOLLAR_ACTION);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_databaseContext ------------------------------------------------------------------

TSqlParser::Create_databaseContext::Create_databaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_databaseContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::DATABASE() {
  return getToken(TSqlParser::DATABASE, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Create_databaseContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Create_databaseContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::CONTAINMENT() {
  return getToken(TSqlParser::CONTAINMENT, 0);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_databaseContext::ON() {
  return getTokens(TSqlParser::ON);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::ON(size_t i) {
  return getToken(TSqlParser::ON, i);
}

std::vector<TSqlParser::Database_file_specContext *> TSqlParser::Create_databaseContext::database_file_spec() {
  return getRuleContexts<TSqlParser::Database_file_specContext>();
}

TSqlParser::Database_file_specContext* TSqlParser::Create_databaseContext::database_file_spec(size_t i) {
  return getRuleContext<TSqlParser::Database_file_specContext>(i);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::LOG() {
  return getToken(TSqlParser::LOG, 0);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Create_database_optionContext *> TSqlParser::Create_databaseContext::create_database_option() {
  return getRuleContexts<TSqlParser::Create_database_optionContext>();
}

TSqlParser::Create_database_optionContext* TSqlParser::Create_databaseContext::create_database_option(size_t i) {
  return getRuleContext<TSqlParser::Create_database_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::NONE() {
  return getToken(TSqlParser::NONE, 0);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::PARTIAL() {
  return getToken(TSqlParser::PARTIAL, 0);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::PRIMARY() {
  return getToken(TSqlParser::PRIMARY, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_databaseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_databaseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Create_databaseContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_database;
}

void TSqlParser::Create_databaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_database(this);
}

void TSqlParser::Create_databaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_database(this);
}

TSqlParser::Create_databaseContext* TSqlParser::create_database() {
  Create_databaseContext *_localctx = _tracker.createInstance<Create_databaseContext>(_ctx, getState());
  enterRule(_localctx, 120, TSqlParser::RuleCreate_database);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1534);
    match(TSqlParser::CREATE);
    setState(1535);
    match(TSqlParser::DATABASE);

    setState(1536);
    dynamic_cast<Create_databaseContext *>(_localctx)->database = id();
    setState(1540);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONTAINMENT) {
      setState(1537);
      match(TSqlParser::CONTAINMENT);
      setState(1538);
      match(TSqlParser::EQUAL);
      setState(1539);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::NONE

      || _la == TSqlParser::PARTIAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1554);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ON) {
      setState(1542);
      match(TSqlParser::ON);
      setState(1544);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PRIMARY) {
        setState(1543);
        match(TSqlParser::PRIMARY);
      }
      setState(1546);
      database_file_spec();
      setState(1551);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1547);
        match(TSqlParser::COMMA);
        setState(1548);
        database_file_spec();
        setState(1553);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1566);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LOG) {
      setState(1556);
      match(TSqlParser::LOG);
      setState(1557);
      match(TSqlParser::ON);
      setState(1558);
      database_file_spec();
      setState(1563);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1559);
        match(TSqlParser::COMMA);
        setState(1560);
        database_file_spec();
        setState(1565);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1570);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COLLATE) {
      setState(1568);
      match(TSqlParser::COLLATE);
      setState(1569);
      dynamic_cast<Create_databaseContext *>(_localctx)->collation_name = id();
    }
    setState(1581);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1572);
      match(TSqlParser::WITH);
      setState(1573);
      create_database_option();
      setState(1578);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1574);
        match(TSqlParser::COMMA);
        setState(1575);
        create_database_option();
        setState(1580);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_indexContext ------------------------------------------------------------------

TSqlParser::Create_indexContext::Create_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_indexContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_indexContext::INDEX() {
  return getToken(TSqlParser::INDEX, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Create_indexContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Create_indexContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_indexContext::ON() {
  return getTokens(TSqlParser::ON);
}

tree::TerminalNode* TSqlParser::Create_indexContext::ON(size_t i) {
  return getToken(TSqlParser::ON, i);
}

TSqlParser::Table_name_with_hintContext* TSqlParser::Create_indexContext::table_name_with_hint() {
  return getRuleContext<TSqlParser::Table_name_with_hintContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_indexContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Create_indexContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::Column_name_list_with_orderContext* TSqlParser::Create_indexContext::column_name_list_with_order() {
  return getRuleContext<TSqlParser::Column_name_list_with_orderContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_indexContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Create_indexContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Create_indexContext::UNIQUE() {
  return getToken(TSqlParser::UNIQUE, 0);
}

TSqlParser::ClusteredContext* TSqlParser::Create_indexContext::clustered() {
  return getRuleContext<TSqlParser::ClusteredContext>(0);
}

tree::TerminalNode* TSqlParser::Create_indexContext::INCLUDE() {
  return getToken(TSqlParser::INCLUDE, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Create_indexContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Create_indexContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

TSqlParser::Index_optionsContext* TSqlParser::Create_indexContext::index_options() {
  return getRuleContext<TSqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Create_indexContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Create_indexContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}


size_t TSqlParser::Create_indexContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_index;
}

void TSqlParser::Create_indexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_index(this);
}

void TSqlParser::Create_indexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_index(this);
}

TSqlParser::Create_indexContext* TSqlParser::create_index() {
  Create_indexContext *_localctx = _tracker.createInstance<Create_indexContext>(_ctx, getState());
  enterRule(_localctx, 122, TSqlParser::RuleCreate_index);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1583);
    match(TSqlParser::CREATE);
    setState(1585);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::UNIQUE) {
      setState(1584);
      match(TSqlParser::UNIQUE);
    }
    setState(1588);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CLUSTERED || _la == TSqlParser::NONCLUSTERED) {
      setState(1587);
      clustered();
    }
    setState(1590);
    match(TSqlParser::INDEX);
    setState(1591);
    id();
    setState(1592);
    match(TSqlParser::ON);
    setState(1593);
    table_name_with_hint();
    setState(1594);
    match(TSqlParser::LR_BRACKET);
    setState(1595);
    column_name_list_with_order();
    setState(1596);
    match(TSqlParser::RR_BRACKET);
    setState(1602);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INCLUDE) {
      setState(1597);
      match(TSqlParser::INCLUDE);
      setState(1598);
      match(TSqlParser::LR_BRACKET);
      setState(1599);
      column_name_list();
      setState(1600);
      match(TSqlParser::RR_BRACKET);
    }
    setState(1606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(1604);
      match(TSqlParser::WHERE);
      setState(1605);
      dynamic_cast<Create_indexContext *>(_localctx)->where = search_condition();
    }
    setState(1609);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
    case 1: {
      setState(1608);
      index_options();
      break;
    }

    }
    setState(1613);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ON) {
      setState(1611);
      match(TSqlParser::ON);
      setState(1612);
      id();
    }
    setState(1616);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx)) {
    case 1: {
      setState(1615);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_procedureContext ------------------------------------------------------------------

TSqlParser::Create_or_alter_procedureContext::Create_or_alter_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Create_or_alter_procedureContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Sql_clausesContext* TSqlParser::Create_or_alter_procedureContext::sql_clauses() {
  return getRuleContext<TSqlParser::Sql_clausesContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::PROC() {
  return getToken(TSqlParser::PROC, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::PROCEDURE() {
  return getToken(TSqlParser::PROCEDURE, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

std::vector<TSqlParser::Procedure_paramContext *> TSqlParser::Create_or_alter_procedureContext::procedure_param() {
  return getRuleContexts<TSqlParser::Procedure_paramContext>();
}

TSqlParser::Procedure_paramContext* TSqlParser::Create_or_alter_procedureContext::procedure_param(size_t i) {
  return getRuleContext<TSqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Procedure_optionContext *> TSqlParser::Create_or_alter_procedureContext::procedure_option() {
  return getRuleContexts<TSqlParser::Procedure_optionContext>();
}

TSqlParser::Procedure_optionContext* TSqlParser::Create_or_alter_procedureContext::procedure_option(size_t i) {
  return getRuleContext<TSqlParser::Procedure_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_or_alter_procedureContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::OR() {
  return getToken(TSqlParser::OR, 0);
}


size_t TSqlParser::Create_or_alter_procedureContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_or_alter_procedure;
}

void TSqlParser::Create_or_alter_procedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_or_alter_procedure(this);
}

void TSqlParser::Create_or_alter_procedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_or_alter_procedure(this);
}

TSqlParser::Create_or_alter_procedureContext* TSqlParser::create_or_alter_procedure() {
  Create_or_alter_procedureContext *_localctx = _tracker.createInstance<Create_or_alter_procedureContext>(_ctx, getState());
  enterRule(_localctx, 124, TSqlParser::RuleCreate_or_alter_procedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1624);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CREATE: {
        setState(1618);
        match(TSqlParser::CREATE);
        setState(1621);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OR) {
          setState(1619);
          match(TSqlParser::OR);
          setState(1620);
          match(TSqlParser::ALTER);
        }
        break;
      }

      case TSqlParser::ALTER: {
        setState(1623);
        match(TSqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1626);
    dynamic_cast<Create_or_alter_procedureContext *>(_localctx)->proc = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PROC

    || _la == TSqlParser::PROCEDURE)) {
      dynamic_cast<Create_or_alter_procedureContext *>(_localctx)->proc = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1627);
    func_proc_name_schema();
    setState(1630);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1628);
      match(TSqlParser::SEMI);
      setState(1629);
      match(TSqlParser::DECIMAL);
    }
    setState(1646);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::LR_BRACKET) {
      setState(1633);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LR_BRACKET) {
        setState(1632);
        match(TSqlParser::LR_BRACKET);
      }
      setState(1635);
      procedure_param();
      setState(1640);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1636);
        match(TSqlParser::COMMA);
        setState(1637);
        procedure_param();
        setState(1642);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1644);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::RR_BRACKET) {
        setState(1643);
        match(TSqlParser::RR_BRACKET);
      }
    }
    setState(1657);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1648);
      match(TSqlParser::WITH);
      setState(1649);
      procedure_option();
      setState(1654);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1650);
        match(TSqlParser::COMMA);
        setState(1651);
        procedure_option();
        setState(1656);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1661);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FOR) {
      setState(1659);
      match(TSqlParser::FOR);
      setState(1660);
      match(TSqlParser::REPLICATION);
    }
    setState(1663);
    match(TSqlParser::AS);
    setState(1664);
    sql_clauses();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_functionContext ------------------------------------------------------------------

TSqlParser::Create_or_alter_functionContext::Create_or_alter_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::FUNCTION() {
  return getToken(TSqlParser::FUNCTION, 0);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Create_or_alter_functionContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Func_body_returns_selectContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_select() {
  return getRuleContext<TSqlParser::Func_body_returns_selectContext>(0);
}

TSqlParser::Func_body_returns_tableContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_table() {
  return getRuleContext<TSqlParser::Func_body_returns_tableContext>(0);
}

TSqlParser::Func_body_returns_scalarContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_scalar() {
  return getRuleContext<TSqlParser::Func_body_returns_scalarContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

std::vector<TSqlParser::Procedure_paramContext *> TSqlParser::Create_or_alter_functionContext::procedure_param() {
  return getRuleContexts<TSqlParser::Procedure_paramContext>();
}

TSqlParser::Procedure_paramContext* TSqlParser::Create_or_alter_functionContext::procedure_param(size_t i) {
  return getRuleContext<TSqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::OR() {
  return getToken(TSqlParser::OR, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_or_alter_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Create_or_alter_functionContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_or_alter_function;
}

void TSqlParser::Create_or_alter_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_or_alter_function(this);
}

void TSqlParser::Create_or_alter_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_or_alter_function(this);
}

TSqlParser::Create_or_alter_functionContext* TSqlParser::create_or_alter_function() {
  Create_or_alter_functionContext *_localctx = _tracker.createInstance<Create_or_alter_functionContext>(_ctx, getState());
  enterRule(_localctx, 126, TSqlParser::RuleCreate_or_alter_function);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1672);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CREATE: {
        setState(1666);
        match(TSqlParser::CREATE);
        setState(1669);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OR) {
          setState(1667);
          match(TSqlParser::OR);
          setState(1668);
          match(TSqlParser::ALTER);
        }
        break;
      }

      case TSqlParser::ALTER: {
        setState(1671);
        match(TSqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1674);
    match(TSqlParser::FUNCTION);
    setState(1675);
    func_proc_name_schema();
    setState(1689);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
    case 1: {
      setState(1676);
      match(TSqlParser::LR_BRACKET);
      setState(1677);
      procedure_param();
      setState(1682);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1678);
        match(TSqlParser::COMMA);
        setState(1679);
        procedure_param();
        setState(1684);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1685);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1687);
      match(TSqlParser::LR_BRACKET);
      setState(1688);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
    setState(1694);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
    case 1: {
      setState(1691);
      func_body_returns_select();
      break;
    }

    case 2: {
      setState(1692);
      func_body_returns_table();
      break;
    }

    case 3: {
      setState(1693);
      func_body_returns_scalar();
      break;
    }

    }
    setState(1697);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx)) {
    case 1: {
      setState(1696);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_selectContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_selectContext::Func_body_returns_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Select_statementContext* TSqlParser::Func_body_returns_selectContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_selectContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_selectContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_selectContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_selectContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_select;
}

void TSqlParser::Func_body_returns_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_select(this);
}

void TSqlParser::Func_body_returns_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_select(this);
}

TSqlParser::Func_body_returns_selectContext* TSqlParser::func_body_returns_select() {
  Func_body_returns_selectContext *_localctx = _tracker.createInstance<Func_body_returns_selectContext>(_ctx, getState());
  enterRule(_localctx, 128, TSqlParser::RuleFunc_body_returns_select);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1699);
    match(TSqlParser::RETURNS);
    setState(1700);
    match(TSqlParser::TABLE);
    setState(1710);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1701);
      match(TSqlParser::WITH);
      setState(1702);
      function_option();
      setState(1707);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1703);
        match(TSqlParser::COMMA);
        setState(1704);
        function_option();
        setState(1709);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1713);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1712);
      match(TSqlParser::AS);
    }
    setState(1715);
    match(TSqlParser::RETURN);
    setState(1721);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx)) {
    case 1: {
      setState(1716);
      match(TSqlParser::LR_BRACKET);
      setState(1717);
      select_statement();
      setState(1718);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1720);
      select_statement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_tableContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_tableContext::Func_body_returns_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_type_definitionContext* TSqlParser::Func_body_returns_tableContext::table_type_definition() {
  return getRuleContext<TSqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::END() {
  return getToken(TSqlParser::END, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_tableContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_tableContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<TSqlParser::Sql_clauseContext *> TSqlParser::Func_body_returns_tableContext::sql_clause() {
  return getRuleContexts<TSqlParser::Sql_clauseContext>();
}

TSqlParser::Sql_clauseContext* TSqlParser::Func_body_returns_tableContext::sql_clause(size_t i) {
  return getRuleContext<TSqlParser::Sql_clauseContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_tableContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_tableContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_table;
}

void TSqlParser::Func_body_returns_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_table(this);
}

void TSqlParser::Func_body_returns_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_table(this);
}

TSqlParser::Func_body_returns_tableContext* TSqlParser::func_body_returns_table() {
  Func_body_returns_tableContext *_localctx = _tracker.createInstance<Func_body_returns_tableContext>(_ctx, getState());
  enterRule(_localctx, 130, TSqlParser::RuleFunc_body_returns_table);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1723);
    match(TSqlParser::RETURNS);
    setState(1724);
    match(TSqlParser::LOCAL_ID);
    setState(1725);
    table_type_definition();
    setState(1735);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1726);
      match(TSqlParser::WITH);
      setState(1727);
      function_option();
      setState(1732);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1728);
        match(TSqlParser::COMMA);
        setState(1729);
        function_option();
        setState(1734);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1738);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1737);
      match(TSqlParser::AS);
    }
    setState(1740);
    match(TSqlParser::BEGIN);
    setState(1744);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1741);
        sql_clause(); 
      }
      setState(1746);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx);
    }
    setState(1747);
    match(TSqlParser::RETURN);
    setState(1749);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1748);
      match(TSqlParser::SEMI);
    }
    setState(1751);
    match(TSqlParser::END);
    setState(1753);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
    case 1: {
      setState(1752);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_scalarContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_scalarContext::Func_body_returns_scalarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Func_body_returns_scalarContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::END() {
  return getToken(TSqlParser::END, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Func_body_returns_scalarContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_scalarContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_scalarContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<TSqlParser::Sql_clauseContext *> TSqlParser::Func_body_returns_scalarContext::sql_clause() {
  return getRuleContexts<TSqlParser::Sql_clauseContext>();
}

TSqlParser::Sql_clauseContext* TSqlParser::Func_body_returns_scalarContext::sql_clause(size_t i) {
  return getRuleContext<TSqlParser::Sql_clauseContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_scalarContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_scalarContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_scalar;
}

void TSqlParser::Func_body_returns_scalarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_scalar(this);
}

void TSqlParser::Func_body_returns_scalarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_scalar(this);
}

TSqlParser::Func_body_returns_scalarContext* TSqlParser::func_body_returns_scalar() {
  Func_body_returns_scalarContext *_localctx = _tracker.createInstance<Func_body_returns_scalarContext>(_ctx, getState());
  enterRule(_localctx, 132, TSqlParser::RuleFunc_body_returns_scalar);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1755);
    match(TSqlParser::RETURNS);
    setState(1756);
    data_type();
    setState(1766);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1757);
      match(TSqlParser::WITH);
      setState(1758);
      function_option();
      setState(1763);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1759);
        match(TSqlParser::COMMA);
        setState(1760);
        function_option();
        setState(1765);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1769);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1768);
      match(TSqlParser::AS);
    }
    setState(1771);
    match(TSqlParser::BEGIN);
    setState(1775);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1772);
        sql_clause(); 
      }
      setState(1777);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
    }
    setState(1778);
    match(TSqlParser::RETURN);
    setState(1779);
    dynamic_cast<Func_body_returns_scalarContext *>(_localctx)->ret = expression(0);
    setState(1781);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1780);
      match(TSqlParser::SEMI);
    }
    setState(1783);
    match(TSqlParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_paramContext ------------------------------------------------------------------

TSqlParser::Procedure_paramContext::Procedure_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Procedure_paramContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

TSqlParser::IdContext* TSqlParser::Procedure_paramContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::VARYING() {
  return getToken(TSqlParser::VARYING, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Default_valueContext* TSqlParser::Procedure_paramContext::default_value() {
  return getRuleContext<TSqlParser::Default_valueContext>(0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::READONLY() {
  return getToken(TSqlParser::READONLY, 0);
}


size_t TSqlParser::Procedure_paramContext::getRuleIndex() const {
  return TSqlParser::RuleProcedure_param;
}

void TSqlParser::Procedure_paramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedure_param(this);
}

void TSqlParser::Procedure_paramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedure_param(this);
}

TSqlParser::Procedure_paramContext* TSqlParser::procedure_param() {
  Procedure_paramContext *_localctx = _tracker.createInstance<Procedure_paramContext>(_ctx, getState());
  enterRule(_localctx, 134, TSqlParser::RuleProcedure_param);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1785);
    match(TSqlParser::LOCAL_ID);
    setState(1789);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
    case 1: {
      setState(1786);
      id();
      setState(1787);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(1792);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1791);
      match(TSqlParser::AS);
    }
    setState(1794);
    data_type();
    setState(1796);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::VARYING) {
      setState(1795);
      match(TSqlParser::VARYING);
    }
    setState(1800);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::EQUAL) {
      setState(1798);
      match(TSqlParser::EQUAL);
      setState(1799);
      dynamic_cast<Procedure_paramContext *>(_localctx)->default_val = default_value();
    }
    setState(1803);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 659) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 659)) & ((1ULL << (TSqlParser::OUT - 659))
      | (1ULL << (TSqlParser::OUTPUT - 659))
      | (1ULL << (TSqlParser::READONLY - 659)))) != 0)) {
      setState(1802);
      _la = _input->LA(1);
      if (!(((((_la - 659) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 659)) & ((1ULL << (TSqlParser::OUT - 659))
        | (1ULL << (TSqlParser::OUTPUT - 659))
        | (1ULL << (TSqlParser::READONLY - 659)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_optionContext ------------------------------------------------------------------

TSqlParser::Procedure_optionContext::Procedure_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Procedure_optionContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Procedure_optionContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

TSqlParser::Execute_clauseContext* TSqlParser::Procedure_optionContext::execute_clause() {
  return getRuleContext<TSqlParser::Execute_clauseContext>(0);
}


size_t TSqlParser::Procedure_optionContext::getRuleIndex() const {
  return TSqlParser::RuleProcedure_option;
}

void TSqlParser::Procedure_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedure_option(this);
}

void TSqlParser::Procedure_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedure_option(this);
}

TSqlParser::Procedure_optionContext* TSqlParser::procedure_option() {
  Procedure_optionContext *_localctx = _tracker.createInstance<Procedure_optionContext>(_ctx, getState());
  enterRule(_localctx, 136, TSqlParser::RuleProcedure_option);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1808);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(1805);
        match(TSqlParser::ENCRYPTION);
        break;
      }

      case TSqlParser::RECOMPILE: {
        enterOuterAlt(_localctx, 2);
        setState(1806);
        match(TSqlParser::RECOMPILE);
        break;
      }

      case TSqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 3);
        setState(1807);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_optionContext ------------------------------------------------------------------

TSqlParser::Function_optionContext::Function_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Function_optionContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::SCHEMABINDING() {
  return getToken(TSqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Function_optionContext::null() {
  return getTokens(TSqlParser::null);
}

tree::TerminalNode* TSqlParser::Function_optionContext::null(size_t i) {
  return getToken(TSqlParser::null, i);
}

tree::TerminalNode* TSqlParser::Function_optionContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::INPUT() {
  return getToken(TSqlParser::INPUT, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::CALLED() {
  return getToken(TSqlParser::CALLED, 0);
}

TSqlParser::Execute_clauseContext* TSqlParser::Function_optionContext::execute_clause() {
  return getRuleContext<TSqlParser::Execute_clauseContext>(0);
}


size_t TSqlParser::Function_optionContext::getRuleIndex() const {
  return TSqlParser::RuleFunction_option;
}

void TSqlParser::Function_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_option(this);
}

void TSqlParser::Function_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_option(this);
}

TSqlParser::Function_optionContext* TSqlParser::function_option() {
  Function_optionContext *_localctx = _tracker.createInstance<Function_optionContext>(_ctx, getState());
  enterRule(_localctx, 138, TSqlParser::RuleFunction_option);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1822);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(1810);
        match(TSqlParser::ENCRYPTION);
        break;
      }

      case TSqlParser::SCHEMABINDING: {
        enterOuterAlt(_localctx, 2);
        setState(1811);
        match(TSqlParser::SCHEMABINDING);
        break;
      }

      case TSqlParser::RETURNS: {
        enterOuterAlt(_localctx, 3);
        setState(1812);
        match(TSqlParser::RETURNS);
        setState(1813);
        match(TSqlParser::null);
        setState(1814);
        match(TSqlParser::ON);
        setState(1815);
        match(TSqlParser::null);
        setState(1816);
        match(TSqlParser::INPUT);
        break;
      }

      case TSqlParser::CALLED: {
        enterOuterAlt(_localctx, 4);
        setState(1817);
        match(TSqlParser::CALLED);
        setState(1818);
        match(TSqlParser::ON);
        setState(1819);
        match(TSqlParser::null);
        setState(1820);
        match(TSqlParser::INPUT);
        break;
      }

      case TSqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 5);
        setState(1821);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_tableContext ------------------------------------------------------------------

TSqlParser::Create_tableContext::Create_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_tableContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Create_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Create_tableContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

TSqlParser::Simple_idContext* TSqlParser::Create_tableContext::simple_id() {
  return getRuleContext<TSqlParser::Simple_idContext>(0);
}

std::vector<TSqlParser::Table_optionsContext *> TSqlParser::Create_tableContext::table_options() {
  return getRuleContexts<TSqlParser::Table_optionsContext>();
}

TSqlParser::Table_optionsContext* TSqlParser::Create_tableContext::table_options(size_t i) {
  return getRuleContext<TSqlParser::Table_optionsContext>(i);
}

tree::TerminalNode* TSqlParser::Create_tableContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Create_tableContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Create_tableContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_tableContext::DEFAULT() {
  return getTokens(TSqlParser::DEFAULT);
}

tree::TerminalNode* TSqlParser::Create_tableContext::DEFAULT(size_t i) {
  return getToken(TSqlParser::DEFAULT, i);
}

tree::TerminalNode* TSqlParser::Create_tableContext::TEXTIMAGE_ON() {
  return getToken(TSqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Create_tableContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_table;
}

void TSqlParser::Create_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table(this);
}

void TSqlParser::Create_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table(this);
}

TSqlParser::Create_tableContext* TSqlParser::create_table() {
  Create_tableContext *_localctx = _tracker.createInstance<Create_tableContext>(_ctx, getState());
  enterRule(_localctx, 140, TSqlParser::RuleCreate_table);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1824);
    match(TSqlParser::CREATE);
    setState(1825);
    match(TSqlParser::TABLE);
    setState(1826);
    table_name();
    setState(1827);
    match(TSqlParser::LR_BRACKET);
    setState(1828);
    column_def_table_constraints();
    setState(1830);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(1829);
      match(TSqlParser::COMMA);
    }
    setState(1832);
    match(TSqlParser::RR_BRACKET);
    setState(1835);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
    case 1: {
      setState(1833);
      match(TSqlParser::LOCK);
      setState(1834);
      simple_id();
      break;
    }

    }
    setState(1840);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1837);
        table_options(); 
      }
      setState(1842);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx);
    }
    setState(1846);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
    case 1: {
      setState(1843);
      match(TSqlParser::ON);
      setState(1844);
      id();
      break;
    }

    case 2: {
      setState(1845);
      match(TSqlParser::DEFAULT);
      break;
    }

    }
    setState(1851);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
    case 1: {
      setState(1848);
      match(TSqlParser::TEXTIMAGE_ON);
      setState(1849);
      id();
      break;
    }

    case 2: {
      setState(1850);
      match(TSqlParser::DEFAULT);
      break;
    }

    }
    setState(1854);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
    case 1: {
      setState(1853);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_optionsContext ------------------------------------------------------------------

TSqlParser::Table_optionsContext::Table_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_optionsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Index_optionContext *> TSqlParser::Table_optionsContext::index_option() {
  return getRuleContexts<TSqlParser::Index_optionContext>();
}

TSqlParser::Index_optionContext* TSqlParser::Table_optionsContext::index_option(size_t i) {
  return getRuleContext<TSqlParser::Index_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_optionsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleTable_options;
}

void TSqlParser::Table_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_options(this);
}

void TSqlParser::Table_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_options(this);
}

TSqlParser::Table_optionsContext* TSqlParser::table_options() {
  Table_optionsContext *_localctx = _tracker.createInstance<Table_optionsContext>(_ctx, getState());
  enterRule(_localctx, 142, TSqlParser::RuleTable_options);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1856);
    match(TSqlParser::WITH);
    setState(1876);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LR_BRACKET: {
        setState(1857);
        match(TSqlParser::LR_BRACKET);
        setState(1858);
        index_option();
        setState(1863);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(1859);
          match(TSqlParser::COMMA);
          setState(1860);
          index_option();
          setState(1865);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1866);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::ID: {
        setState(1868);
        index_option();
        setState(1873);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(1869);
          match(TSqlParser::COMMA);
          setState(1870);
          index_option();
          setState(1875);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_viewContext ------------------------------------------------------------------

TSqlParser::Create_viewContext::Create_viewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_viewContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_viewContext::VIEW() {
  return getToken(TSqlParser::VIEW, 0);
}

TSqlParser::Simple_nameContext* TSqlParser::Create_viewContext::simple_name() {
  return getRuleContext<TSqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Create_viewContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Select_statementContext* TSqlParser::Create_viewContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Create_viewContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Create_viewContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Create_viewContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_viewContext::WITH() {
  return getTokens(TSqlParser::WITH);
}

tree::TerminalNode* TSqlParser::Create_viewContext::WITH(size_t i) {
  return getToken(TSqlParser::WITH, i);
}

std::vector<TSqlParser::View_attributeContext *> TSqlParser::Create_viewContext::view_attribute() {
  return getRuleContexts<TSqlParser::View_attributeContext>();
}

TSqlParser::View_attributeContext* TSqlParser::Create_viewContext::view_attribute(size_t i) {
  return getRuleContext<TSqlParser::View_attributeContext>(i);
}

tree::TerminalNode* TSqlParser::Create_viewContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

tree::TerminalNode* TSqlParser::Create_viewContext::OPTION() {
  return getToken(TSqlParser::OPTION, 0);
}

tree::TerminalNode* TSqlParser::Create_viewContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_viewContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_viewContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Create_viewContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_view;
}

void TSqlParser::Create_viewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_view(this);
}

void TSqlParser::Create_viewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_view(this);
}

TSqlParser::Create_viewContext* TSqlParser::create_view() {
  Create_viewContext *_localctx = _tracker.createInstance<Create_viewContext>(_ctx, getState());
  enterRule(_localctx, 144, TSqlParser::RuleCreate_view);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1878);
    match(TSqlParser::CREATE);
    setState(1879);
    match(TSqlParser::VIEW);
    setState(1880);
    simple_name();
    setState(1885);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(1881);
      match(TSqlParser::LR_BRACKET);
      setState(1882);
      column_name_list();
      setState(1883);
      match(TSqlParser::RR_BRACKET);
    }
    setState(1896);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1887);
      match(TSqlParser::WITH);
      setState(1888);
      view_attribute();
      setState(1893);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1889);
        match(TSqlParser::COMMA);
        setState(1890);
        view_attribute();
        setState(1895);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1898);
    match(TSqlParser::AS);
    setState(1899);
    select_statement();
    setState(1903);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
    case 1: {
      setState(1900);
      match(TSqlParser::WITH);
      setState(1901);
      match(TSqlParser::CHECK);
      setState(1902);
      match(TSqlParser::OPTION);
      break;
    }

    }
    setState(1906);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
    case 1: {
      setState(1905);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_attributeContext ------------------------------------------------------------------

TSqlParser::View_attributeContext::View_attributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::View_attributeContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::View_attributeContext::SCHEMABINDING() {
  return getToken(TSqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* TSqlParser::View_attributeContext::VIEW_METADATA() {
  return getToken(TSqlParser::VIEW_METADATA, 0);
}


size_t TSqlParser::View_attributeContext::getRuleIndex() const {
  return TSqlParser::RuleView_attribute;
}

void TSqlParser::View_attributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_attribute(this);
}

void TSqlParser::View_attributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_attribute(this);
}

TSqlParser::View_attributeContext* TSqlParser::view_attribute() {
  View_attributeContext *_localctx = _tracker.createInstance<View_attributeContext>(_ctx, getState());
  enterRule(_localctx, 146, TSqlParser::RuleView_attribute);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1908);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::ENCRYPTION || _la == TSqlParser::SCHEMABINDING || _la == TSqlParser::VIEW_METADATA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_tableContext ------------------------------------------------------------------

TSqlParser::Alter_tableContext::Alter_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::ALTER() {
  return getTokens(TSqlParser::ALTER);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::ALTER(size_t i) {
  return getToken(TSqlParser::ALTER, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::TABLE() {
  return getTokens(TSqlParser::TABLE);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::TABLE(size_t i) {
  return getToken(TSqlParser::TABLE, i);
}

std::vector<TSqlParser::Table_nameContext *> TSqlParser::Alter_tableContext::table_name() {
  return getRuleContexts<TSqlParser::Table_nameContext>();
}

TSqlParser::Table_nameContext* TSqlParser::Alter_tableContext::table_name(size_t i) {
  return getRuleContext<TSqlParser::Table_nameContext>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::LOCK_ESCALATION() {
  return getToken(TSqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::ADD() {
  return getToken(TSqlParser::ADD, 0);
}

TSqlParser::Column_def_table_constraintContext* TSqlParser::Alter_tableContext::column_def_table_constraint() {
  return getRuleContext<TSqlParser::Column_def_table_constraintContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::COLUMN() {
  return getToken(TSqlParser::COLUMN, 0);
}

TSqlParser::Column_definitionContext* TSqlParser::Alter_tableContext::column_definition() {
  return getRuleContext<TSqlParser::Column_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

TSqlParser::IdContext* TSqlParser::Alter_tableContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::TRIGGER() {
  return getToken(TSqlParser::TRIGGER, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::REBUILD() {
  return getToken(TSqlParser::REBUILD, 0);
}

TSqlParser::Table_optionsContext* TSqlParser::Alter_tableContext::table_options() {
  return getRuleContext<TSqlParser::Table_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::AUTO() {
  return getToken(TSqlParser::AUTO, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::DISABLE() {
  return getToken(TSqlParser::DISABLE, 0);
}

std::vector<TSqlParser::Column_name_listContext *> TSqlParser::Alter_tableContext::column_name_list() {
  return getRuleContexts<TSqlParser::Column_name_listContext>();
}

TSqlParser::Column_name_listContext* TSqlParser::Alter_tableContext::column_name_list(size_t i) {
  return getRuleContext<TSqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::ENABLE() {
  return getToken(TSqlParser::ENABLE, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Alter_tableContext::getRuleIndex() const {
  return TSqlParser::RuleAlter_table;
}

void TSqlParser::Alter_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table(this);
}

void TSqlParser::Alter_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table(this);
}

TSqlParser::Alter_tableContext* TSqlParser::alter_table() {
  Alter_tableContext *_localctx = _tracker.createInstance<Alter_tableContext>(_ctx, getState());
  enterRule(_localctx, 148, TSqlParser::RuleAlter_table);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1910);
    match(TSqlParser::ALTER);
    setState(1911);
    match(TSqlParser::TABLE);
    setState(1912);
    table_name();
    setState(1956);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      setState(1913);
      match(TSqlParser::SET);
      setState(1914);
      match(TSqlParser::LR_BRACKET);
      setState(1915);
      match(TSqlParser::LOCK_ESCALATION);
      setState(1916);
      match(TSqlParser::EQUAL);
      setState(1917);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TABLE || _la == TSqlParser::AUTO || _la == TSqlParser::DISABLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1918);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1919);
      match(TSqlParser::ADD);
      setState(1920);
      column_def_table_constraint();
      break;
    }

    case 3: {
      setState(1921);
      match(TSqlParser::ALTER);
      setState(1922);
      match(TSqlParser::COLUMN);
      setState(1923);
      column_definition();
      break;
    }

    case 4: {
      setState(1924);
      match(TSqlParser::DROP);
      setState(1925);
      match(TSqlParser::COLUMN);
      setState(1926);
      id();
      break;
    }

    case 5: {
      setState(1927);
      match(TSqlParser::DROP);
      setState(1928);
      match(TSqlParser::CONSTRAINT);
      setState(1929);
      dynamic_cast<Alter_tableContext *>(_localctx)->constraint = id();
      break;
    }

    case 6: {
      setState(1930);
      match(TSqlParser::WITH);
      setState(1931);
      match(TSqlParser::CHECK);
      setState(1932);
      match(TSqlParser::ADD);
      setState(1933);
      match(TSqlParser::CONSTRAINT);
      setState(1934);
      dynamic_cast<Alter_tableContext *>(_localctx)->constraint = id();
      setState(1935);
      match(TSqlParser::FOREIGN);
      setState(1936);
      match(TSqlParser::KEY);
      setState(1937);
      match(TSqlParser::LR_BRACKET);
      setState(1938);
      dynamic_cast<Alter_tableContext *>(_localctx)->fk = column_name_list();
      setState(1939);
      match(TSqlParser::RR_BRACKET);
      setState(1940);
      match(TSqlParser::REFERENCES);
      setState(1941);
      table_name();
      setState(1942);
      match(TSqlParser::LR_BRACKET);
      setState(1943);
      dynamic_cast<Alter_tableContext *>(_localctx)->pk = column_name_list();
      setState(1944);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 7: {
      setState(1946);
      match(TSqlParser::CHECK);
      setState(1947);
      match(TSqlParser::CONSTRAINT);
      setState(1948);
      dynamic_cast<Alter_tableContext *>(_localctx)->constraint = id();
      break;
    }

    case 8: {
      setState(1949);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DISABLE

      || _la == TSqlParser::ENABLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1950);
      match(TSqlParser::TRIGGER);
      setState(1952);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
      case 1: {
        setState(1951);
        id();
        break;
      }

      }
      break;
    }

    case 9: {
      setState(1954);
      match(TSqlParser::REBUILD);
      setState(1955);
      table_options();
      break;
    }

    }
    setState(1959);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
    case 1: {
      setState(1958);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_optionContext ------------------------------------------------------------------

TSqlParser::Cursor_optionContext::Cursor_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

TSqlParser::On_offContext* TSqlParser::Cursor_optionContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::CURSOR_DEFAULT() {
  return getToken(TSqlParser::CURSOR_DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Cursor_optionContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_option;
}

void TSqlParser::Cursor_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_option(this);
}

void TSqlParser::Cursor_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_option(this);
}

TSqlParser::Cursor_optionContext* TSqlParser::cursor_option() {
  Cursor_optionContext *_localctx = _tracker.createInstance<Cursor_optionContext>(_ctx, getState());
  enterRule(_localctx, 150, TSqlParser::RuleCursor_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1965);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT: {
        enterOuterAlt(_localctx, 1);
        setState(1961);
        match(TSqlParser::CURSOR_CLOSE_ON_COMMIT);
        setState(1962);
        on_off();
        break;
      }

      case TSqlParser::CURSOR_DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(1963);
        match(TSqlParser::CURSOR_DEFAULT);
        setState(1964);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::GLOBAL

        || _la == TSqlParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Target_recovery_time_optionContext ------------------------------------------------------------------

TSqlParser::Target_recovery_time_optionContext::Target_recovery_time_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Target_recovery_time_optionContext::TARGET_RECOVERY_TIME() {
  return getToken(TSqlParser::TARGET_RECOVERY_TIME, 0);
}

tree::TerminalNode* TSqlParser::Target_recovery_time_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Target_recovery_time_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Target_recovery_time_optionContext::SECONDS() {
  return getToken(TSqlParser::SECONDS, 0);
}

tree::TerminalNode* TSqlParser::Target_recovery_time_optionContext::MINUTES() {
  return getToken(TSqlParser::MINUTES, 0);
}


size_t TSqlParser::Target_recovery_time_optionContext::getRuleIndex() const {
  return TSqlParser::RuleTarget_recovery_time_option;
}

void TSqlParser::Target_recovery_time_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTarget_recovery_time_option(this);
}

void TSqlParser::Target_recovery_time_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTarget_recovery_time_option(this);
}

TSqlParser::Target_recovery_time_optionContext* TSqlParser::target_recovery_time_option() {
  Target_recovery_time_optionContext *_localctx = _tracker.createInstance<Target_recovery_time_optionContext>(_ctx, getState());
  enterRule(_localctx, 152, TSqlParser::RuleTarget_recovery_time_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1967);
    match(TSqlParser::TARGET_RECOVERY_TIME);
    setState(1968);
    match(TSqlParser::EQUAL);
    setState(1969);
    match(TSqlParser::DECIMAL);
    setState(1970);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::MINUTES || _la == TSqlParser::SECONDS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TerminationContext ------------------------------------------------------------------

TSqlParser::TerminationContext::TerminationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::TerminationContext::ROLLBACK() {
  return getToken(TSqlParser::ROLLBACK, 0);
}

tree::TerminalNode* TSqlParser::TerminationContext::AFTER() {
  return getToken(TSqlParser::AFTER, 0);
}

tree::TerminalNode* TSqlParser::TerminationContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::TerminationContext::IMMEDIATE() {
  return getToken(TSqlParser::IMMEDIATE, 0);
}

tree::TerminalNode* TSqlParser::TerminationContext::NO_WAIT() {
  return getToken(TSqlParser::NO_WAIT, 0);
}


size_t TSqlParser::TerminationContext::getRuleIndex() const {
  return TSqlParser::RuleTermination;
}

void TSqlParser::TerminationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTermination(this);
}

void TSqlParser::TerminationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTermination(this);
}

TSqlParser::TerminationContext* TSqlParser::termination() {
  TerminationContext *_localctx = _tracker.createInstance<TerminationContext>(_ctx, getState());
  enterRule(_localctx, 154, TSqlParser::RuleTermination);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1978);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1972);
      match(TSqlParser::ROLLBACK);
      setState(1973);
      match(TSqlParser::AFTER);
      setState(1974);
      dynamic_cast<TerminationContext *>(_localctx)->seconds = match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1975);
      match(TSqlParser::ROLLBACK);
      setState(1976);
      match(TSqlParser::IMMEDIATE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1977);
      match(TSqlParser::NO_WAIT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_indexContext ------------------------------------------------------------------

TSqlParser::Drop_indexContext::Drop_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_indexContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_indexContext::INDEX() {
  return getToken(TSqlParser::INDEX, 0);
}

std::vector<TSqlParser::Drop_relational_or_xml_or_spatial_indexContext *> TSqlParser::Drop_indexContext::drop_relational_or_xml_or_spatial_index() {
  return getRuleContexts<TSqlParser::Drop_relational_or_xml_or_spatial_indexContext>();
}

TSqlParser::Drop_relational_or_xml_or_spatial_indexContext* TSqlParser::Drop_indexContext::drop_relational_or_xml_or_spatial_index(size_t i) {
  return getRuleContext<TSqlParser::Drop_relational_or_xml_or_spatial_indexContext>(i);
}

std::vector<TSqlParser::Drop_backward_compatible_indexContext *> TSqlParser::Drop_indexContext::drop_backward_compatible_index() {
  return getRuleContexts<TSqlParser::Drop_backward_compatible_indexContext>();
}

TSqlParser::Drop_backward_compatible_indexContext* TSqlParser::Drop_indexContext::drop_backward_compatible_index(size_t i) {
  return getRuleContext<TSqlParser::Drop_backward_compatible_indexContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_indexContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_indexContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::Drop_indexContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_indexContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_indexContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Drop_indexContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_index;
}

void TSqlParser::Drop_indexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_index(this);
}

void TSqlParser::Drop_indexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_index(this);
}

TSqlParser::Drop_indexContext* TSqlParser::drop_index() {
  Drop_indexContext *_localctx = _tracker.createInstance<Drop_indexContext>(_ctx, getState());
  enterRule(_localctx, 156, TSqlParser::RuleDrop_index);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1980);
    match(TSqlParser::DROP);
    setState(1981);
    match(TSqlParser::INDEX);
    setState(1984);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(1982);
      match(TSqlParser::IF);
      setState(1983);
      match(TSqlParser::EXISTS);
    }
    setState(2002);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx)) {
    case 1: {
      setState(1986);
      drop_relational_or_xml_or_spatial_index();
      setState(1991);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1987);
        match(TSqlParser::COMMA);
        setState(1988);
        drop_relational_or_xml_or_spatial_index();
        setState(1993);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(1994);
      drop_backward_compatible_index();
      setState(1999);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1995);
        match(TSqlParser::COMMA);
        setState(1996);
        drop_backward_compatible_index();
        setState(2001);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
    setState(2005);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
    case 1: {
      setState(2004);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_relational_or_xml_or_spatial_indexContext ------------------------------------------------------------------

TSqlParser::Drop_relational_or_xml_or_spatial_indexContext::Drop_relational_or_xml_or_spatial_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_relational_or_xml_or_spatial_indexContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Drop_relational_or_xml_or_spatial_indexContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

TSqlParser::IdContext* TSqlParser::Drop_relational_or_xml_or_spatial_indexContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}


size_t TSqlParser::Drop_relational_or_xml_or_spatial_indexContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_relational_or_xml_or_spatial_index;
}

void TSqlParser::Drop_relational_or_xml_or_spatial_indexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_relational_or_xml_or_spatial_index(this);
}

void TSqlParser::Drop_relational_or_xml_or_spatial_indexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_relational_or_xml_or_spatial_index(this);
}

TSqlParser::Drop_relational_or_xml_or_spatial_indexContext* TSqlParser::drop_relational_or_xml_or_spatial_index() {
  Drop_relational_or_xml_or_spatial_indexContext *_localctx = _tracker.createInstance<Drop_relational_or_xml_or_spatial_indexContext>(_ctx, getState());
  enterRule(_localctx, 158, TSqlParser::RuleDrop_relational_or_xml_or_spatial_index);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2007);
    dynamic_cast<Drop_relational_or_xml_or_spatial_indexContext *>(_localctx)->index_name = id();
    setState(2008);
    match(TSqlParser::ON);
    setState(2009);
    full_table_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_backward_compatible_indexContext ------------------------------------------------------------------

TSqlParser::Drop_backward_compatible_indexContext::Drop_backward_compatible_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_backward_compatible_indexContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Drop_backward_compatible_indexContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Drop_backward_compatible_indexContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Drop_backward_compatible_indexContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}


size_t TSqlParser::Drop_backward_compatible_indexContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_backward_compatible_index;
}

void TSqlParser::Drop_backward_compatible_indexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_backward_compatible_index(this);
}

void TSqlParser::Drop_backward_compatible_indexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_backward_compatible_index(this);
}

TSqlParser::Drop_backward_compatible_indexContext* TSqlParser::drop_backward_compatible_index() {
  Drop_backward_compatible_indexContext *_localctx = _tracker.createInstance<Drop_backward_compatible_indexContext>(_ctx, getState());
  enterRule(_localctx, 160, TSqlParser::RuleDrop_backward_compatible_index);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2014);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
    case 1: {
      setState(2011);
      dynamic_cast<Drop_backward_compatible_indexContext *>(_localctx)->owner_name = id();
      setState(2012);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(2016);
    dynamic_cast<Drop_backward_compatible_indexContext *>(_localctx)->table_or_view_name = id();
    setState(2017);
    match(TSqlParser::DOT);
    setState(2018);
    dynamic_cast<Drop_backward_compatible_indexContext *>(_localctx)->index_name = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_procedureContext ------------------------------------------------------------------

TSqlParser::Drop_procedureContext::Drop_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

std::vector<TSqlParser::Func_proc_name_schemaContext *> TSqlParser::Drop_procedureContext::func_proc_name_schema() {
  return getRuleContexts<TSqlParser::Func_proc_name_schemaContext>();
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Drop_procedureContext::func_proc_name_schema(size_t i) {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::PROC() {
  return getToken(TSqlParser::PROC, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::PROCEDURE() {
  return getToken(TSqlParser::PROCEDURE, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_procedureContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_procedureContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_procedure;
}

void TSqlParser::Drop_procedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_procedure(this);
}

void TSqlParser::Drop_procedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_procedure(this);
}

TSqlParser::Drop_procedureContext* TSqlParser::drop_procedure() {
  Drop_procedureContext *_localctx = _tracker.createInstance<Drop_procedureContext>(_ctx, getState());
  enterRule(_localctx, 162, TSqlParser::RuleDrop_procedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2020);
    match(TSqlParser::DROP);
    setState(2021);
    dynamic_cast<Drop_procedureContext *>(_localctx)->proc = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PROC

    || _la == TSqlParser::PROCEDURE)) {
      dynamic_cast<Drop_procedureContext *>(_localctx)->proc = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2024);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(2022);
      match(TSqlParser::IF);
      setState(2023);
      match(TSqlParser::EXISTS);
    }
    setState(2026);
    func_proc_name_schema();
    setState(2031);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2027);
      match(TSqlParser::COMMA);
      setState(2028);
      func_proc_name_schema();
      setState(2033);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2035);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
    case 1: {
      setState(2034);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_functionContext ------------------------------------------------------------------

TSqlParser::Drop_functionContext::Drop_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_functionContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::FUNCTION() {
  return getToken(TSqlParser::FUNCTION, 0);
}

std::vector<TSqlParser::Func_proc_name_schemaContext *> TSqlParser::Drop_functionContext::func_proc_name_schema() {
  return getRuleContexts<TSqlParser::Func_proc_name_schemaContext>();
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Drop_functionContext::func_proc_name_schema(size_t i) {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_functionContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_function;
}

void TSqlParser::Drop_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_function(this);
}

void TSqlParser::Drop_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_function(this);
}

TSqlParser::Drop_functionContext* TSqlParser::drop_function() {
  Drop_functionContext *_localctx = _tracker.createInstance<Drop_functionContext>(_ctx, getState());
  enterRule(_localctx, 164, TSqlParser::RuleDrop_function);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2037);
    match(TSqlParser::DROP);
    setState(2038);
    match(TSqlParser::FUNCTION);
    setState(2041);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(2039);
      match(TSqlParser::IF);
      setState(2040);
      match(TSqlParser::EXISTS);
    }
    setState(2043);
    func_proc_name_schema();
    setState(2048);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2044);
      match(TSqlParser::COMMA);
      setState(2045);
      func_proc_name_schema();
      setState(2050);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2052);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      setState(2051);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_tableContext ------------------------------------------------------------------

TSqlParser::Drop_tableContext::Drop_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_tableContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Drop_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_tableContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_table;
}

void TSqlParser::Drop_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_table(this);
}

void TSqlParser::Drop_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_table(this);
}

TSqlParser::Drop_tableContext* TSqlParser::drop_table() {
  Drop_tableContext *_localctx = _tracker.createInstance<Drop_tableContext>(_ctx, getState());
  enterRule(_localctx, 166, TSqlParser::RuleDrop_table);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2054);
    match(TSqlParser::DROP);
    setState(2055);
    match(TSqlParser::TABLE);
    setState(2058);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(2056);
      match(TSqlParser::IF);
      setState(2057);
      match(TSqlParser::EXISTS);
    }
    setState(2060);
    table_name();
    setState(2062);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      setState(2061);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_viewContext ------------------------------------------------------------------

TSqlParser::Drop_viewContext::Drop_viewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_viewContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_viewContext::VIEW() {
  return getToken(TSqlParser::VIEW, 0);
}

std::vector<TSqlParser::Simple_nameContext *> TSqlParser::Drop_viewContext::simple_name() {
  return getRuleContexts<TSqlParser::Simple_nameContext>();
}

TSqlParser::Simple_nameContext* TSqlParser::Drop_viewContext::simple_name(size_t i) {
  return getRuleContext<TSqlParser::Simple_nameContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_viewContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_viewContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_viewContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_viewContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Drop_viewContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_viewContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_view;
}

void TSqlParser::Drop_viewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_view(this);
}

void TSqlParser::Drop_viewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_view(this);
}

TSqlParser::Drop_viewContext* TSqlParser::drop_view() {
  Drop_viewContext *_localctx = _tracker.createInstance<Drop_viewContext>(_ctx, getState());
  enterRule(_localctx, 168, TSqlParser::RuleDrop_view);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2064);
    match(TSqlParser::DROP);
    setState(2065);
    match(TSqlParser::VIEW);
    setState(2068);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(2066);
      match(TSqlParser::IF);
      setState(2067);
      match(TSqlParser::EXISTS);
    }
    setState(2070);
    simple_name();
    setState(2075);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2071);
      match(TSqlParser::COMMA);
      setState(2072);
      simple_name();
      setState(2077);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2079);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
    case 1: {
      setState(2078);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_typeContext ------------------------------------------------------------------

TSqlParser::Create_typeContext::Create_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_typeContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_typeContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

TSqlParser::Simple_nameContext* TSqlParser::Create_typeContext::simple_name() {
  return getRuleContext<TSqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Create_typeContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Create_typeContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

TSqlParser::Default_valueContext* TSqlParser::Create_typeContext::default_value() {
  return getRuleContext<TSqlParser::Default_valueContext>(0);
}

tree::TerminalNode* TSqlParser::Create_typeContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Create_typeContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

tree::TerminalNode* TSqlParser::Create_typeContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Create_typeContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Create_typeContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Create_typeContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_type;
}

void TSqlParser::Create_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_type(this);
}

void TSqlParser::Create_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_type(this);
}

TSqlParser::Create_typeContext* TSqlParser::create_type() {
  Create_typeContext *_localctx = _tracker.createInstance<Create_typeContext>(_ctx, getState());
  enterRule(_localctx, 170, TSqlParser::RuleCreate_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2081);
    match(TSqlParser::CREATE);
    setState(2082);
    match(TSqlParser::TYPE);
    setState(2083);
    dynamic_cast<Create_typeContext *>(_localctx)->name = simple_name();
    setState(2088);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(2084);
      match(TSqlParser::FROM);
      setState(2085);
      data_type();
      setState(2086);
      default_value();
    }
    setState(2096);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(2090);
      match(TSqlParser::AS);
      setState(2091);
      match(TSqlParser::TABLE);
      setState(2092);
      match(TSqlParser::LR_BRACKET);
      setState(2093);
      column_def_table_constraints();
      setState(2094);
      match(TSqlParser::RR_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_typeContext ------------------------------------------------------------------

TSqlParser::Drop_typeContext::Drop_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_typeContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_typeContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

TSqlParser::Simple_nameContext* TSqlParser::Drop_typeContext::simple_name() {
  return getRuleContext<TSqlParser::Simple_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Drop_typeContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_typeContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}


size_t TSqlParser::Drop_typeContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_type;
}

void TSqlParser::Drop_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_type(this);
}

void TSqlParser::Drop_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_type(this);
}

TSqlParser::Drop_typeContext* TSqlParser::drop_type() {
  Drop_typeContext *_localctx = _tracker.createInstance<Drop_typeContext>(_ctx, getState());
  enterRule(_localctx, 172, TSqlParser::RuleDrop_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2098);
    match(TSqlParser::DROP);
    setState(2099);
    match(TSqlParser::TYPE);
    setState(2102);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(2100);
      match(TSqlParser::IF);
      setState(2101);
      match(TSqlParser::EXISTS);
    }
    setState(2104);
    dynamic_cast<Drop_typeContext *>(_localctx)->name = simple_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rowset_function_limitedContext ------------------------------------------------------------------

TSqlParser::Rowset_function_limitedContext::Rowset_function_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::OpenqueryContext* TSqlParser::Rowset_function_limitedContext::openquery() {
  return getRuleContext<TSqlParser::OpenqueryContext>(0);
}

TSqlParser::OpendatasourceContext* TSqlParser::Rowset_function_limitedContext::opendatasource() {
  return getRuleContext<TSqlParser::OpendatasourceContext>(0);
}


size_t TSqlParser::Rowset_function_limitedContext::getRuleIndex() const {
  return TSqlParser::RuleRowset_function_limited;
}

void TSqlParser::Rowset_function_limitedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowset_function_limited(this);
}

void TSqlParser::Rowset_function_limitedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowset_function_limited(this);
}

TSqlParser::Rowset_function_limitedContext* TSqlParser::rowset_function_limited() {
  Rowset_function_limitedContext *_localctx = _tracker.createInstance<Rowset_function_limitedContext>(_ctx, getState());
  enterRule(_localctx, 174, TSqlParser::RuleRowset_function_limited);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2108);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::OPENQUERY: {
        enterOuterAlt(_localctx, 1);
        setState(2106);
        openquery();
        break;
      }

      case TSqlParser::OPENDATASOURCE: {
        enterOuterAlt(_localctx, 2);
        setState(2107);
        opendatasource();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpenqueryContext ------------------------------------------------------------------

TSqlParser::OpenqueryContext::OpenqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::OpenqueryContext::OPENQUERY() {
  return getToken(TSqlParser::OPENQUERY, 0);
}

tree::TerminalNode* TSqlParser::OpenqueryContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::OpenqueryContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::OpenqueryContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::IdContext* TSqlParser::OpenqueryContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::OpenqueryContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::OpenqueryContext::getRuleIndex() const {
  return TSqlParser::RuleOpenquery;
}

void TSqlParser::OpenqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpenquery(this);
}

void TSqlParser::OpenqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpenquery(this);
}

TSqlParser::OpenqueryContext* TSqlParser::openquery() {
  OpenqueryContext *_localctx = _tracker.createInstance<OpenqueryContext>(_ctx, getState());
  enterRule(_localctx, 176, TSqlParser::RuleOpenquery);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2110);
    match(TSqlParser::OPENQUERY);
    setState(2111);
    match(TSqlParser::LR_BRACKET);
    setState(2112);
    dynamic_cast<OpenqueryContext *>(_localctx)->linked_server = id();
    setState(2113);
    match(TSqlParser::COMMA);
    setState(2114);
    dynamic_cast<OpenqueryContext *>(_localctx)->query = match(TSqlParser::STRING);
    setState(2115);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpendatasourceContext ------------------------------------------------------------------

TSqlParser::OpendatasourceContext::OpendatasourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::OpendatasourceContext::OPENDATASOURCE() {
  return getToken(TSqlParser::OPENDATASOURCE, 0);
}

tree::TerminalNode* TSqlParser::OpendatasourceContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::OpendatasourceContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::OpendatasourceContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::OpendatasourceContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::OpendatasourceContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

std::vector<tree::TerminalNode *> TSqlParser::OpendatasourceContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::OpendatasourceContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<TSqlParser::IdContext *> TSqlParser::OpendatasourceContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::OpendatasourceContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}


size_t TSqlParser::OpendatasourceContext::getRuleIndex() const {
  return TSqlParser::RuleOpendatasource;
}

void TSqlParser::OpendatasourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpendatasource(this);
}

void TSqlParser::OpendatasourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpendatasource(this);
}

TSqlParser::OpendatasourceContext* TSqlParser::opendatasource() {
  OpendatasourceContext *_localctx = _tracker.createInstance<OpendatasourceContext>(_ctx, getState());
  enterRule(_localctx, 178, TSqlParser::RuleOpendatasource);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2117);
    match(TSqlParser::OPENDATASOURCE);
    setState(2118);
    match(TSqlParser::LR_BRACKET);
    setState(2119);
    dynamic_cast<OpendatasourceContext *>(_localctx)->provider = match(TSqlParser::STRING);
    setState(2120);
    match(TSqlParser::COMMA);
    setState(2121);
    dynamic_cast<OpendatasourceContext *>(_localctx)->init = match(TSqlParser::STRING);
    setState(2122);
    match(TSqlParser::RR_BRACKET);
    setState(2123);
    match(TSqlParser::DOT);
    setState(2125);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
      | (1ULL << (TSqlParser::EVENTDATA - 85))
      | (1ULL << (TSqlParser::FILENAME - 85))
      | (1ULL << (TSqlParser::FILLFACTOR - 85))
      | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
      | (1ULL << (TSqlParser::KEY - 164))
      | (1ULL << (TSqlParser::MASTER - 164))
      | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
      | (1ULL << (TSqlParser::PAGE - 238))
      | (1ULL << (TSqlParser::PUBLIC - 238))
      | (1ULL << (TSqlParser::R - 238))
      | (1ULL << (TSqlParser::RAW - 238))
      | (1ULL << (TSqlParser::RETURN - 238))
      | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
      | (1ULL << (TSqlParser::SAFETY - 305))
      | (1ULL << (TSqlParser::SERVER - 305))
      | (1ULL << (TSqlParser::SID - 305))
      | (1ULL << (TSqlParser::SOURCE - 305))
      | (1ULL << (TSqlParser::SPLIT - 305))
      | (1ULL << (TSqlParser::STATE - 305))
      | (1ULL << (TSqlParser::START - 305))
      | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
      | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
      | (1ULL << (TSqlParser::ACTION - 405))
      | (1ULL << (TSqlParser::ACTIVATION - 405))
      | (1ULL << (TSqlParser::ACTIVE - 405))
      | (1ULL << (TSqlParser::ADDRESS - 405))
      | (1ULL << (TSqlParser::AES_128 - 405))
      | (1ULL << (TSqlParser::AES_192 - 405))
      | (1ULL << (TSqlParser::AES_256 - 405))
      | (1ULL << (TSqlParser::AFFINITY - 405))
      | (1ULL << (TSqlParser::AFTER - 405))
      | (1ULL << (TSqlParser::AGGREGATE - 405))
      | (1ULL << (TSqlParser::ALGORITHM - 405))
      | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
      | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
      | (1ULL << (TSqlParser::ALLOWED - 405))
      | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
      | (1ULL << (TSqlParser::ANSI_NULLS - 405))
      | (1ULL << (TSqlParser::ANSI_PADDING - 405))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
      | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
      | (1ULL << (TSqlParser::APPLY - 405))
      | (1ULL << (TSqlParser::ARITHABORT - 405))
      | (1ULL << (TSqlParser::ASSEMBLY - 405))
      | (1ULL << (TSqlParser::AUDIT - 405))
      | (1ULL << (TSqlParser::AUDIT_GUID - 405))
      | (1ULL << (TSqlParser::AUTO - 405))
      | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
      | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
      | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
      | (1ULL << (TSqlParser::AVAILABILITY - 405))
      | (1ULL << (TSqlParser::AVG - 405))
      | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
      | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
      | (1ULL << (TSqlParser::BIGINT - 405))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
      | (1ULL << (TSqlParser::BINDING - 405))
      | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
      | (1ULL << (TSqlParser::BROKER - 405))
      | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
      | (1ULL << (TSqlParser::BULK_LOGGED - 405))
      | (1ULL << (TSqlParser::CALLER - 405))
      | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
      | (1ULL << (TSqlParser::CAST - 405))
      | (1ULL << (TSqlParser::CATALOG - 405))
      | (1ULL << (TSqlParser::CATCH - 405))
      | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
      | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
      | (1ULL << (TSqlParser::CHECKSUM - 405))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
      | (1ULL << (TSqlParser::CLEANUP - 405))
      | (1ULL << (TSqlParser::COLLECTION - 405))
      | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
      | (1ULL << (TSqlParser::COMMITTED - 405))
      | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
      | (1ULL << (TSqlParser::CONCAT - 405))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
      | (1ULL << (TSqlParser::CONTENT - 405))
      | (1ULL << (TSqlParser::CONTROL - 405))
      | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
      | (1ULL << (TSqlParser::COUNT_BIG - 469))
      | (1ULL << (TSqlParser::COUNTER - 469))
      | (1ULL << (TSqlParser::CPU - 469))
      | (1ULL << (TSqlParser::CREATE_NEW - 469))
      | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
      | (1ULL << (TSqlParser::CREDENTIAL - 469))
      | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
      | (1ULL << (TSqlParser::DATA - 469))
      | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
      | (1ULL << (TSqlParser::DATEADD - 469))
      | (1ULL << (TSqlParser::DATEDIFF - 469))
      | (1ULL << (TSqlParser::DATENAME - 469))
      | (1ULL << (TSqlParser::DATEPART - 469))
      | (1ULL << (TSqlParser::DAYS - 469))
      | (1ULL << (TSqlParser::DB_CHAINING - 469))
      | (1ULL << (TSqlParser::DB_FAILOVER - 469))
      | (1ULL << (TSqlParser::DECRYPTION - 469))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
      | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DELAY - 469))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
      | (1ULL << (TSqlParser::DELETED - 469))
      | (1ULL << (TSqlParser::DENSE_RANK - 469))
      | (1ULL << (TSqlParser::DEPENDENTS - 469))
      | (1ULL << (TSqlParser::DES - 469))
      | (1ULL << (TSqlParser::DESCRIPTION - 469))
      | (1ULL << (TSqlParser::DESX - 469))
      | (1ULL << (TSqlParser::DHCP - 469))
      | (1ULL << (TSqlParser::DIALOG - 469))
      | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
      | (1ULL << (TSqlParser::DISABLE - 469))
      | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
      | (1ULL << (TSqlParser::DISABLED - 469))
      | (1ULL << (TSqlParser::DISK_DRIVE - 469))
      | (1ULL << (TSqlParser::DOCUMENT - 469))
      | (1ULL << (TSqlParser::DYNAMIC - 469))
      | (1ULL << (TSqlParser::EMERGENCY - 469))
      | (1ULL << (TSqlParser::EMPTY - 469))
      | (1ULL << (TSqlParser::ENABLE - 469))
      | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
      | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
      | (1ULL << (TSqlParser::ENCRYPTION - 469))
      | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
      | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
      | (1ULL << (TSqlParser::EXCLUSIVE - 469))
      | (1ULL << (TSqlParser::EXECUTABLE - 469))
      | (1ULL << (TSqlParser::EXIST - 469))
      | (1ULL << (TSqlParser::EXPAND - 469))
      | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
      | (1ULL << (TSqlParser::EXPLICIT - 469))
      | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
      | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
      | (1ULL << (TSqlParser::FAILURE - 469))
      | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
      | (1ULL << (TSqlParser::FAST - 469))
      | (1ULL << (TSqlParser::FAST_FORWARD - 469))
      | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
      | (1ULL << (TSqlParser::FILEPATH - 533))
      | (1ULL << (TSqlParser::FILESTREAM - 533))
      | (1ULL << (TSqlParser::FILTER - 533))
      | (1ULL << (TSqlParser::FIRST - 533))
      | (1ULL << (TSqlParser::FIRST_VALUE - 533))
      | (1ULL << (TSqlParser::FOLLOWING - 533))
      | (1ULL << (TSqlParser::FORCE - 533))
      | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
      | (1ULL << (TSqlParser::FORCED - 533))
      | (1ULL << (TSqlParser::FORMAT - 533))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
      | (1ULL << (TSqlParser::FULLSCAN - 533))
      | (1ULL << (TSqlParser::FULLTEXT - 533))
      | (1ULL << (TSqlParser::GB - 533))
      | (1ULL << (TSqlParser::GETDATE - 533))
      | (1ULL << (TSqlParser::GETUTCDATE - 533))
      | (1ULL << (TSqlParser::GLOBAL - 533))
      | (1ULL << (TSqlParser::GO - 533))
      | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
      | (1ULL << (TSqlParser::GROUPING - 533))
      | (1ULL << (TSqlParser::GROUPING_ID - 533))
      | (1ULL << (TSqlParser::HADR - 533))
      | (1ULL << (TSqlParser::HASH - 533))
      | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
      | (1ULL << (TSqlParser::HIGH - 533))
      | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
      | (1ULL << (TSqlParser::HOURS - 533))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
      | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
      | (1ULL << (TSqlParser::IMMEDIATE - 533))
      | (1ULL << (TSqlParser::IMPERSONATE - 533))
      | (1ULL << (TSqlParser::IMPORTANCE - 533))
      | (1ULL << (TSqlParser::INCREMENTAL - 533))
      | (1ULL << (TSqlParser::INITIATOR - 533))
      | (1ULL << (TSqlParser::INPUT - 533))
      | (1ULL << (TSqlParser::INSENSITIVE - 533))
      | (1ULL << (TSqlParser::INSERTED - 533))
      | (1ULL << (TSqlParser::INT - 533))
      | (1ULL << (TSqlParser::IP - 533))
      | (1ULL << (TSqlParser::ISOLATION - 533))
      | (1ULL << (TSqlParser::KB - 533))
      | (1ULL << (TSqlParser::KEEP - 533))
      | (1ULL << (TSqlParser::KEEPFIXED - 533))
      | (1ULL << (TSqlParser::KEY_SOURCE - 533))
      | (1ULL << (TSqlParser::KEYS - 533))
      | (1ULL << (TSqlParser::KEYSET - 533))
      | (1ULL << (TSqlParser::LAG - 533))
      | (1ULL << (TSqlParser::LAST - 533))
      | (1ULL << (TSqlParser::LAST_VALUE - 533))
      | (1ULL << (TSqlParser::LEAD - 533))
      | (1ULL << (TSqlParser::LEVEL - 533))
      | (1ULL << (TSqlParser::LIST - 533))
      | (1ULL << (TSqlParser::LISTENER - 533))
      | (1ULL << (TSqlParser::LISTENER_URL - 533))
      | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
      | (1ULL << (TSqlParser::LOCAL - 533))
      | (1ULL << (TSqlParser::LOCATION - 533))
      | (1ULL << (TSqlParser::LOCK - 533))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
      | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
      | (1ULL << (TSqlParser::LOW - 597))
      | (1ULL << (TSqlParser::MANUAL - 597))
      | (1ULL << (TSqlParser::MARK - 597))
      | (1ULL << (TSqlParser::MATERIALIZED - 597))
      | (1ULL << (TSqlParser::MAX - 597))
      | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_DOP - 597))
      | (1ULL << (TSqlParser::MAX_FILES - 597))
      | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
      | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
      | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
      | (1ULL << (TSqlParser::MAXDOP - 597))
      | (1ULL << (TSqlParser::MAXRECURSION - 597))
      | (1ULL << (TSqlParser::MAXSIZE - 597))
      | (1ULL << (TSqlParser::MB - 597))
      | (1ULL << (TSqlParser::MEDIUM - 597))
      | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
      | (1ULL << (TSqlParser::MESSAGE - 597))
      | (1ULL << (TSqlParser::MIN - 597))
      | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
      | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MINUTES - 597))
      | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
      | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
      | (1ULL << (TSqlParser::MODE - 597))
      | (1ULL << (TSqlParser::MODIFY - 597))
      | (1ULL << (TSqlParser::MOVE - 597))
      | (1ULL << (TSqlParser::MULTI_USER - 597))
      | (1ULL << (TSqlParser::NAME - 597))
      | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
      | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
      | (1ULL << (TSqlParser::NEW_BROKER - 597))
      | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
      | (1ULL << (TSqlParser::NEXT - 597))
      | (1ULL << (TSqlParser::NO - 597))
      | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
      | (1ULL << (TSqlParser::NO_WAIT - 597))
      | (1ULL << (TSqlParser::NOCOUNT - 597))
      | (1ULL << (TSqlParser::NODES - 597))
      | (1ULL << (TSqlParser::NOEXPAND - 597))
      | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
      | (1ULL << (TSqlParser::NORECOMPUTE - 597))
      | (1ULL << (TSqlParser::NORECOVERY - 597))
      | (1ULL << (TSqlParser::NOWAIT - 597))
      | (1ULL << (TSqlParser::NTILE - 597))
      | (1ULL << (TSqlParser::NUMANODE - 597))
      | (1ULL << (TSqlParser::NUMBER - 597))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
      | (1ULL << (TSqlParser::OBJECT - 597))
      | (1ULL << (TSqlParser::OFFLINE - 597))
      | (1ULL << (TSqlParser::OFFSET - 597))
      | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
      | (1ULL << (TSqlParser::ONLINE - 597))
      | (1ULL << (TSqlParser::ONLY - 597))
      | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
      | (1ULL << (TSqlParser::OPTIMISTIC - 597))
      | (1ULL << (TSqlParser::OPTIMIZE - 597))
      | (1ULL << (TSqlParser::OUT - 597))
      | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
      | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
      | (1ULL << (TSqlParser::PARTITION - 662))
      | (1ULL << (TSqlParser::PARTITIONS - 662))
      | (1ULL << (TSqlParser::PARTNER - 662))
      | (1ULL << (TSqlParser::PATH - 662))
      | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
      | (1ULL << (TSqlParser::POOL - 662))
      | (1ULL << (TSqlParser::PORT - 662))
      | (1ULL << (TSqlParser::PRECEDING - 662))
      | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
      | (1ULL << (TSqlParser::PRIOR - 662))
      | (1ULL << (TSqlParser::PRIORITY - 662))
      | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
      | (1ULL << (TSqlParser::PRIVATE - 662))
      | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
      | (1ULL << (TSqlParser::PRIVILEGES - 662))
      | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
      | (1ULL << (TSqlParser::PROPERTY - 662))
      | (1ULL << (TSqlParser::PROVIDER - 662))
      | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
      | (1ULL << (TSqlParser::QUERY - 662))
      | (1ULL << (TSqlParser::QUEUE - 662))
      | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
      | (1ULL << (TSqlParser::RANGE - 662))
      | (1ULL << (TSqlParser::RANK - 662))
      | (1ULL << (TSqlParser::RC2 - 662))
      | (1ULL << (TSqlParser::RC4 - 662))
      | (1ULL << (TSqlParser::RC4_128 - 662))
      | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
      | (1ULL << (TSqlParser::READ_ONLY - 662))
      | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
      | (1ULL << (TSqlParser::READ_WRITE - 662))
      | (1ULL << (TSqlParser::READONLY - 662))
      | (1ULL << (TSqlParser::REBUILD - 662))
      | (1ULL << (TSqlParser::RECEIVE - 662))
      | (1ULL << (TSqlParser::RECOMPILE - 662))
      | (1ULL << (TSqlParser::RECOVERY - 662))
      | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
      | (1ULL << (TSqlParser::RELATIVE - 662))
      | (1ULL << (TSqlParser::REMOTE - 662))
      | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
      | (1ULL << (TSqlParser::REMOVE - 662))
      | (1ULL << (TSqlParser::REORGANIZE - 662))
      | (1ULL << (TSqlParser::REPEATABLE - 662))
      | (1ULL << (TSqlParser::REPLICA - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
      | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
      | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
      | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
      | (1ULL << (TSqlParser::RESOURCE - 662))
      | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
      | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
      | (1ULL << (TSqlParser::RETENTION - 662))
      | (1ULL << (TSqlParser::ROBUST - 662))
      | (1ULL << (TSqlParser::ROOT - 662))
      | (1ULL << (TSqlParser::ROUTE - 662))
      | (1ULL << (TSqlParser::ROW - 662))
      | (1ULL << (TSqlParser::ROW_NUMBER - 662))
      | (1ULL << (TSqlParser::ROWGUID - 662))
      | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
      | (1ULL << (TSqlParser::SCHEMABINDING - 726))
      | (1ULL << (TSqlParser::SCOPED - 726))
      | (1ULL << (TSqlParser::SCROLL - 726))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
      | (1ULL << (TSqlParser::SEARCH - 726))
      | (1ULL << (TSqlParser::SECONDARY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
      | (1ULL << (TSqlParser::SECONDS - 726))
      | (1ULL << (TSqlParser::SECRET - 726))
      | (1ULL << (TSqlParser::SECURITY - 726))
      | (1ULL << (TSqlParser::SECURITY_LOG - 726))
      | (1ULL << (TSqlParser::SEEDING_MODE - 726))
      | (1ULL << (TSqlParser::SELF - 726))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
      | (1ULL << (TSqlParser::SEND - 726))
      | (1ULL << (TSqlParser::SENT - 726))
      | (1ULL << (TSqlParser::SEQUENCE - 726))
      | (1ULL << (TSqlParser::SERIALIZABLE - 726))
      | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
      | (1ULL << (TSqlParser::SETERROR - 726))
      | (1ULL << (TSqlParser::SHARE - 726))
      | (1ULL << (TSqlParser::SHOWPLAN - 726))
      | (1ULL << (TSqlParser::SIGNATURE - 726))
      | (1ULL << (TSqlParser::SIMPLE - 726))
      | (1ULL << (TSqlParser::SINGLE_USER - 726))
      | (1ULL << (TSqlParser::SIZE - 726))
      | (1ULL << (TSqlParser::SMALLINT - 726))
      | (1ULL << (TSqlParser::SNAPSHOT - 726))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
      | (1ULL << (TSqlParser::STANDBY - 726))
      | (1ULL << (TSqlParser::START_DATE - 726))
      | (1ULL << (TSqlParser::STATIC - 726))
      | (1ULL << (TSqlParser::STATS_STREAM - 726))
      | (1ULL << (TSqlParser::STATUS - 726))
      | (1ULL << (TSqlParser::STDEV - 726))
      | (1ULL << (TSqlParser::STDEVP - 726))
      | (1ULL << (TSqlParser::STOPLIST - 726))
      | (1ULL << (TSqlParser::STRING_AGG - 726))
      | (1ULL << (TSqlParser::STUFF - 726))
      | (1ULL << (TSqlParser::SUBJECT - 726))
      | (1ULL << (TSqlParser::SUM - 726))
      | (1ULL << (TSqlParser::SUSPEND - 726))
      | (1ULL << (TSqlParser::SYMMETRIC - 726))
      | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
      | (1ULL << (TSqlParser::SYNONYM - 726))
      | (1ULL << (TSqlParser::SYSTEM - 726))
      | (1ULL << (TSqlParser::TAKE - 726))
      | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
      | (1ULL << (TSqlParser::TB - 726))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
      | (1ULL << (TSqlParser::THROW - 726))
      | (1ULL << (TSqlParser::TIES - 726))
      | (1ULL << (TSqlParser::TIME - 726))
      | (1ULL << (TSqlParser::TIMEOUT - 726))
      | (1ULL << (TSqlParser::TIMER - 726))
      | (1ULL << (TSqlParser::TINYINT - 726))
      | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
      | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
      | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
      | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
      | (1ULL << (TSqlParser::TRY - 790))
      | (1ULL << (TSqlParser::TSQL - 790))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
      | (1ULL << (TSqlParser::TYPE - 790))
      | (1ULL << (TSqlParser::TYPE_WARNING - 790))
      | (1ULL << (TSqlParser::UNBOUNDED - 790))
      | (1ULL << (TSqlParser::UNCOMMITTED - 790))
      | (1ULL << (TSqlParser::UNKNOWN - 790))
      | (1ULL << (TSqlParser::UNLIMITED - 790))
      | (1ULL << (TSqlParser::USING - 790))
      | (1ULL << (TSqlParser::VALID_XML - 790))
      | (1ULL << (TSqlParser::VALIDATION - 790))
      | (1ULL << (TSqlParser::VALUE - 790))
      | (1ULL << (TSqlParser::VAR - 790))
      | (1ULL << (TSqlParser::VARP - 790))
      | (1ULL << (TSqlParser::VIEW_METADATA - 790))
      | (1ULL << (TSqlParser::VIEWS - 790))
      | (1ULL << (TSqlParser::WAIT - 790))
      | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
      | (1ULL << (TSqlParser::WORK - 790))
      | (1ULL << (TSqlParser::WORKLOAD - 790))
      | (1ULL << (TSqlParser::XML - 790))
      | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
      | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
      setState(2124);
      dynamic_cast<OpendatasourceContext *>(_localctx)->database = id();
    }
    setState(2127);
    match(TSqlParser::DOT);
    setState(2129);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
      | (1ULL << (TSqlParser::EVENTDATA - 85))
      | (1ULL << (TSqlParser::FILENAME - 85))
      | (1ULL << (TSqlParser::FILLFACTOR - 85))
      | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
      | (1ULL << (TSqlParser::KEY - 164))
      | (1ULL << (TSqlParser::MASTER - 164))
      | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
      | (1ULL << (TSqlParser::PAGE - 238))
      | (1ULL << (TSqlParser::PUBLIC - 238))
      | (1ULL << (TSqlParser::R - 238))
      | (1ULL << (TSqlParser::RAW - 238))
      | (1ULL << (TSqlParser::RETURN - 238))
      | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
      | (1ULL << (TSqlParser::SAFETY - 305))
      | (1ULL << (TSqlParser::SERVER - 305))
      | (1ULL << (TSqlParser::SID - 305))
      | (1ULL << (TSqlParser::SOURCE - 305))
      | (1ULL << (TSqlParser::SPLIT - 305))
      | (1ULL << (TSqlParser::STATE - 305))
      | (1ULL << (TSqlParser::START - 305))
      | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
      | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
      | (1ULL << (TSqlParser::ACTION - 405))
      | (1ULL << (TSqlParser::ACTIVATION - 405))
      | (1ULL << (TSqlParser::ACTIVE - 405))
      | (1ULL << (TSqlParser::ADDRESS - 405))
      | (1ULL << (TSqlParser::AES_128 - 405))
      | (1ULL << (TSqlParser::AES_192 - 405))
      | (1ULL << (TSqlParser::AES_256 - 405))
      | (1ULL << (TSqlParser::AFFINITY - 405))
      | (1ULL << (TSqlParser::AFTER - 405))
      | (1ULL << (TSqlParser::AGGREGATE - 405))
      | (1ULL << (TSqlParser::ALGORITHM - 405))
      | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
      | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
      | (1ULL << (TSqlParser::ALLOWED - 405))
      | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
      | (1ULL << (TSqlParser::ANSI_NULLS - 405))
      | (1ULL << (TSqlParser::ANSI_PADDING - 405))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
      | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
      | (1ULL << (TSqlParser::APPLY - 405))
      | (1ULL << (TSqlParser::ARITHABORT - 405))
      | (1ULL << (TSqlParser::ASSEMBLY - 405))
      | (1ULL << (TSqlParser::AUDIT - 405))
      | (1ULL << (TSqlParser::AUDIT_GUID - 405))
      | (1ULL << (TSqlParser::AUTO - 405))
      | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
      | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
      | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
      | (1ULL << (TSqlParser::AVAILABILITY - 405))
      | (1ULL << (TSqlParser::AVG - 405))
      | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
      | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
      | (1ULL << (TSqlParser::BIGINT - 405))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
      | (1ULL << (TSqlParser::BINDING - 405))
      | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
      | (1ULL << (TSqlParser::BROKER - 405))
      | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
      | (1ULL << (TSqlParser::BULK_LOGGED - 405))
      | (1ULL << (TSqlParser::CALLER - 405))
      | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
      | (1ULL << (TSqlParser::CAST - 405))
      | (1ULL << (TSqlParser::CATALOG - 405))
      | (1ULL << (TSqlParser::CATCH - 405))
      | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
      | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
      | (1ULL << (TSqlParser::CHECKSUM - 405))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
      | (1ULL << (TSqlParser::CLEANUP - 405))
      | (1ULL << (TSqlParser::COLLECTION - 405))
      | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
      | (1ULL << (TSqlParser::COMMITTED - 405))
      | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
      | (1ULL << (TSqlParser::CONCAT - 405))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
      | (1ULL << (TSqlParser::CONTENT - 405))
      | (1ULL << (TSqlParser::CONTROL - 405))
      | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
      | (1ULL << (TSqlParser::COUNT_BIG - 469))
      | (1ULL << (TSqlParser::COUNTER - 469))
      | (1ULL << (TSqlParser::CPU - 469))
      | (1ULL << (TSqlParser::CREATE_NEW - 469))
      | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
      | (1ULL << (TSqlParser::CREDENTIAL - 469))
      | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
      | (1ULL << (TSqlParser::DATA - 469))
      | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
      | (1ULL << (TSqlParser::DATEADD - 469))
      | (1ULL << (TSqlParser::DATEDIFF - 469))
      | (1ULL << (TSqlParser::DATENAME - 469))
      | (1ULL << (TSqlParser::DATEPART - 469))
      | (1ULL << (TSqlParser::DAYS - 469))
      | (1ULL << (TSqlParser::DB_CHAINING - 469))
      | (1ULL << (TSqlParser::DB_FAILOVER - 469))
      | (1ULL << (TSqlParser::DECRYPTION - 469))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
      | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DELAY - 469))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
      | (1ULL << (TSqlParser::DELETED - 469))
      | (1ULL << (TSqlParser::DENSE_RANK - 469))
      | (1ULL << (TSqlParser::DEPENDENTS - 469))
      | (1ULL << (TSqlParser::DES - 469))
      | (1ULL << (TSqlParser::DESCRIPTION - 469))
      | (1ULL << (TSqlParser::DESX - 469))
      | (1ULL << (TSqlParser::DHCP - 469))
      | (1ULL << (TSqlParser::DIALOG - 469))
      | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
      | (1ULL << (TSqlParser::DISABLE - 469))
      | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
      | (1ULL << (TSqlParser::DISABLED - 469))
      | (1ULL << (TSqlParser::DISK_DRIVE - 469))
      | (1ULL << (TSqlParser::DOCUMENT - 469))
      | (1ULL << (TSqlParser::DYNAMIC - 469))
      | (1ULL << (TSqlParser::EMERGENCY - 469))
      | (1ULL << (TSqlParser::EMPTY - 469))
      | (1ULL << (TSqlParser::ENABLE - 469))
      | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
      | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
      | (1ULL << (TSqlParser::ENCRYPTION - 469))
      | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
      | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
      | (1ULL << (TSqlParser::EXCLUSIVE - 469))
      | (1ULL << (TSqlParser::EXECUTABLE - 469))
      | (1ULL << (TSqlParser::EXIST - 469))
      | (1ULL << (TSqlParser::EXPAND - 469))
      | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
      | (1ULL << (TSqlParser::EXPLICIT - 469))
      | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
      | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
      | (1ULL << (TSqlParser::FAILURE - 469))
      | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
      | (1ULL << (TSqlParser::FAST - 469))
      | (1ULL << (TSqlParser::FAST_FORWARD - 469))
      | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
      | (1ULL << (TSqlParser::FILEPATH - 533))
      | (1ULL << (TSqlParser::FILESTREAM - 533))
      | (1ULL << (TSqlParser::FILTER - 533))
      | (1ULL << (TSqlParser::FIRST - 533))
      | (1ULL << (TSqlParser::FIRST_VALUE - 533))
      | (1ULL << (TSqlParser::FOLLOWING - 533))
      | (1ULL << (TSqlParser::FORCE - 533))
      | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
      | (1ULL << (TSqlParser::FORCED - 533))
      | (1ULL << (TSqlParser::FORMAT - 533))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
      | (1ULL << (TSqlParser::FULLSCAN - 533))
      | (1ULL << (TSqlParser::FULLTEXT - 533))
      | (1ULL << (TSqlParser::GB - 533))
      | (1ULL << (TSqlParser::GETDATE - 533))
      | (1ULL << (TSqlParser::GETUTCDATE - 533))
      | (1ULL << (TSqlParser::GLOBAL - 533))
      | (1ULL << (TSqlParser::GO - 533))
      | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
      | (1ULL << (TSqlParser::GROUPING - 533))
      | (1ULL << (TSqlParser::GROUPING_ID - 533))
      | (1ULL << (TSqlParser::HADR - 533))
      | (1ULL << (TSqlParser::HASH - 533))
      | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
      | (1ULL << (TSqlParser::HIGH - 533))
      | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
      | (1ULL << (TSqlParser::HOURS - 533))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
      | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
      | (1ULL << (TSqlParser::IMMEDIATE - 533))
      | (1ULL << (TSqlParser::IMPERSONATE - 533))
      | (1ULL << (TSqlParser::IMPORTANCE - 533))
      | (1ULL << (TSqlParser::INCREMENTAL - 533))
      | (1ULL << (TSqlParser::INITIATOR - 533))
      | (1ULL << (TSqlParser::INPUT - 533))
      | (1ULL << (TSqlParser::INSENSITIVE - 533))
      | (1ULL << (TSqlParser::INSERTED - 533))
      | (1ULL << (TSqlParser::INT - 533))
      | (1ULL << (TSqlParser::IP - 533))
      | (1ULL << (TSqlParser::ISOLATION - 533))
      | (1ULL << (TSqlParser::KB - 533))
      | (1ULL << (TSqlParser::KEEP - 533))
      | (1ULL << (TSqlParser::KEEPFIXED - 533))
      | (1ULL << (TSqlParser::KEY_SOURCE - 533))
      | (1ULL << (TSqlParser::KEYS - 533))
      | (1ULL << (TSqlParser::KEYSET - 533))
      | (1ULL << (TSqlParser::LAG - 533))
      | (1ULL << (TSqlParser::LAST - 533))
      | (1ULL << (TSqlParser::LAST_VALUE - 533))
      | (1ULL << (TSqlParser::LEAD - 533))
      | (1ULL << (TSqlParser::LEVEL - 533))
      | (1ULL << (TSqlParser::LIST - 533))
      | (1ULL << (TSqlParser::LISTENER - 533))
      | (1ULL << (TSqlParser::LISTENER_URL - 533))
      | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
      | (1ULL << (TSqlParser::LOCAL - 533))
      | (1ULL << (TSqlParser::LOCATION - 533))
      | (1ULL << (TSqlParser::LOCK - 533))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
      | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
      | (1ULL << (TSqlParser::LOW - 597))
      | (1ULL << (TSqlParser::MANUAL - 597))
      | (1ULL << (TSqlParser::MARK - 597))
      | (1ULL << (TSqlParser::MATERIALIZED - 597))
      | (1ULL << (TSqlParser::MAX - 597))
      | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_DOP - 597))
      | (1ULL << (TSqlParser::MAX_FILES - 597))
      | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
      | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
      | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
      | (1ULL << (TSqlParser::MAXDOP - 597))
      | (1ULL << (TSqlParser::MAXRECURSION - 597))
      | (1ULL << (TSqlParser::MAXSIZE - 597))
      | (1ULL << (TSqlParser::MB - 597))
      | (1ULL << (TSqlParser::MEDIUM - 597))
      | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
      | (1ULL << (TSqlParser::MESSAGE - 597))
      | (1ULL << (TSqlParser::MIN - 597))
      | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
      | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MINUTES - 597))
      | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
      | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
      | (1ULL << (TSqlParser::MODE - 597))
      | (1ULL << (TSqlParser::MODIFY - 597))
      | (1ULL << (TSqlParser::MOVE - 597))
      | (1ULL << (TSqlParser::MULTI_USER - 597))
      | (1ULL << (TSqlParser::NAME - 597))
      | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
      | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
      | (1ULL << (TSqlParser::NEW_BROKER - 597))
      | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
      | (1ULL << (TSqlParser::NEXT - 597))
      | (1ULL << (TSqlParser::NO - 597))
      | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
      | (1ULL << (TSqlParser::NO_WAIT - 597))
      | (1ULL << (TSqlParser::NOCOUNT - 597))
      | (1ULL << (TSqlParser::NODES - 597))
      | (1ULL << (TSqlParser::NOEXPAND - 597))
      | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
      | (1ULL << (TSqlParser::NORECOMPUTE - 597))
      | (1ULL << (TSqlParser::NORECOVERY - 597))
      | (1ULL << (TSqlParser::NOWAIT - 597))
      | (1ULL << (TSqlParser::NTILE - 597))
      | (1ULL << (TSqlParser::NUMANODE - 597))
      | (1ULL << (TSqlParser::NUMBER - 597))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
      | (1ULL << (TSqlParser::OBJECT - 597))
      | (1ULL << (TSqlParser::OFFLINE - 597))
      | (1ULL << (TSqlParser::OFFSET - 597))
      | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
      | (1ULL << (TSqlParser::ONLINE - 597))
      | (1ULL << (TSqlParser::ONLY - 597))
      | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
      | (1ULL << (TSqlParser::OPTIMISTIC - 597))
      | (1ULL << (TSqlParser::OPTIMIZE - 597))
      | (1ULL << (TSqlParser::OUT - 597))
      | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
      | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
      | (1ULL << (TSqlParser::PARTITION - 662))
      | (1ULL << (TSqlParser::PARTITIONS - 662))
      | (1ULL << (TSqlParser::PARTNER - 662))
      | (1ULL << (TSqlParser::PATH - 662))
      | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
      | (1ULL << (TSqlParser::POOL - 662))
      | (1ULL << (TSqlParser::PORT - 662))
      | (1ULL << (TSqlParser::PRECEDING - 662))
      | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
      | (1ULL << (TSqlParser::PRIOR - 662))
      | (1ULL << (TSqlParser::PRIORITY - 662))
      | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
      | (1ULL << (TSqlParser::PRIVATE - 662))
      | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
      | (1ULL << (TSqlParser::PRIVILEGES - 662))
      | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
      | (1ULL << (TSqlParser::PROPERTY - 662))
      | (1ULL << (TSqlParser::PROVIDER - 662))
      | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
      | (1ULL << (TSqlParser::QUERY - 662))
      | (1ULL << (TSqlParser::QUEUE - 662))
      | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
      | (1ULL << (TSqlParser::RANGE - 662))
      | (1ULL << (TSqlParser::RANK - 662))
      | (1ULL << (TSqlParser::RC2 - 662))
      | (1ULL << (TSqlParser::RC4 - 662))
      | (1ULL << (TSqlParser::RC4_128 - 662))
      | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
      | (1ULL << (TSqlParser::READ_ONLY - 662))
      | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
      | (1ULL << (TSqlParser::READ_WRITE - 662))
      | (1ULL << (TSqlParser::READONLY - 662))
      | (1ULL << (TSqlParser::REBUILD - 662))
      | (1ULL << (TSqlParser::RECEIVE - 662))
      | (1ULL << (TSqlParser::RECOMPILE - 662))
      | (1ULL << (TSqlParser::RECOVERY - 662))
      | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
      | (1ULL << (TSqlParser::RELATIVE - 662))
      | (1ULL << (TSqlParser::REMOTE - 662))
      | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
      | (1ULL << (TSqlParser::REMOVE - 662))
      | (1ULL << (TSqlParser::REORGANIZE - 662))
      | (1ULL << (TSqlParser::REPEATABLE - 662))
      | (1ULL << (TSqlParser::REPLICA - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
      | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
      | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
      | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
      | (1ULL << (TSqlParser::RESOURCE - 662))
      | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
      | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
      | (1ULL << (TSqlParser::RETENTION - 662))
      | (1ULL << (TSqlParser::ROBUST - 662))
      | (1ULL << (TSqlParser::ROOT - 662))
      | (1ULL << (TSqlParser::ROUTE - 662))
      | (1ULL << (TSqlParser::ROW - 662))
      | (1ULL << (TSqlParser::ROW_NUMBER - 662))
      | (1ULL << (TSqlParser::ROWGUID - 662))
      | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
      | (1ULL << (TSqlParser::SCHEMABINDING - 726))
      | (1ULL << (TSqlParser::SCOPED - 726))
      | (1ULL << (TSqlParser::SCROLL - 726))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
      | (1ULL << (TSqlParser::SEARCH - 726))
      | (1ULL << (TSqlParser::SECONDARY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
      | (1ULL << (TSqlParser::SECONDS - 726))
      | (1ULL << (TSqlParser::SECRET - 726))
      | (1ULL << (TSqlParser::SECURITY - 726))
      | (1ULL << (TSqlParser::SECURITY_LOG - 726))
      | (1ULL << (TSqlParser::SEEDING_MODE - 726))
      | (1ULL << (TSqlParser::SELF - 726))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
      | (1ULL << (TSqlParser::SEND - 726))
      | (1ULL << (TSqlParser::SENT - 726))
      | (1ULL << (TSqlParser::SEQUENCE - 726))
      | (1ULL << (TSqlParser::SERIALIZABLE - 726))
      | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
      | (1ULL << (TSqlParser::SETERROR - 726))
      | (1ULL << (TSqlParser::SHARE - 726))
      | (1ULL << (TSqlParser::SHOWPLAN - 726))
      | (1ULL << (TSqlParser::SIGNATURE - 726))
      | (1ULL << (TSqlParser::SIMPLE - 726))
      | (1ULL << (TSqlParser::SINGLE_USER - 726))
      | (1ULL << (TSqlParser::SIZE - 726))
      | (1ULL << (TSqlParser::SMALLINT - 726))
      | (1ULL << (TSqlParser::SNAPSHOT - 726))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
      | (1ULL << (TSqlParser::STANDBY - 726))
      | (1ULL << (TSqlParser::START_DATE - 726))
      | (1ULL << (TSqlParser::STATIC - 726))
      | (1ULL << (TSqlParser::STATS_STREAM - 726))
      | (1ULL << (TSqlParser::STATUS - 726))
      | (1ULL << (TSqlParser::STDEV - 726))
      | (1ULL << (TSqlParser::STDEVP - 726))
      | (1ULL << (TSqlParser::STOPLIST - 726))
      | (1ULL << (TSqlParser::STRING_AGG - 726))
      | (1ULL << (TSqlParser::STUFF - 726))
      | (1ULL << (TSqlParser::SUBJECT - 726))
      | (1ULL << (TSqlParser::SUM - 726))
      | (1ULL << (TSqlParser::SUSPEND - 726))
      | (1ULL << (TSqlParser::SYMMETRIC - 726))
      | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
      | (1ULL << (TSqlParser::SYNONYM - 726))
      | (1ULL << (TSqlParser::SYSTEM - 726))
      | (1ULL << (TSqlParser::TAKE - 726))
      | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
      | (1ULL << (TSqlParser::TB - 726))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
      | (1ULL << (TSqlParser::THROW - 726))
      | (1ULL << (TSqlParser::TIES - 726))
      | (1ULL << (TSqlParser::TIME - 726))
      | (1ULL << (TSqlParser::TIMEOUT - 726))
      | (1ULL << (TSqlParser::TIMER - 726))
      | (1ULL << (TSqlParser::TINYINT - 726))
      | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
      | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
      | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
      | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
      | (1ULL << (TSqlParser::TRY - 790))
      | (1ULL << (TSqlParser::TSQL - 790))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
      | (1ULL << (TSqlParser::TYPE - 790))
      | (1ULL << (TSqlParser::TYPE_WARNING - 790))
      | (1ULL << (TSqlParser::UNBOUNDED - 790))
      | (1ULL << (TSqlParser::UNCOMMITTED - 790))
      | (1ULL << (TSqlParser::UNKNOWN - 790))
      | (1ULL << (TSqlParser::UNLIMITED - 790))
      | (1ULL << (TSqlParser::USING - 790))
      | (1ULL << (TSqlParser::VALID_XML - 790))
      | (1ULL << (TSqlParser::VALIDATION - 790))
      | (1ULL << (TSqlParser::VALUE - 790))
      | (1ULL << (TSqlParser::VAR - 790))
      | (1ULL << (TSqlParser::VARP - 790))
      | (1ULL << (TSqlParser::VIEW_METADATA - 790))
      | (1ULL << (TSqlParser::VIEWS - 790))
      | (1ULL << (TSqlParser::WAIT - 790))
      | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
      | (1ULL << (TSqlParser::WORK - 790))
      | (1ULL << (TSqlParser::WORKLOAD - 790))
      | (1ULL << (TSqlParser::XML - 790))
      | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
      | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
      setState(2128);
      dynamic_cast<OpendatasourceContext *>(_localctx)->scheme = id();
    }
    setState(2131);
    match(TSqlParser::DOT);

    setState(2132);
    dynamic_cast<OpendatasourceContext *>(_localctx)->table = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_statementContext ------------------------------------------------------------------

TSqlParser::Declare_statementContext::Declare_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_statementContext::DECLARE() {
  return getToken(TSqlParser::DECLARE, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_type_definitionContext* TSqlParser::Declare_statementContext::table_type_definition() {
  return getRuleContext<TSqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<TSqlParser::Declare_localContext *> TSqlParser::Declare_statementContext::declare_local() {
  return getRuleContexts<TSqlParser::Declare_localContext>();
}

TSqlParser::Declare_localContext* TSqlParser::Declare_statementContext::declare_local(size_t i) {
  return getRuleContext<TSqlParser::Declare_localContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Declare_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Xml_type_definitionContext* TSqlParser::Declare_statementContext::xml_type_definition() {
  return getRuleContext<TSqlParser::Xml_type_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::XMLNAMESPACES() {
  return getToken(TSqlParser::XMLNAMESPACES, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::IdContext* TSqlParser::Declare_statementContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Declare_statementContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_statement;
}

void TSqlParser::Declare_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_statement(this);
}

void TSqlParser::Declare_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_statement(this);
}

TSqlParser::Declare_statementContext* TSqlParser::declare_statement() {
  Declare_statementContext *_localctx = _tracker.createInstance<Declare_statementContext>(_ctx, getState());
  enterRule(_localctx, 180, TSqlParser::RuleDeclare_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2177);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2134);
      match(TSqlParser::DECLARE);
      setState(2135);
      match(TSqlParser::LOCAL_ID);
      setState(2137);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AS) {
        setState(2136);
        match(TSqlParser::AS);
      }
      setState(2139);
      table_type_definition();
      setState(2141);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 289, _ctx)) {
      case 1: {
        setState(2140);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2143);
      match(TSqlParser::DECLARE);
      setState(2144);
      declare_local();
      setState(2149);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2145);
        match(TSqlParser::COMMA);
        setState(2146);
        declare_local();
        setState(2151);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2153);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx)) {
      case 1: {
        setState(2152);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2155);
      match(TSqlParser::DECLARE);
      setState(2156);
      match(TSqlParser::LOCAL_ID);
      setState(2158);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AS) {
        setState(2157);
        match(TSqlParser::AS);
      }
      setState(2160);
      xml_type_definition();
      setState(2162);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
      case 1: {
        setState(2161);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2164);
      match(TSqlParser::WITH);
      setState(2165);
      match(TSqlParser::XMLNAMESPACES);
      setState(2166);
      match(TSqlParser::LR_BRACKET);
      setState(2167);
      dynamic_cast<Declare_statementContext *>(_localctx)->xml_namespace_uri = match(TSqlParser::STRING);
      setState(2169);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(2168);
        match(TSqlParser::COMMA);
      }
      setState(2171);
      match(TSqlParser::AS);
      setState(2172);
      id();
      setState(2173);
      match(TSqlParser::RR_BRACKET);
      setState(2175);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
      case 1: {
        setState(2174);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_statementContext ------------------------------------------------------------------

TSqlParser::Cursor_statementContext::Cursor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::CLOSE() {
  return getToken(TSqlParser::CLOSE, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Cursor_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::DEALLOCATE() {
  return getToken(TSqlParser::DEALLOCATE, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

TSqlParser::Declare_cursorContext* TSqlParser::Cursor_statementContext::declare_cursor() {
  return getRuleContext<TSqlParser::Declare_cursorContext>(0);
}

TSqlParser::Fetch_cursorContext* TSqlParser::Cursor_statementContext::fetch_cursor() {
  return getRuleContext<TSqlParser::Fetch_cursorContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::OPEN() {
  return getToken(TSqlParser::OPEN, 0);
}


size_t TSqlParser::Cursor_statementContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_statement;
}

void TSqlParser::Cursor_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_statement(this);
}

void TSqlParser::Cursor_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_statement(this);
}

TSqlParser::Cursor_statementContext* TSqlParser::cursor_statement() {
  Cursor_statementContext *_localctx = _tracker.createInstance<Cursor_statementContext>(_ctx, getState());
  enterRule(_localctx, 182, TSqlParser::RuleCursor_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2208);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CLOSE: {
        enterOuterAlt(_localctx, 1);
        setState(2179);
        match(TSqlParser::CLOSE);
        setState(2181);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
        case 1: {
          setState(2180);
          match(TSqlParser::GLOBAL);
          break;
        }

        }
        setState(2183);
        cursor_name();
        setState(2185);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
        case 1: {
          setState(2184);
          match(TSqlParser::SEMI);
          break;
        }

        }
        break;
      }

      case TSqlParser::DEALLOCATE: {
        enterOuterAlt(_localctx, 2);
        setState(2187);
        match(TSqlParser::DEALLOCATE);
        setState(2189);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
        case 1: {
          setState(2188);
          match(TSqlParser::GLOBAL);
          break;
        }

        }
        setState(2192);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CURSOR) {
          setState(2191);
          match(TSqlParser::CURSOR);
        }
        setState(2194);
        cursor_name();
        setState(2196);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
        case 1: {
          setState(2195);
          match(TSqlParser::SEMI);
          break;
        }

        }
        break;
      }

      case TSqlParser::DECLARE: {
        enterOuterAlt(_localctx, 3);
        setState(2198);
        declare_cursor();
        break;
      }

      case TSqlParser::FETCH: {
        enterOuterAlt(_localctx, 4);
        setState(2199);
        fetch_cursor();
        break;
      }

      case TSqlParser::OPEN: {
        enterOuterAlt(_localctx, 5);
        setState(2200);
        match(TSqlParser::OPEN);
        setState(2202);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
        case 1: {
          setState(2201);
          match(TSqlParser::GLOBAL);
          break;
        }

        }
        setState(2204);
        cursor_name();
        setState(2206);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
        case 1: {
          setState(2205);
          match(TSqlParser::SEMI);
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_statementContext ------------------------------------------------------------------

TSqlParser::Kill_statementContext::Kill_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_statementContext::KILL() {
  return getToken(TSqlParser::KILL, 0);
}

TSqlParser::Kill_processContext* TSqlParser::Kill_statementContext::kill_process() {
  return getRuleContext<TSqlParser::Kill_processContext>(0);
}

TSqlParser::Kill_query_notificationContext* TSqlParser::Kill_statementContext::kill_query_notification() {
  return getRuleContext<TSqlParser::Kill_query_notificationContext>(0);
}

TSqlParser::Kill_stats_jobContext* TSqlParser::Kill_statementContext::kill_stats_job() {
  return getRuleContext<TSqlParser::Kill_stats_jobContext>(0);
}


size_t TSqlParser::Kill_statementContext::getRuleIndex() const {
  return TSqlParser::RuleKill_statement;
}

void TSqlParser::Kill_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_statement(this);
}

void TSqlParser::Kill_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_statement(this);
}

TSqlParser::Kill_statementContext* TSqlParser::kill_statement() {
  Kill_statementContext *_localctx = _tracker.createInstance<Kill_statementContext>(_ctx, getState());
  enterRule(_localctx, 184, TSqlParser::RuleKill_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2210);
    match(TSqlParser::KILL);
    setState(2214);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UOW:
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING: {
        setState(2211);
        kill_process();
        break;
      }

      case TSqlParser::QUERY: {
        setState(2212);
        kill_query_notification();
        break;
      }

      case TSqlParser::STATS: {
        setState(2213);
        kill_stats_job();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_processContext ------------------------------------------------------------------

TSqlParser::Kill_processContext::Kill_processContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_processContext::UOW() {
  return getToken(TSqlParser::UOW, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::STATUSONLY() {
  return getToken(TSqlParser::STATUSONLY, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Kill_processContext::getRuleIndex() const {
  return TSqlParser::RuleKill_process;
}

void TSqlParser::Kill_processContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_process(this);
}

void TSqlParser::Kill_processContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_process(this);
}

TSqlParser::Kill_processContext* TSqlParser::kill_process() {
  Kill_processContext *_localctx = _tracker.createInstance<Kill_processContext>(_ctx, getState());
  enterRule(_localctx, 186, TSqlParser::RuleKill_process);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2218);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING: {
        setState(2216);
        dynamic_cast<Kill_processContext *>(_localctx)->session_id = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DECIMAL

        || _la == TSqlParser::STRING)) {
          dynamic_cast<Kill_processContext *>(_localctx)->session_id = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::UOW: {
        setState(2217);
        match(TSqlParser::UOW);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2222);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
    case 1: {
      setState(2220);
      match(TSqlParser::WITH);
      setState(2221);
      match(TSqlParser::STATUSONLY);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_query_notificationContext ------------------------------------------------------------------

TSqlParser::Kill_query_notificationContext::Kill_query_notificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::QUERY() {
  return getToken(TSqlParser::QUERY, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::NOTIFICATION() {
  return getToken(TSqlParser::NOTIFICATION, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::SUBSCRIPTION() {
  return getToken(TSqlParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Kill_query_notificationContext::getRuleIndex() const {
  return TSqlParser::RuleKill_query_notification;
}

void TSqlParser::Kill_query_notificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_query_notification(this);
}

void TSqlParser::Kill_query_notificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_query_notification(this);
}

TSqlParser::Kill_query_notificationContext* TSqlParser::kill_query_notification() {
  Kill_query_notificationContext *_localctx = _tracker.createInstance<Kill_query_notificationContext>(_ctx, getState());
  enterRule(_localctx, 188, TSqlParser::RuleKill_query_notification);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2224);
    match(TSqlParser::QUERY);
    setState(2225);
    match(TSqlParser::NOTIFICATION);
    setState(2226);
    match(TSqlParser::SUBSCRIPTION);
    setState(2229);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ALL: {
        setState(2227);
        match(TSqlParser::ALL);
        break;
      }

      case TSqlParser::DECIMAL: {
        setState(2228);
        dynamic_cast<Kill_query_notificationContext *>(_localctx)->subscription_id = match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_stats_jobContext ------------------------------------------------------------------

TSqlParser::Kill_stats_jobContext::Kill_stats_jobContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_stats_jobContext::STATS() {
  return getToken(TSqlParser::STATS, 0);
}

tree::TerminalNode* TSqlParser::Kill_stats_jobContext::JOB() {
  return getToken(TSqlParser::JOB, 0);
}

tree::TerminalNode* TSqlParser::Kill_stats_jobContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Kill_stats_jobContext::getRuleIndex() const {
  return TSqlParser::RuleKill_stats_job;
}

void TSqlParser::Kill_stats_jobContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_stats_job(this);
}

void TSqlParser::Kill_stats_jobContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_stats_job(this);
}

TSqlParser::Kill_stats_jobContext* TSqlParser::kill_stats_job() {
  Kill_stats_jobContext *_localctx = _tracker.createInstance<Kill_stats_jobContext>(_ctx, getState());
  enterRule(_localctx, 190, TSqlParser::RuleKill_stats_job);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2231);
    match(TSqlParser::STATS);
    setState(2232);
    match(TSqlParser::JOB);
    setState(2233);
    dynamic_cast<Kill_stats_jobContext *>(_localctx)->job_id = match(TSqlParser::DECIMAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statementContext ------------------------------------------------------------------

TSqlParser::Execute_statementContext::Execute_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_statementContext::EXECUTE() {
  return getToken(TSqlParser::EXECUTE, 0);
}

TSqlParser::Execute_bodyContext* TSqlParser::Execute_statementContext::execute_body() {
  return getRuleContext<TSqlParser::Execute_bodyContext>(0);
}


size_t TSqlParser::Execute_statementContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement;
}

void TSqlParser::Execute_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement(this);
}

void TSqlParser::Execute_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement(this);
}

TSqlParser::Execute_statementContext* TSqlParser::execute_statement() {
  Execute_statementContext *_localctx = _tracker.createInstance<Execute_statementContext>(_ctx, getState());
  enterRule(_localctx, 192, TSqlParser::RuleExecute_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2235);
    match(TSqlParser::EXECUTE);
    setState(2236);
    execute_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_bodyContext ------------------------------------------------------------------

TSqlParser::Execute_bodyContext::Execute_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Execute_bodyContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Execute_bodyContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<TSqlParser::Execute_statement_argContext *> TSqlParser::Execute_bodyContext::execute_statement_arg() {
  return getRuleContexts<TSqlParser::Execute_statement_argContext>();
}

TSqlParser::Execute_statement_argContext* TSqlParser::Execute_bodyContext::execute_statement_arg(size_t i) {
  return getRuleContext<TSqlParser::Execute_statement_argContext>(i);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_bodyContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Execute_var_stringContext *> TSqlParser::Execute_bodyContext::execute_var_string() {
  return getRuleContexts<TSqlParser::Execute_var_stringContext>();
}

TSqlParser::Execute_var_stringContext* TSqlParser::Execute_bodyContext::execute_var_string(size_t i) {
  return getRuleContext<TSqlParser::Execute_var_stringContext>(i);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_bodyContext::PLUS() {
  return getTokens(TSqlParser::PLUS);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::PLUS(size_t i) {
  return getToken(TSqlParser::PLUS, i);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::LOGIN() {
  return getToken(TSqlParser::LOGIN, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::USER() {
  return getToken(TSqlParser::USER, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::AS() {
  return getToken(TSqlParser::AS, 0);
}


size_t TSqlParser::Execute_bodyContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_body;
}

void TSqlParser::Execute_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_body(this);
}

void TSqlParser::Execute_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_body(this);
}

TSqlParser::Execute_bodyContext* TSqlParser::execute_body() {
  Execute_bodyContext *_localctx = _tracker.createInstance<Execute_bodyContext>(_ctx, getState());
  enterRule(_localctx, 194, TSqlParser::RuleExecute_body);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2280);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2240);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
      case 1: {
        setState(2238);
        dynamic_cast<Execute_bodyContext *>(_localctx)->return_status = match(TSqlParser::LOCAL_ID);
        setState(2239);
        match(TSqlParser::EQUAL);
        break;
      }

      }
      setState(2244);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
      case 1: {
        setState(2242);
        func_proc_name_server_database_schema();
        break;
      }

      case 2: {
        setState(2243);
        expression(0);
        break;
      }

      }
      setState(2254);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
      case 1: {
        setState(2246);
        execute_statement_arg();
        setState(2251);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(2247);
          match(TSqlParser::COMMA);
          setState(2248);
          execute_statement_arg();
          setState(2253);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      }
      setState(2257);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
      case 1: {
        setState(2256);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2259);
      match(TSqlParser::LR_BRACKET);
      setState(2260);
      execute_var_string();
      setState(2265);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::PLUS) {
        setState(2261);
        match(TSqlParser::PLUS);
        setState(2262);
        execute_var_string();
        setState(2267);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2268);
      match(TSqlParser::RR_BRACKET);
      setState(2275);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
      case 1: {
        setState(2270);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::AS) {
          setState(2269);
          match(TSqlParser::AS);
        }
        setState(2272);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::USER || _la == TSqlParser::LOGIN)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2273);
        match(TSqlParser::EQUAL);
        setState(2274);
        match(TSqlParser::STRING);
        break;
      }

      }
      setState(2278);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
      case 1: {
        setState(2277);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_argContext ------------------------------------------------------------------

TSqlParser::Execute_statement_argContext::Execute_statement_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::null() {
  return getToken(TSqlParser::null, 0);
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::Execute_statement_argContext::constant_LOCAL_ID() {
  return getRuleContext<TSqlParser::Constant_LOCAL_IDContext>(0);
}

TSqlParser::IdContext* TSqlParser::Execute_statement_argContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}


size_t TSqlParser::Execute_statement_argContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement_arg;
}

void TSqlParser::Execute_statement_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement_arg(this);
}

void TSqlParser::Execute_statement_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement_arg(this);
}

TSqlParser::Execute_statement_argContext* TSqlParser::execute_statement_arg() {
  Execute_statement_argContext *_localctx = _tracker.createInstance<Execute_statement_argContext>(_ctx, getState());
  enterRule(_localctx, 196, TSqlParser::RuleExecute_statement_arg);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2284);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
    case 1: {
      setState(2282);
      dynamic_cast<Execute_statement_argContext *>(_localctx)->parameter = match(TSqlParser::LOCAL_ID);
      setState(2283);
      match(TSqlParser::EQUAL);
      break;
    }

    }
    setState(2295);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::LOCAL_ID:
      case TSqlParser::DECIMAL:
      case TSqlParser::ID:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        setState(2288);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::LOCAL_ID:
          case TSqlParser::DECIMAL:
          case TSqlParser::STRING:
          case TSqlParser::BINARY:
          case TSqlParser::FLOAT:
          case TSqlParser::REAL:
          case TSqlParser::DOLLAR:
          case TSqlParser::PLUS:
          case TSqlParser::MINUS: {
            setState(2286);
            constant_LOCAL_ID();
            break;
          }

          case TSqlParser::CALLED:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::INIT:
          case TSqlParser::KEY:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::OFFSETS:
          case TSqlParser::PAGE:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAW:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(2287);
            id();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2291);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
        case 1: {
          setState(2290);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::OUT

          || _la == TSqlParser::OUTPUT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        }
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(2293);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::null: {
        setState(2294);
        match(TSqlParser::null);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_var_stringContext ------------------------------------------------------------------

TSqlParser::Execute_var_stringContext::Execute_var_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_var_stringContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Execute_var_stringContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Execute_var_stringContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_var_string;
}

void TSqlParser::Execute_var_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_var_string(this);
}

void TSqlParser::Execute_var_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_var_string(this);
}

TSqlParser::Execute_var_stringContext* TSqlParser::execute_var_string() {
  Execute_var_stringContext *_localctx = _tracker.createInstance<Execute_var_stringContext>(_ctx, getState());
  enterRule(_localctx, 198, TSqlParser::RuleExecute_var_string);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2297);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_statementContext ------------------------------------------------------------------

TSqlParser::Set_statementContext::Set_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Set_statementContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Set_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::IdContext* TSqlParser::Set_statementContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Set_statementContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::Set_statementContext::declare_set_cursor_common() {
  return getRuleContext<TSqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Set_statementContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

TSqlParser::Set_specialContext* TSqlParser::Set_statementContext::set_special() {
  return getRuleContext<TSqlParser::Set_specialContext>(0);
}


size_t TSqlParser::Set_statementContext::getRuleIndex() const {
  return TSqlParser::RuleSet_statement;
}

void TSqlParser::Set_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_statement(this);
}

void TSqlParser::Set_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_statement(this);
}

TSqlParser::Set_statementContext* TSqlParser::set_statement() {
  Set_statementContext *_localctx = _tracker.createInstance<Set_statementContext>(_ctx, getState());
  enterRule(_localctx, 200, TSqlParser::RuleSet_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2338);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2299);
      match(TSqlParser::SET);
      setState(2300);
      match(TSqlParser::LOCAL_ID);
      setState(2303);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DOT) {
        setState(2301);
        match(TSqlParser::DOT);
        setState(2302);
        dynamic_cast<Set_statementContext *>(_localctx)->member_name = id();
      }
      setState(2305);
      match(TSqlParser::EQUAL);
      setState(2306);
      expression(0);
      setState(2308);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx)) {
      case 1: {
        setState(2307);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2310);
      match(TSqlParser::SET);
      setState(2311);
      match(TSqlParser::LOCAL_ID);
      setState(2312);
      assignment_operator();
      setState(2313);
      expression(0);
      setState(2315);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx)) {
      case 1: {
        setState(2314);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2317);
      match(TSqlParser::SET);
      setState(2318);
      match(TSqlParser::LOCAL_ID);
      setState(2319);
      match(TSqlParser::EQUAL);
      setState(2320);
      match(TSqlParser::CURSOR);
      setState(2321);
      declare_set_cursor_common();
      setState(2332);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::FOR) {
        setState(2322);
        match(TSqlParser::FOR);
        setState(2330);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::READ: {
            setState(2323);
            match(TSqlParser::READ);
            setState(2324);
            match(TSqlParser::ONLY);
            break;
          }

          case TSqlParser::UPDATE: {
            setState(2325);
            match(TSqlParser::UPDATE);
            setState(2328);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == TSqlParser::OF) {
              setState(2326);
              match(TSqlParser::OF);
              setState(2327);
              column_name_list();
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(2335);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
      case 1: {
        setState(2334);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2337);
      set_special();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_statementContext ------------------------------------------------------------------

TSqlParser::Transaction_statementContext::Transaction_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::DISTRIBUTED() {
  return getToken(TSqlParser::DISTRIBUTED, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::TRAN() {
  return getToken(TSqlParser::TRAN, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::TRANSACTION() {
  return getToken(TSqlParser::TRANSACTION, 0);
}

TSqlParser::IdContext* TSqlParser::Transaction_statementContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::MARK() {
  return getToken(TSqlParser::MARK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::COMMIT() {
  return getToken(TSqlParser::COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::DELAYED_DURABILITY() {
  return getToken(TSqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::WORK() {
  return getToken(TSqlParser::WORK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::ROLLBACK() {
  return getToken(TSqlParser::ROLLBACK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::SAVE() {
  return getToken(TSqlParser::SAVE, 0);
}


size_t TSqlParser::Transaction_statementContext::getRuleIndex() const {
  return TSqlParser::RuleTransaction_statement;
}

void TSqlParser::Transaction_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_statement(this);
}

void TSqlParser::Transaction_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_statement(this);
}

TSqlParser::Transaction_statementContext* TSqlParser::transaction_statement() {
  Transaction_statementContext *_localctx = _tracker.createInstance<Transaction_statementContext>(_ctx, getState());
  enterRule(_localctx, 202, TSqlParser::RuleTransaction_statement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2421);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 349, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2340);
      match(TSqlParser::BEGIN);
      setState(2341);
      match(TSqlParser::DISTRIBUTED);
      setState(2342);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2345);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
      case 1: {
        setState(2343);
        id();
        break;
      }

      case 2: {
        setState(2344);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      }
      setState(2348);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
      case 1: {
        setState(2347);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2350);
      match(TSqlParser::BEGIN);
      setState(2351);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2361);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
      case 1: {
        setState(2354);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CALLED:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::INIT:
          case TSqlParser::KEY:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::OFFSETS:
          case TSqlParser::PAGE:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAW:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(2352);
            id();
            break;
          }

          case TSqlParser::LOCAL_ID: {
            setState(2353);
            match(TSqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2359);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx)) {
        case 1: {
          setState(2356);
          match(TSqlParser::WITH);
          setState(2357);
          match(TSqlParser::MARK);
          setState(2358);
          match(TSqlParser::STRING);
          break;
        }

        }
        break;
      }

      }
      setState(2364);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
      case 1: {
        setState(2363);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2366);
      match(TSqlParser::COMMIT);
      setState(2367);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2380);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
      case 1: {
        setState(2370);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CALLED:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::INIT:
          case TSqlParser::KEY:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::OFFSETS:
          case TSqlParser::PAGE:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAW:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(2368);
            id();
            break;
          }

          case TSqlParser::LOCAL_ID: {
            setState(2369);
            match(TSqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2378);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
        case 1: {
          setState(2372);
          match(TSqlParser::WITH);
          setState(2373);
          match(TSqlParser::LR_BRACKET);
          setState(2374);
          match(TSqlParser::DELAYED_DURABILITY);
          setState(2375);
          match(TSqlParser::EQUAL);
          setState(2376);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::OFF

          || _la == TSqlParser::ON)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2377);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        }
        break;
      }

      }
      setState(2383);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
      case 1: {
        setState(2382);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2385);
      match(TSqlParser::COMMIT);
      setState(2387);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
      case 1: {
        setState(2386);
        match(TSqlParser::WORK);
        break;
      }

      }
      setState(2390);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
      case 1: {
        setState(2389);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2392);
      match(TSqlParser::COMMIT);
      setState(2393);
      id();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2394);
      match(TSqlParser::ROLLBACK);
      setState(2395);
      id();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2396);
      match(TSqlParser::ROLLBACK);
      setState(2397);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2400);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
      case 1: {
        setState(2398);
        id();
        break;
      }

      case 2: {
        setState(2399);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      }
      setState(2403);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
      case 1: {
        setState(2402);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2405);
      match(TSqlParser::ROLLBACK);
      setState(2407);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
      case 1: {
        setState(2406);
        match(TSqlParser::WORK);
        break;
      }

      }
      setState(2410);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
      case 1: {
        setState(2409);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2412);
      match(TSqlParser::SAVE);
      setState(2413);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2416);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
      case 1: {
        setState(2414);
        id();
        break;
      }

      case 2: {
        setState(2415);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      }
      setState(2419);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx)) {
      case 1: {
        setState(2418);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Go_statementContext ------------------------------------------------------------------

TSqlParser::Go_statementContext::Go_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Go_statementContext::GO() {
  return getToken(TSqlParser::GO, 0);
}

tree::TerminalNode* TSqlParser::Go_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Go_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGo_statement;
}

void TSqlParser::Go_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGo_statement(this);
}

void TSqlParser::Go_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGo_statement(this);
}

TSqlParser::Go_statementContext* TSqlParser::go_statement() {
  Go_statementContext *_localctx = _tracker.createInstance<Go_statementContext>(_ctx, getState());
  enterRule(_localctx, 204, TSqlParser::RuleGo_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2423);
    match(TSqlParser::GO);
    setState(2425);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx)) {
    case 1: {
      setState(2424);
      dynamic_cast<Go_statementContext *>(_localctx)->count = match(TSqlParser::DECIMAL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_statementContext ------------------------------------------------------------------

TSqlParser::Use_statementContext::Use_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Use_statementContext::USE() {
  return getToken(TSqlParser::USE, 0);
}

TSqlParser::IdContext* TSqlParser::Use_statementContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Use_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Use_statementContext::getRuleIndex() const {
  return TSqlParser::RuleUse_statement;
}

void TSqlParser::Use_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse_statement(this);
}

void TSqlParser::Use_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse_statement(this);
}

TSqlParser::Use_statementContext* TSqlParser::use_statement() {
  Use_statementContext *_localctx = _tracker.createInstance<Use_statementContext>(_ctx, getState());
  enterRule(_localctx, 206, TSqlParser::RuleUse_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    match(TSqlParser::USE);
    setState(2428);
    dynamic_cast<Use_statementContext *>(_localctx)->database = id();
    setState(2430);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
    case 1: {
      setState(2429);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setuser_statementContext ------------------------------------------------------------------

TSqlParser::Setuser_statementContext::Setuser_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Setuser_statementContext::SETUSER() {
  return getToken(TSqlParser::SETUSER, 0);
}

tree::TerminalNode* TSqlParser::Setuser_statementContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Setuser_statementContext::getRuleIndex() const {
  return TSqlParser::RuleSetuser_statement;
}

void TSqlParser::Setuser_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetuser_statement(this);
}

void TSqlParser::Setuser_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetuser_statement(this);
}

TSqlParser::Setuser_statementContext* TSqlParser::setuser_statement() {
  Setuser_statementContext *_localctx = _tracker.createInstance<Setuser_statementContext>(_ctx, getState());
  enterRule(_localctx, 208, TSqlParser::RuleSetuser_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2432);
    match(TSqlParser::SETUSER);
    setState(2434);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
    case 1: {
      setState(2433);
      dynamic_cast<Setuser_statementContext *>(_localctx)->user = match(TSqlParser::STRING);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reconfigure_statementContext ------------------------------------------------------------------

TSqlParser::Reconfigure_statementContext::Reconfigure_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Reconfigure_statementContext::RECONFIGURE() {
  return getToken(TSqlParser::RECONFIGURE, 0);
}

tree::TerminalNode* TSqlParser::Reconfigure_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Reconfigure_statementContext::OVERRIDE() {
  return getToken(TSqlParser::OVERRIDE, 0);
}


size_t TSqlParser::Reconfigure_statementContext::getRuleIndex() const {
  return TSqlParser::RuleReconfigure_statement;
}

void TSqlParser::Reconfigure_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReconfigure_statement(this);
}

void TSqlParser::Reconfigure_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReconfigure_statement(this);
}

TSqlParser::Reconfigure_statementContext* TSqlParser::reconfigure_statement() {
  Reconfigure_statementContext *_localctx = _tracker.createInstance<Reconfigure_statementContext>(_ctx, getState());
  enterRule(_localctx, 210, TSqlParser::RuleReconfigure_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2436);
    match(TSqlParser::RECONFIGURE);
    setState(2439);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
    case 1: {
      setState(2437);
      match(TSqlParser::WITH);
      setState(2438);
      match(TSqlParser::OVERRIDE);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Shutdown_statementContext ------------------------------------------------------------------

TSqlParser::Shutdown_statementContext::Shutdown_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::SHUTDOWN() {
  return getToken(TSqlParser::SHUTDOWN, 0);
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}


size_t TSqlParser::Shutdown_statementContext::getRuleIndex() const {
  return TSqlParser::RuleShutdown_statement;
}

void TSqlParser::Shutdown_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShutdown_statement(this);
}

void TSqlParser::Shutdown_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShutdown_statement(this);
}

TSqlParser::Shutdown_statementContext* TSqlParser::shutdown_statement() {
  Shutdown_statementContext *_localctx = _tracker.createInstance<Shutdown_statementContext>(_ctx, getState());
  enterRule(_localctx, 212, TSqlParser::RuleShutdown_statement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2441);
    match(TSqlParser::SHUTDOWN);
    setState(2444);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      setState(2442);
      match(TSqlParser::WITH);
      setState(2443);
      match(TSqlParser::NOWAIT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_clauseContext ------------------------------------------------------------------

TSqlParser::Dbcc_clauseContext::Dbcc_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::DBCC() {
  return getToken(TSqlParser::DBCC, 0);
}

TSqlParser::Simple_idContext* TSqlParser::Dbcc_clauseContext::simple_id() {
  return getRuleContext<TSqlParser::Simple_idContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Dbcc_clauseContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

TSqlParser::Dbcc_optionsContext* TSqlParser::Dbcc_clauseContext::dbcc_options() {
  return getRuleContext<TSqlParser::Dbcc_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Dbcc_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_clause;
}

void TSqlParser::Dbcc_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_clause(this);
}

void TSqlParser::Dbcc_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_clause(this);
}

TSqlParser::Dbcc_clauseContext* TSqlParser::dbcc_clause() {
  Dbcc_clauseContext *_localctx = _tracker.createInstance<Dbcc_clauseContext>(_ctx, getState());
  enterRule(_localctx, 214, TSqlParser::RuleDbcc_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2446);
    match(TSqlParser::DBCC);
    setState(2447);
    dynamic_cast<Dbcc_clauseContext *>(_localctx)->name = simple_id();
    setState(2452);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
    case 1: {
      setState(2448);
      match(TSqlParser::LR_BRACKET);
      setState(2449);
      expression_list();
      setState(2450);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
    setState(2456);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
    case 1: {
      setState(2454);
      match(TSqlParser::WITH);
      setState(2455);
      dbcc_options();
      break;
    }

    }
    setState(2459);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 357, _ctx)) {
    case 1: {
      setState(2458);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_optionsContext ------------------------------------------------------------------

TSqlParser::Dbcc_optionsContext::Dbcc_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Simple_idContext *> TSqlParser::Dbcc_optionsContext::simple_id() {
  return getRuleContexts<TSqlParser::Simple_idContext>();
}

TSqlParser::Simple_idContext* TSqlParser::Dbcc_optionsContext::simple_id(size_t i) {
  return getRuleContext<TSqlParser::Simple_idContext>(i);
}

tree::TerminalNode* TSqlParser::Dbcc_optionsContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}


size_t TSqlParser::Dbcc_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_options;
}

void TSqlParser::Dbcc_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_options(this);
}

void TSqlParser::Dbcc_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_options(this);
}

TSqlParser::Dbcc_optionsContext* TSqlParser::dbcc_options() {
  Dbcc_optionsContext *_localctx = _tracker.createInstance<Dbcc_optionsContext>(_ctx, getState());
  enterRule(_localctx, 216, TSqlParser::RuleDbcc_options);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2461);
    simple_id();
    setState(2464);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(2462);
      match(TSqlParser::COMMA);
      setState(2463);
      simple_id();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_clauseContext ------------------------------------------------------------------

TSqlParser::Execute_clauseContext::Execute_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::EXECUTE() {
  return getToken(TSqlParser::EXECUTE, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::CALLER() {
  return getToken(TSqlParser::CALLER, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::SELF() {
  return getToken(TSqlParser::SELF, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::OWNER() {
  return getToken(TSqlParser::OWNER, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Execute_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_clause;
}

void TSqlParser::Execute_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_clause(this);
}

void TSqlParser::Execute_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_clause(this);
}

TSqlParser::Execute_clauseContext* TSqlParser::execute_clause() {
  Execute_clauseContext *_localctx = _tracker.createInstance<Execute_clauseContext>(_ctx, getState());
  enterRule(_localctx, 218, TSqlParser::RuleExecute_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2466);
    match(TSqlParser::EXECUTE);
    setState(2467);
    match(TSqlParser::AS);
    setState(2468);
    dynamic_cast<Execute_clauseContext *>(_localctx)->clause = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::CALLER || _la == TSqlParser::OWNER || _la == TSqlParser::SELF || _la == TSqlParser::STRING)) {
      dynamic_cast<Execute_clauseContext *>(_localctx)->clause = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_localContext ------------------------------------------------------------------

TSqlParser::Declare_localContext::Declare_localContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_localContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Declare_localContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_localContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Declare_localContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Declare_localContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Declare_localContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_local;
}

void TSqlParser::Declare_localContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_local(this);
}

void TSqlParser::Declare_localContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_local(this);
}

TSqlParser::Declare_localContext* TSqlParser::declare_local() {
  Declare_localContext *_localctx = _tracker.createInstance<Declare_localContext>(_ctx, getState());
  enterRule(_localctx, 220, TSqlParser::RuleDeclare_local);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2470);
    match(TSqlParser::LOCAL_ID);
    setState(2472);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(2471);
      match(TSqlParser::AS);
    }
    setState(2474);
    data_type();
    setState(2477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::EQUAL) {
      setState(2475);
      match(TSqlParser::EQUAL);
      setState(2476);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_type_definitionContext ------------------------------------------------------------------

TSqlParser::Table_type_definitionContext::Table_type_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Table_type_definitionContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_type_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleTable_type_definition;
}

void TSqlParser::Table_type_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_type_definition(this);
}

void TSqlParser::Table_type_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_type_definition(this);
}

TSqlParser::Table_type_definitionContext* TSqlParser::table_type_definition() {
  Table_type_definitionContext *_localctx = _tracker.createInstance<Table_type_definitionContext>(_ctx, getState());
  enterRule(_localctx, 222, TSqlParser::RuleTable_type_definition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2479);
    match(TSqlParser::TABLE);
    setState(2480);
    match(TSqlParser::LR_BRACKET);
    setState(2481);
    column_def_table_constraints();
    setState(2482);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_type_definitionContext ------------------------------------------------------------------

TSqlParser::Xml_type_definitionContext::Xml_type_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Xml_type_definitionContext::XML() {
  return getToken(TSqlParser::XML, 0);
}

tree::TerminalNode* TSqlParser::Xml_type_definitionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Xml_schema_collectionContext* TSqlParser::Xml_type_definitionContext::xml_schema_collection() {
  return getRuleContext<TSqlParser::Xml_schema_collectionContext>(0);
}

tree::TerminalNode* TSqlParser::Xml_type_definitionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Xml_type_definitionContext::CONTENT() {
  return getToken(TSqlParser::CONTENT, 0);
}

tree::TerminalNode* TSqlParser::Xml_type_definitionContext::DOCUMENT() {
  return getToken(TSqlParser::DOCUMENT, 0);
}


size_t TSqlParser::Xml_type_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleXml_type_definition;
}

void TSqlParser::Xml_type_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_type_definition(this);
}

void TSqlParser::Xml_type_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_type_definition(this);
}

TSqlParser::Xml_type_definitionContext* TSqlParser::xml_type_definition() {
  Xml_type_definitionContext *_localctx = _tracker.createInstance<Xml_type_definitionContext>(_ctx, getState());
  enterRule(_localctx, 224, TSqlParser::RuleXml_type_definition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2484);
    match(TSqlParser::XML);
    setState(2485);
    match(TSqlParser::LR_BRACKET);
    setState(2487);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONTENT

    || _la == TSqlParser::DOCUMENT) {
      setState(2486);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::CONTENT

      || _la == TSqlParser::DOCUMENT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2489);
    xml_schema_collection();
    setState(2490);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_schema_collectionContext ------------------------------------------------------------------

TSqlParser::Xml_schema_collectionContext::Xml_schema_collectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Xml_schema_collectionContext::ID() {
  return getTokens(TSqlParser::ID);
}

tree::TerminalNode* TSqlParser::Xml_schema_collectionContext::ID(size_t i) {
  return getToken(TSqlParser::ID, i);
}

tree::TerminalNode* TSqlParser::Xml_schema_collectionContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Xml_schema_collectionContext::getRuleIndex() const {
  return TSqlParser::RuleXml_schema_collection;
}

void TSqlParser::Xml_schema_collectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_schema_collection(this);
}

void TSqlParser::Xml_schema_collectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_schema_collection(this);
}

TSqlParser::Xml_schema_collectionContext* TSqlParser::xml_schema_collection() {
  Xml_schema_collectionContext *_localctx = _tracker.createInstance<Xml_schema_collectionContext>(_ctx, getState());
  enterRule(_localctx, 226, TSqlParser::RuleXml_schema_collection);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2492);
    match(TSqlParser::ID);
    setState(2493);
    match(TSqlParser::DOT);
    setState(2494);
    match(TSqlParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintsContext ------------------------------------------------------------------

TSqlParser::Column_def_table_constraintsContext::Column_def_table_constraintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Column_def_table_constraintContext *> TSqlParser::Column_def_table_constraintsContext::column_def_table_constraint() {
  return getRuleContexts<TSqlParser::Column_def_table_constraintContext>();
}

TSqlParser::Column_def_table_constraintContext* TSqlParser::Column_def_table_constraintsContext::column_def_table_constraint(size_t i) {
  return getRuleContext<TSqlParser::Column_def_table_constraintContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_def_table_constraintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_def_table_constraintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_def_table_constraintsContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_def_table_constraints;
}

void TSqlParser::Column_def_table_constraintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def_table_constraints(this);
}

void TSqlParser::Column_def_table_constraintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def_table_constraints(this);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::column_def_table_constraints() {
  Column_def_table_constraintsContext *_localctx = _tracker.createInstance<Column_def_table_constraintsContext>(_ctx, getState());
  enterRule(_localctx, 228, TSqlParser::RuleColumn_def_table_constraints);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2496);
    column_def_table_constraint();
    setState(2503);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2498);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(2497);
          match(TSqlParser::COMMA);
        }
        setState(2500);
        column_def_table_constraint(); 
      }
      setState(2505);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintContext ------------------------------------------------------------------

TSqlParser::Column_def_table_constraintContext::Column_def_table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_definitionContext* TSqlParser::Column_def_table_constraintContext::column_definition() {
  return getRuleContext<TSqlParser::Column_definitionContext>(0);
}

TSqlParser::Materialized_column_definitionContext* TSqlParser::Column_def_table_constraintContext::materialized_column_definition() {
  return getRuleContext<TSqlParser::Materialized_column_definitionContext>(0);
}

TSqlParser::Table_constraintContext* TSqlParser::Column_def_table_constraintContext::table_constraint() {
  return getRuleContext<TSqlParser::Table_constraintContext>(0);
}


size_t TSqlParser::Column_def_table_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_def_table_constraint;
}

void TSqlParser::Column_def_table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def_table_constraint(this);
}

void TSqlParser::Column_def_table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def_table_constraint(this);
}

TSqlParser::Column_def_table_constraintContext* TSqlParser::column_def_table_constraint() {
  Column_def_table_constraintContext *_localctx = _tracker.createInstance<Column_def_table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 230, TSqlParser::RuleColumn_def_table_constraint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2509);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2506);
      column_definition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2507);
      materialized_column_definition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2508);
      table_constraint();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_definitionContext ------------------------------------------------------------------

TSqlParser::Column_definitionContext::Column_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Column_definitionContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Column_definitionContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

TSqlParser::Data_typeContext* TSqlParser::Column_definitionContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Column_definitionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::Null_notnullContext* TSqlParser::Column_definitionContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

std::vector<TSqlParser::Null_or_defaultContext *> TSqlParser::Column_definitionContext::null_or_default() {
  return getRuleContexts<TSqlParser::Null_or_defaultContext>();
}

TSqlParser::Null_or_defaultContext* TSqlParser::Column_definitionContext::null_or_default(size_t i) {
  return getRuleContext<TSqlParser::Null_or_defaultContext>(i);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::ROWGUIDCOL() {
  return getToken(TSqlParser::ROWGUIDCOL, 0);
}

std::vector<TSqlParser::Column_constraintContext *> TSqlParser::Column_definitionContext::column_constraint() {
  return getRuleContexts<TSqlParser::Column_constraintContext>();
}

TSqlParser::Column_constraintContext* TSqlParser::Column_definitionContext::column_constraint(size_t i) {
  return getRuleContext<TSqlParser::Column_constraintContext>(i);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_definitionContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}


size_t TSqlParser::Column_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_definition;
}

void TSqlParser::Column_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_definition(this);
}

void TSqlParser::Column_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_definition(this);
}

TSqlParser::Column_definitionContext* TSqlParser::column_definition() {
  Column_definitionContext *_localctx = _tracker.createInstance<Column_definitionContext>(_ctx, getState());
  enterRule(_localctx, 232, TSqlParser::RuleColumn_definition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2511);
    id();
    setState(2515);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::DOUBLE:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(2512);
        data_type();
        break;
      }

      case TSqlParser::AS: {
        setState(2513);
        match(TSqlParser::AS);
        setState(2514);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2519);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COLLATE) {
      setState(2517);
      match(TSqlParser::COLLATE);
      setState(2518);
      id();
    }
    setState(2522);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 367, _ctx)) {
    case 1: {
      setState(2521);
      null_notnull();
      break;
    }

    }
    setState(2545);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 372, _ctx)) {
    case 1: {
      setState(2526);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::CONSTRAINT) {
        setState(2524);
        match(TSqlParser::CONSTRAINT);
        setState(2525);
        dynamic_cast<Column_definitionContext *>(_localctx)->constraint = id();
      }
      setState(2528);
      null_or_default();
      setState(2530);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
      case 1: {
        setState(2529);
        null_or_default();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2532);
      match(TSqlParser::IDENTITY);
      setState(2538);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
      case 1: {
        setState(2533);
        match(TSqlParser::LR_BRACKET);
        setState(2534);
        dynamic_cast<Column_definitionContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
        setState(2535);
        match(TSqlParser::COMMA);
        setState(2536);
        dynamic_cast<Column_definitionContext *>(_localctx)->increment = match(TSqlParser::DECIMAL);
        setState(2537);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      }
      setState(2543);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
      case 1: {
        setState(2540);
        match(TSqlParser::NOT);
        setState(2541);
        match(TSqlParser::FOR);
        setState(2542);
        match(TSqlParser::REPLICATION);
        break;
      }

      }
      break;
    }

    }
    setState(2548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ROWGUIDCOL) {
      setState(2547);
      match(TSqlParser::ROWGUIDCOL);
    }
    setState(2553);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2550);
        column_constraint(); 
      }
      setState(2555);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Materialized_column_definitionContext ------------------------------------------------------------------

TSqlParser::Materialized_column_definitionContext::Materialized_column_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Materialized_column_definitionContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Materialized_column_definitionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Materialized_column_definitionContext::COMPUTE() {
  return getToken(TSqlParser::COMPUTE, 0);
}

tree::TerminalNode* TSqlParser::Materialized_column_definitionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Materialized_column_definitionContext::MATERIALIZED() {
  return getToken(TSqlParser::MATERIALIZED, 0);
}

tree::TerminalNode* TSqlParser::Materialized_column_definitionContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}


size_t TSqlParser::Materialized_column_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleMaterialized_column_definition;
}

void TSqlParser::Materialized_column_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaterialized_column_definition(this);
}

void TSqlParser::Materialized_column_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaterialized_column_definition(this);
}

TSqlParser::Materialized_column_definitionContext* TSqlParser::materialized_column_definition() {
  Materialized_column_definitionContext *_localctx = _tracker.createInstance<Materialized_column_definitionContext>(_ctx, getState());
  enterRule(_localctx, 234, TSqlParser::RuleMaterialized_column_definition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2556);
    id();
    setState(2557);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::AS

    || _la == TSqlParser::COMPUTE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2558);
    expression(0);
    setState(2562);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx)) {
    case 1: {
      setState(2559);
      match(TSqlParser::MATERIALIZED);
      break;
    }

    case 2: {
      setState(2560);
      match(TSqlParser::NOT);
      setState(2561);
      match(TSqlParser::MATERIALIZED);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_constraintContext ------------------------------------------------------------------

TSqlParser::Column_constraintContext::Column_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_constraintContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Column_constraintContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Column_constraintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::Null_notnullContext* TSqlParser::Column_constraintContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Column_constraintContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

TSqlParser::IdContext* TSqlParser::Column_constraintContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::PRIMARY() {
  return getToken(TSqlParser::PRIMARY, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::UNIQUE() {
  return getToken(TSqlParser::UNIQUE, 0);
}

TSqlParser::ClusteredContext* TSqlParser::Column_constraintContext::clustered() {
  return getRuleContext<TSqlParser::ClusteredContext>(0);
}

TSqlParser::Index_optionsContext* TSqlParser::Column_constraintContext::index_options() {
  return getRuleContext<TSqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}

TSqlParser::On_deleteContext* TSqlParser::Column_constraintContext::on_delete() {
  return getRuleContext<TSqlParser::On_deleteContext>(0);
}

TSqlParser::On_updateContext* TSqlParser::Column_constraintContext::on_update() {
  return getRuleContext<TSqlParser::On_updateContext>(0);
}


size_t TSqlParser::Column_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_constraint;
}

void TSqlParser::Column_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_constraint(this);
}

void TSqlParser::Column_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_constraint(this);
}

TSqlParser::Column_constraintContext* TSqlParser::column_constraint() {
  Column_constraintContext *_localctx = _tracker.createInstance<Column_constraintContext>(_ctx, getState());
  enterRule(_localctx, 236, TSqlParser::RuleColumn_constraint);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2566);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONSTRAINT) {
      setState(2564);
      match(TSqlParser::CONSTRAINT);
      setState(2565);
      dynamic_cast<Column_constraintContext *>(_localctx)->constraint = id();
    }
    setState(2605);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        setState(2571);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::PRIMARY: {
            setState(2568);
            match(TSqlParser::PRIMARY);
            setState(2569);
            match(TSqlParser::KEY);
            break;
          }

          case TSqlParser::UNIQUE: {
            setState(2570);
            match(TSqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2574);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CLUSTERED || _la == TSqlParser::NONCLUSTERED) {
          setState(2573);
          clustered();
        }
        setState(2577);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx)) {
        case 1: {
          setState(2576);
          index_options();
          break;
        }

        }
        break;
      }

      case TSqlParser::CHECK: {
        setState(2579);
        match(TSqlParser::CHECK);
        setState(2583);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::NOT) {
          setState(2580);
          match(TSqlParser::NOT);
          setState(2581);
          match(TSqlParser::FOR);
          setState(2582);
          match(TSqlParser::REPLICATION);
        }
        setState(2585);
        match(TSqlParser::LR_BRACKET);
        setState(2586);
        search_condition();
        setState(2587);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::FOREIGN:
      case TSqlParser::REFERENCES: {
        setState(2591);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::FOREIGN) {
          setState(2589);
          match(TSqlParser::FOREIGN);
          setState(2590);
          match(TSqlParser::KEY);
        }
        setState(2593);
        match(TSqlParser::REFERENCES);
        setState(2594);
        table_name();
        setState(2595);
        match(TSqlParser::LR_BRACKET);
        setState(2596);
        dynamic_cast<Column_constraintContext *>(_localctx)->pk = column_name_list();
        setState(2597);
        match(TSqlParser::RR_BRACKET);
        setState(2599);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
        case 1: {
          setState(2598);
          on_delete();
          break;
        }

        }
        setState(2602);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ON) {
          setState(2601);
          on_update();
        }
        break;
      }

      case TSqlParser::NOT:
      case TSqlParser::null: {
        setState(2604);
        null_notnull();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

TSqlParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::Column_name_list_with_orderContext* TSqlParser::Table_constraintContext::column_name_list_with_order() {
  return getRuleContext<TSqlParser::Column_name_list_with_orderContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Table_constraintContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Table_constraintContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Table_constraintContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Table_constraintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

std::vector<TSqlParser::Column_name_listContext *> TSqlParser::Table_constraintContext::column_name_list() {
  return getRuleContexts<TSqlParser::Column_name_listContext>();
}

TSqlParser::Column_name_listContext* TSqlParser::Table_constraintContext::column_name_list(size_t i) {
  return getRuleContext<TSqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::PRIMARY() {
  return getToken(TSqlParser::PRIMARY, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::UNIQUE() {
  return getToken(TSqlParser::UNIQUE, 0);
}

TSqlParser::ClusteredContext* TSqlParser::Table_constraintContext::clustered() {
  return getRuleContext<TSqlParser::ClusteredContext>(0);
}

TSqlParser::Index_optionsContext* TSqlParser::Table_constraintContext::index_options() {
  return getRuleContext<TSqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::PLUS() {
  return getTokens(TSqlParser::PLUS);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::PLUS(size_t i) {
  return getToken(TSqlParser::PLUS, i);
}

std::vector<TSqlParser::Function_callContext *> TSqlParser::Table_constraintContext::function_call() {
  return getRuleContexts<TSqlParser::Function_callContext>();
}

TSqlParser::Function_callContext* TSqlParser::Table_constraintContext::function_call(size_t i) {
  return getRuleContext<TSqlParser::Function_callContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

TSqlParser::On_deleteContext* TSqlParser::Table_constraintContext::on_delete() {
  return getRuleContext<TSqlParser::On_deleteContext>(0);
}

TSqlParser::On_updateContext* TSqlParser::Table_constraintContext::on_update() {
  return getRuleContext<TSqlParser::On_updateContext>(0);
}


size_t TSqlParser::Table_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_constraint;
}

void TSqlParser::Table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_constraint(this);
}

void TSqlParser::Table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_constraint(this);
}

TSqlParser::Table_constraintContext* TSqlParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 238, TSqlParser::RuleTable_constraint);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2609);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONSTRAINT) {
      setState(2607);
      match(TSqlParser::CONSTRAINT);
      setState(2608);
      dynamic_cast<Table_constraintContext *>(_localctx)->constraint = id();
    }
    setState(2675);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        setState(2614);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::PRIMARY: {
            setState(2611);
            match(TSqlParser::PRIMARY);
            setState(2612);
            match(TSqlParser::KEY);
            break;
          }

          case TSqlParser::UNIQUE: {
            setState(2613);
            match(TSqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2617);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CLUSTERED || _la == TSqlParser::NONCLUSTERED) {
          setState(2616);
          clustered();
        }
        setState(2619);
        match(TSqlParser::LR_BRACKET);
        setState(2620);
        column_name_list_with_order();
        setState(2621);
        match(TSqlParser::RR_BRACKET);
        setState(2623);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx)) {
        case 1: {
          setState(2622);
          index_options();
          break;
        }

        }
        setState(2627);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ON) {
          setState(2625);
          match(TSqlParser::ON);
          setState(2626);
          id();
        }
        break;
      }

      case TSqlParser::CHECK: {
        setState(2629);
        match(TSqlParser::CHECK);
        setState(2633);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::NOT) {
          setState(2630);
          match(TSqlParser::NOT);
          setState(2631);
          match(TSqlParser::FOR);
          setState(2632);
          match(TSqlParser::REPLICATION);
        }
        setState(2635);
        match(TSqlParser::LR_BRACKET);
        setState(2636);
        search_condition();
        setState(2637);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(2639);
        match(TSqlParser::DEFAULT);
        setState(2641);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::LR_BRACKET) {
          setState(2640);
          match(TSqlParser::LR_BRACKET);
        }
        setState(2647); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2647);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case TSqlParser::STRING: {
              setState(2643);
              match(TSqlParser::STRING);
              break;
            }

            case TSqlParser::PLUS: {
              setState(2644);
              match(TSqlParser::PLUS);
              break;
            }

            case TSqlParser::ABS:
            case TSqlParser::ASCII:
            case TSqlParser::CALLED:
            case TSqlParser::CEILING:
            case TSqlParser::CHARINDEX:
            case TSqlParser::COALESCE:
            case TSqlParser::CONVERT:
            case TSqlParser::CURRENT_TIMESTAMP:
            case TSqlParser::CURRENT_USER:
            case TSqlParser::DATA_COMPRESSION:
            case TSqlParser::EVENTDATA:
            case TSqlParser::FILENAME:
            case TSqlParser::FILLFACTOR:
            case TSqlParser::FLOOR:
            case TSqlParser::FORCESEEK:
            case TSqlParser::IDENTITY:
            case TSqlParser::IIF:
            case TSqlParser::INIT:
            case TSqlParser::ISDATE:
            case TSqlParser::ISNULL:
            case TSqlParser::ISNUMERIC:
            case TSqlParser::KEY:
            case TSqlParser::LEFT:
            case TSqlParser::LEN:
            case TSqlParser::LOWER:
            case TSqlParser::LTRIM:
            case TSqlParser::MASTER:
            case TSqlParser::MAX_MEMORY:
            case TSqlParser::MONTH:
            case TSqlParser::NCHAR:
            case TSqlParser::NULLIF:
            case TSqlParser::OFFSETS:
            case TSqlParser::PAGE:
            case TSqlParser::PATINDEX:
            case TSqlParser::PUBLIC:
            case TSqlParser::R:
            case TSqlParser::RAND:
            case TSqlParser::RAW:
            case TSqlParser::REPLACE:
            case TSqlParser::RETURN:
            case TSqlParser::RETURNS:
            case TSqlParser::RIGHT:
            case TSqlParser::ROUND:
            case TSqlParser::ROWCOUNT:
            case TSqlParser::RTRIM:
            case TSqlParser::SAFETY:
            case TSqlParser::SERVER:
            case TSqlParser::SESSION_USER:
            case TSqlParser::SIGN:
            case TSqlParser::SID:
            case TSqlParser::SOURCE:
            case TSqlParser::SPACE:
            case TSqlParser::SPLIT:
            case TSqlParser::STATE:
            case TSqlParser::START:
            case TSqlParser::STR:
            case TSqlParser::SYSTEM_USER:
            case TSqlParser::TARGET:
            case TSqlParser::UPPER:
            case TSqlParser::USER_NAME:
            case TSqlParser::YEAR:
            case TSqlParser::ABSOLUTE:
            case TSqlParser::ACCENT_SENSITIVITY:
            case TSqlParser::ACTION:
            case TSqlParser::ACTIVATION:
            case TSqlParser::ACTIVE:
            case TSqlParser::ADDRESS:
            case TSqlParser::AES_128:
            case TSqlParser::AES_192:
            case TSqlParser::AES_256:
            case TSqlParser::AFFINITY:
            case TSqlParser::AFTER:
            case TSqlParser::AGGREGATE:
            case TSqlParser::ALGORITHM:
            case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
            case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
            case TSqlParser::ALLOWED:
            case TSqlParser::ANSI_NULL_DEFAULT:
            case TSqlParser::ANSI_NULLS:
            case TSqlParser::ANSI_PADDING:
            case TSqlParser::ANSI_WARNINGS:
            case TSqlParser::APPLICATION_LOG:
            case TSqlParser::APPLY:
            case TSqlParser::ARITHABORT:
            case TSqlParser::ASSEMBLY:
            case TSqlParser::AUDIT:
            case TSqlParser::AUDIT_GUID:
            case TSqlParser::AUTO:
            case TSqlParser::AUTO_CLEANUP:
            case TSqlParser::AUTO_CLOSE:
            case TSqlParser::AUTO_CREATE_STATISTICS:
            case TSqlParser::AUTO_SHRINK:
            case TSqlParser::AUTO_UPDATE_STATISTICS:
            case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
            case TSqlParser::AVAILABILITY:
            case TSqlParser::AVG:
            case TSqlParser::BACKUP_PRIORITY:
            case TSqlParser::BEGIN_DIALOG:
            case TSqlParser::BIGINT:
            case TSqlParser::BINARY_BASE64:
            case TSqlParser::BINARY_CHECKSUM:
            case TSqlParser::BINDING:
            case TSqlParser::BLOB_STORAGE:
            case TSqlParser::BROKER:
            case TSqlParser::BROKER_INSTANCE:
            case TSqlParser::BULK_LOGGED:
            case TSqlParser::CALLER:
            case TSqlParser::CAP_CPU_PERCENT:
            case TSqlParser::CAST:
            case TSqlParser::CATALOG:
            case TSqlParser::CATCH:
            case TSqlParser::CHANGE_RETENTION:
            case TSqlParser::CHANGE_TRACKING:
            case TSqlParser::CHECKSUM:
            case TSqlParser::CHECKSUM_AGG:
            case TSqlParser::CLEANUP:
            case TSqlParser::COLLECTION:
            case TSqlParser::COLUMN_MASTER_KEY:
            case TSqlParser::COMMITTED:
            case TSqlParser::COMPATIBILITY_LEVEL:
            case TSqlParser::CONCAT:
            case TSqlParser::CONCAT_NULL_YIELDS_NULL:
            case TSqlParser::CONTENT:
            case TSqlParser::CONTROL:
            case TSqlParser::COOKIE:
            case TSqlParser::COUNT:
            case TSqlParser::COUNT_BIG:
            case TSqlParser::COUNTER:
            case TSqlParser::CPU:
            case TSqlParser::CREATE_NEW:
            case TSqlParser::CREATION_DISPOSITION:
            case TSqlParser::CREDENTIAL:
            case TSqlParser::CRYPTOGRAPHIC:
            case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
            case TSqlParser::CURSOR_DEFAULT:
            case TSqlParser::DATA:
            case TSqlParser::DATALENGTH:
            case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
            case TSqlParser::DATEADD:
            case TSqlParser::DATEDIFF:
            case TSqlParser::DATENAME:
            case TSqlParser::DATEPART:
            case TSqlParser::DAY:
            case TSqlParser::DAYS:
            case TSqlParser::DB_CHAINING:
            case TSqlParser::DB_FAILOVER:
            case TSqlParser::DECRYPTION:
            case TSqlParser::DEFAULT_DOUBLE_QUOTE:
            case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
            case TSqlParser::DEFAULT_LANGUAGE:
            case TSqlParser::DELAY:
            case TSqlParser::DELAYED_DURABILITY:
            case TSqlParser::DELETED:
            case TSqlParser::DENSE_RANK:
            case TSqlParser::DEPENDENTS:
            case TSqlParser::DES:
            case TSqlParser::DESCRIPTION:
            case TSqlParser::DESX:
            case TSqlParser::DHCP:
            case TSqlParser::DIALOG:
            case TSqlParser::DIRECTORY_NAME:
            case TSqlParser::DISABLE:
            case TSqlParser::DISABLE_BROKER:
            case TSqlParser::DISABLED:
            case TSqlParser::DISK_DRIVE:
            case TSqlParser::DOCUMENT:
            case TSqlParser::DYNAMIC:
            case TSqlParser::EMERGENCY:
            case TSqlParser::EMPTY:
            case TSqlParser::ENABLE:
            case TSqlParser::ENABLE_BROKER:
            case TSqlParser::ENCRYPTED_VALUE:
            case TSqlParser::ENCRYPTION:
            case TSqlParser::ENDPOINT_URL:
            case TSqlParser::ERROR_BROKER_CONVERSATIONS:
            case TSqlParser::EXCLUSIVE:
            case TSqlParser::EXECUTABLE:
            case TSqlParser::EXIST:
            case TSqlParser::EXPAND:
            case TSqlParser::EXPIRY_DATE:
            case TSqlParser::EXPLICIT:
            case TSqlParser::FAIL_OPERATION:
            case TSqlParser::FAILOVER_MODE:
            case TSqlParser::FAILURE:
            case TSqlParser::FAILURE_CONDITION_LEVEL:
            case TSqlParser::FAST:
            case TSqlParser::FAST_FORWARD:
            case TSqlParser::FILEGROUP:
            case TSqlParser::FILEGROWTH:
            case TSqlParser::FILEPATH:
            case TSqlParser::FILESTREAM:
            case TSqlParser::FILTER:
            case TSqlParser::FIRST:
            case TSqlParser::FIRST_VALUE:
            case TSqlParser::FOLLOWING:
            case TSqlParser::FORCE:
            case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
            case TSqlParser::FORCED:
            case TSqlParser::FORMAT:
            case TSqlParser::FORWARD_ONLY:
            case TSqlParser::FULLSCAN:
            case TSqlParser::FULLTEXT:
            case TSqlParser::GB:
            case TSqlParser::GETDATE:
            case TSqlParser::GETUTCDATE:
            case TSqlParser::GLOBAL:
            case TSqlParser::GO:
            case TSqlParser::GROUP_MAX_REQUESTS:
            case TSqlParser::GROUPING:
            case TSqlParser::GROUPING_ID:
            case TSqlParser::HADR:
            case TSqlParser::HASH:
            case TSqlParser::HEALTH_CHECK_TIMEOUT:
            case TSqlParser::HIGH:
            case TSqlParser::HONOR_BROKER_PRIORITY:
            case TSqlParser::HOURS:
            case TSqlParser::IDENTITY_VALUE:
            case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
            case TSqlParser::IMMEDIATE:
            case TSqlParser::IMPERSONATE:
            case TSqlParser::IMPORTANCE:
            case TSqlParser::INCREMENTAL:
            case TSqlParser::INITIATOR:
            case TSqlParser::INPUT:
            case TSqlParser::INSENSITIVE:
            case TSqlParser::INSERTED:
            case TSqlParser::INT:
            case TSqlParser::IP:
            case TSqlParser::ISOLATION:
            case TSqlParser::KB:
            case TSqlParser::KEEP:
            case TSqlParser::KEEPFIXED:
            case TSqlParser::KEY_SOURCE:
            case TSqlParser::KEYS:
            case TSqlParser::KEYSET:
            case TSqlParser::LAG:
            case TSqlParser::LAST:
            case TSqlParser::LAST_VALUE:
            case TSqlParser::LEAD:
            case TSqlParser::LEVEL:
            case TSqlParser::LIST:
            case TSqlParser::LISTENER:
            case TSqlParser::LISTENER_URL:
            case TSqlParser::LOB_COMPACTION:
            case TSqlParser::LOCAL:
            case TSqlParser::LOCATION:
            case TSqlParser::LOCK:
            case TSqlParser::LOCK_ESCALATION:
            case TSqlParser::LOGIN:
            case TSqlParser::LOOP:
            case TSqlParser::LOW:
            case TSqlParser::MANUAL:
            case TSqlParser::MARK:
            case TSqlParser::MATERIALIZED:
            case TSqlParser::MAX:
            case TSqlParser::MAX_CPU_PERCENT:
            case TSqlParser::MAX_DOP:
            case TSqlParser::MAX_FILES:
            case TSqlParser::MAX_IOPS_PER_VOLUME:
            case TSqlParser::MAX_MEMORY_PERCENT:
            case TSqlParser::MAX_PROCESSES:
            case TSqlParser::MAX_QUEUE_READERS:
            case TSqlParser::MAX_ROLLOVER_FILES:
            case TSqlParser::MAXDOP:
            case TSqlParser::MAXRECURSION:
            case TSqlParser::MAXSIZE:
            case TSqlParser::MB:
            case TSqlParser::MEDIUM:
            case TSqlParser::MEMORY_OPTIMIZED_DATA:
            case TSqlParser::MESSAGE:
            case TSqlParser::MIN:
            case TSqlParser::MIN_ACTIVE_ROWVERSION:
            case TSqlParser::MIN_CPU_PERCENT:
            case TSqlParser::MIN_IOPS_PER_VOLUME:
            case TSqlParser::MIN_MEMORY_PERCENT:
            case TSqlParser::MINUTES:
            case TSqlParser::MIRROR_ADDRESS:
            case TSqlParser::MIXED_PAGE_ALLOCATION:
            case TSqlParser::MODE:
            case TSqlParser::MODIFY:
            case TSqlParser::MOVE:
            case TSqlParser::MULTI_USER:
            case TSqlParser::NAME:
            case TSqlParser::NESTED_TRIGGERS:
            case TSqlParser::NEW_ACCOUNT:
            case TSqlParser::NEW_BROKER:
            case TSqlParser::NEW_PASSWORD:
            case TSqlParser::NEXT:
            case TSqlParser::NO:
            case TSqlParser::NO_TRUNCATE:
            case TSqlParser::NO_WAIT:
            case TSqlParser::NOCOUNT:
            case TSqlParser::NODES:
            case TSqlParser::NOEXPAND:
            case TSqlParser::NON_TRANSACTED_ACCESS:
            case TSqlParser::NORECOMPUTE:
            case TSqlParser::NORECOVERY:
            case TSqlParser::NOWAIT:
            case TSqlParser::NTILE:
            case TSqlParser::NUMANODE:
            case TSqlParser::NUMBER:
            case TSqlParser::NUMERIC_ROUNDABORT:
            case TSqlParser::OBJECT:
            case TSqlParser::OFFLINE:
            case TSqlParser::OFFSET:
            case TSqlParser::OLD_ACCOUNT:
            case TSqlParser::ONLINE:
            case TSqlParser::ONLY:
            case TSqlParser::OPEN_EXISTING:
            case TSqlParser::OPTIMISTIC:
            case TSqlParser::OPTIMIZE:
            case TSqlParser::OUT:
            case TSqlParser::OUTPUT:
            case TSqlParser::OWNER:
            case TSqlParser::PAGE_VERIFY:
            case TSqlParser::PARAMETERIZATION:
            case TSqlParser::PARTITION:
            case TSqlParser::PARTITIONS:
            case TSqlParser::PARTNER:
            case TSqlParser::PATH:
            case TSqlParser::POISON_MESSAGE_HANDLING:
            case TSqlParser::POOL:
            case TSqlParser::PORT:
            case TSqlParser::PRECEDING:
            case TSqlParser::PRIMARY_ROLE:
            case TSqlParser::PRIOR:
            case TSqlParser::PRIORITY:
            case TSqlParser::PRIORITY_LEVEL:
            case TSqlParser::PRIVATE:
            case TSqlParser::PRIVATE_KEY:
            case TSqlParser::PRIVILEGES:
            case TSqlParser::PROCEDURE_NAME:
            case TSqlParser::PROPERTY:
            case TSqlParser::PROVIDER:
            case TSqlParser::PROVIDER_KEY_NAME:
            case TSqlParser::QUERY:
            case TSqlParser::QUEUE:
            case TSqlParser::QUEUE_DELAY:
            case TSqlParser::QUOTED_IDENTIFIER:
            case TSqlParser::RANGE:
            case TSqlParser::RANK:
            case TSqlParser::RC2:
            case TSqlParser::RC4:
            case TSqlParser::RC4_128:
            case TSqlParser::READ_COMMITTED_SNAPSHOT:
            case TSqlParser::READ_ONLY:
            case TSqlParser::READ_ONLY_ROUTING_LIST:
            case TSqlParser::READ_WRITE:
            case TSqlParser::READONLY:
            case TSqlParser::REBUILD:
            case TSqlParser::RECEIVE:
            case TSqlParser::RECOMPILE:
            case TSqlParser::RECOVERY:
            case TSqlParser::RECURSIVE_TRIGGERS:
            case TSqlParser::RELATIVE:
            case TSqlParser::REMOTE:
            case TSqlParser::REMOTE_SERVICE_NAME:
            case TSqlParser::REMOVE:
            case TSqlParser::REORGANIZE:
            case TSqlParser::REPEATABLE:
            case TSqlParser::REPLICA:
            case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
            case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
            case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
            case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
            case TSqlParser::RESERVE_DISK_SPACE:
            case TSqlParser::RESOURCE:
            case TSqlParser::RESOURCE_MANAGER_LOCATION:
            case TSqlParser::RESTRICTED_USER:
            case TSqlParser::RETENTION:
            case TSqlParser::ROBUST:
            case TSqlParser::ROOT:
            case TSqlParser::ROUTE:
            case TSqlParser::ROW:
            case TSqlParser::ROW_NUMBER:
            case TSqlParser::ROWGUID:
            case TSqlParser::ROWS:
            case TSqlParser::SAMPLE:
            case TSqlParser::SCHEMABINDING:
            case TSqlParser::SCOPED:
            case TSqlParser::SCROLL:
            case TSqlParser::SCROLL_LOCKS:
            case TSqlParser::SEARCH:
            case TSqlParser::SECONDARY:
            case TSqlParser::SECONDARY_ONLY:
            case TSqlParser::SECONDARY_ROLE:
            case TSqlParser::SECONDS:
            case TSqlParser::SECRET:
            case TSqlParser::SECURITY:
            case TSqlParser::SECURITY_LOG:
            case TSqlParser::SEEDING_MODE:
            case TSqlParser::SELF:
            case TSqlParser::SEMI_SENSITIVE:
            case TSqlParser::SEND:
            case TSqlParser::SENT:
            case TSqlParser::SEQUENCE:
            case TSqlParser::SERIALIZABLE:
            case TSqlParser::SESSION_TIMEOUT:
            case TSqlParser::SETERROR:
            case TSqlParser::SHARE:
            case TSqlParser::SHOWPLAN:
            case TSqlParser::SIGNATURE:
            case TSqlParser::SIMPLE:
            case TSqlParser::SINGLE_USER:
            case TSqlParser::SIZE:
            case TSqlParser::SMALLINT:
            case TSqlParser::SNAPSHOT:
            case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
            case TSqlParser::STANDBY:
            case TSqlParser::START_DATE:
            case TSqlParser::STATIC:
            case TSqlParser::STATS_STREAM:
            case TSqlParser::STATUS:
            case TSqlParser::STDEV:
            case TSqlParser::STDEVP:
            case TSqlParser::STOPLIST:
            case TSqlParser::STRING_AGG:
            case TSqlParser::STUFF:
            case TSqlParser::SUBJECT:
            case TSqlParser::SUBSTRING:
            case TSqlParser::SUM:
            case TSqlParser::SUSPEND:
            case TSqlParser::SYMMETRIC:
            case TSqlParser::SYNCHRONOUS_COMMIT:
            case TSqlParser::SYNONYM:
            case TSqlParser::SYSTEM:
            case TSqlParser::TAKE:
            case TSqlParser::TARGET_RECOVERY_TIME:
            case TSqlParser::TB:
            case TSqlParser::TEXTIMAGE_ON:
            case TSqlParser::THROW:
            case TSqlParser::TIES:
            case TSqlParser::TIME:
            case TSqlParser::TIMEOUT:
            case TSqlParser::TIMER:
            case TSqlParser::TINYINT:
            case TSqlParser::TORN_PAGE_DETECTION:
            case TSqlParser::TRANSFORM_NOISE_WORDS:
            case TSqlParser::TRIPLE_DES:
            case TSqlParser::TRIPLE_DES_3KEY:
            case TSqlParser::TRUSTWORTHY:
            case TSqlParser::TRY:
            case TSqlParser::TSQL:
            case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
            case TSqlParser::TYPE:
            case TSqlParser::TYPE_WARNING:
            case TSqlParser::UNBOUNDED:
            case TSqlParser::UNCOMMITTED:
            case TSqlParser::UNKNOWN:
            case TSqlParser::UNLIMITED:
            case TSqlParser::USING:
            case TSqlParser::VALID_XML:
            case TSqlParser::VALIDATION:
            case TSqlParser::VALUE:
            case TSqlParser::VAR:
            case TSqlParser::VARP:
            case TSqlParser::VIEW_METADATA:
            case TSqlParser::VIEWS:
            case TSqlParser::WAIT:
            case TSqlParser::WELL_FORMED_XML:
            case TSqlParser::WORK:
            case TSqlParser::WORKLOAD:
            case TSqlParser::XML:
            case TSqlParser::XMLNAMESPACES:
            case TSqlParser::DOUBLE_QUOTE_ID:
            case TSqlParser::SQUARE_BRACKET_ID:
            case TSqlParser::LOCAL_ID:
            case TSqlParser::ID: {
              setState(2645);
              function_call();
              break;
            }

            case TSqlParser::DECIMAL: {
              setState(2646);
              match(TSqlParser::DECIMAL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(2649); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << TSqlParser::ABS)
          | (1ULL << TSqlParser::ASCII)
          | (1ULL << TSqlParser::CALLED)
          | (1ULL << TSqlParser::CEILING)
          | (1ULL << TSqlParser::CHARINDEX)
          | (1ULL << TSqlParser::COALESCE))) != 0) || ((((_la - 74) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 74)) & ((1ULL << (TSqlParser::CONVERT - 74))
          | (1ULL << (TSqlParser::CURRENT_TIMESTAMP - 74))
          | (1ULL << (TSqlParser::CURRENT_USER - 74))
          | (1ULL << (TSqlParser::DATA_COMPRESSION - 74))
          | (1ULL << (TSqlParser::EVENTDATA - 74))
          | (1ULL << (TSqlParser::FILENAME - 74))
          | (1ULL << (TSqlParser::FILLFACTOR - 74))
          | (1ULL << (TSqlParser::FLOOR - 74)))) != 0) || ((((_la - 138) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 138)) & ((1ULL << (TSqlParser::FORCESEEK - 138))
          | (1ULL << (TSqlParser::IDENTITY - 138))
          | (1ULL << (TSqlParser::IIF - 138))
          | (1ULL << (TSqlParser::INIT - 138))
          | (1ULL << (TSqlParser::ISDATE - 138))
          | (1ULL << (TSqlParser::ISNULL - 138))
          | (1ULL << (TSqlParser::ISNUMERIC - 138))
          | (1ULL << (TSqlParser::KEY - 138))
          | (1ULL << (TSqlParser::LEFT - 138))
          | (1ULL << (TSqlParser::LEN - 138))
          | (1ULL << (TSqlParser::LOWER - 138))
          | (1ULL << (TSqlParser::LTRIM - 138))
          | (1ULL << (TSqlParser::MASTER - 138))
          | (1ULL << (TSqlParser::MAX_MEMORY - 138)))) != 0) || ((((_la - 215) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 215)) & ((1ULL << (TSqlParser::MONTH - 215))
          | (1ULL << (TSqlParser::NCHAR - 215))
          | (1ULL << (TSqlParser::NULLIF - 215))
          | (1ULL << (TSqlParser::OFFSETS - 215))
          | (1ULL << (TSqlParser::PAGE - 215))
          | (1ULL << (TSqlParser::PATINDEX - 215))
          | (1ULL << (TSqlParser::PUBLIC - 215))
          | (1ULL << (TSqlParser::R - 215))
          | (1ULL << (TSqlParser::RAND - 215))
          | (1ULL << (TSqlParser::RAW - 215)))) != 0) || ((((_la - 287) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 287)) & ((1ULL << (TSqlParser::REPLACE - 287))
          | (1ULL << (TSqlParser::RETURN - 287))
          | (1ULL << (TSqlParser::RETURNS - 287))
          | (1ULL << (TSqlParser::RIGHT - 287))
          | (1ULL << (TSqlParser::ROUND - 287))
          | (1ULL << (TSqlParser::ROWCOUNT - 287))
          | (1ULL << (TSqlParser::RTRIM - 287))
          | (1ULL << (TSqlParser::SAFETY - 287))
          | (1ULL << (TSqlParser::SERVER - 287))
          | (1ULL << (TSqlParser::SESSION_USER - 287))
          | (1ULL << (TSqlParser::SIGN - 287))
          | (1ULL << (TSqlParser::SID - 287))
          | (1ULL << (TSqlParser::SOURCE - 287))
          | (1ULL << (TSqlParser::SPACE - 287))
          | (1ULL << (TSqlParser::SPLIT - 287))
          | (1ULL << (TSqlParser::STATE - 287))
          | (1ULL << (TSqlParser::START - 287)))) != 0) || ((((_la - 356) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 356)) & ((1ULL << (TSqlParser::STR - 356))
          | (1ULL << (TSqlParser::SYSTEM_USER - 356))
          | (1ULL << (TSqlParser::TARGET - 356))
          | (1ULL << (TSqlParser::UPPER - 356))
          | (1ULL << (TSqlParser::USER_NAME - 356))
          | (1ULL << (TSqlParser::YEAR - 356))
          | (1ULL << (TSqlParser::ABSOLUTE - 356))
          | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 356))
          | (1ULL << (TSqlParser::ACTION - 356))
          | (1ULL << (TSqlParser::ACTIVATION - 356))
          | (1ULL << (TSqlParser::ACTIVE - 356))
          | (1ULL << (TSqlParser::ADDRESS - 356))
          | (1ULL << (TSqlParser::AES_128 - 356))
          | (1ULL << (TSqlParser::AES_192 - 356))
          | (1ULL << (TSqlParser::AES_256 - 356))
          | (1ULL << (TSqlParser::AFFINITY - 356))
          | (1ULL << (TSqlParser::AFTER - 356))
          | (1ULL << (TSqlParser::AGGREGATE - 356))
          | (1ULL << (TSqlParser::ALGORITHM - 356))
          | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 356))
          | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 356)))) != 0) || ((((_la - 420) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 420)) & ((1ULL << (TSqlParser::ALLOWED - 420))
          | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 420))
          | (1ULL << (TSqlParser::ANSI_NULLS - 420))
          | (1ULL << (TSqlParser::ANSI_PADDING - 420))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 420))
          | (1ULL << (TSqlParser::APPLICATION_LOG - 420))
          | (1ULL << (TSqlParser::APPLY - 420))
          | (1ULL << (TSqlParser::ARITHABORT - 420))
          | (1ULL << (TSqlParser::ASSEMBLY - 420))
          | (1ULL << (TSqlParser::AUDIT - 420))
          | (1ULL << (TSqlParser::AUDIT_GUID - 420))
          | (1ULL << (TSqlParser::AUTO - 420))
          | (1ULL << (TSqlParser::AUTO_CLEANUP - 420))
          | (1ULL << (TSqlParser::AUTO_CLOSE - 420))
          | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 420))
          | (1ULL << (TSqlParser::AUTO_SHRINK - 420))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 420))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 420))
          | (1ULL << (TSqlParser::AVAILABILITY - 420))
          | (1ULL << (TSqlParser::AVG - 420))
          | (1ULL << (TSqlParser::BACKUP_PRIORITY - 420))
          | (1ULL << (TSqlParser::BEGIN_DIALOG - 420))
          | (1ULL << (TSqlParser::BIGINT - 420))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 420))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 420))
          | (1ULL << (TSqlParser::BINDING - 420))
          | (1ULL << (TSqlParser::BLOB_STORAGE - 420))
          | (1ULL << (TSqlParser::BROKER - 420))
          | (1ULL << (TSqlParser::BROKER_INSTANCE - 420))
          | (1ULL << (TSqlParser::BULK_LOGGED - 420))
          | (1ULL << (TSqlParser::CALLER - 420))
          | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 420))
          | (1ULL << (TSqlParser::CAST - 420))
          | (1ULL << (TSqlParser::CATALOG - 420))
          | (1ULL << (TSqlParser::CATCH - 420))
          | (1ULL << (TSqlParser::CHANGE_RETENTION - 420))
          | (1ULL << (TSqlParser::CHANGE_TRACKING - 420))
          | (1ULL << (TSqlParser::CHECKSUM - 420))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 420))
          | (1ULL << (TSqlParser::CLEANUP - 420))
          | (1ULL << (TSqlParser::COLLECTION - 420))
          | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 420))
          | (1ULL << (TSqlParser::COMMITTED - 420))
          | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 420))
          | (1ULL << (TSqlParser::CONCAT - 420))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 420))
          | (1ULL << (TSqlParser::CONTENT - 420))
          | (1ULL << (TSqlParser::CONTROL - 420))
          | (1ULL << (TSqlParser::COOKIE - 420))
          | (1ULL << (TSqlParser::COUNT - 420))
          | (1ULL << (TSqlParser::COUNT_BIG - 420))
          | (1ULL << (TSqlParser::COUNTER - 420))
          | (1ULL << (TSqlParser::CPU - 420))
          | (1ULL << (TSqlParser::CREATE_NEW - 420))
          | (1ULL << (TSqlParser::CREATION_DISPOSITION - 420))
          | (1ULL << (TSqlParser::CREDENTIAL - 420))
          | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 420))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 420))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 420))
          | (1ULL << (TSqlParser::DATA - 420))
          | (1ULL << (TSqlParser::DATALENGTH - 420))
          | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 420))
          | (1ULL << (TSqlParser::DATEADD - 420))
          | (1ULL << (TSqlParser::DATEDIFF - 420)))) != 0) || ((((_la - 484) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 484)) & ((1ULL << (TSqlParser::DATENAME - 484))
          | (1ULL << (TSqlParser::DATEPART - 484))
          | (1ULL << (TSqlParser::DAY - 484))
          | (1ULL << (TSqlParser::DAYS - 484))
          | (1ULL << (TSqlParser::DB_CHAINING - 484))
          | (1ULL << (TSqlParser::DB_FAILOVER - 484))
          | (1ULL << (TSqlParser::DECRYPTION - 484))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 484))
          | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 484))
          | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 484))
          | (1ULL << (TSqlParser::DELAY - 484))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 484))
          | (1ULL << (TSqlParser::DELETED - 484))
          | (1ULL << (TSqlParser::DENSE_RANK - 484))
          | (1ULL << (TSqlParser::DEPENDENTS - 484))
          | (1ULL << (TSqlParser::DES - 484))
          | (1ULL << (TSqlParser::DESCRIPTION - 484))
          | (1ULL << (TSqlParser::DESX - 484))
          | (1ULL << (TSqlParser::DHCP - 484))
          | (1ULL << (TSqlParser::DIALOG - 484))
          | (1ULL << (TSqlParser::DIRECTORY_NAME - 484))
          | (1ULL << (TSqlParser::DISABLE - 484))
          | (1ULL << (TSqlParser::DISABLE_BROKER - 484))
          | (1ULL << (TSqlParser::DISABLED - 484))
          | (1ULL << (TSqlParser::DISK_DRIVE - 484))
          | (1ULL << (TSqlParser::DOCUMENT - 484))
          | (1ULL << (TSqlParser::DYNAMIC - 484))
          | (1ULL << (TSqlParser::EMERGENCY - 484))
          | (1ULL << (TSqlParser::EMPTY - 484))
          | (1ULL << (TSqlParser::ENABLE - 484))
          | (1ULL << (TSqlParser::ENABLE_BROKER - 484))
          | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 484))
          | (1ULL << (TSqlParser::ENCRYPTION - 484))
          | (1ULL << (TSqlParser::ENDPOINT_URL - 484))
          | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 484))
          | (1ULL << (TSqlParser::EXCLUSIVE - 484))
          | (1ULL << (TSqlParser::EXECUTABLE - 484))
          | (1ULL << (TSqlParser::EXIST - 484))
          | (1ULL << (TSqlParser::EXPAND - 484))
          | (1ULL << (TSqlParser::EXPIRY_DATE - 484))
          | (1ULL << (TSqlParser::EXPLICIT - 484))
          | (1ULL << (TSqlParser::FAIL_OPERATION - 484))
          | (1ULL << (TSqlParser::FAILOVER_MODE - 484))
          | (1ULL << (TSqlParser::FAILURE - 484))
          | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 484))
          | (1ULL << (TSqlParser::FAST - 484))
          | (1ULL << (TSqlParser::FAST_FORWARD - 484))
          | (1ULL << (TSqlParser::FILEGROUP - 484))
          | (1ULL << (TSqlParser::FILEGROWTH - 484))
          | (1ULL << (TSqlParser::FILEPATH - 484))
          | (1ULL << (TSqlParser::FILESTREAM - 484))
          | (1ULL << (TSqlParser::FILTER - 484))
          | (1ULL << (TSqlParser::FIRST - 484))
          | (1ULL << (TSqlParser::FIRST_VALUE - 484))
          | (1ULL << (TSqlParser::FOLLOWING - 484))
          | (1ULL << (TSqlParser::FORCE - 484))
          | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 484))
          | (1ULL << (TSqlParser::FORCED - 484))
          | (1ULL << (TSqlParser::FORMAT - 484))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 484))
          | (1ULL << (TSqlParser::FULLSCAN - 484))
          | (1ULL << (TSqlParser::FULLTEXT - 484))
          | (1ULL << (TSqlParser::GB - 484)))) != 0) || ((((_la - 548) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 548)) & ((1ULL << (TSqlParser::GETDATE - 548))
          | (1ULL << (TSqlParser::GETUTCDATE - 548))
          | (1ULL << (TSqlParser::GLOBAL - 548))
          | (1ULL << (TSqlParser::GO - 548))
          | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 548))
          | (1ULL << (TSqlParser::GROUPING - 548))
          | (1ULL << (TSqlParser::GROUPING_ID - 548))
          | (1ULL << (TSqlParser::HADR - 548))
          | (1ULL << (TSqlParser::HASH - 548))
          | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 548))
          | (1ULL << (TSqlParser::HIGH - 548))
          | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 548))
          | (1ULL << (TSqlParser::HOURS - 548))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 548))
          | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 548))
          | (1ULL << (TSqlParser::IMMEDIATE - 548))
          | (1ULL << (TSqlParser::IMPERSONATE - 548))
          | (1ULL << (TSqlParser::IMPORTANCE - 548))
          | (1ULL << (TSqlParser::INCREMENTAL - 548))
          | (1ULL << (TSqlParser::INITIATOR - 548))
          | (1ULL << (TSqlParser::INPUT - 548))
          | (1ULL << (TSqlParser::INSENSITIVE - 548))
          | (1ULL << (TSqlParser::INSERTED - 548))
          | (1ULL << (TSqlParser::INT - 548))
          | (1ULL << (TSqlParser::IP - 548))
          | (1ULL << (TSqlParser::ISOLATION - 548))
          | (1ULL << (TSqlParser::KB - 548))
          | (1ULL << (TSqlParser::KEEP - 548))
          | (1ULL << (TSqlParser::KEEPFIXED - 548))
          | (1ULL << (TSqlParser::KEY_SOURCE - 548))
          | (1ULL << (TSqlParser::KEYS - 548))
          | (1ULL << (TSqlParser::KEYSET - 548))
          | (1ULL << (TSqlParser::LAG - 548))
          | (1ULL << (TSqlParser::LAST - 548))
          | (1ULL << (TSqlParser::LAST_VALUE - 548))
          | (1ULL << (TSqlParser::LEAD - 548))
          | (1ULL << (TSqlParser::LEVEL - 548))
          | (1ULL << (TSqlParser::LIST - 548))
          | (1ULL << (TSqlParser::LISTENER - 548))
          | (1ULL << (TSqlParser::LISTENER_URL - 548))
          | (1ULL << (TSqlParser::LOB_COMPACTION - 548))
          | (1ULL << (TSqlParser::LOCAL - 548))
          | (1ULL << (TSqlParser::LOCATION - 548))
          | (1ULL << (TSqlParser::LOCK - 548))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 548))
          | (1ULL << (TSqlParser::LOGIN - 548))
          | (1ULL << (TSqlParser::LOOP - 548))
          | (1ULL << (TSqlParser::LOW - 548))
          | (1ULL << (TSqlParser::MANUAL - 548))
          | (1ULL << (TSqlParser::MARK - 548))
          | (1ULL << (TSqlParser::MATERIALIZED - 548))
          | (1ULL << (TSqlParser::MAX - 548))
          | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 548))
          | (1ULL << (TSqlParser::MAX_DOP - 548))
          | (1ULL << (TSqlParser::MAX_FILES - 548))
          | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 548))
          | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 548))
          | (1ULL << (TSqlParser::MAX_PROCESSES - 548))
          | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 548))
          | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 548))
          | (1ULL << (TSqlParser::MAXDOP - 548)))) != 0) || ((((_la - 612) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 612)) & ((1ULL << (TSqlParser::MAXRECURSION - 612))
          | (1ULL << (TSqlParser::MAXSIZE - 612))
          | (1ULL << (TSqlParser::MB - 612))
          | (1ULL << (TSqlParser::MEDIUM - 612))
          | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 612))
          | (1ULL << (TSqlParser::MESSAGE - 612))
          | (1ULL << (TSqlParser::MIN - 612))
          | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 612))
          | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 612))
          | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 612))
          | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 612))
          | (1ULL << (TSqlParser::MINUTES - 612))
          | (1ULL << (TSqlParser::MIRROR_ADDRESS - 612))
          | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 612))
          | (1ULL << (TSqlParser::MODE - 612))
          | (1ULL << (TSqlParser::MODIFY - 612))
          | (1ULL << (TSqlParser::MOVE - 612))
          | (1ULL << (TSqlParser::MULTI_USER - 612))
          | (1ULL << (TSqlParser::NAME - 612))
          | (1ULL << (TSqlParser::NESTED_TRIGGERS - 612))
          | (1ULL << (TSqlParser::NEW_ACCOUNT - 612))
          | (1ULL << (TSqlParser::NEW_BROKER - 612))
          | (1ULL << (TSqlParser::NEW_PASSWORD - 612))
          | (1ULL << (TSqlParser::NEXT - 612))
          | (1ULL << (TSqlParser::NO - 612))
          | (1ULL << (TSqlParser::NO_TRUNCATE - 612))
          | (1ULL << (TSqlParser::NO_WAIT - 612))
          | (1ULL << (TSqlParser::NOCOUNT - 612))
          | (1ULL << (TSqlParser::NODES - 612))
          | (1ULL << (TSqlParser::NOEXPAND - 612))
          | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 612))
          | (1ULL << (TSqlParser::NORECOMPUTE - 612))
          | (1ULL << (TSqlParser::NORECOVERY - 612))
          | (1ULL << (TSqlParser::NOWAIT - 612))
          | (1ULL << (TSqlParser::NTILE - 612))
          | (1ULL << (TSqlParser::NUMANODE - 612))
          | (1ULL << (TSqlParser::NUMBER - 612))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 612))
          | (1ULL << (TSqlParser::OBJECT - 612))
          | (1ULL << (TSqlParser::OFFLINE - 612))
          | (1ULL << (TSqlParser::OFFSET - 612))
          | (1ULL << (TSqlParser::OLD_ACCOUNT - 612))
          | (1ULL << (TSqlParser::ONLINE - 612))
          | (1ULL << (TSqlParser::ONLY - 612))
          | (1ULL << (TSqlParser::OPEN_EXISTING - 612))
          | (1ULL << (TSqlParser::OPTIMISTIC - 612))
          | (1ULL << (TSqlParser::OPTIMIZE - 612))
          | (1ULL << (TSqlParser::OUT - 612))
          | (1ULL << (TSqlParser::OUTPUT - 612))
          | (1ULL << (TSqlParser::OWNER - 612))
          | (1ULL << (TSqlParser::PAGE_VERIFY - 612))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 612))
          | (1ULL << (TSqlParser::PARTITION - 612))
          | (1ULL << (TSqlParser::PARTITIONS - 612))
          | (1ULL << (TSqlParser::PARTNER - 612))
          | (1ULL << (TSqlParser::PATH - 612))
          | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 612))
          | (1ULL << (TSqlParser::POOL - 612))
          | (1ULL << (TSqlParser::PORT - 612))
          | (1ULL << (TSqlParser::PRECEDING - 612))
          | (1ULL << (TSqlParser::PRIMARY_ROLE - 612))
          | (1ULL << (TSqlParser::PRIOR - 612))
          | (1ULL << (TSqlParser::PRIORITY - 612)))) != 0) || ((((_la - 676) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 676)) & ((1ULL << (TSqlParser::PRIORITY_LEVEL - 676))
          | (1ULL << (TSqlParser::PRIVATE - 676))
          | (1ULL << (TSqlParser::PRIVATE_KEY - 676))
          | (1ULL << (TSqlParser::PRIVILEGES - 676))
          | (1ULL << (TSqlParser::PROCEDURE_NAME - 676))
          | (1ULL << (TSqlParser::PROPERTY - 676))
          | (1ULL << (TSqlParser::PROVIDER - 676))
          | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 676))
          | (1ULL << (TSqlParser::QUERY - 676))
          | (1ULL << (TSqlParser::QUEUE - 676))
          | (1ULL << (TSqlParser::QUEUE_DELAY - 676))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 676))
          | (1ULL << (TSqlParser::RANGE - 676))
          | (1ULL << (TSqlParser::RANK - 676))
          | (1ULL << (TSqlParser::RC2 - 676))
          | (1ULL << (TSqlParser::RC4 - 676))
          | (1ULL << (TSqlParser::RC4_128 - 676))
          | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 676))
          | (1ULL << (TSqlParser::READ_ONLY - 676))
          | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 676))
          | (1ULL << (TSqlParser::READ_WRITE - 676))
          | (1ULL << (TSqlParser::READONLY - 676))
          | (1ULL << (TSqlParser::REBUILD - 676))
          | (1ULL << (TSqlParser::RECEIVE - 676))
          | (1ULL << (TSqlParser::RECOMPILE - 676))
          | (1ULL << (TSqlParser::RECOVERY - 676))
          | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 676))
          | (1ULL << (TSqlParser::RELATIVE - 676))
          | (1ULL << (TSqlParser::REMOTE - 676))
          | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 676))
          | (1ULL << (TSqlParser::REMOVE - 676))
          | (1ULL << (TSqlParser::REORGANIZE - 676))
          | (1ULL << (TSqlParser::REPEATABLE - 676))
          | (1ULL << (TSqlParser::REPLICA - 676))
          | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 676))
          | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 676))
          | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 676))
          | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 676))
          | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 676))
          | (1ULL << (TSqlParser::RESOURCE - 676))
          | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 676))
          | (1ULL << (TSqlParser::RESTRICTED_USER - 676))
          | (1ULL << (TSqlParser::RETENTION - 676))
          | (1ULL << (TSqlParser::ROBUST - 676))
          | (1ULL << (TSqlParser::ROOT - 676))
          | (1ULL << (TSqlParser::ROUTE - 676))
          | (1ULL << (TSqlParser::ROW - 676))
          | (1ULL << (TSqlParser::ROW_NUMBER - 676))
          | (1ULL << (TSqlParser::ROWGUID - 676))
          | (1ULL << (TSqlParser::ROWS - 676))
          | (1ULL << (TSqlParser::SAMPLE - 676))
          | (1ULL << (TSqlParser::SCHEMABINDING - 676))
          | (1ULL << (TSqlParser::SCOPED - 676))
          | (1ULL << (TSqlParser::SCROLL - 676))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 676))
          | (1ULL << (TSqlParser::SEARCH - 676))
          | (1ULL << (TSqlParser::SECONDARY - 676))
          | (1ULL << (TSqlParser::SECONDARY_ONLY - 676))
          | (1ULL << (TSqlParser::SECONDARY_ROLE - 676))
          | (1ULL << (TSqlParser::SECONDS - 676))
          | (1ULL << (TSqlParser::SECRET - 676))
          | (1ULL << (TSqlParser::SECURITY - 676))
          | (1ULL << (TSqlParser::SECURITY_LOG - 676))
          | (1ULL << (TSqlParser::SEEDING_MODE - 676)))) != 0) || ((((_la - 740) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 740)) & ((1ULL << (TSqlParser::SELF - 740))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 740))
          | (1ULL << (TSqlParser::SEND - 740))
          | (1ULL << (TSqlParser::SENT - 740))
          | (1ULL << (TSqlParser::SEQUENCE - 740))
          | (1ULL << (TSqlParser::SERIALIZABLE - 740))
          | (1ULL << (TSqlParser::SESSION_TIMEOUT - 740))
          | (1ULL << (TSqlParser::SETERROR - 740))
          | (1ULL << (TSqlParser::SHARE - 740))
          | (1ULL << (TSqlParser::SHOWPLAN - 740))
          | (1ULL << (TSqlParser::SIGNATURE - 740))
          | (1ULL << (TSqlParser::SIMPLE - 740))
          | (1ULL << (TSqlParser::SINGLE_USER - 740))
          | (1ULL << (TSqlParser::SIZE - 740))
          | (1ULL << (TSqlParser::SMALLINT - 740))
          | (1ULL << (TSqlParser::SNAPSHOT - 740))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 740))
          | (1ULL << (TSqlParser::STANDBY - 740))
          | (1ULL << (TSqlParser::START_DATE - 740))
          | (1ULL << (TSqlParser::STATIC - 740))
          | (1ULL << (TSqlParser::STATS_STREAM - 740))
          | (1ULL << (TSqlParser::STATUS - 740))
          | (1ULL << (TSqlParser::STDEV - 740))
          | (1ULL << (TSqlParser::STDEVP - 740))
          | (1ULL << (TSqlParser::STOPLIST - 740))
          | (1ULL << (TSqlParser::STRING_AGG - 740))
          | (1ULL << (TSqlParser::STUFF - 740))
          | (1ULL << (TSqlParser::SUBJECT - 740))
          | (1ULL << (TSqlParser::SUBSTRING - 740))
          | (1ULL << (TSqlParser::SUM - 740))
          | (1ULL << (TSqlParser::SUSPEND - 740))
          | (1ULL << (TSqlParser::SYMMETRIC - 740))
          | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 740))
          | (1ULL << (TSqlParser::SYNONYM - 740))
          | (1ULL << (TSqlParser::SYSTEM - 740))
          | (1ULL << (TSqlParser::TAKE - 740))
          | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 740))
          | (1ULL << (TSqlParser::TB - 740))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 740))
          | (1ULL << (TSqlParser::THROW - 740))
          | (1ULL << (TSqlParser::TIES - 740))
          | (1ULL << (TSqlParser::TIME - 740))
          | (1ULL << (TSqlParser::TIMEOUT - 740))
          | (1ULL << (TSqlParser::TIMER - 740))
          | (1ULL << (TSqlParser::TINYINT - 740))
          | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 740))
          | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 740))
          | (1ULL << (TSqlParser::TRIPLE_DES - 740))
          | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 740))
          | (1ULL << (TSqlParser::TRUSTWORTHY - 740))
          | (1ULL << (TSqlParser::TRY - 740))
          | (1ULL << (TSqlParser::TSQL - 740))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 740))
          | (1ULL << (TSqlParser::TYPE - 740))
          | (1ULL << (TSqlParser::TYPE_WARNING - 740))
          | (1ULL << (TSqlParser::UNBOUNDED - 740))
          | (1ULL << (TSqlParser::UNCOMMITTED - 740))
          | (1ULL << (TSqlParser::UNKNOWN - 740))
          | (1ULL << (TSqlParser::UNLIMITED - 740))
          | (1ULL << (TSqlParser::USING - 740))
          | (1ULL << (TSqlParser::VALID_XML - 740)))) != 0) || ((((_la - 804) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 804)) & ((1ULL << (TSqlParser::VALIDATION - 804))
          | (1ULL << (TSqlParser::VALUE - 804))
          | (1ULL << (TSqlParser::VAR - 804))
          | (1ULL << (TSqlParser::VARP - 804))
          | (1ULL << (TSqlParser::VIEW_METADATA - 804))
          | (1ULL << (TSqlParser::VIEWS - 804))
          | (1ULL << (TSqlParser::WAIT - 804))
          | (1ULL << (TSqlParser::WELL_FORMED_XML - 804))
          | (1ULL << (TSqlParser::WORK - 804))
          | (1ULL << (TSqlParser::WORKLOAD - 804))
          | (1ULL << (TSqlParser::XML - 804))
          | (1ULL << (TSqlParser::XMLNAMESPACES - 804))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 804))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 804))
          | (1ULL << (TSqlParser::LOCAL_ID - 804))
          | (1ULL << (TSqlParser::DECIMAL - 804))
          | (1ULL << (TSqlParser::ID - 804))
          | (1ULL << (TSqlParser::STRING - 804))
          | (1ULL << (TSqlParser::PLUS - 804)))) != 0));
        setState(2652);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::RR_BRACKET) {
          setState(2651);
          match(TSqlParser::RR_BRACKET);
        }
        setState(2654);
        match(TSqlParser::FOR);
        setState(2655);
        id();
        break;
      }

      case TSqlParser::FOREIGN: {
        setState(2656);
        match(TSqlParser::FOREIGN);
        setState(2657);
        match(TSqlParser::KEY);
        setState(2658);
        match(TSqlParser::LR_BRACKET);
        setState(2659);
        dynamic_cast<Table_constraintContext *>(_localctx)->fk = column_name_list();
        setState(2660);
        match(TSqlParser::RR_BRACKET);
        setState(2661);
        match(TSqlParser::REFERENCES);
        setState(2662);
        table_name();
        setState(2667);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx)) {
        case 1: {
          setState(2663);
          match(TSqlParser::LR_BRACKET);
          setState(2664);
          dynamic_cast<Table_constraintContext *>(_localctx)->pk = column_name_list();
          setState(2665);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        }
        setState(2670);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx)) {
        case 1: {
          setState(2669);
          on_delete();
          break;
        }

        }
        setState(2673);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ON) {
          setState(2672);
          on_update();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_deleteContext ------------------------------------------------------------------

TSqlParser::On_deleteContext::On_deleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::On_deleteContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::On_deleteContext::DELETE() {
  return getToken(TSqlParser::DELETE, 0);
}

tree::TerminalNode* TSqlParser::On_deleteContext::NO() {
  return getToken(TSqlParser::NO, 0);
}

tree::TerminalNode* TSqlParser::On_deleteContext::ACTION() {
  return getToken(TSqlParser::ACTION, 0);
}

tree::TerminalNode* TSqlParser::On_deleteContext::CASCADE() {
  return getToken(TSqlParser::CASCADE, 0);
}

tree::TerminalNode* TSqlParser::On_deleteContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

tree::TerminalNode* TSqlParser::On_deleteContext::null() {
  return getToken(TSqlParser::null, 0);
}

tree::TerminalNode* TSqlParser::On_deleteContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}


size_t TSqlParser::On_deleteContext::getRuleIndex() const {
  return TSqlParser::RuleOn_delete;
}

void TSqlParser::On_deleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOn_delete(this);
}

void TSqlParser::On_deleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOn_delete(this);
}

TSqlParser::On_deleteContext* TSqlParser::on_delete() {
  On_deleteContext *_localctx = _tracker.createInstance<On_deleteContext>(_ctx, getState());
  enterRule(_localctx, 240, TSqlParser::RuleOn_delete);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2677);
    match(TSqlParser::ON);
    setState(2678);
    match(TSqlParser::DELETE);
    setState(2686);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
    case 1: {
      setState(2679);
      match(TSqlParser::NO);
      setState(2680);
      match(TSqlParser::ACTION);
      break;
    }

    case 2: {
      setState(2681);
      match(TSqlParser::CASCADE);
      break;
    }

    case 3: {
      setState(2682);
      match(TSqlParser::SET);
      setState(2683);
      match(TSqlParser::null);
      break;
    }

    case 4: {
      setState(2684);
      match(TSqlParser::SET);
      setState(2685);
      match(TSqlParser::DEFAULT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_updateContext ------------------------------------------------------------------

TSqlParser::On_updateContext::On_updateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::On_updateContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::On_updateContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::On_updateContext::NO() {
  return getToken(TSqlParser::NO, 0);
}

tree::TerminalNode* TSqlParser::On_updateContext::ACTION() {
  return getToken(TSqlParser::ACTION, 0);
}

tree::TerminalNode* TSqlParser::On_updateContext::CASCADE() {
  return getToken(TSqlParser::CASCADE, 0);
}

tree::TerminalNode* TSqlParser::On_updateContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

tree::TerminalNode* TSqlParser::On_updateContext::null() {
  return getToken(TSqlParser::null, 0);
}

tree::TerminalNode* TSqlParser::On_updateContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}


size_t TSqlParser::On_updateContext::getRuleIndex() const {
  return TSqlParser::RuleOn_update;
}

void TSqlParser::On_updateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOn_update(this);
}

void TSqlParser::On_updateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOn_update(this);
}

TSqlParser::On_updateContext* TSqlParser::on_update() {
  On_updateContext *_localctx = _tracker.createInstance<On_updateContext>(_ctx, getState());
  enterRule(_localctx, 242, TSqlParser::RuleOn_update);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2688);
    match(TSqlParser::ON);
    setState(2689);
    match(TSqlParser::UPDATE);
    setState(2697);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 400, _ctx)) {
    case 1: {
      setState(2690);
      match(TSqlParser::NO);
      setState(2691);
      match(TSqlParser::ACTION);
      break;
    }

    case 2: {
      setState(2692);
      match(TSqlParser::CASCADE);
      break;
    }

    case 3: {
      setState(2693);
      match(TSqlParser::SET);
      setState(2694);
      match(TSqlParser::null);
      break;
    }

    case 4: {
      setState(2695);
      match(TSqlParser::SET);
      setState(2696);
      match(TSqlParser::DEFAULT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionsContext ------------------------------------------------------------------

TSqlParser::Index_optionsContext::Index_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Index_optionsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Index_optionContext *> TSqlParser::Index_optionsContext::index_option() {
  return getRuleContexts<TSqlParser::Index_optionContext>();
}

TSqlParser::Index_optionContext* TSqlParser::Index_optionsContext::index_option(size_t i) {
  return getRuleContext<TSqlParser::Index_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Index_optionsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Index_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_options;
}

void TSqlParser::Index_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_options(this);
}

void TSqlParser::Index_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_options(this);
}

TSqlParser::Index_optionsContext* TSqlParser::index_options() {
  Index_optionsContext *_localctx = _tracker.createInstance<Index_optionsContext>(_ctx, getState());
  enterRule(_localctx, 244, TSqlParser::RuleIndex_options);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2699);
    match(TSqlParser::WITH);
    setState(2700);
    match(TSqlParser::LR_BRACKET);
    setState(2701);
    index_option();
    setState(2706);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2702);
      match(TSqlParser::COMMA);
      setState(2703);
      index_option();
      setState(2708);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2709);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionContext ------------------------------------------------------------------

TSqlParser::Index_optionContext::Index_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Simple_idContext *> TSqlParser::Index_optionContext::simple_id() {
  return getRuleContexts<TSqlParser::Simple_idContext>();
}

TSqlParser::Simple_idContext* TSqlParser::Index_optionContext::simple_id(size_t i) {
  return getRuleContext<TSqlParser::Simple_idContext>(i);
}

tree::TerminalNode* TSqlParser::Index_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::On_offContext* TSqlParser::Index_optionContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Index_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Index_optionContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_option;
}

void TSqlParser::Index_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_option(this);
}

void TSqlParser::Index_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_option(this);
}

TSqlParser::Index_optionContext* TSqlParser::index_option() {
  Index_optionContext *_localctx = _tracker.createInstance<Index_optionContext>(_ctx, getState());
  enterRule(_localctx, 246, TSqlParser::RuleIndex_option);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2711);
    simple_id();
    setState(2712);
    match(TSqlParser::EQUAL);
    setState(2716);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::ID: {
        setState(2713);
        simple_id();
        break;
      }

      case TSqlParser::OFF:
      case TSqlParser::ON: {
        setState(2714);
        on_off();
        break;
      }

      case TSqlParser::DECIMAL: {
        setState(2715);
        match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_cursorContext ------------------------------------------------------------------

TSqlParser::Declare_cursorContext::Declare_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::DECLARE() {
  return getToken(TSqlParser::DECLARE, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Declare_cursorContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Declare_cursorContext::FOR() {
  return getTokens(TSqlParser::FOR);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::FOR(size_t i) {
  return getToken(TSqlParser::FOR, i);
}

TSqlParser::Select_statementContext* TSqlParser::Declare_cursorContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::Declare_cursorContext::declare_set_cursor_common() {
  return getRuleContext<TSqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SEMI_SENSITIVE() {
  return getToken(TSqlParser::SEMI_SENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::INSENSITIVE() {
  return getToken(TSqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Declare_cursorContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}


size_t TSqlParser::Declare_cursorContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_cursor;
}

void TSqlParser::Declare_cursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_cursor(this);
}

void TSqlParser::Declare_cursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_cursor(this);
}

TSqlParser::Declare_cursorContext* TSqlParser::declare_cursor() {
  Declare_cursorContext *_localctx = _tracker.createInstance<Declare_cursorContext>(_ctx, getState());
  enterRule(_localctx, 248, TSqlParser::RuleDeclare_cursor);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2718);
    match(TSqlParser::DECLARE);
    setState(2719);
    cursor_name();
    setState(2751);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx)) {
    case 1: {
      setState(2720);
      match(TSqlParser::CURSOR);
      setState(2730);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx)) {
      case 1: {
        setState(2721);
        declare_set_cursor_common();
        setState(2728);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::FOR) {
          setState(2722);
          match(TSqlParser::FOR);
          setState(2723);
          match(TSqlParser::UPDATE);
          setState(2726);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::OF) {
            setState(2724);
            match(TSqlParser::OF);
            setState(2725);
            column_name_list();
          }
        }
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2733);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::INSENSITIVE || _la == TSqlParser::SEMI_SENSITIVE) {
        setState(2732);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::INSENSITIVE || _la == TSqlParser::SEMI_SENSITIVE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2736);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::SCROLL) {
        setState(2735);
        match(TSqlParser::SCROLL);
      }
      setState(2738);
      match(TSqlParser::CURSOR);
      setState(2739);
      match(TSqlParser::FOR);
      setState(2740);
      select_statement();
      setState(2749);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::FOR) {
        setState(2741);
        match(TSqlParser::FOR);
        setState(2747);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::READ: {
            setState(2742);
            match(TSqlParser::READ);
            setState(2743);
            match(TSqlParser::ONLY);
            break;
          }

          case TSqlParser::UPDATE: {
            setState(2744);
            match(TSqlParser::UPDATE);
            break;
          }

          case TSqlParser::OF: {
            setState(2745);
            match(TSqlParser::OF);
            setState(2746);
            column_name_list();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      break;
    }

    }
    setState(2754);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
    case 1: {
      setState(2753);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_set_cursor_commonContext ------------------------------------------------------------------

TSqlParser::Declare_set_cursor_commonContext::Declare_set_cursor_commonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_commonContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Select_statementContext* TSqlParser::Declare_set_cursor_commonContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

std::vector<TSqlParser::Declare_set_cursor_common_partialContext *> TSqlParser::Declare_set_cursor_commonContext::declare_set_cursor_common_partial() {
  return getRuleContexts<TSqlParser::Declare_set_cursor_common_partialContext>();
}

TSqlParser::Declare_set_cursor_common_partialContext* TSqlParser::Declare_set_cursor_commonContext::declare_set_cursor_common_partial(size_t i) {
  return getRuleContext<TSqlParser::Declare_set_cursor_common_partialContext>(i);
}


size_t TSqlParser::Declare_set_cursor_commonContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_set_cursor_common;
}

void TSqlParser::Declare_set_cursor_commonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_set_cursor_common(this);
}

void TSqlParser::Declare_set_cursor_commonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_set_cursor_common(this);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::declare_set_cursor_common() {
  Declare_set_cursor_commonContext *_localctx = _tracker.createInstance<Declare_set_cursor_commonContext>(_ctx, getState());
  enterRule(_localctx, 250, TSqlParser::RuleDeclare_set_cursor_common);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2759);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 510) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 510)) & ((1ULL << (TSqlParser::DYNAMIC - 510))
      | (1ULL << (TSqlParser::FAST_FORWARD - 510))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 510))
      | (1ULL << (TSqlParser::GLOBAL - 510)))) != 0) || _la == TSqlParser::KEYSET

    || _la == TSqlParser::LOCAL || _la == TSqlParser::OPTIMISTIC

    || _la == TSqlParser::READ_ONLY || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & ((1ULL << (TSqlParser::SCROLL - 729))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 729))
      | (1ULL << (TSqlParser::STATIC - 729)))) != 0) || _la == TSqlParser::TYPE_WARNING) {
      setState(2756);
      declare_set_cursor_common_partial();
      setState(2761);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2762);
    match(TSqlParser::FOR);
    setState(2763);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_set_cursor_common_partialContext ------------------------------------------------------------------

TSqlParser::Declare_set_cursor_common_partialContext::Declare_set_cursor_common_partialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::FORWARD_ONLY() {
  return getToken(TSqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::STATIC() {
  return getToken(TSqlParser::STATIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::KEYSET() {
  return getToken(TSqlParser::KEYSET, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::DYNAMIC() {
  return getToken(TSqlParser::DYNAMIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::FAST_FORWARD() {
  return getToken(TSqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::READ_ONLY() {
  return getToken(TSqlParser::READ_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::SCROLL_LOCKS() {
  return getToken(TSqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::OPTIMISTIC() {
  return getToken(TSqlParser::OPTIMISTIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::TYPE_WARNING() {
  return getToken(TSqlParser::TYPE_WARNING, 0);
}


size_t TSqlParser::Declare_set_cursor_common_partialContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_set_cursor_common_partial;
}

void TSqlParser::Declare_set_cursor_common_partialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_set_cursor_common_partial(this);
}

void TSqlParser::Declare_set_cursor_common_partialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_set_cursor_common_partial(this);
}

TSqlParser::Declare_set_cursor_common_partialContext* TSqlParser::declare_set_cursor_common_partial() {
  Declare_set_cursor_common_partialContext *_localctx = _tracker.createInstance<Declare_set_cursor_common_partialContext>(_ctx, getState());
  enterRule(_localctx, 252, TSqlParser::RuleDeclare_set_cursor_common_partial);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2770);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::GLOBAL:
      case TSqlParser::LOCAL: {
        enterOuterAlt(_localctx, 1);
        setState(2765);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::GLOBAL

        || _la == TSqlParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::SCROLL: {
        enterOuterAlt(_localctx, 2);
        setState(2766);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FORWARD_ONLY || _la == TSqlParser::SCROLL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::DYNAMIC:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::KEYSET:
      case TSqlParser::STATIC: {
        enterOuterAlt(_localctx, 3);
        setState(2767);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DYNAMIC

        || _la == TSqlParser::FAST_FORWARD || _la == TSqlParser::KEYSET || _la == TSqlParser::STATIC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::OPTIMISTIC:
      case TSqlParser::READ_ONLY:
      case TSqlParser::SCROLL_LOCKS: {
        enterOuterAlt(_localctx, 4);
        setState(2768);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::OPTIMISTIC

        || _la == TSqlParser::READ_ONLY || _la == TSqlParser::SCROLL_LOCKS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::TYPE_WARNING: {
        enterOuterAlt(_localctx, 5);
        setState(2769);
        match(TSqlParser::TYPE_WARNING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_cursorContext ------------------------------------------------------------------

TSqlParser::Fetch_cursorContext::Fetch_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FETCH() {
  return getToken(TSqlParser::FETCH, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Fetch_cursorContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Fetch_cursorContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::PRIOR() {
  return getToken(TSqlParser::PRIOR, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::LAST() {
  return getToken(TSqlParser::LAST, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Fetch_cursorContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Fetch_cursorContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::ABSOLUTE() {
  return getToken(TSqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::RELATIVE() {
  return getToken(TSqlParser::RELATIVE, 0);
}


size_t TSqlParser::Fetch_cursorContext::getRuleIndex() const {
  return TSqlParser::RuleFetch_cursor;
}

void TSqlParser::Fetch_cursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFetch_cursor(this);
}

void TSqlParser::Fetch_cursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFetch_cursor(this);
}

TSqlParser::Fetch_cursorContext* TSqlParser::fetch_cursor() {
  Fetch_cursorContext *_localctx = _tracker.createInstance<Fetch_cursorContext>(_ctx, getState());
  enterRule(_localctx, 254, TSqlParser::RuleFetch_cursor);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2772);
    match(TSqlParser::FETCH);
    setState(2782);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx)) {
    case 1: {
      setState(2779);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::NEXT: {
          setState(2773);
          match(TSqlParser::NEXT);
          break;
        }

        case TSqlParser::PRIOR: {
          setState(2774);
          match(TSqlParser::PRIOR);
          break;
        }

        case TSqlParser::FIRST: {
          setState(2775);
          match(TSqlParser::FIRST);
          break;
        }

        case TSqlParser::LAST: {
          setState(2776);
          match(TSqlParser::LAST);
          break;
        }

        case TSqlParser::ABSOLUTE:
        case TSqlParser::RELATIVE: {
          setState(2777);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::ABSOLUTE || _la == TSqlParser::RELATIVE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2778);
          expression(0);
          break;
        }

        case TSqlParser::FROM: {
          break;
        }

      default:
        break;
      }
      setState(2781);
      match(TSqlParser::FROM);
      break;
    }

    }
    setState(2785);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
    case 1: {
      setState(2784);
      match(TSqlParser::GLOBAL);
      break;
    }

    }
    setState(2787);
    cursor_name();
    setState(2797);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(2788);
      match(TSqlParser::INTO);
      setState(2789);
      match(TSqlParser::LOCAL_ID);
      setState(2794);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2790);
        match(TSqlParser::COMMA);
        setState(2791);
        match(TSqlParser::LOCAL_ID);
        setState(2796);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2800);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx)) {
    case 1: {
      setState(2799);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_specialContext ------------------------------------------------------------------

TSqlParser::Set_specialContext::Set_specialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Set_specialContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Set_specialContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Set_specialContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::Set_specialContext::constant_LOCAL_ID() {
  return getRuleContext<TSqlParser::Constant_LOCAL_IDContext>(0);
}

TSqlParser::On_offContext* TSqlParser::Set_specialContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::TRANSACTION() {
  return getToken(TSqlParser::TRANSACTION, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ISOLATION() {
  return getToken(TSqlParser::ISOLATION, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::LEVEL() {
  return getToken(TSqlParser::LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::UNCOMMITTED() {
  return getToken(TSqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::COMMITTED() {
  return getToken(TSqlParser::COMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::REPEATABLE() {
  return getToken(TSqlParser::REPEATABLE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::IDENTITY_INSERT() {
  return getToken(TSqlParser::IDENTITY_INSERT, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Set_specialContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_NULLS() {
  return getToken(TSqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::QUOTED_IDENTIFIER() {
  return getToken(TSqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_PADDING() {
  return getToken(TSqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_WARNINGS() {
  return getToken(TSqlParser::ANSI_WARNINGS, 0);
}

TSqlParser::Modify_methodContext* TSqlParser::Set_specialContext::modify_method() {
  return getRuleContext<TSqlParser::Modify_methodContext>(0);
}


size_t TSqlParser::Set_specialContext::getRuleIndex() const {
  return TSqlParser::RuleSet_special;
}

void TSqlParser::Set_specialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_special(this);
}

void TSqlParser::Set_specialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_special(this);
}

TSqlParser::Set_specialContext* TSqlParser::set_special() {
  Set_specialContext *_localctx = _tracker.createInstance<Set_specialContext>(_ctx, getState());
  enterRule(_localctx, 256, TSqlParser::RuleSet_special);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2851);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2802);
      match(TSqlParser::SET);
      setState(2803);
      id();
      setState(2807);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::CALLED:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::EVENTDATA:
        case TSqlParser::FILENAME:
        case TSqlParser::FILLFACTOR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::INIT:
        case TSqlParser::KEY:
        case TSqlParser::MASTER:
        case TSqlParser::MAX_MEMORY:
        case TSqlParser::OFFSETS:
        case TSqlParser::PAGE:
        case TSqlParser::PUBLIC:
        case TSqlParser::R:
        case TSqlParser::RAW:
        case TSqlParser::RETURN:
        case TSqlParser::RETURNS:
        case TSqlParser::ROWCOUNT:
        case TSqlParser::SAFETY:
        case TSqlParser::SERVER:
        case TSqlParser::SID:
        case TSqlParser::SOURCE:
        case TSqlParser::SPLIT:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::ACCENT_SENSITIVITY:
        case TSqlParser::ACTION:
        case TSqlParser::ACTIVATION:
        case TSqlParser::ACTIVE:
        case TSqlParser::ADDRESS:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::AFFINITY:
        case TSqlParser::AFTER:
        case TSqlParser::AGGREGATE:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
        case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
        case TSqlParser::ALLOWED:
        case TSqlParser::ANSI_NULL_DEFAULT:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLICATION_LOG:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::ASSEMBLY:
        case TSqlParser::AUDIT:
        case TSqlParser::AUDIT_GUID:
        case TSqlParser::AUTO:
        case TSqlParser::AUTO_CLEANUP:
        case TSqlParser::AUTO_CLOSE:
        case TSqlParser::AUTO_CREATE_STATISTICS:
        case TSqlParser::AUTO_SHRINK:
        case TSqlParser::AUTO_UPDATE_STATISTICS:
        case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
        case TSqlParser::AVAILABILITY:
        case TSqlParser::AVG:
        case TSqlParser::BACKUP_PRIORITY:
        case TSqlParser::BEGIN_DIALOG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::BINDING:
        case TSqlParser::BLOB_STORAGE:
        case TSqlParser::BROKER:
        case TSqlParser::BROKER_INSTANCE:
        case TSqlParser::BULK_LOGGED:
        case TSqlParser::CALLER:
        case TSqlParser::CAP_CPU_PERCENT:
        case TSqlParser::CAST:
        case TSqlParser::CATALOG:
        case TSqlParser::CATCH:
        case TSqlParser::CHANGE_RETENTION:
        case TSqlParser::CHANGE_TRACKING:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::CLEANUP:
        case TSqlParser::COLLECTION:
        case TSqlParser::COLUMN_MASTER_KEY:
        case TSqlParser::COMMITTED:
        case TSqlParser::COMPATIBILITY_LEVEL:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::CONTENT:
        case TSqlParser::CONTROL:
        case TSqlParser::COOKIE:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::COUNTER:
        case TSqlParser::CPU:
        case TSqlParser::CREATE_NEW:
        case TSqlParser::CREATION_DISPOSITION:
        case TSqlParser::CREDENTIAL:
        case TSqlParser::CRYPTOGRAPHIC:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DB_CHAINING:
        case TSqlParser::DB_FAILOVER:
        case TSqlParser::DECRYPTION:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
        case TSqlParser::DEFAULT_LANGUAGE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DEPENDENTS:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DHCP:
        case TSqlParser::DIALOG:
        case TSqlParser::DIRECTORY_NAME:
        case TSqlParser::DISABLE:
        case TSqlParser::DISABLE_BROKER:
        case TSqlParser::DISABLED:
        case TSqlParser::DISK_DRIVE:
        case TSqlParser::DOCUMENT:
        case TSqlParser::DYNAMIC:
        case TSqlParser::EMERGENCY:
        case TSqlParser::EMPTY:
        case TSqlParser::ENABLE:
        case TSqlParser::ENABLE_BROKER:
        case TSqlParser::ENCRYPTED_VALUE:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::ENDPOINT_URL:
        case TSqlParser::ERROR_BROKER_CONVERSATIONS:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::EXECUTABLE:
        case TSqlParser::EXIST:
        case TSqlParser::EXPAND:
        case TSqlParser::EXPIRY_DATE:
        case TSqlParser::EXPLICIT:
        case TSqlParser::FAIL_OPERATION:
        case TSqlParser::FAILOVER_MODE:
        case TSqlParser::FAILURE:
        case TSqlParser::FAILURE_CONDITION_LEVEL:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FILEGROUP:
        case TSqlParser::FILEGROWTH:
        case TSqlParser::FILEPATH:
        case TSqlParser::FILESTREAM:
        case TSqlParser::FILTER:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
        case TSqlParser::FORCED:
        case TSqlParser::FORMAT:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::FULLSCAN:
        case TSqlParser::FULLTEXT:
        case TSqlParser::GB:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO:
        case TSqlParser::GROUP_MAX_REQUESTS:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HADR:
        case TSqlParser::HASH:
        case TSqlParser::HEALTH_CHECK_TIMEOUT:
        case TSqlParser::HIGH:
        case TSqlParser::HONOR_BROKER_PRIORITY:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case TSqlParser::IMMEDIATE:
        case TSqlParser::IMPERSONATE:
        case TSqlParser::IMPORTANCE:
        case TSqlParser::INCREMENTAL:
        case TSqlParser::INITIATOR:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::IP:
        case TSqlParser::ISOLATION:
        case TSqlParser::KB:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEY_SOURCE:
        case TSqlParser::KEYS:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LIST:
        case TSqlParser::LISTENER:
        case TSqlParser::LISTENER_URL:
        case TSqlParser::LOB_COMPACTION:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOGIN:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MATERIALIZED:
        case TSqlParser::MAX:
        case TSqlParser::MAX_CPU_PERCENT:
        case TSqlParser::MAX_DOP:
        case TSqlParser::MAX_FILES:
        case TSqlParser::MAX_IOPS_PER_VOLUME:
        case TSqlParser::MAX_MEMORY_PERCENT:
        case TSqlParser::MAX_PROCESSES:
        case TSqlParser::MAX_QUEUE_READERS:
        case TSqlParser::MAX_ROLLOVER_FILES:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MAXSIZE:
        case TSqlParser::MB:
        case TSqlParser::MEDIUM:
        case TSqlParser::MEMORY_OPTIMIZED_DATA:
        case TSqlParser::MESSAGE:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MIN_CPU_PERCENT:
        case TSqlParser::MIN_IOPS_PER_VOLUME:
        case TSqlParser::MIN_MEMORY_PERCENT:
        case TSqlParser::MINUTES:
        case TSqlParser::MIRROR_ADDRESS:
        case TSqlParser::MIXED_PAGE_ALLOCATION:
        case TSqlParser::MODE:
        case TSqlParser::MODIFY:
        case TSqlParser::MOVE:
        case TSqlParser::MULTI_USER:
        case TSqlParser::NAME:
        case TSqlParser::NESTED_TRIGGERS:
        case TSqlParser::NEW_ACCOUNT:
        case TSqlParser::NEW_BROKER:
        case TSqlParser::NEW_PASSWORD:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NO_TRUNCATE:
        case TSqlParser::NO_WAIT:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NON_TRANSACTED_ACCESS:
        case TSqlParser::NORECOMPUTE:
        case TSqlParser::NORECOVERY:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMBER:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFLINE:
        case TSqlParser::OFFSET:
        case TSqlParser::OLD_ACCOUNT:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPEN_EXISTING:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PAGE_VERIFY:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PARTNER:
        case TSqlParser::PATH:
        case TSqlParser::POISON_MESSAGE_HANDLING:
        case TSqlParser::POOL:
        case TSqlParser::PORT:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIMARY_ROLE:
        case TSqlParser::PRIOR:
        case TSqlParser::PRIORITY:
        case TSqlParser::PRIORITY_LEVEL:
        case TSqlParser::PRIVATE:
        case TSqlParser::PRIVATE_KEY:
        case TSqlParser::PRIVILEGES:
        case TSqlParser::PROCEDURE_NAME:
        case TSqlParser::PROPERTY:
        case TSqlParser::PROVIDER:
        case TSqlParser::PROVIDER_KEY_NAME:
        case TSqlParser::QUERY:
        case TSqlParser::QUEUE:
        case TSqlParser::QUEUE_DELAY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_COMMITTED_SNAPSHOT:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READ_ONLY_ROUTING_LIST:
        case TSqlParser::READ_WRITE:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECEIVE:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RECOVERY:
        case TSqlParser::RECURSIVE_TRIGGERS:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REMOTE_SERVICE_NAME:
        case TSqlParser::REMOVE:
        case TSqlParser::REORGANIZE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::REPLICA:
        case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
        case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
        case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
        case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
        case TSqlParser::RESERVE_DISK_SPACE:
        case TSqlParser::RESOURCE:
        case TSqlParser::RESOURCE_MANAGER_LOCATION:
        case TSqlParser::RESTRICTED_USER:
        case TSqlParser::RETENTION:
        case TSqlParser::ROBUST:
        case TSqlParser::ROOT:
        case TSqlParser::ROUTE:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SAMPLE:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCOPED:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SEARCH:
        case TSqlParser::SECONDARY:
        case TSqlParser::SECONDARY_ONLY:
        case TSqlParser::SECONDARY_ROLE:
        case TSqlParser::SECONDS:
        case TSqlParser::SECRET:
        case TSqlParser::SECURITY:
        case TSqlParser::SECURITY_LOG:
        case TSqlParser::SEEDING_MODE:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEND:
        case TSqlParser::SENT:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SESSION_TIMEOUT:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SHOWPLAN:
        case TSqlParser::SIGNATURE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SINGLE_USER:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STANDBY:
        case TSqlParser::START_DATE:
        case TSqlParser::STATIC:
        case TSqlParser::STATS_STREAM:
        case TSqlParser::STATUS:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STOPLIST:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBJECT:
        case TSqlParser::SUM:
        case TSqlParser::SUSPEND:
        case TSqlParser::SYMMETRIC:
        case TSqlParser::SYNCHRONOUS_COMMIT:
        case TSqlParser::SYNONYM:
        case TSqlParser::SYSTEM:
        case TSqlParser::TAKE:
        case TSqlParser::TARGET_RECOVERY_TIME:
        case TSqlParser::TB:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TIMER:
        case TSqlParser::TINYINT:
        case TSqlParser::TORN_PAGE_DETECTION:
        case TSqlParser::TRANSFORM_NOISE_WORDS:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRUSTWORTHY:
        case TSqlParser::TRY:
        case TSqlParser::TSQL:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UNLIMITED:
        case TSqlParser::USING:
        case TSqlParser::VALID_XML:
        case TSqlParser::VALIDATION:
        case TSqlParser::VALUE:
        case TSqlParser::VAR:
        case TSqlParser::VARP:
        case TSqlParser::VIEW_METADATA:
        case TSqlParser::VIEWS:
        case TSqlParser::WAIT:
        case TSqlParser::WELL_FORMED_XML:
        case TSqlParser::WORK:
        case TSqlParser::WORKLOAD:
        case TSqlParser::XML:
        case TSqlParser::XMLNAMESPACES:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID: {
          setState(2804);
          id();
          break;
        }

        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOLLAR:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS: {
          setState(2805);
          constant_LOCAL_ID();
          break;
        }

        case TSqlParser::OFF:
        case TSqlParser::ON: {
          setState(2806);
          on_off();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2810);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx)) {
      case 1: {
        setState(2809);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2812);
      match(TSqlParser::SET);
      setState(2813);
      match(TSqlParser::TRANSACTION);
      setState(2814);
      match(TSqlParser::ISOLATION);
      setState(2815);
      match(TSqlParser::LEVEL);
      setState(2825);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx)) {
      case 1: {
        setState(2816);
        match(TSqlParser::READ);
        setState(2817);
        match(TSqlParser::UNCOMMITTED);
        break;
      }

      case 2: {
        setState(2818);
        match(TSqlParser::READ);
        setState(2819);
        match(TSqlParser::COMMITTED);
        break;
      }

      case 3: {
        setState(2820);
        match(TSqlParser::REPEATABLE);
        setState(2821);
        match(TSqlParser::READ);
        break;
      }

      case 4: {
        setState(2822);
        match(TSqlParser::SNAPSHOT);
        break;
      }

      case 5: {
        setState(2823);
        match(TSqlParser::SERIALIZABLE);
        break;
      }

      case 6: {
        setState(2824);
        match(TSqlParser::DECIMAL);
        break;
      }

      }
      setState(2828);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx)) {
      case 1: {
        setState(2827);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2830);
      match(TSqlParser::SET);
      setState(2831);
      match(TSqlParser::IDENTITY_INSERT);
      setState(2832);
      table_name();
      setState(2833);
      on_off();
      setState(2835);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx)) {
      case 1: {
        setState(2834);
        match(TSqlParser::SEMI);
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2837);
      match(TSqlParser::SET);
      setState(2838);
      match(TSqlParser::ANSI_NULLS);
      setState(2839);
      on_off();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2840);
      match(TSqlParser::SET);
      setState(2841);
      match(TSqlParser::QUOTED_IDENTIFIER);
      setState(2842);
      on_off();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2843);
      match(TSqlParser::SET);
      setState(2844);
      match(TSqlParser::ANSI_PADDING);
      setState(2845);
      on_off();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2846);
      match(TSqlParser::SET);
      setState(2847);
      match(TSqlParser::ANSI_WARNINGS);
      setState(2848);
      on_off();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2849);
      match(TSqlParser::SET);
      setState(2850);
      modify_method();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_LOCAL_IDContext ------------------------------------------------------------------

TSqlParser::Constant_LOCAL_IDContext::Constant_LOCAL_IDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ConstantContext* TSqlParser::Constant_LOCAL_IDContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_LOCAL_IDContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Constant_LOCAL_IDContext::getRuleIndex() const {
  return TSqlParser::RuleConstant_LOCAL_ID;
}

void TSqlParser::Constant_LOCAL_IDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_LOCAL_ID(this);
}

void TSqlParser::Constant_LOCAL_IDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_LOCAL_ID(this);
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::constant_LOCAL_ID() {
  Constant_LOCAL_IDContext *_localctx = _tracker.createInstance<Constant_LOCAL_IDContext>(_ctx, getState());
  enterRule(_localctx, 258, TSqlParser::RuleConstant_LOCAL_ID);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2855);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 1);
        setState(2853);
        constant();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(2854);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

TSqlParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Primitive_expressionContext* TSqlParser::ExpressionContext::primitive_expression() {
  return getRuleContext<TSqlParser::Primitive_expressionContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::ExpressionContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

TSqlParser::Case_expressionContext* TSqlParser::ExpressionContext::case_expression() {
  return getRuleContext<TSqlParser::Case_expressionContext>(0);
}

TSqlParser::Full_column_nameContext* TSqlParser::ExpressionContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

TSqlParser::Bracket_expressionContext* TSqlParser::ExpressionContext::bracket_expression() {
  return getRuleContext<TSqlParser::Bracket_expressionContext>(0);
}

TSqlParser::Unary_operator_expressionContext* TSqlParser::ExpressionContext::unary_operator_expression() {
  return getRuleContext<TSqlParser::Unary_operator_expressionContext>(0);
}

TSqlParser::Over_clauseContext* TSqlParser::ExpressionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::ExpressionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::ExpressionContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DIVIDE() {
  return getToken(TSqlParser::DIVIDE, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::MODULE() {
  return getToken(TSqlParser::MODULE, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_AND() {
  return getToken(TSqlParser::BIT_AND, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_XOR() {
  return getToken(TSqlParser::BIT_XOR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_OR() {
  return getToken(TSqlParser::BIT_OR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DOUBLE_BAR() {
  return getToken(TSqlParser::DOUBLE_BAR, 0);
}

TSqlParser::Comparison_operatorContext* TSqlParser::ExpressionContext::comparison_operator() {
  return getRuleContext<TSqlParser::Comparison_operatorContext>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::ExpressionContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::IdContext* TSqlParser::ExpressionContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}


size_t TSqlParser::ExpressionContext::getRuleIndex() const {
  return TSqlParser::RuleExpression;
}

void TSqlParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void TSqlParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


TSqlParser::ExpressionContext* TSqlParser::expression() {
   return expression(0);
}

TSqlParser::ExpressionContext* TSqlParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TSqlParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  TSqlParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 260;
  enterRecursionRule(_localctx, 260, TSqlParser::RuleExpression, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2865);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx)) {
    case 1: {
      setState(2858);
      primitive_expression();
      break;
    }

    case 2: {
      setState(2859);
      function_call();
      break;
    }

    case 3: {
      setState(2860);
      case_expression();
      break;
    }

    case 4: {
      setState(2861);
      full_column_name();
      break;
    }

    case 5: {
      setState(2862);
      bracket_expression();
      break;
    }

    case 6: {
      setState(2863);
      unary_operator_expression();
      break;
    }

    case 7: {
      setState(2864);
      over_clause();
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(2886);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2884);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2867);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(2868);
          dynamic_cast<ExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 859) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 859)) & ((1ULL << (TSqlParser::STAR - 859))
            | (1ULL << (TSqlParser::DIVIDE - 859))
            | (1ULL << (TSqlParser::MODULE - 859)))) != 0))) {
            dynamic_cast<ExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2869);
          expression(6);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2870);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(2871);
          dynamic_cast<ExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 848) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 848)) & ((1ULL << (TSqlParser::DOUBLE_BAR - 848))
            | (1ULL << (TSqlParser::PLUS - 848))
            | (1ULL << (TSqlParser::MINUS - 848))
            | (1ULL << (TSqlParser::BIT_OR - 848))
            | (1ULL << (TSqlParser::BIT_AND - 848))
            | (1ULL << (TSqlParser::BIT_XOR - 848)))) != 0))) {
            dynamic_cast<ExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2872);
          expression(5);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2873);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(2874);
          comparison_operator();
          setState(2875);
          expression(4);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2877);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(2878);
          assignment_operator();
          setState(2879);
          expression(3);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2881);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(2882);
          match(TSqlParser::COLLATE);
          setState(2883);
          id();
          break;
        }

        } 
      }
      setState(2888);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Primitive_expressionContext ------------------------------------------------------------------

TSqlParser::Primitive_expressionContext::Primitive_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::null() {
  return getToken(TSqlParser::null, 0);
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ConstantContext* TSqlParser::Primitive_expressionContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::Primitive_expressionContext::getRuleIndex() const {
  return TSqlParser::RulePrimitive_expression;
}

void TSqlParser::Primitive_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimitive_expression(this);
}

void TSqlParser::Primitive_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimitive_expression(this);
}

TSqlParser::Primitive_expressionContext* TSqlParser::primitive_expression() {
  Primitive_expressionContext *_localctx = _tracker.createInstance<Primitive_expressionContext>(_ctx, getState());
  enterRule(_localctx, 262, TSqlParser::RulePrimitive_expression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2893);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(2889);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::null: {
        enterOuterAlt(_localctx, 2);
        setState(2890);
        match(TSqlParser::null);
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 3);
        setState(2891);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 4);
        setState(2892);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_expressionContext ------------------------------------------------------------------

TSqlParser::Case_expressionContext::Case_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Case_expressionContext::CASE() {
  return getToken(TSqlParser::CASE, 0);
}

tree::TerminalNode* TSqlParser::Case_expressionContext::END() {
  return getToken(TSqlParser::END, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Case_expressionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Case_expressionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<TSqlParser::Switch_sectionContext *> TSqlParser::Case_expressionContext::switch_section() {
  return getRuleContexts<TSqlParser::Switch_sectionContext>();
}

TSqlParser::Switch_sectionContext* TSqlParser::Case_expressionContext::switch_section(size_t i) {
  return getRuleContext<TSqlParser::Switch_sectionContext>(i);
}

tree::TerminalNode* TSqlParser::Case_expressionContext::ELSE() {
  return getToken(TSqlParser::ELSE, 0);
}

std::vector<TSqlParser::Switch_search_condition_sectionContext *> TSqlParser::Case_expressionContext::switch_search_condition_section() {
  return getRuleContexts<TSqlParser::Switch_search_condition_sectionContext>();
}

TSqlParser::Switch_search_condition_sectionContext* TSqlParser::Case_expressionContext::switch_search_condition_section(size_t i) {
  return getRuleContext<TSqlParser::Switch_search_condition_sectionContext>(i);
}


size_t TSqlParser::Case_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleCase_expression;
}

void TSqlParser::Case_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_expression(this);
}

void TSqlParser::Case_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_expression(this);
}

TSqlParser::Case_expressionContext* TSqlParser::case_expression() {
  Case_expressionContext *_localctx = _tracker.createInstance<Case_expressionContext>(_ctx, getState());
  enterRule(_localctx, 264, TSqlParser::RuleCase_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2920);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2895);
      match(TSqlParser::CASE);
      setState(2896);
      dynamic_cast<Case_expressionContext *>(_localctx)->caseExpr = expression(0);
      setState(2898); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2897);
        switch_section();
        setState(2900); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::WHEN);
      setState(2904);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ELSE) {
        setState(2902);
        match(TSqlParser::ELSE);
        setState(2903);
        dynamic_cast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2906);
      match(TSqlParser::END);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2908);
      match(TSqlParser::CASE);
      setState(2910); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2909);
        switch_search_condition_section();
        setState(2912); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::WHEN);
      setState(2916);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ELSE) {
        setState(2914);
        match(TSqlParser::ELSE);
        setState(2915);
        dynamic_cast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2918);
      match(TSqlParser::END);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operator_expressionContext ------------------------------------------------------------------

TSqlParser::Unary_operator_expressionContext::Unary_operator_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::BIT_NOT() {
  return getToken(TSqlParser::BIT_NOT, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Unary_operator_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::Unary_operator_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleUnary_operator_expression;
}

void TSqlParser::Unary_operator_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_operator_expression(this);
}

void TSqlParser::Unary_operator_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_operator_expression(this);
}

TSqlParser::Unary_operator_expressionContext* TSqlParser::unary_operator_expression() {
  Unary_operator_expressionContext *_localctx = _tracker.createInstance<Unary_operator_expressionContext>(_ctx, getState());
  enterRule(_localctx, 266, TSqlParser::RuleUnary_operator_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2926);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BIT_NOT: {
        enterOuterAlt(_localctx, 1);
        setState(2922);
        match(TSqlParser::BIT_NOT);
        setState(2923);
        expression(0);
        break;
      }

      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(2924);
        dynamic_cast<Unary_operator_expressionContext *>(_localctx)->op = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::PLUS

        || _la == TSqlParser::MINUS)) {
          dynamic_cast<Unary_operator_expressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2925);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bracket_expressionContext ------------------------------------------------------------------

TSqlParser::Bracket_expressionContext::Bracket_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Bracket_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Bracket_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Bracket_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::SubqueryContext* TSqlParser::Bracket_expressionContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}


size_t TSqlParser::Bracket_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleBracket_expression;
}

void TSqlParser::Bracket_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBracket_expression(this);
}

void TSqlParser::Bracket_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBracket_expression(this);
}

TSqlParser::Bracket_expressionContext* TSqlParser::bracket_expression() {
  Bracket_expressionContext *_localctx = _tracker.createInstance<Bracket_expressionContext>(_ctx, getState());
  enterRule(_localctx, 268, TSqlParser::RuleBracket_expression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2936);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2928);
      match(TSqlParser::LR_BRACKET);
      setState(2929);
      expression(0);
      setState(2930);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2932);
      match(TSqlParser::LR_BRACKET);
      setState(2933);
      subquery();
      setState(2934);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

TSqlParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::null() {
  return getToken(TSqlParser::null, 0);
}

TSqlParser::ConstantContext* TSqlParser::Constant_expressionContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::Constant_expressionContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Constant_expressionContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Constant_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleConstant_expression;
}

void TSqlParser::Constant_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_expression(this);
}

void TSqlParser::Constant_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_expression(this);
}

TSqlParser::Constant_expressionContext* TSqlParser::constant_expression() {
  Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 270, TSqlParser::RuleConstant_expression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2946);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2938);
      match(TSqlParser::null);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2939);
      constant();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2940);
      function_call();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2941);
      match(TSqlParser::LOCAL_ID);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2942);
      match(TSqlParser::LR_BRACKET);
      setState(2943);
      constant_expression();
      setState(2944);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

TSqlParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Select_statementContext* TSqlParser::SubqueryContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}


size_t TSqlParser::SubqueryContext::getRuleIndex() const {
  return TSqlParser::RuleSubquery;
}

void TSqlParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}

void TSqlParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}

TSqlParser::SubqueryContext* TSqlParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 272, TSqlParser::RuleSubquery);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2948);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_expressionContext ------------------------------------------------------------------

TSqlParser::With_expressionContext::With_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::With_expressionContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Common_table_expressionContext *> TSqlParser::With_expressionContext::common_table_expression() {
  return getRuleContexts<TSqlParser::Common_table_expressionContext>();
}

TSqlParser::Common_table_expressionContext* TSqlParser::With_expressionContext::common_table_expression(size_t i) {
  return getRuleContext<TSqlParser::Common_table_expressionContext>(i);
}

tree::TerminalNode* TSqlParser::With_expressionContext::XMLNAMESPACES() {
  return getToken(TSqlParser::XMLNAMESPACES, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::With_expressionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::With_expressionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::With_expressionContext::BLOCKING_HIERARCHY() {
  return getToken(TSqlParser::BLOCKING_HIERARCHY, 0);
}

tree::TerminalNode* TSqlParser::With_expressionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::With_expressionContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::With_expressionContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::Select_statementContext* TSqlParser::With_expressionContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::With_expressionContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::With_expressionContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::Full_column_name_listContext* TSqlParser::With_expressionContext::full_column_name_list() {
  return getRuleContext<TSqlParser::Full_column_name_listContext>(0);
}


size_t TSqlParser::With_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleWith_expression;
}

void TSqlParser::With_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_expression(this);
}

void TSqlParser::With_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_expression(this);
}

TSqlParser::With_expressionContext* TSqlParser::with_expression() {
  With_expressionContext *_localctx = _tracker.createInstance<With_expressionContext>(_ctx, getState());
  enterRule(_localctx, 274, TSqlParser::RuleWith_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2976);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2950);
      match(TSqlParser::WITH);
      setState(2953);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx)) {
      case 1: {
        setState(2951);
        match(TSqlParser::XMLNAMESPACES);
        setState(2952);
        match(TSqlParser::COMMA);
        break;
      }

      }
      setState(2955);
      common_table_expression();
      setState(2960);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2956);
        match(TSqlParser::COMMA);
        setState(2957);
        common_table_expression();
        setState(2962);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2963);
      match(TSqlParser::WITH);
      setState(2964);
      match(TSqlParser::BLOCKING_HIERARCHY);
      setState(2969);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LR_BRACKET) {
        setState(2965);
        match(TSqlParser::LR_BRACKET);
        setState(2966);
        full_column_name_list();
        setState(2967);
        match(TSqlParser::RR_BRACKET);
      }
      setState(2971);
      match(TSqlParser::AS);
      setState(2972);
      match(TSqlParser::LR_BRACKET);
      setState(2973);
      select_statement();
      setState(2974);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_expressionContext ------------------------------------------------------------------

TSqlParser::Common_table_expressionContext::Common_table_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Common_table_expressionContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::Select_statementContext* TSqlParser::Common_table_expressionContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Common_table_expressionContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::IdContext* TSqlParser::Common_table_expressionContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

TSqlParser::Column_name_listContext* TSqlParser::Common_table_expressionContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}


size_t TSqlParser::Common_table_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleCommon_table_expression;
}

void TSqlParser::Common_table_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_expression(this);
}

void TSqlParser::Common_table_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_expression(this);
}

TSqlParser::Common_table_expressionContext* TSqlParser::common_table_expression() {
  Common_table_expressionContext *_localctx = _tracker.createInstance<Common_table_expressionContext>(_ctx, getState());
  enterRule(_localctx, 276, TSqlParser::RuleCommon_table_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2978);
    dynamic_cast<Common_table_expressionContext *>(_localctx)->expression_name = id();
    setState(2983);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(2979);
      match(TSqlParser::LR_BRACKET);
      setState(2980);
      column_name_list();
      setState(2981);
      match(TSqlParser::RR_BRACKET);
    }
    setState(2985);
    match(TSqlParser::AS);
    setState(2986);
    match(TSqlParser::LR_BRACKET);
    setState(2987);
    select_statement();
    setState(2988);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_elemContext ------------------------------------------------------------------

TSqlParser::Update_elemContext::Update_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Update_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Update_elemContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Update_elemContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Update_elemContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Update_elemContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Update_elemContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}


size_t TSqlParser::Update_elemContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_elem;
}

void TSqlParser::Update_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_elem(this);
}

void TSqlParser::Update_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_elem(this);
}

TSqlParser::Update_elemContext* TSqlParser::update_elem() {
  Update_elemContext *_localctx = _tracker.createInstance<Update_elemContext>(_ctx, getState());
  enterRule(_localctx, 278, TSqlParser::RuleUpdate_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3006);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2992);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CALLED:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::EVENTDATA:
        case TSqlParser::FILENAME:
        case TSqlParser::FILLFACTOR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::INIT:
        case TSqlParser::KEY:
        case TSqlParser::MASTER:
        case TSqlParser::MAX_MEMORY:
        case TSqlParser::OFFSETS:
        case TSqlParser::PAGE:
        case TSqlParser::PUBLIC:
        case TSqlParser::R:
        case TSqlParser::RAW:
        case TSqlParser::RETURN:
        case TSqlParser::RETURNS:
        case TSqlParser::ROWCOUNT:
        case TSqlParser::SAFETY:
        case TSqlParser::SERVER:
        case TSqlParser::SID:
        case TSqlParser::SOURCE:
        case TSqlParser::SPLIT:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::ACCENT_SENSITIVITY:
        case TSqlParser::ACTION:
        case TSqlParser::ACTIVATION:
        case TSqlParser::ACTIVE:
        case TSqlParser::ADDRESS:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::AFFINITY:
        case TSqlParser::AFTER:
        case TSqlParser::AGGREGATE:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
        case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
        case TSqlParser::ALLOWED:
        case TSqlParser::ANSI_NULL_DEFAULT:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLICATION_LOG:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::ASSEMBLY:
        case TSqlParser::AUDIT:
        case TSqlParser::AUDIT_GUID:
        case TSqlParser::AUTO:
        case TSqlParser::AUTO_CLEANUP:
        case TSqlParser::AUTO_CLOSE:
        case TSqlParser::AUTO_CREATE_STATISTICS:
        case TSqlParser::AUTO_SHRINK:
        case TSqlParser::AUTO_UPDATE_STATISTICS:
        case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
        case TSqlParser::AVAILABILITY:
        case TSqlParser::AVG:
        case TSqlParser::BACKUP_PRIORITY:
        case TSqlParser::BEGIN_DIALOG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::BINDING:
        case TSqlParser::BLOB_STORAGE:
        case TSqlParser::BROKER:
        case TSqlParser::BROKER_INSTANCE:
        case TSqlParser::BULK_LOGGED:
        case TSqlParser::CALLER:
        case TSqlParser::CAP_CPU_PERCENT:
        case TSqlParser::CAST:
        case TSqlParser::CATALOG:
        case TSqlParser::CATCH:
        case TSqlParser::CHANGE_RETENTION:
        case TSqlParser::CHANGE_TRACKING:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::CLEANUP:
        case TSqlParser::COLLECTION:
        case TSqlParser::COLUMN_MASTER_KEY:
        case TSqlParser::COMMITTED:
        case TSqlParser::COMPATIBILITY_LEVEL:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::CONTENT:
        case TSqlParser::CONTROL:
        case TSqlParser::COOKIE:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::COUNTER:
        case TSqlParser::CPU:
        case TSqlParser::CREATE_NEW:
        case TSqlParser::CREATION_DISPOSITION:
        case TSqlParser::CREDENTIAL:
        case TSqlParser::CRYPTOGRAPHIC:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DB_CHAINING:
        case TSqlParser::DB_FAILOVER:
        case TSqlParser::DECRYPTION:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
        case TSqlParser::DEFAULT_LANGUAGE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DEPENDENTS:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DHCP:
        case TSqlParser::DIALOG:
        case TSqlParser::DIRECTORY_NAME:
        case TSqlParser::DISABLE:
        case TSqlParser::DISABLE_BROKER:
        case TSqlParser::DISABLED:
        case TSqlParser::DISK_DRIVE:
        case TSqlParser::DOCUMENT:
        case TSqlParser::DYNAMIC:
        case TSqlParser::EMERGENCY:
        case TSqlParser::EMPTY:
        case TSqlParser::ENABLE:
        case TSqlParser::ENABLE_BROKER:
        case TSqlParser::ENCRYPTED_VALUE:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::ENDPOINT_URL:
        case TSqlParser::ERROR_BROKER_CONVERSATIONS:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::EXECUTABLE:
        case TSqlParser::EXIST:
        case TSqlParser::EXPAND:
        case TSqlParser::EXPIRY_DATE:
        case TSqlParser::EXPLICIT:
        case TSqlParser::FAIL_OPERATION:
        case TSqlParser::FAILOVER_MODE:
        case TSqlParser::FAILURE:
        case TSqlParser::FAILURE_CONDITION_LEVEL:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FILEGROUP:
        case TSqlParser::FILEGROWTH:
        case TSqlParser::FILEPATH:
        case TSqlParser::FILESTREAM:
        case TSqlParser::FILTER:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
        case TSqlParser::FORCED:
        case TSqlParser::FORMAT:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::FULLSCAN:
        case TSqlParser::FULLTEXT:
        case TSqlParser::GB:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO:
        case TSqlParser::GROUP_MAX_REQUESTS:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HADR:
        case TSqlParser::HASH:
        case TSqlParser::HEALTH_CHECK_TIMEOUT:
        case TSqlParser::HIGH:
        case TSqlParser::HONOR_BROKER_PRIORITY:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case TSqlParser::IMMEDIATE:
        case TSqlParser::IMPERSONATE:
        case TSqlParser::IMPORTANCE:
        case TSqlParser::INCREMENTAL:
        case TSqlParser::INITIATOR:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::IP:
        case TSqlParser::ISOLATION:
        case TSqlParser::KB:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEY_SOURCE:
        case TSqlParser::KEYS:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LIST:
        case TSqlParser::LISTENER:
        case TSqlParser::LISTENER_URL:
        case TSqlParser::LOB_COMPACTION:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOGIN:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MATERIALIZED:
        case TSqlParser::MAX:
        case TSqlParser::MAX_CPU_PERCENT:
        case TSqlParser::MAX_DOP:
        case TSqlParser::MAX_FILES:
        case TSqlParser::MAX_IOPS_PER_VOLUME:
        case TSqlParser::MAX_MEMORY_PERCENT:
        case TSqlParser::MAX_PROCESSES:
        case TSqlParser::MAX_QUEUE_READERS:
        case TSqlParser::MAX_ROLLOVER_FILES:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MAXSIZE:
        case TSqlParser::MB:
        case TSqlParser::MEDIUM:
        case TSqlParser::MEMORY_OPTIMIZED_DATA:
        case TSqlParser::MESSAGE:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MIN_CPU_PERCENT:
        case TSqlParser::MIN_IOPS_PER_VOLUME:
        case TSqlParser::MIN_MEMORY_PERCENT:
        case TSqlParser::MINUTES:
        case TSqlParser::MIRROR_ADDRESS:
        case TSqlParser::MIXED_PAGE_ALLOCATION:
        case TSqlParser::MODE:
        case TSqlParser::MODIFY:
        case TSqlParser::MOVE:
        case TSqlParser::MULTI_USER:
        case TSqlParser::NAME:
        case TSqlParser::NESTED_TRIGGERS:
        case TSqlParser::NEW_ACCOUNT:
        case TSqlParser::NEW_BROKER:
        case TSqlParser::NEW_PASSWORD:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NO_TRUNCATE:
        case TSqlParser::NO_WAIT:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NON_TRANSACTED_ACCESS:
        case TSqlParser::NORECOMPUTE:
        case TSqlParser::NORECOVERY:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMBER:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFLINE:
        case TSqlParser::OFFSET:
        case TSqlParser::OLD_ACCOUNT:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPEN_EXISTING:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PAGE_VERIFY:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PARTNER:
        case TSqlParser::PATH:
        case TSqlParser::POISON_MESSAGE_HANDLING:
        case TSqlParser::POOL:
        case TSqlParser::PORT:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIMARY_ROLE:
        case TSqlParser::PRIOR:
        case TSqlParser::PRIORITY:
        case TSqlParser::PRIORITY_LEVEL:
        case TSqlParser::PRIVATE:
        case TSqlParser::PRIVATE_KEY:
        case TSqlParser::PRIVILEGES:
        case TSqlParser::PROCEDURE_NAME:
        case TSqlParser::PROPERTY:
        case TSqlParser::PROVIDER:
        case TSqlParser::PROVIDER_KEY_NAME:
        case TSqlParser::QUERY:
        case TSqlParser::QUEUE:
        case TSqlParser::QUEUE_DELAY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_COMMITTED_SNAPSHOT:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READ_ONLY_ROUTING_LIST:
        case TSqlParser::READ_WRITE:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECEIVE:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RECOVERY:
        case TSqlParser::RECURSIVE_TRIGGERS:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REMOTE_SERVICE_NAME:
        case TSqlParser::REMOVE:
        case TSqlParser::REORGANIZE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::REPLICA:
        case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
        case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
        case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
        case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
        case TSqlParser::RESERVE_DISK_SPACE:
        case TSqlParser::RESOURCE:
        case TSqlParser::RESOURCE_MANAGER_LOCATION:
        case TSqlParser::RESTRICTED_USER:
        case TSqlParser::RETENTION:
        case TSqlParser::ROBUST:
        case TSqlParser::ROOT:
        case TSqlParser::ROUTE:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SAMPLE:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCOPED:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SEARCH:
        case TSqlParser::SECONDARY:
        case TSqlParser::SECONDARY_ONLY:
        case TSqlParser::SECONDARY_ROLE:
        case TSqlParser::SECONDS:
        case TSqlParser::SECRET:
        case TSqlParser::SECURITY:
        case TSqlParser::SECURITY_LOG:
        case TSqlParser::SEEDING_MODE:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEND:
        case TSqlParser::SENT:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SESSION_TIMEOUT:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SHOWPLAN:
        case TSqlParser::SIGNATURE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SINGLE_USER:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STANDBY:
        case TSqlParser::START_DATE:
        case TSqlParser::STATIC:
        case TSqlParser::STATS_STREAM:
        case TSqlParser::STATUS:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STOPLIST:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBJECT:
        case TSqlParser::SUM:
        case TSqlParser::SUSPEND:
        case TSqlParser::SYMMETRIC:
        case TSqlParser::SYNCHRONOUS_COMMIT:
        case TSqlParser::SYNONYM:
        case TSqlParser::SYSTEM:
        case TSqlParser::TAKE:
        case TSqlParser::TARGET_RECOVERY_TIME:
        case TSqlParser::TB:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TIMER:
        case TSqlParser::TINYINT:
        case TSqlParser::TORN_PAGE_DETECTION:
        case TSqlParser::TRANSFORM_NOISE_WORDS:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRUSTWORTHY:
        case TSqlParser::TRY:
        case TSqlParser::TSQL:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UNLIMITED:
        case TSqlParser::USING:
        case TSqlParser::VALID_XML:
        case TSqlParser::VALIDATION:
        case TSqlParser::VALUE:
        case TSqlParser::VAR:
        case TSqlParser::VARP:
        case TSqlParser::VIEW_METADATA:
        case TSqlParser::VIEWS:
        case TSqlParser::WAIT:
        case TSqlParser::WELL_FORMED_XML:
        case TSqlParser::WORK:
        case TSqlParser::WORKLOAD:
        case TSqlParser::XML:
        case TSqlParser::XMLNAMESPACES:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID: {
          setState(2990);
          full_column_name();
          break;
        }

        case TSqlParser::LOCAL_ID: {
          setState(2991);
          match(TSqlParser::LOCAL_ID);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2996);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EQUAL: {
          setState(2994);
          match(TSqlParser::EQUAL);
          break;
        }

        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2995);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2998);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2999);
      dynamic_cast<Update_elemContext *>(_localctx)->udt_column_name = id();
      setState(3000);
      match(TSqlParser::DOT);
      setState(3001);
      dynamic_cast<Update_elemContext *>(_localctx)->method_name = id();
      setState(3002);
      match(TSqlParser::LR_BRACKET);
      setState(3003);
      expression_list();
      setState(3004);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_condition_listContext ------------------------------------------------------------------

TSqlParser::Search_condition_listContext::Search_condition_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::Search_condition_listContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::Search_condition_listContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Search_condition_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Search_condition_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Search_condition_listContext::getRuleIndex() const {
  return TSqlParser::RuleSearch_condition_list;
}

void TSqlParser::Search_condition_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_condition_list(this);
}

void TSqlParser::Search_condition_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_condition_list(this);
}

TSqlParser::Search_condition_listContext* TSqlParser::search_condition_list() {
  Search_condition_listContext *_localctx = _tracker.createInstance<Search_condition_listContext>(_ctx, getState());
  enterRule(_localctx, 280, TSqlParser::RuleSearch_condition_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3008);
    search_condition();
    setState(3013);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3009);
      match(TSqlParser::COMMA);
      setState(3010);
      search_condition();
      setState(3015);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_conditionContext ------------------------------------------------------------------

TSqlParser::Search_conditionContext::Search_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Search_condition_andContext *> TSqlParser::Search_conditionContext::search_condition_and() {
  return getRuleContexts<TSqlParser::Search_condition_andContext>();
}

TSqlParser::Search_condition_andContext* TSqlParser::Search_conditionContext::search_condition_and(size_t i) {
  return getRuleContext<TSqlParser::Search_condition_andContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Search_conditionContext::OR() {
  return getTokens(TSqlParser::OR);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::OR(size_t i) {
  return getToken(TSqlParser::OR, i);
}


size_t TSqlParser::Search_conditionContext::getRuleIndex() const {
  return TSqlParser::RuleSearch_condition;
}

void TSqlParser::Search_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_condition(this);
}

void TSqlParser::Search_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_condition(this);
}

TSqlParser::Search_conditionContext* TSqlParser::search_condition() {
  Search_conditionContext *_localctx = _tracker.createInstance<Search_conditionContext>(_ctx, getState());
  enterRule(_localctx, 282, TSqlParser::RuleSearch_condition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3016);
    search_condition_and();
    setState(3021);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::OR) {
      setState(3017);
      match(TSqlParser::OR);
      setState(3018);
      search_condition_and();
      setState(3023);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_condition_andContext ------------------------------------------------------------------

TSqlParser::Search_condition_andContext::Search_condition_andContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Search_condition_notContext *> TSqlParser::Search_condition_andContext::search_condition_not() {
  return getRuleContexts<TSqlParser::Search_condition_notContext>();
}

TSqlParser::Search_condition_notContext* TSqlParser::Search_condition_andContext::search_condition_not(size_t i) {
  return getRuleContext<TSqlParser::Search_condition_notContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Search_condition_andContext::AND() {
  return getTokens(TSqlParser::AND);
}

tree::TerminalNode* TSqlParser::Search_condition_andContext::AND(size_t i) {
  return getToken(TSqlParser::AND, i);
}


size_t TSqlParser::Search_condition_andContext::getRuleIndex() const {
  return TSqlParser::RuleSearch_condition_and;
}

void TSqlParser::Search_condition_andContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_condition_and(this);
}

void TSqlParser::Search_condition_andContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_condition_and(this);
}

TSqlParser::Search_condition_andContext* TSqlParser::search_condition_and() {
  Search_condition_andContext *_localctx = _tracker.createInstance<Search_condition_andContext>(_ctx, getState());
  enterRule(_localctx, 284, TSqlParser::RuleSearch_condition_and);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3024);
    search_condition_not();
    setState(3029);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::AND) {
      setState(3025);
      match(TSqlParser::AND);
      setState(3026);
      search_condition_not();
      setState(3031);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_condition_notContext ------------------------------------------------------------------

TSqlParser::Search_condition_notContext::Search_condition_notContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::PredicateContext* TSqlParser::Search_condition_notContext::predicate() {
  return getRuleContext<TSqlParser::PredicateContext>(0);
}

tree::TerminalNode* TSqlParser::Search_condition_notContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}


size_t TSqlParser::Search_condition_notContext::getRuleIndex() const {
  return TSqlParser::RuleSearch_condition_not;
}

void TSqlParser::Search_condition_notContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_condition_not(this);
}

void TSqlParser::Search_condition_notContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_condition_not(this);
}

TSqlParser::Search_condition_notContext* TSqlParser::search_condition_not() {
  Search_condition_notContext *_localctx = _tracker.createInstance<Search_condition_notContext>(_ctx, getState());
  enterRule(_localctx, 286, TSqlParser::RuleSearch_condition_not);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3033);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::NOT) {
      setState(3032);
      match(TSqlParser::NOT);
    }
    setState(3035);
    predicate();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

TSqlParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::PredicateContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::SubqueryContext* TSqlParser::PredicateContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::PredicateContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::PredicateContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::Comparison_operatorContext* TSqlParser::PredicateContext::comparison_operator() {
  return getRuleContext<TSqlParser::Comparison_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::SOME() {
  return getToken(TSqlParser::SOME, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ANY() {
  return getToken(TSqlParser::ANY, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::BETWEEN() {
  return getToken(TSqlParser::BETWEEN, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::AND() {
  return getToken(TSqlParser::AND, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Expression_listContext* TSqlParser::PredicateContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::LIKE() {
  return getToken(TSqlParser::LIKE, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ESCAPE() {
  return getToken(TSqlParser::ESCAPE, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::IS() {
  return getToken(TSqlParser::IS, 0);
}

TSqlParser::Null_notnullContext* TSqlParser::PredicateContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

TSqlParser::Search_conditionContext* TSqlParser::PredicateContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}


size_t TSqlParser::PredicateContext::getRuleIndex() const {
  return TSqlParser::RulePredicate;
}

void TSqlParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void TSqlParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

TSqlParser::PredicateContext* TSqlParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 288, TSqlParser::RulePredicate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3092);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 456, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3037);
      match(TSqlParser::EXISTS);
      setState(3038);
      match(TSqlParser::LR_BRACKET);
      setState(3039);
      subquery();
      setState(3040);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3042);
      expression(0);
      setState(3043);
      comparison_operator();
      setState(3044);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3046);
      expression(0);
      setState(3047);
      comparison_operator();
      setState(3048);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL

      || _la == TSqlParser::ANY || _la == TSqlParser::SOME)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3049);
      match(TSqlParser::LR_BRACKET);
      setState(3050);
      subquery();
      setState(3051);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3053);
      expression(0);
      setState(3055);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::NOT) {
        setState(3054);
        match(TSqlParser::NOT);
      }
      setState(3057);
      match(TSqlParser::BETWEEN);
      setState(3058);
      expression(0);
      setState(3059);
      match(TSqlParser::AND);
      setState(3060);
      expression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3062);
      expression(0);
      setState(3064);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::NOT) {
        setState(3063);
        match(TSqlParser::NOT);
      }
      setState(3066);
      match(TSqlParser::IN);
      setState(3067);
      match(TSqlParser::LR_BRACKET);
      setState(3070);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 453, _ctx)) {
      case 1: {
        setState(3068);
        subquery();
        break;
      }

      case 2: {
        setState(3069);
        expression_list();
        break;
      }

      }
      setState(3072);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3074);
      expression(0);
      setState(3076);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::NOT) {
        setState(3075);
        match(TSqlParser::NOT);
      }
      setState(3078);
      match(TSqlParser::LIKE);
      setState(3079);
      expression(0);
      setState(3082);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ESCAPE) {
        setState(3080);
        match(TSqlParser::ESCAPE);
        setState(3081);
        expression(0);
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3084);
      expression(0);
      setState(3085);
      match(TSqlParser::IS);
      setState(3086);
      null_notnull();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3088);
      match(TSqlParser::LR_BRACKET);
      setState(3089);
      search_condition();
      setState(3090);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_expressionContext ------------------------------------------------------------------

TSqlParser::Query_expressionContext::Query_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Query_specificationContext* TSqlParser::Query_expressionContext::query_specification() {
  return getRuleContext<TSqlParser::Query_specificationContext>(0);
}

tree::TerminalNode* TSqlParser::Query_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Query_expressionContext* TSqlParser::Query_expressionContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Query_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Sql_unionContext *> TSqlParser::Query_expressionContext::sql_union() {
  return getRuleContexts<TSqlParser::Sql_unionContext>();
}

TSqlParser::Sql_unionContext* TSqlParser::Query_expressionContext::sql_union(size_t i) {
  return getRuleContext<TSqlParser::Sql_unionContext>(i);
}


size_t TSqlParser::Query_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleQuery_expression;
}

void TSqlParser::Query_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery_expression(this);
}

void TSqlParser::Query_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery_expression(this);
}

TSqlParser::Query_expressionContext* TSqlParser::query_expression() {
  Query_expressionContext *_localctx = _tracker.createInstance<Query_expressionContext>(_ctx, getState());
  enterRule(_localctx, 290, TSqlParser::RuleQuery_expression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3099);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::SELECT: {
        setState(3094);
        query_specification();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        setState(3095);
        match(TSqlParser::LR_BRACKET);
        setState(3096);
        query_expression();
        setState(3097);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3104);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 458, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3101);
        sql_union(); 
      }
      setState(3106);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 458, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_unionContext ------------------------------------------------------------------

TSqlParser::Sql_unionContext::Sql_unionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Sql_unionContext::UNION() {
  return getToken(TSqlParser::UNION, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::EXCEPT() {
  return getToken(TSqlParser::EXCEPT, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::INTERSECT() {
  return getToken(TSqlParser::INTERSECT, 0);
}

TSqlParser::Query_specificationContext* TSqlParser::Sql_unionContext::query_specification() {
  return getRuleContext<TSqlParser::Query_specificationContext>(0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Query_expressionContext* TSqlParser::Sql_unionContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}


size_t TSqlParser::Sql_unionContext::getRuleIndex() const {
  return TSqlParser::RuleSql_union;
}

void TSqlParser::Sql_unionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_union(this);
}

void TSqlParser::Sql_unionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_union(this);
}

TSqlParser::Sql_unionContext* TSqlParser::sql_union() {
  Sql_unionContext *_localctx = _tracker.createInstance<Sql_unionContext>(_ctx, getState());
  enterRule(_localctx, 292, TSqlParser::RuleSql_union);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3113);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNION: {
        setState(3107);
        match(TSqlParser::UNION);
        setState(3109);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ALL) {
          setState(3108);
          match(TSqlParser::ALL);
        }
        break;
      }

      case TSqlParser::EXCEPT: {
        setState(3111);
        match(TSqlParser::EXCEPT);
        break;
      }

      case TSqlParser::INTERSECT: {
        setState(3112);
        match(TSqlParser::INTERSECT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3120);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::SELECT: {
        setState(3115);
        query_specification();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        setState(3116);
        match(TSqlParser::LR_BRACKET);
        setState(3117);
        query_expression();
        setState(3118);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_specificationContext ------------------------------------------------------------------

TSqlParser::Query_specificationContext::Query_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Query_specificationContext::SELECT() {
  return getToken(TSqlParser::SELECT, 0);
}

TSqlParser::Select_listContext* TSqlParser::Query_specificationContext::select_list() {
  return getRuleContext<TSqlParser::Select_listContext>(0);
}

TSqlParser::Top_clauseContext* TSqlParser::Query_specificationContext::top_clause() {
  return getRuleContext<TSqlParser::Top_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Query_specificationContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Query_specificationContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

std::vector<TSqlParser::Group_by_itemContext *> TSqlParser::Query_specificationContext::group_by_item() {
  return getRuleContexts<TSqlParser::Group_by_itemContext>();
}

TSqlParser::Group_by_itemContext* TSqlParser::Query_specificationContext::group_by_item(size_t i) {
  return getRuleContext<TSqlParser::Group_by_itemContext>(i);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::HAVING() {
  return getToken(TSqlParser::HAVING, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Query_specificationContext::ALL() {
  return getTokens(TSqlParser::ALL);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::ALL(size_t i) {
  return getToken(TSqlParser::ALL, i);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::Query_specificationContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::Query_specificationContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Query_specificationContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Query_specificationContext::getRuleIndex() const {
  return TSqlParser::RuleQuery_specification;
}

void TSqlParser::Query_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery_specification(this);
}

void TSqlParser::Query_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery_specification(this);
}

TSqlParser::Query_specificationContext* TSqlParser::query_specification() {
  Query_specificationContext *_localctx = _tracker.createInstance<Query_specificationContext>(_ctx, getState());
  enterRule(_localctx, 294, TSqlParser::RuleQuery_specification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3122);
    match(TSqlParser::SELECT);
    setState(3124);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ALL || _la == TSqlParser::DISTINCT) {
      setState(3123);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL || _la == TSqlParser::DISTINCT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3127);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(3126);
      top_clause();
    }
    setState(3129);
    select_list();
    setState(3132);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(3130);
      match(TSqlParser::INTO);
      setState(3131);
      table_name();
    }
    setState(3136);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(3134);
      match(TSqlParser::FROM);
      setState(3135);
      table_sources();
    }
    setState(3140);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 466, _ctx)) {
    case 1: {
      setState(3138);
      match(TSqlParser::WHERE);
      setState(3139);
      dynamic_cast<Query_specificationContext *>(_localctx)->where = search_condition();
      break;
    }

    }
    setState(3155);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx)) {
    case 1: {
      setState(3142);
      match(TSqlParser::GROUP);
      setState(3143);
      match(TSqlParser::BY);
      setState(3145);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ALL) {
        setState(3144);
        match(TSqlParser::ALL);
      }
      setState(3147);
      group_by_item();
      setState(3152);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 468, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3148);
          match(TSqlParser::COMMA);
          setState(3149);
          group_by_item(); 
        }
        setState(3154);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 468, _ctx);
      }
      break;
    }

    }
    setState(3159);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 470, _ctx)) {
    case 1: {
      setState(3157);
      match(TSqlParser::HAVING);
      setState(3158);
      dynamic_cast<Query_specificationContext *>(_localctx)->having = search_condition();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_clauseContext ------------------------------------------------------------------

TSqlParser::Top_clauseContext::Top_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_clauseContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

TSqlParser::Top_percentContext* TSqlParser::Top_clauseContext::top_percent() {
  return getRuleContext<TSqlParser::Top_percentContext>(0);
}

TSqlParser::Top_countContext* TSqlParser::Top_clauseContext::top_count() {
  return getRuleContext<TSqlParser::Top_countContext>(0);
}

tree::TerminalNode* TSqlParser::Top_clauseContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Top_clauseContext::TIES() {
  return getToken(TSqlParser::TIES, 0);
}


size_t TSqlParser::Top_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleTop_clause;
}

void TSqlParser::Top_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_clause(this);
}

void TSqlParser::Top_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_clause(this);
}

TSqlParser::Top_clauseContext* TSqlParser::top_clause() {
  Top_clauseContext *_localctx = _tracker.createInstance<Top_clauseContext>(_ctx, getState());
  enterRule(_localctx, 296, TSqlParser::RuleTop_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3161);
    match(TSqlParser::TOP);
    setState(3164);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 471, _ctx)) {
    case 1: {
      setState(3162);
      top_percent();
      break;
    }

    case 2: {
      setState(3163);
      top_count();
      break;
    }

    }
    setState(3168);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(3166);
      match(TSqlParser::WITH);
      setState(3167);
      match(TSqlParser::TIES);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_percentContext ------------------------------------------------------------------

TSqlParser::Top_percentContext::Top_percentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_percentContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::REAL() {
  return getToken(TSqlParser::REAL, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::FLOAT() {
  return getToken(TSqlParser::FLOAT, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Top_percentContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Top_percentContext::getRuleIndex() const {
  return TSqlParser::RuleTop_percent;
}

void TSqlParser::Top_percentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_percent(this);
}

void TSqlParser::Top_percentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_percent(this);
}

TSqlParser::Top_percentContext* TSqlParser::top_percent() {
  Top_percentContext *_localctx = _tracker.createInstance<Top_percentContext>(_ctx, getState());
  enterRule(_localctx, 298, TSqlParser::RuleTop_percent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3177);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::FLOAT:
      case TSqlParser::REAL: {
        enterOuterAlt(_localctx, 1);
        setState(3170);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FLOAT

        || _la == TSqlParser::REAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3171);
        match(TSqlParser::PERCENT);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(3172);
        match(TSqlParser::LR_BRACKET);
        setState(3173);
        expression(0);
        setState(3174);
        match(TSqlParser::RR_BRACKET);
        setState(3175);
        match(TSqlParser::PERCENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_countContext ------------------------------------------------------------------

TSqlParser::Top_countContext::Top_countContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_countContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Top_countContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Top_countContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Top_countContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Top_countContext::getRuleIndex() const {
  return TSqlParser::RuleTop_count;
}

void TSqlParser::Top_countContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_count(this);
}

void TSqlParser::Top_countContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_count(this);
}

TSqlParser::Top_countContext* TSqlParser::top_count() {
  Top_countContext *_localctx = _tracker.createInstance<Top_countContext>(_ctx, getState());
  enterRule(_localctx, 300, TSqlParser::RuleTop_count);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3184);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(3179);
        match(TSqlParser::DECIMAL);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(3180);
        match(TSqlParser::LR_BRACKET);
        setState(3181);
        expression(0);
        setState(3182);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_clauseContext ------------------------------------------------------------------

TSqlParser::Order_by_clauseContext::Order_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

std::vector<TSqlParser::Order_by_expressionContext *> TSqlParser::Order_by_clauseContext::order_by_expression() {
  return getRuleContexts<TSqlParser::Order_by_expressionContext>();
}

TSqlParser::Order_by_expressionContext* TSqlParser::Order_by_clauseContext::order_by_expression(size_t i) {
  return getRuleContext<TSqlParser::Order_by_expressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::OFFSET() {
  return getToken(TSqlParser::OFFSET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Order_by_clauseContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Order_by_clauseContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::ROW() {
  return getTokens(TSqlParser::ROW);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ROW(size_t i) {
  return getToken(TSqlParser::ROW, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::ROWS() {
  return getTokens(TSqlParser::ROWS);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ROWS(size_t i) {
  return getToken(TSqlParser::ROWS, i);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::FETCH() {
  return getToken(TSqlParser::FETCH, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}


size_t TSqlParser::Order_by_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOrder_by_clause;
}

void TSqlParser::Order_by_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_clause(this);
}

void TSqlParser::Order_by_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_clause(this);
}

TSqlParser::Order_by_clauseContext* TSqlParser::order_by_clause() {
  Order_by_clauseContext *_localctx = _tracker.createInstance<Order_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 302, TSqlParser::RuleOrder_by_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3186);
    match(TSqlParser::ORDER);
    setState(3187);
    match(TSqlParser::BY);
    setState(3188);
    order_by_expression();
    setState(3193);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3189);
        match(TSqlParser::COMMA);
        setState(3190);
        order_by_expression(); 
      }
      setState(3195);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx);
    }
    setState(3207);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 477, _ctx)) {
    case 1: {
      setState(3196);
      match(TSqlParser::OFFSET);
      setState(3197);
      expression(0);
      setState(3198);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ROW

      || _la == TSqlParser::ROWS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3205);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 476, _ctx)) {
      case 1: {
        setState(3199);
        match(TSqlParser::FETCH);
        setState(3200);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FIRST || _la == TSqlParser::NEXT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3201);
        expression(0);
        setState(3202);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ROW

        || _la == TSqlParser::ROWS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3203);
        match(TSqlParser::ONLY);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_clauseContext ------------------------------------------------------------------

TSqlParser::For_clauseContext::For_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::For_clauseContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::BROWSE() {
  return getToken(TSqlParser::BROWSE, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::XML() {
  return getToken(TSqlParser::XML, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::RAW() {
  return getToken(TSqlParser::RAW, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::AUTO() {
  return getToken(TSqlParser::AUTO, 0);
}

std::vector<TSqlParser::Xml_common_directivesContext *> TSqlParser::For_clauseContext::xml_common_directives() {
  return getRuleContexts<TSqlParser::Xml_common_directivesContext>();
}

TSqlParser::Xml_common_directivesContext* TSqlParser::For_clauseContext::xml_common_directives(size_t i) {
  return getRuleContext<TSqlParser::Xml_common_directivesContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::For_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::For_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::For_clauseContext::ELEMENTS() {
  return getToken(TSqlParser::ELEMENTS, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::XSINIL() {
  return getToken(TSqlParser::XSINIL, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::ABSENT() {
  return getToken(TSqlParser::ABSENT, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::For_clauseContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::For_clauseContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::For_clauseContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::For_clauseContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::For_clauseContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::For_clauseContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::For_clauseContext::XMLDATA() {
  return getToken(TSqlParser::XMLDATA, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::XMLSCHEMA() {
  return getToken(TSqlParser::XMLSCHEMA, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::EXPLICIT() {
  return getToken(TSqlParser::EXPLICIT, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::PATH() {
  return getToken(TSqlParser::PATH, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::JSON() {
  return getToken(TSqlParser::JSON, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::ROOT() {
  return getToken(TSqlParser::ROOT, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::INCLUDE_NULL_VALUES() {
  return getToken(TSqlParser::INCLUDE_NULL_VALUES, 0);
}

tree::TerminalNode* TSqlParser::For_clauseContext::WITHOUT_ARRAY_WRAPPER() {
  return getToken(TSqlParser::WITHOUT_ARRAY_WRAPPER, 0);
}


size_t TSqlParser::For_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleFor_clause;
}

void TSqlParser::For_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_clause(this);
}

void TSqlParser::For_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_clause(this);
}

TSqlParser::For_clauseContext* TSqlParser::for_clause() {
  For_clauseContext *_localctx = _tracker.createInstance<For_clauseContext>(_ctx, getState());
  enterRule(_localctx, 304, TSqlParser::RuleFor_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(3297);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 494, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3209);
      match(TSqlParser::FOR);
      setState(3210);
      match(TSqlParser::BROWSE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3211);
      match(TSqlParser::FOR);
      setState(3212);
      match(TSqlParser::XML);
      setState(3220);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::RAW: {
          setState(3213);
          match(TSqlParser::RAW);
          setState(3217);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx)) {
          case 1: {
            setState(3214);
            match(TSqlParser::LR_BRACKET);
            setState(3215);
            match(TSqlParser::STRING);
            setState(3216);
            match(TSqlParser::RR_BRACKET);
            break;
          }

          }
          break;
        }

        case TSqlParser::AUTO: {
          setState(3219);
          match(TSqlParser::AUTO);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3225);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3222);
          xml_common_directives(); 
        }
        setState(3227);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx);
      }
      setState(3238);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 483, _ctx)) {
      case 1: {
        setState(3228);
        match(TSqlParser::COMMA);
        setState(3236);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::XMLDATA: {
            setState(3229);
            match(TSqlParser::XMLDATA);
            break;
          }

          case TSqlParser::XMLSCHEMA: {
            setState(3230);
            match(TSqlParser::XMLSCHEMA);
            setState(3234);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 481, _ctx)) {
            case 1: {
              setState(3231);
              match(TSqlParser::LR_BRACKET);
              setState(3232);
              match(TSqlParser::STRING);
              setState(3233);
              match(TSqlParser::RR_BRACKET);
              break;
            }

            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      }
      setState(3243);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx)) {
      case 1: {
        setState(3240);
        match(TSqlParser::COMMA);
        setState(3241);
        match(TSqlParser::ELEMENTS);
        setState(3242);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ABSENT || _la == TSqlParser::XSINIL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3245);
      match(TSqlParser::FOR);
      setState(3246);
      match(TSqlParser::XML);
      setState(3247);
      match(TSqlParser::EXPLICIT);
      setState(3251);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 485, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3248);
          xml_common_directives(); 
        }
        setState(3253);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 485, _ctx);
      }
      setState(3256);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 486, _ctx)) {
      case 1: {
        setState(3254);
        match(TSqlParser::COMMA);
        setState(3255);
        match(TSqlParser::XMLDATA);
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3258);
      match(TSqlParser::FOR);
      setState(3259);
      match(TSqlParser::XML);
      setState(3260);
      match(TSqlParser::PATH);
      setState(3264);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 487, _ctx)) {
      case 1: {
        setState(3261);
        match(TSqlParser::LR_BRACKET);
        setState(3262);
        match(TSqlParser::STRING);
        setState(3263);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      }
      setState(3269);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 488, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3266);
          xml_common_directives(); 
        }
        setState(3271);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 488, _ctx);
      }
      setState(3275);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 489, _ctx)) {
      case 1: {
        setState(3272);
        match(TSqlParser::COMMA);
        setState(3273);
        match(TSqlParser::ELEMENTS);
        setState(3274);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ABSENT || _la == TSqlParser::XSINIL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3277);
      match(TSqlParser::FOR);
      setState(3278);
      match(TSqlParser::JSON);
      setState(3279);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::AUTO || _la == TSqlParser::PATH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3287);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 491, _ctx)) {
      case 1: {
        setState(3280);
        match(TSqlParser::COMMA);
        setState(3281);
        match(TSqlParser::ROOT);
        setState(3285);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 490, _ctx)) {
        case 1: {
          setState(3282);
          match(TSqlParser::LR_BRACKET);
          setState(3283);
          match(TSqlParser::STRING);
          setState(3284);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        }
        break;
      }

      }
      setState(3291);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 492, _ctx)) {
      case 1: {
        setState(3289);
        match(TSqlParser::COMMA);
        setState(3290);
        match(TSqlParser::INCLUDE_NULL_VALUES);
        break;
      }

      }
      setState(3295);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 493, _ctx)) {
      case 1: {
        setState(3293);
        match(TSqlParser::COMMA);
        setState(3294);
        match(TSqlParser::WITHOUT_ARRAY_WRAPPER);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_common_directivesContext ------------------------------------------------------------------

TSqlParser::Xml_common_directivesContext::Xml_common_directivesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Xml_common_directivesContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Xml_common_directivesContext::BINARY_BASE64() {
  return getToken(TSqlParser::BINARY_BASE64, 0);
}

tree::TerminalNode* TSqlParser::Xml_common_directivesContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Xml_common_directivesContext::ROOT() {
  return getToken(TSqlParser::ROOT, 0);
}

tree::TerminalNode* TSqlParser::Xml_common_directivesContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Xml_common_directivesContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Xml_common_directivesContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Xml_common_directivesContext::getRuleIndex() const {
  return TSqlParser::RuleXml_common_directives;
}

void TSqlParser::Xml_common_directivesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_common_directives(this);
}

void TSqlParser::Xml_common_directivesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_common_directives(this);
}

TSqlParser::Xml_common_directivesContext* TSqlParser::xml_common_directives() {
  Xml_common_directivesContext *_localctx = _tracker.createInstance<Xml_common_directivesContext>(_ctx, getState());
  enterRule(_localctx, 306, TSqlParser::RuleXml_common_directives);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3299);
    match(TSqlParser::COMMA);
    setState(3308);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BINARY_BASE64: {
        setState(3300);
        match(TSqlParser::BINARY_BASE64);
        break;
      }

      case TSqlParser::TYPE: {
        setState(3301);
        match(TSqlParser::TYPE);
        break;
      }

      case TSqlParser::ROOT: {
        setState(3302);
        match(TSqlParser::ROOT);
        setState(3306);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
        case 1: {
          setState(3303);
          match(TSqlParser::LR_BRACKET);
          setState(3304);
          match(TSqlParser::STRING);
          setState(3305);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_expressionContext ------------------------------------------------------------------

TSqlParser::Order_by_expressionContext::Order_by_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Order_by_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Order_by_expressionContext::ASC() {
  return getToken(TSqlParser::ASC, 0);
}

tree::TerminalNode* TSqlParser::Order_by_expressionContext::DESC() {
  return getToken(TSqlParser::DESC, 0);
}


size_t TSqlParser::Order_by_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleOrder_by_expression;
}

void TSqlParser::Order_by_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_expression(this);
}

void TSqlParser::Order_by_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_expression(this);
}

TSqlParser::Order_by_expressionContext* TSqlParser::order_by_expression() {
  Order_by_expressionContext *_localctx = _tracker.createInstance<Order_by_expressionContext>(_ctx, getState());
  enterRule(_localctx, 308, TSqlParser::RuleOrder_by_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3310);
    expression(0);
    setState(3312);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ASC || _la == TSqlParser::DESC) {
      setState(3311);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ASC || _la == TSqlParser::DESC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_itemContext ------------------------------------------------------------------

TSqlParser::Group_by_itemContext::Group_by_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Group_by_itemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Group_by_itemContext::getRuleIndex() const {
  return TSqlParser::RuleGroup_by_item;
}

void TSqlParser::Group_by_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_by_item(this);
}

void TSqlParser::Group_by_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_by_item(this);
}

TSqlParser::Group_by_itemContext* TSqlParser::group_by_item() {
  Group_by_itemContext *_localctx = _tracker.createInstance<Group_by_itemContext>(_ctx, getState());
  enterRule(_localctx, 310, TSqlParser::RuleGroup_by_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3314);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Option_clauseContext ------------------------------------------------------------------

TSqlParser::Option_clauseContext::Option_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Option_clauseContext::OPTION() {
  return getToken(TSqlParser::OPTION, 0);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::OptionContext *> TSqlParser::Option_clauseContext::option() {
  return getRuleContexts<TSqlParser::OptionContext>();
}

TSqlParser::OptionContext* TSqlParser::Option_clauseContext::option(size_t i) {
  return getRuleContext<TSqlParser::OptionContext>(i);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Option_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Option_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOption_clause;
}

void TSqlParser::Option_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption_clause(this);
}

void TSqlParser::Option_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption_clause(this);
}

TSqlParser::Option_clauseContext* TSqlParser::option_clause() {
  Option_clauseContext *_localctx = _tracker.createInstance<Option_clauseContext>(_ctx, getState());
  enterRule(_localctx, 312, TSqlParser::RuleOption_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3316);
    match(TSqlParser::OPTION);
    setState(3317);
    match(TSqlParser::LR_BRACKET);
    setState(3318);
    option();
    setState(3323);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3319);
      match(TSqlParser::COMMA);
      setState(3320);
      option();
      setState(3325);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3326);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext ------------------------------------------------------------------

TSqlParser::OptionContext::OptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::OptionContext::FAST() {
  return getToken(TSqlParser::FAST, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::UNION() {
  return getToken(TSqlParser::UNION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::CONCAT() {
  return getToken(TSqlParser::CONCAT, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::EXPAND() {
  return getToken(TSqlParser::EXPAND, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::VIEWS() {
  return getToken(TSqlParser::VIEWS, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FORCE() {
  return getToken(TSqlParser::FORCE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX() {
  return getToken(TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::KEEP() {
  return getToken(TSqlParser::KEEP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::PLAN() {
  return getToken(TSqlParser::PLAN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::KEEPFIXED() {
  return getToken(TSqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MAXDOP() {
  return getToken(TSqlParser::MAXDOP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MAXRECURSION() {
  return getToken(TSqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::OPTIMIZE() {
  return getToken(TSqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Optimize_for_argContext *> TSqlParser::OptionContext::optimize_for_arg() {
  return getRuleContexts<TSqlParser::Optimize_for_argContext>();
}

TSqlParser::Optimize_for_argContext* TSqlParser::OptionContext::optimize_for_arg(size_t i) {
  return getRuleContext<TSqlParser::Optimize_for_argContext>(i);
}

tree::TerminalNode* TSqlParser::OptionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::OptionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::OptionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::OptionContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::PARAMETERIZATION() {
  return getToken(TSqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::SIMPLE() {
  return getToken(TSqlParser::SIMPLE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FORCED() {
  return getToken(TSqlParser::FORCED, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::ROBUST() {
  return getToken(TSqlParser::ROBUST, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::USE() {
  return getToken(TSqlParser::USE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::OptionContext::getRuleIndex() const {
  return TSqlParser::RuleOption;
}

void TSqlParser::OptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption(this);
}

void TSqlParser::OptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption(this);
}

TSqlParser::OptionContext* TSqlParser::option() {
  OptionContext *_localctx = _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 314, TSqlParser::RuleOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3373);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3328);
      match(TSqlParser::FAST);
      setState(3329);
      dynamic_cast<OptionContext *>(_localctx)->number_rows = match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3330);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ORDER || _la == TSqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3331);
      match(TSqlParser::GROUP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3332);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::CONCAT || _la == TSqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3333);
      match(TSqlParser::UNION);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3334);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::HASH

      || _la == TSqlParser::LOOP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3335);
      match(TSqlParser::JOIN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3336);
      match(TSqlParser::EXPAND);
      setState(3337);
      match(TSqlParser::VIEWS);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3338);
      match(TSqlParser::FORCE);
      setState(3339);
      match(TSqlParser::ORDER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3340);
      match(TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3341);
      match(TSqlParser::KEEP);
      setState(3342);
      match(TSqlParser::PLAN);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3343);
      match(TSqlParser::KEEPFIXED);
      setState(3344);
      match(TSqlParser::PLAN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3345);
      match(TSqlParser::MAXDOP);
      setState(3346);
      dynamic_cast<OptionContext *>(_localctx)->number_of_processors = match(TSqlParser::DECIMAL);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3347);
      match(TSqlParser::MAXRECURSION);
      setState(3348);
      dynamic_cast<OptionContext *>(_localctx)->number_recursion = match(TSqlParser::DECIMAL);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3349);
      match(TSqlParser::OPTIMIZE);
      setState(3350);
      match(TSqlParser::FOR);
      setState(3351);
      match(TSqlParser::LR_BRACKET);
      setState(3352);
      optimize_for_arg();
      setState(3357);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(3353);
        match(TSqlParser::COMMA);
        setState(3354);
        optimize_for_arg();
        setState(3359);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3360);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3362);
      match(TSqlParser::OPTIMIZE);
      setState(3363);
      match(TSqlParser::FOR);
      setState(3364);
      match(TSqlParser::UNKNOWN);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3365);
      match(TSqlParser::PARAMETERIZATION);
      setState(3366);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::FORCED || _la == TSqlParser::SIMPLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3367);
      match(TSqlParser::RECOMPILE);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(3368);
      match(TSqlParser::ROBUST);
      setState(3369);
      match(TSqlParser::PLAN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(3370);
      match(TSqlParser::USE);
      setState(3371);
      match(TSqlParser::PLAN);
      setState(3372);
      match(TSqlParser::STRING);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optimize_for_argContext ------------------------------------------------------------------

TSqlParser::Optimize_for_argContext::Optimize_for_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ConstantContext* TSqlParser::Optimize_for_argContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::null() {
  return getToken(TSqlParser::null, 0);
}


size_t TSqlParser::Optimize_for_argContext::getRuleIndex() const {
  return TSqlParser::RuleOptimize_for_arg;
}

void TSqlParser::Optimize_for_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptimize_for_arg(this);
}

void TSqlParser::Optimize_for_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptimize_for_arg(this);
}

TSqlParser::Optimize_for_argContext* TSqlParser::optimize_for_arg() {
  Optimize_for_argContext *_localctx = _tracker.createInstance<Optimize_for_argContext>(_ctx, getState());
  enterRule(_localctx, 316, TSqlParser::RuleOptimize_for_arg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3375);
    match(TSqlParser::LOCAL_ID);
    setState(3382);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNKNOWN: {
        setState(3376);
        match(TSqlParser::UNKNOWN);
        break;
      }

      case TSqlParser::EQUAL: {
        setState(3377);
        match(TSqlParser::EQUAL);
        setState(3380);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::DECIMAL:
          case TSqlParser::STRING:
          case TSqlParser::BINARY:
          case TSqlParser::FLOAT:
          case TSqlParser::REAL:
          case TSqlParser::DOLLAR:
          case TSqlParser::PLUS:
          case TSqlParser::MINUS: {
            setState(3378);
            constant();
            break;
          }

          case TSqlParser::null: {
            setState(3379);
            match(TSqlParser::null);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_listContext ------------------------------------------------------------------

TSqlParser::Select_listContext::Select_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Select_list_elemContext *> TSqlParser::Select_listContext::select_list_elem() {
  return getRuleContexts<TSqlParser::Select_list_elemContext>();
}

TSqlParser::Select_list_elemContext* TSqlParser::Select_listContext::select_list_elem(size_t i) {
  return getRuleContext<TSqlParser::Select_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Select_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Select_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Select_listContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_list;
}

void TSqlParser::Select_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list(this);
}

void TSqlParser::Select_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list(this);
}

TSqlParser::Select_listContext* TSqlParser::select_list() {
  Select_listContext *_localctx = _tracker.createInstance<Select_listContext>(_ctx, getState());
  enterRule(_localctx, 318, TSqlParser::RuleSelect_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3384);
    select_list_elem();
    setState(3389);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 503, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3385);
        match(TSqlParser::COMMA);
        setState(3386);
        select_list_elem(); 
      }
      setState(3391);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 503, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udt_method_argumentsContext ------------------------------------------------------------------

TSqlParser::Udt_method_argumentsContext::Udt_method_argumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Execute_var_stringContext *> TSqlParser::Udt_method_argumentsContext::execute_var_string() {
  return getRuleContexts<TSqlParser::Execute_var_stringContext>();
}

TSqlParser::Execute_var_stringContext* TSqlParser::Udt_method_argumentsContext::execute_var_string(size_t i) {
  return getRuleContext<TSqlParser::Execute_var_stringContext>(i);
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Udt_method_argumentsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Udt_method_argumentsContext::getRuleIndex() const {
  return TSqlParser::RuleUdt_method_arguments;
}

void TSqlParser::Udt_method_argumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdt_method_arguments(this);
}

void TSqlParser::Udt_method_argumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdt_method_arguments(this);
}

TSqlParser::Udt_method_argumentsContext* TSqlParser::udt_method_arguments() {
  Udt_method_argumentsContext *_localctx = _tracker.createInstance<Udt_method_argumentsContext>(_ctx, getState());
  enterRule(_localctx, 320, TSqlParser::RuleUdt_method_arguments);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3392);
    match(TSqlParser::LR_BRACKET);
    setState(3393);
    execute_var_string();
    setState(3398);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3394);
      match(TSqlParser::COMMA);
      setState(3395);
      execute_var_string();
      setState(3400);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3401);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsteriskContext ------------------------------------------------------------------

TSqlParser::AsteriskContext::AsteriskContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::AsteriskContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

TSqlParser::Table_nameContext* TSqlParser::AsteriskContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::AsteriskContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::AsteriskContext::getRuleIndex() const {
  return TSqlParser::RuleAsterisk;
}

void TSqlParser::AsteriskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsterisk(this);
}

void TSqlParser::AsteriskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsterisk(this);
}

TSqlParser::AsteriskContext* TSqlParser::asterisk() {
  AsteriskContext *_localctx = _tracker.createInstance<AsteriskContext>(_ctx, getState());
  enterRule(_localctx, 322, TSqlParser::RuleAsterisk);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3406);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::BLOCKING_HIERARCHY

    || _la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
      | (1ULL << (TSqlParser::EVENTDATA - 85))
      | (1ULL << (TSqlParser::FILENAME - 85))
      | (1ULL << (TSqlParser::FILLFACTOR - 85))
      | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
      | (1ULL << (TSqlParser::KEY - 164))
      | (1ULL << (TSqlParser::MASTER - 164))
      | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
      | (1ULL << (TSqlParser::PAGE - 238))
      | (1ULL << (TSqlParser::PUBLIC - 238))
      | (1ULL << (TSqlParser::R - 238))
      | (1ULL << (TSqlParser::RAW - 238))
      | (1ULL << (TSqlParser::RETURN - 238))
      | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
      | (1ULL << (TSqlParser::SAFETY - 305))
      | (1ULL << (TSqlParser::SERVER - 305))
      | (1ULL << (TSqlParser::SID - 305))
      | (1ULL << (TSqlParser::SOURCE - 305))
      | (1ULL << (TSqlParser::SPLIT - 305))
      | (1ULL << (TSqlParser::STATE - 305))
      | (1ULL << (TSqlParser::START - 305))
      | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
      | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
      | (1ULL << (TSqlParser::ACTION - 405))
      | (1ULL << (TSqlParser::ACTIVATION - 405))
      | (1ULL << (TSqlParser::ACTIVE - 405))
      | (1ULL << (TSqlParser::ADDRESS - 405))
      | (1ULL << (TSqlParser::AES_128 - 405))
      | (1ULL << (TSqlParser::AES_192 - 405))
      | (1ULL << (TSqlParser::AES_256 - 405))
      | (1ULL << (TSqlParser::AFFINITY - 405))
      | (1ULL << (TSqlParser::AFTER - 405))
      | (1ULL << (TSqlParser::AGGREGATE - 405))
      | (1ULL << (TSqlParser::ALGORITHM - 405))
      | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
      | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
      | (1ULL << (TSqlParser::ALLOWED - 405))
      | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
      | (1ULL << (TSqlParser::ANSI_NULLS - 405))
      | (1ULL << (TSqlParser::ANSI_PADDING - 405))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
      | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
      | (1ULL << (TSqlParser::APPLY - 405))
      | (1ULL << (TSqlParser::ARITHABORT - 405))
      | (1ULL << (TSqlParser::ASSEMBLY - 405))
      | (1ULL << (TSqlParser::AUDIT - 405))
      | (1ULL << (TSqlParser::AUDIT_GUID - 405))
      | (1ULL << (TSqlParser::AUTO - 405))
      | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
      | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
      | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
      | (1ULL << (TSqlParser::AVAILABILITY - 405))
      | (1ULL << (TSqlParser::AVG - 405))
      | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
      | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
      | (1ULL << (TSqlParser::BIGINT - 405))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
      | (1ULL << (TSqlParser::BINDING - 405))
      | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
      | (1ULL << (TSqlParser::BROKER - 405))
      | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
      | (1ULL << (TSqlParser::BULK_LOGGED - 405))
      | (1ULL << (TSqlParser::CALLER - 405))
      | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
      | (1ULL << (TSqlParser::CAST - 405))
      | (1ULL << (TSqlParser::CATALOG - 405))
      | (1ULL << (TSqlParser::CATCH - 405))
      | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
      | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
      | (1ULL << (TSqlParser::CHECKSUM - 405))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
      | (1ULL << (TSqlParser::CLEANUP - 405))
      | (1ULL << (TSqlParser::COLLECTION - 405))
      | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
      | (1ULL << (TSqlParser::COMMITTED - 405))
      | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
      | (1ULL << (TSqlParser::CONCAT - 405))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
      | (1ULL << (TSqlParser::CONTENT - 405))
      | (1ULL << (TSqlParser::CONTROL - 405))
      | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
      | (1ULL << (TSqlParser::COUNT_BIG - 469))
      | (1ULL << (TSqlParser::COUNTER - 469))
      | (1ULL << (TSqlParser::CPU - 469))
      | (1ULL << (TSqlParser::CREATE_NEW - 469))
      | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
      | (1ULL << (TSqlParser::CREDENTIAL - 469))
      | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
      | (1ULL << (TSqlParser::DATA - 469))
      | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
      | (1ULL << (TSqlParser::DATEADD - 469))
      | (1ULL << (TSqlParser::DATEDIFF - 469))
      | (1ULL << (TSqlParser::DATENAME - 469))
      | (1ULL << (TSqlParser::DATEPART - 469))
      | (1ULL << (TSqlParser::DAYS - 469))
      | (1ULL << (TSqlParser::DB_CHAINING - 469))
      | (1ULL << (TSqlParser::DB_FAILOVER - 469))
      | (1ULL << (TSqlParser::DECRYPTION - 469))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
      | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DELAY - 469))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
      | (1ULL << (TSqlParser::DELETED - 469))
      | (1ULL << (TSqlParser::DENSE_RANK - 469))
      | (1ULL << (TSqlParser::DEPENDENTS - 469))
      | (1ULL << (TSqlParser::DES - 469))
      | (1ULL << (TSqlParser::DESCRIPTION - 469))
      | (1ULL << (TSqlParser::DESX - 469))
      | (1ULL << (TSqlParser::DHCP - 469))
      | (1ULL << (TSqlParser::DIALOG - 469))
      | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
      | (1ULL << (TSqlParser::DISABLE - 469))
      | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
      | (1ULL << (TSqlParser::DISABLED - 469))
      | (1ULL << (TSqlParser::DISK_DRIVE - 469))
      | (1ULL << (TSqlParser::DOCUMENT - 469))
      | (1ULL << (TSqlParser::DYNAMIC - 469))
      | (1ULL << (TSqlParser::EMERGENCY - 469))
      | (1ULL << (TSqlParser::EMPTY - 469))
      | (1ULL << (TSqlParser::ENABLE - 469))
      | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
      | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
      | (1ULL << (TSqlParser::ENCRYPTION - 469))
      | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
      | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
      | (1ULL << (TSqlParser::EXCLUSIVE - 469))
      | (1ULL << (TSqlParser::EXECUTABLE - 469))
      | (1ULL << (TSqlParser::EXIST - 469))
      | (1ULL << (TSqlParser::EXPAND - 469))
      | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
      | (1ULL << (TSqlParser::EXPLICIT - 469))
      | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
      | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
      | (1ULL << (TSqlParser::FAILURE - 469))
      | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
      | (1ULL << (TSqlParser::FAST - 469))
      | (1ULL << (TSqlParser::FAST_FORWARD - 469))
      | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
      | (1ULL << (TSqlParser::FILEPATH - 533))
      | (1ULL << (TSqlParser::FILESTREAM - 533))
      | (1ULL << (TSqlParser::FILTER - 533))
      | (1ULL << (TSqlParser::FIRST - 533))
      | (1ULL << (TSqlParser::FIRST_VALUE - 533))
      | (1ULL << (TSqlParser::FOLLOWING - 533))
      | (1ULL << (TSqlParser::FORCE - 533))
      | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
      | (1ULL << (TSqlParser::FORCED - 533))
      | (1ULL << (TSqlParser::FORMAT - 533))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
      | (1ULL << (TSqlParser::FULLSCAN - 533))
      | (1ULL << (TSqlParser::FULLTEXT - 533))
      | (1ULL << (TSqlParser::GB - 533))
      | (1ULL << (TSqlParser::GETDATE - 533))
      | (1ULL << (TSqlParser::GETUTCDATE - 533))
      | (1ULL << (TSqlParser::GLOBAL - 533))
      | (1ULL << (TSqlParser::GO - 533))
      | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
      | (1ULL << (TSqlParser::GROUPING - 533))
      | (1ULL << (TSqlParser::GROUPING_ID - 533))
      | (1ULL << (TSqlParser::HADR - 533))
      | (1ULL << (TSqlParser::HASH - 533))
      | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
      | (1ULL << (TSqlParser::HIGH - 533))
      | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
      | (1ULL << (TSqlParser::HOURS - 533))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
      | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
      | (1ULL << (TSqlParser::IMMEDIATE - 533))
      | (1ULL << (TSqlParser::IMPERSONATE - 533))
      | (1ULL << (TSqlParser::IMPORTANCE - 533))
      | (1ULL << (TSqlParser::INCREMENTAL - 533))
      | (1ULL << (TSqlParser::INITIATOR - 533))
      | (1ULL << (TSqlParser::INPUT - 533))
      | (1ULL << (TSqlParser::INSENSITIVE - 533))
      | (1ULL << (TSqlParser::INSERTED - 533))
      | (1ULL << (TSqlParser::INT - 533))
      | (1ULL << (TSqlParser::IP - 533))
      | (1ULL << (TSqlParser::ISOLATION - 533))
      | (1ULL << (TSqlParser::KB - 533))
      | (1ULL << (TSqlParser::KEEP - 533))
      | (1ULL << (TSqlParser::KEEPFIXED - 533))
      | (1ULL << (TSqlParser::KEY_SOURCE - 533))
      | (1ULL << (TSqlParser::KEYS - 533))
      | (1ULL << (TSqlParser::KEYSET - 533))
      | (1ULL << (TSqlParser::LAG - 533))
      | (1ULL << (TSqlParser::LAST - 533))
      | (1ULL << (TSqlParser::LAST_VALUE - 533))
      | (1ULL << (TSqlParser::LEAD - 533))
      | (1ULL << (TSqlParser::LEVEL - 533))
      | (1ULL << (TSqlParser::LIST - 533))
      | (1ULL << (TSqlParser::LISTENER - 533))
      | (1ULL << (TSqlParser::LISTENER_URL - 533))
      | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
      | (1ULL << (TSqlParser::LOCAL - 533))
      | (1ULL << (TSqlParser::LOCATION - 533))
      | (1ULL << (TSqlParser::LOCK - 533))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
      | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
      | (1ULL << (TSqlParser::LOW - 597))
      | (1ULL << (TSqlParser::MANUAL - 597))
      | (1ULL << (TSqlParser::MARK - 597))
      | (1ULL << (TSqlParser::MATERIALIZED - 597))
      | (1ULL << (TSqlParser::MAX - 597))
      | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_DOP - 597))
      | (1ULL << (TSqlParser::MAX_FILES - 597))
      | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
      | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
      | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
      | (1ULL << (TSqlParser::MAXDOP - 597))
      | (1ULL << (TSqlParser::MAXRECURSION - 597))
      | (1ULL << (TSqlParser::MAXSIZE - 597))
      | (1ULL << (TSqlParser::MB - 597))
      | (1ULL << (TSqlParser::MEDIUM - 597))
      | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
      | (1ULL << (TSqlParser::MESSAGE - 597))
      | (1ULL << (TSqlParser::MIN - 597))
      | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
      | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MINUTES - 597))
      | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
      | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
      | (1ULL << (TSqlParser::MODE - 597))
      | (1ULL << (TSqlParser::MODIFY - 597))
      | (1ULL << (TSqlParser::MOVE - 597))
      | (1ULL << (TSqlParser::MULTI_USER - 597))
      | (1ULL << (TSqlParser::NAME - 597))
      | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
      | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
      | (1ULL << (TSqlParser::NEW_BROKER - 597))
      | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
      | (1ULL << (TSqlParser::NEXT - 597))
      | (1ULL << (TSqlParser::NO - 597))
      | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
      | (1ULL << (TSqlParser::NO_WAIT - 597))
      | (1ULL << (TSqlParser::NOCOUNT - 597))
      | (1ULL << (TSqlParser::NODES - 597))
      | (1ULL << (TSqlParser::NOEXPAND - 597))
      | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
      | (1ULL << (TSqlParser::NORECOMPUTE - 597))
      | (1ULL << (TSqlParser::NORECOVERY - 597))
      | (1ULL << (TSqlParser::NOWAIT - 597))
      | (1ULL << (TSqlParser::NTILE - 597))
      | (1ULL << (TSqlParser::NUMANODE - 597))
      | (1ULL << (TSqlParser::NUMBER - 597))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
      | (1ULL << (TSqlParser::OBJECT - 597))
      | (1ULL << (TSqlParser::OFFLINE - 597))
      | (1ULL << (TSqlParser::OFFSET - 597))
      | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
      | (1ULL << (TSqlParser::ONLINE - 597))
      | (1ULL << (TSqlParser::ONLY - 597))
      | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
      | (1ULL << (TSqlParser::OPTIMISTIC - 597))
      | (1ULL << (TSqlParser::OPTIMIZE - 597))
      | (1ULL << (TSqlParser::OUT - 597))
      | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
      | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
      | (1ULL << (TSqlParser::PARTITION - 662))
      | (1ULL << (TSqlParser::PARTITIONS - 662))
      | (1ULL << (TSqlParser::PARTNER - 662))
      | (1ULL << (TSqlParser::PATH - 662))
      | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
      | (1ULL << (TSqlParser::POOL - 662))
      | (1ULL << (TSqlParser::PORT - 662))
      | (1ULL << (TSqlParser::PRECEDING - 662))
      | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
      | (1ULL << (TSqlParser::PRIOR - 662))
      | (1ULL << (TSqlParser::PRIORITY - 662))
      | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
      | (1ULL << (TSqlParser::PRIVATE - 662))
      | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
      | (1ULL << (TSqlParser::PRIVILEGES - 662))
      | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
      | (1ULL << (TSqlParser::PROPERTY - 662))
      | (1ULL << (TSqlParser::PROVIDER - 662))
      | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
      | (1ULL << (TSqlParser::QUERY - 662))
      | (1ULL << (TSqlParser::QUEUE - 662))
      | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
      | (1ULL << (TSqlParser::RANGE - 662))
      | (1ULL << (TSqlParser::RANK - 662))
      | (1ULL << (TSqlParser::RC2 - 662))
      | (1ULL << (TSqlParser::RC4 - 662))
      | (1ULL << (TSqlParser::RC4_128 - 662))
      | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
      | (1ULL << (TSqlParser::READ_ONLY - 662))
      | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
      | (1ULL << (TSqlParser::READ_WRITE - 662))
      | (1ULL << (TSqlParser::READONLY - 662))
      | (1ULL << (TSqlParser::REBUILD - 662))
      | (1ULL << (TSqlParser::RECEIVE - 662))
      | (1ULL << (TSqlParser::RECOMPILE - 662))
      | (1ULL << (TSqlParser::RECOVERY - 662))
      | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
      | (1ULL << (TSqlParser::RELATIVE - 662))
      | (1ULL << (TSqlParser::REMOTE - 662))
      | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
      | (1ULL << (TSqlParser::REMOVE - 662))
      | (1ULL << (TSqlParser::REORGANIZE - 662))
      | (1ULL << (TSqlParser::REPEATABLE - 662))
      | (1ULL << (TSqlParser::REPLICA - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
      | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
      | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
      | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
      | (1ULL << (TSqlParser::RESOURCE - 662))
      | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
      | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
      | (1ULL << (TSqlParser::RETENTION - 662))
      | (1ULL << (TSqlParser::ROBUST - 662))
      | (1ULL << (TSqlParser::ROOT - 662))
      | (1ULL << (TSqlParser::ROUTE - 662))
      | (1ULL << (TSqlParser::ROW - 662))
      | (1ULL << (TSqlParser::ROW_NUMBER - 662))
      | (1ULL << (TSqlParser::ROWGUID - 662))
      | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
      | (1ULL << (TSqlParser::SCHEMABINDING - 726))
      | (1ULL << (TSqlParser::SCOPED - 726))
      | (1ULL << (TSqlParser::SCROLL - 726))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
      | (1ULL << (TSqlParser::SEARCH - 726))
      | (1ULL << (TSqlParser::SECONDARY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
      | (1ULL << (TSqlParser::SECONDS - 726))
      | (1ULL << (TSqlParser::SECRET - 726))
      | (1ULL << (TSqlParser::SECURITY - 726))
      | (1ULL << (TSqlParser::SECURITY_LOG - 726))
      | (1ULL << (TSqlParser::SEEDING_MODE - 726))
      | (1ULL << (TSqlParser::SELF - 726))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
      | (1ULL << (TSqlParser::SEND - 726))
      | (1ULL << (TSqlParser::SENT - 726))
      | (1ULL << (TSqlParser::SEQUENCE - 726))
      | (1ULL << (TSqlParser::SERIALIZABLE - 726))
      | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
      | (1ULL << (TSqlParser::SETERROR - 726))
      | (1ULL << (TSqlParser::SHARE - 726))
      | (1ULL << (TSqlParser::SHOWPLAN - 726))
      | (1ULL << (TSqlParser::SIGNATURE - 726))
      | (1ULL << (TSqlParser::SIMPLE - 726))
      | (1ULL << (TSqlParser::SINGLE_USER - 726))
      | (1ULL << (TSqlParser::SIZE - 726))
      | (1ULL << (TSqlParser::SMALLINT - 726))
      | (1ULL << (TSqlParser::SNAPSHOT - 726))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
      | (1ULL << (TSqlParser::STANDBY - 726))
      | (1ULL << (TSqlParser::START_DATE - 726))
      | (1ULL << (TSqlParser::STATIC - 726))
      | (1ULL << (TSqlParser::STATS_STREAM - 726))
      | (1ULL << (TSqlParser::STATUS - 726))
      | (1ULL << (TSqlParser::STDEV - 726))
      | (1ULL << (TSqlParser::STDEVP - 726))
      | (1ULL << (TSqlParser::STOPLIST - 726))
      | (1ULL << (TSqlParser::STRING_AGG - 726))
      | (1ULL << (TSqlParser::STUFF - 726))
      | (1ULL << (TSqlParser::SUBJECT - 726))
      | (1ULL << (TSqlParser::SUM - 726))
      | (1ULL << (TSqlParser::SUSPEND - 726))
      | (1ULL << (TSqlParser::SYMMETRIC - 726))
      | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
      | (1ULL << (TSqlParser::SYNONYM - 726))
      | (1ULL << (TSqlParser::SYSTEM - 726))
      | (1ULL << (TSqlParser::TAKE - 726))
      | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
      | (1ULL << (TSqlParser::TB - 726))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
      | (1ULL << (TSqlParser::THROW - 726))
      | (1ULL << (TSqlParser::TIES - 726))
      | (1ULL << (TSqlParser::TIME - 726))
      | (1ULL << (TSqlParser::TIMEOUT - 726))
      | (1ULL << (TSqlParser::TIMER - 726))
      | (1ULL << (TSqlParser::TINYINT - 726))
      | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
      | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
      | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
      | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
      | (1ULL << (TSqlParser::TRY - 790))
      | (1ULL << (TSqlParser::TSQL - 790))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
      | (1ULL << (TSqlParser::TYPE - 790))
      | (1ULL << (TSqlParser::TYPE_WARNING - 790))
      | (1ULL << (TSqlParser::UNBOUNDED - 790))
      | (1ULL << (TSqlParser::UNCOMMITTED - 790))
      | (1ULL << (TSqlParser::UNKNOWN - 790))
      | (1ULL << (TSqlParser::UNLIMITED - 790))
      | (1ULL << (TSqlParser::USING - 790))
      | (1ULL << (TSqlParser::VALID_XML - 790))
      | (1ULL << (TSqlParser::VALIDATION - 790))
      | (1ULL << (TSqlParser::VALUE - 790))
      | (1ULL << (TSqlParser::VAR - 790))
      | (1ULL << (TSqlParser::VARP - 790))
      | (1ULL << (TSqlParser::VIEW_METADATA - 790))
      | (1ULL << (TSqlParser::VIEWS - 790))
      | (1ULL << (TSqlParser::WAIT - 790))
      | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
      | (1ULL << (TSqlParser::WORK - 790))
      | (1ULL << (TSqlParser::WORKLOAD - 790))
      | (1ULL << (TSqlParser::XML - 790))
      | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
      | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
      setState(3403);
      table_name();
      setState(3404);
      match(TSqlParser::DOT);
    }
    setState(3408);
    match(TSqlParser::STAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_elemContext ------------------------------------------------------------------

TSqlParser::Column_elemContext::Column_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_elemContext::null() {
  return getToken(TSqlParser::null, 0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Column_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::DOLLAR() {
  return getToken(TSqlParser::DOLLAR, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::ROWGUID() {
  return getToken(TSqlParser::ROWGUID, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Column_elemContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

TSqlParser::IdContext* TSqlParser::Column_elemContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}


size_t TSqlParser::Column_elemContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_elem;
}

void TSqlParser::Column_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_elem(this);
}

void TSqlParser::Column_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_elem(this);
}

TSqlParser::Column_elemContext* TSqlParser::column_elem() {
  Column_elemContext *_localctx = _tracker.createInstance<Column_elemContext>(_ctx, getState());
  enterRule(_localctx, 324, TSqlParser::RuleColumn_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3423);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID:
      case TSqlParser::DOLLAR: {
        setState(3413);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx)) {
        case 1: {
          setState(3410);
          table_name();
          setState(3411);
          match(TSqlParser::DOT);
          break;
        }

        }
        setState(3420);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
        case 1: {
          setState(3415);
          dynamic_cast<Column_elemContext *>(_localctx)->column_name = id();
          break;
        }

        case 2: {
          setState(3416);
          match(TSqlParser::DOLLAR);
          setState(3417);
          match(TSqlParser::IDENTITY);
          break;
        }

        case 3: {
          setState(3418);
          match(TSqlParser::DOLLAR);
          setState(3419);
          match(TSqlParser::ROWGUID);
          break;
        }

        }
        break;
      }

      case TSqlParser::null: {
        setState(3422);
        match(TSqlParser::null);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3426);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 509, _ctx)) {
    case 1: {
      setState(3425);
      as_column_alias();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udt_elemContext ------------------------------------------------------------------

TSqlParser::Udt_elemContext::Udt_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Udt_elemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

TSqlParser::Udt_method_argumentsContext* TSqlParser::Udt_elemContext::udt_method_arguments() {
  return getRuleContext<TSqlParser::Udt_method_argumentsContext>(0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Udt_elemContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Udt_elemContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

TSqlParser::As_column_aliasContext* TSqlParser::Udt_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Udt_elemContext::COLON() {
  return getTokens(TSqlParser::COLON);
}

tree::TerminalNode* TSqlParser::Udt_elemContext::COLON(size_t i) {
  return getToken(TSqlParser::COLON, i);
}


size_t TSqlParser::Udt_elemContext::getRuleIndex() const {
  return TSqlParser::RuleUdt_elem;
}

void TSqlParser::Udt_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdt_elem(this);
}

void TSqlParser::Udt_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdt_elem(this);
}

TSqlParser::Udt_elemContext* TSqlParser::udt_elem() {
  Udt_elemContext *_localctx = _tracker.createInstance<Udt_elemContext>(_ctx, getState());
  enterRule(_localctx, 326, TSqlParser::RuleUdt_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3445);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3428);
      dynamic_cast<Udt_elemContext *>(_localctx)->udt_column_name = id();
      setState(3429);
      match(TSqlParser::DOT);
      setState(3430);
      dynamic_cast<Udt_elemContext *>(_localctx)->non_static_attr = id();
      setState(3431);
      udt_method_arguments();
      setState(3433);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx)) {
      case 1: {
        setState(3432);
        as_column_alias();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3435);
      dynamic_cast<Udt_elemContext *>(_localctx)->udt_column_name = id();
      setState(3436);
      match(TSqlParser::COLON);
      setState(3437);
      match(TSqlParser::COLON);
      setState(3438);
      dynamic_cast<Udt_elemContext *>(_localctx)->static_attr = id();
      setState(3440);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 511, _ctx)) {
      case 1: {
        setState(3439);
        udt_method_arguments();
        break;
      }

      }
      setState(3443);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 512, _ctx)) {
      case 1: {
        setState(3442);
        as_column_alias();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_elemContext ------------------------------------------------------------------

TSqlParser::Expression_elemContext::Expression_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_aliasContext* TSqlParser::Expression_elemContext::column_alias() {
  return getRuleContext<TSqlParser::Column_aliasContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Expression_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Expression_elemContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Expression_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Expression_elemContext::getRuleIndex() const {
  return TSqlParser::RuleExpression_elem;
}

void TSqlParser::Expression_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_elem(this);
}

void TSqlParser::Expression_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_elem(this);
}

TSqlParser::Expression_elemContext* TSqlParser::expression_elem() {
  Expression_elemContext *_localctx = _tracker.createInstance<Expression_elemContext>(_ctx, getState());
  enterRule(_localctx, 328, TSqlParser::RuleExpression_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3455);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 515, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3447);
      column_alias();
      setState(3448);
      dynamic_cast<Expression_elemContext *>(_localctx)->eq = match(TSqlParser::EQUAL);
      setState(3449);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3451);
      expression(0);
      setState(3453);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 514, _ctx)) {
      case 1: {
        setState(3452);
        as_column_alias();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_elemContext ------------------------------------------------------------------

TSqlParser::Select_list_elemContext::Select_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::AsteriskContext* TSqlParser::Select_list_elemContext::asterisk() {
  return getRuleContext<TSqlParser::AsteriskContext>(0);
}

TSqlParser::Column_elemContext* TSqlParser::Select_list_elemContext::column_elem() {
  return getRuleContext<TSqlParser::Column_elemContext>(0);
}

TSqlParser::Udt_elemContext* TSqlParser::Select_list_elemContext::udt_elem() {
  return getRuleContext<TSqlParser::Udt_elemContext>(0);
}

TSqlParser::Expression_elemContext* TSqlParser::Select_list_elemContext::expression_elem() {
  return getRuleContext<TSqlParser::Expression_elemContext>(0);
}


size_t TSqlParser::Select_list_elemContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_list_elem;
}

void TSqlParser::Select_list_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_elem(this);
}

void TSqlParser::Select_list_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_elem(this);
}

TSqlParser::Select_list_elemContext* TSqlParser::select_list_elem() {
  Select_list_elemContext *_localctx = _tracker.createInstance<Select_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 330, TSqlParser::RuleSelect_list_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3461);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3457);
      asterisk();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3458);
      column_elem();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3459);
      udt_elem();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3460);
      expression_elem();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourcesContext ------------------------------------------------------------------

TSqlParser::Table_sourcesContext::Table_sourcesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Table_sourceContext *> TSqlParser::Table_sourcesContext::table_source() {
  return getRuleContexts<TSqlParser::Table_sourceContext>();
}

TSqlParser::Table_sourceContext* TSqlParser::Table_sourcesContext::table_source(size_t i) {
  return getRuleContext<TSqlParser::Table_sourceContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_sourcesContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_sourcesContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_sourcesContext::getRuleIndex() const {
  return TSqlParser::RuleTable_sources;
}

void TSqlParser::Table_sourcesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_sources(this);
}

void TSqlParser::Table_sourcesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_sources(this);
}

TSqlParser::Table_sourcesContext* TSqlParser::table_sources() {
  Table_sourcesContext *_localctx = _tracker.createInstance<Table_sourcesContext>(_ctx, getState());
  enterRule(_localctx, 332, TSqlParser::RuleTable_sources);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3463);
    table_source();
    setState(3468);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3464);
        match(TSqlParser::COMMA);
        setState(3465);
        table_source(); 
      }
      setState(3470);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourceContext ------------------------------------------------------------------

TSqlParser::Table_sourceContext::Table_sourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::Table_sourceContext::table_source_item_joined() {
  return getRuleContext<TSqlParser::Table_source_item_joinedContext>(0);
}

tree::TerminalNode* TSqlParser::Table_sourceContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Table_sourceContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_sourceContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source;
}

void TSqlParser::Table_sourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source(this);
}

void TSqlParser::Table_sourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source(this);
}

TSqlParser::Table_sourceContext* TSqlParser::table_source() {
  Table_sourceContext *_localctx = _tracker.createInstance<Table_sourceContext>(_ctx, getState());
  enterRule(_localctx, 334, TSqlParser::RuleTable_source);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3476);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 518, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3471);
      table_source_item_joined();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3472);
      match(TSqlParser::LR_BRACKET);
      setState(3473);
      table_source_item_joined();
      setState(3474);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_source_item_joinedContext ------------------------------------------------------------------

TSqlParser::Table_source_item_joinedContext::Table_source_item_joinedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_source_itemContext* TSqlParser::Table_source_item_joinedContext::table_source_item() {
  return getRuleContext<TSqlParser::Table_source_itemContext>(0);
}

std::vector<TSqlParser::Join_partContext *> TSqlParser::Table_source_item_joinedContext::join_part() {
  return getRuleContexts<TSqlParser::Join_partContext>();
}

TSqlParser::Join_partContext* TSqlParser::Table_source_item_joinedContext::join_part(size_t i) {
  return getRuleContext<TSqlParser::Join_partContext>(i);
}


size_t TSqlParser::Table_source_item_joinedContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source_item_joined;
}

void TSqlParser::Table_source_item_joinedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source_item_joined(this);
}

void TSqlParser::Table_source_item_joinedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source_item_joined(this);
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::table_source_item_joined() {
  Table_source_item_joinedContext *_localctx = _tracker.createInstance<Table_source_item_joinedContext>(_ctx, getState());
  enterRule(_localctx, 336, TSqlParser::RuleTable_source_item_joined);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3478);
    table_source_item();
    setState(3482);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 519, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3479);
        join_part(); 
      }
      setState(3484);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 519, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_source_itemContext ------------------------------------------------------------------

TSqlParser::Table_source_itemContext::Table_source_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_name_with_hintContext* TSqlParser::Table_source_itemContext::table_name_with_hint() {
  return getRuleContext<TSqlParser::Table_name_with_hintContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::Table_source_itemContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Table_source_itemContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

TSqlParser::Rowset_functionContext* TSqlParser::Table_source_itemContext::rowset_function() {
  return getRuleContext<TSqlParser::Rowset_functionContext>(0);
}

TSqlParser::Derived_tableContext* TSqlParser::Table_source_itemContext::derived_table() {
  return getRuleContext<TSqlParser::Derived_tableContext>(0);
}

TSqlParser::Column_alias_listContext* TSqlParser::Table_source_itemContext::column_alias_list() {
  return getRuleContext<TSqlParser::Column_alias_listContext>(0);
}

TSqlParser::Change_tableContext* TSqlParser::Table_source_itemContext::change_table() {
  return getRuleContext<TSqlParser::Change_tableContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::Table_source_itemContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

TSqlParser::Open_xmlContext* TSqlParser::Table_source_itemContext::open_xml() {
  return getRuleContext<TSqlParser::Open_xmlContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_source_itemContext::COLON() {
  return getTokens(TSqlParser::COLON);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::COLON(size_t i) {
  return getToken(TSqlParser::COLON, i);
}


size_t TSqlParser::Table_source_itemContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source_item;
}

void TSqlParser::Table_source_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source_item(this);
}

void TSqlParser::Table_source_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source_item(this);
}

TSqlParser::Table_source_itemContext* TSqlParser::table_source_item() {
  Table_source_itemContext *_localctx = _tracker.createInstance<Table_source_itemContext>(_ctx, getState());
  enterRule(_localctx, 338, TSqlParser::RuleTable_source_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3534);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 531, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3485);
      table_name_with_hint();
      setState(3487);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 520, _ctx)) {
      case 1: {
        setState(3486);
        as_table_alias();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3489);
      full_table_name();
      setState(3491);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 521, _ctx)) {
      case 1: {
        setState(3490);
        as_table_alias();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3493);
      rowset_function();
      setState(3495);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 522, _ctx)) {
      case 1: {
        setState(3494);
        as_table_alias();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3497);
      derived_table();
      setState(3502);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 524, _ctx)) {
      case 1: {
        setState(3498);
        as_table_alias();
        setState(3500);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 523, _ctx)) {
        case 1: {
          setState(3499);
          column_alias_list();
          break;
        }

        }
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3504);
      change_table();
      setState(3505);
      as_table_alias();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3507);
      function_call();
      setState(3512);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 526, _ctx)) {
      case 1: {
        setState(3508);
        as_table_alias();
        setState(3510);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx)) {
        case 1: {
          setState(3509);
          column_alias_list();
          break;
        }

        }
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3514);
      match(TSqlParser::LOCAL_ID);
      setState(3516);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 527, _ctx)) {
      case 1: {
        setState(3515);
        as_table_alias();
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3518);
      match(TSqlParser::LOCAL_ID);
      setState(3519);
      match(TSqlParser::DOT);
      setState(3520);
      function_call();
      setState(3525);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx)) {
      case 1: {
        setState(3521);
        as_table_alias();
        setState(3523);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 528, _ctx)) {
        case 1: {
          setState(3522);
          column_alias_list();
          break;
        }

        }
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3527);
      open_xml();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3528);
      match(TSqlParser::COLON);
      setState(3529);
      match(TSqlParser::COLON);
      setState(3530);
      function_call();
      setState(3532);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 530, _ctx)) {
      case 1: {
        setState(3531);
        as_table_alias();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Open_xmlContext ------------------------------------------------------------------

TSqlParser::Open_xmlContext::Open_xmlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Open_xmlContext::OPENXML() {
  return getToken(TSqlParser::OPENXML, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Open_xmlContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Open_xmlContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Open_xmlContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Open_xmlContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Open_xmlContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Open_xmlContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Open_xmlContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Open_xmlContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Open_xmlContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

TSqlParser::Schema_declarationContext* TSqlParser::Open_xmlContext::schema_declaration() {
  return getRuleContext<TSqlParser::Schema_declarationContext>(0);
}


size_t TSqlParser::Open_xmlContext::getRuleIndex() const {
  return TSqlParser::RuleOpen_xml;
}

void TSqlParser::Open_xmlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpen_xml(this);
}

void TSqlParser::Open_xmlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpen_xml(this);
}

TSqlParser::Open_xmlContext* TSqlParser::open_xml() {
  Open_xmlContext *_localctx = _tracker.createInstance<Open_xmlContext>(_ctx, getState());
  enterRule(_localctx, 340, TSqlParser::RuleOpen_xml);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3536);
    match(TSqlParser::OPENXML);
    setState(3537);
    match(TSqlParser::LR_BRACKET);
    setState(3538);
    expression(0);
    setState(3539);
    match(TSqlParser::COMMA);
    setState(3540);
    expression(0);
    setState(3543);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(3541);
      match(TSqlParser::COMMA);
      setState(3542);
      expression(0);
    }
    setState(3545);
    match(TSqlParser::RR_BRACKET);
    setState(3551);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 533, _ctx)) {
    case 1: {
      setState(3546);
      match(TSqlParser::WITH);
      setState(3547);
      match(TSqlParser::LR_BRACKET);
      setState(3548);
      schema_declaration();
      setState(3549);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_declarationContext ------------------------------------------------------------------

TSqlParser::Schema_declarationContext::Schema_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Column_declarationContext *> TSqlParser::Schema_declarationContext::column_declaration() {
  return getRuleContexts<TSqlParser::Column_declarationContext>();
}

TSqlParser::Column_declarationContext* TSqlParser::Schema_declarationContext::column_declaration(size_t i) {
  return getRuleContext<TSqlParser::Column_declarationContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Schema_declarationContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Schema_declarationContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Schema_declarationContext::getRuleIndex() const {
  return TSqlParser::RuleSchema_declaration;
}

void TSqlParser::Schema_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_declaration(this);
}

void TSqlParser::Schema_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_declaration(this);
}

TSqlParser::Schema_declarationContext* TSqlParser::schema_declaration() {
  Schema_declarationContext *_localctx = _tracker.createInstance<Schema_declarationContext>(_ctx, getState());
  enterRule(_localctx, 342, TSqlParser::RuleSchema_declaration);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3553);
    column_declaration();
    setState(3558);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3554);
      match(TSqlParser::COMMA);
      setState(3555);
      column_declaration();
      setState(3560);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_declarationContext ------------------------------------------------------------------

TSqlParser::Column_declarationContext::Column_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_declarationContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Column_declarationContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Column_declarationContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Column_declarationContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_declaration;
}

void TSqlParser::Column_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_declaration(this);
}

void TSqlParser::Column_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_declaration(this);
}

TSqlParser::Column_declarationContext* TSqlParser::column_declaration() {
  Column_declarationContext *_localctx = _tracker.createInstance<Column_declarationContext>(_ctx, getState());
  enterRule(_localctx, 344, TSqlParser::RuleColumn_declaration);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3561);
    match(TSqlParser::ID);
    setState(3562);
    data_type();
    setState(3564);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::STRING) {
      setState(3563);
      match(TSqlParser::STRING);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_tableContext ------------------------------------------------------------------

TSqlParser::Change_tableContext::Change_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Change_tableContext::CHANGETABLE() {
  return getToken(TSqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* TSqlParser::Change_tableContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Change_tableContext::CHANGES() {
  return getToken(TSqlParser::CHANGES, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Change_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Change_tableContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Change_tableContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Change_tableContext::null() {
  return getToken(TSqlParser::null, 0);
}

tree::TerminalNode* TSqlParser::Change_tableContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Change_tableContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Change_tableContext::getRuleIndex() const {
  return TSqlParser::RuleChange_table;
}

void TSqlParser::Change_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange_table(this);
}

void TSqlParser::Change_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange_table(this);
}

TSqlParser::Change_tableContext* TSqlParser::change_table() {
  Change_tableContext *_localctx = _tracker.createInstance<Change_tableContext>(_ctx, getState());
  enterRule(_localctx, 346, TSqlParser::RuleChange_table);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3566);
    match(TSqlParser::CHANGETABLE);
    setState(3567);
    match(TSqlParser::LR_BRACKET);
    setState(3568);
    match(TSqlParser::CHANGES);
    setState(3569);
    table_name();
    setState(3570);
    match(TSqlParser::COMMA);
    setState(3571);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::null || _la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3572);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_partContext ------------------------------------------------------------------

TSqlParser::Join_partContext::Join_partContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Join_partContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Join_partContext::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}

tree::TerminalNode* TSqlParser::Join_partContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Join_partContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Join_partContext::LEFT() {
  return getToken(TSqlParser::LEFT, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::RIGHT() {
  return getToken(TSqlParser::RIGHT, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::FULL() {
  return getToken(TSqlParser::FULL, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::INNER() {
  return getToken(TSqlParser::INNER, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::OUTER() {
  return getToken(TSqlParser::OUTER, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::REMOTE() {
  return getToken(TSqlParser::REMOTE, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::CROSS() {
  return getToken(TSqlParser::CROSS, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::APPLY() {
  return getToken(TSqlParser::APPLY, 0);
}

tree::TerminalNode* TSqlParser::Join_partContext::PIVOT() {
  return getToken(TSqlParser::PIVOT, 0);
}

TSqlParser::Pivot_clauseContext* TSqlParser::Join_partContext::pivot_clause() {
  return getRuleContext<TSqlParser::Pivot_clauseContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::Join_partContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Join_partContext::UNPIVOT() {
  return getToken(TSqlParser::UNPIVOT, 0);
}

TSqlParser::Unpivot_clauseContext* TSqlParser::Join_partContext::unpivot_clause() {
  return getRuleContext<TSqlParser::Unpivot_clauseContext>(0);
}


size_t TSqlParser::Join_partContext::getRuleIndex() const {
  return TSqlParser::RuleJoin_part;
}

void TSqlParser::Join_partContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_part(this);
}

void TSqlParser::Join_partContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_part(this);
}

TSqlParser::Join_partContext* TSqlParser::join_part() {
  Join_partContext *_localctx = _tracker.createInstance<Join_partContext>(_ctx, getState());
  enterRule(_localctx, 348, TSqlParser::RuleJoin_part);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3608);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 540, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3581);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::INNER:
        case TSqlParser::JOIN:
        case TSqlParser::MERGE:
        case TSqlParser::HASH:
        case TSqlParser::LOOP:
        case TSqlParser::REMOTE: {
          setState(3575);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::INNER) {
            setState(3574);
            match(TSqlParser::INNER);
          }
          break;
        }

        case TSqlParser::FULL:
        case TSqlParser::LEFT:
        case TSqlParser::RIGHT: {
          setState(3577);
          dynamic_cast<Join_partContext *>(_localctx)->join_type = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::FULL

          || _la == TSqlParser::LEFT || _la == TSqlParser::RIGHT)) {
            dynamic_cast<Join_partContext *>(_localctx)->join_type = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3579);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::OUTER) {
            setState(3578);
            match(TSqlParser::OUTER);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3584);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::MERGE || _la == TSqlParser::HASH

      || _la == TSqlParser::LOOP || _la == TSqlParser::REMOTE) {
        setState(3583);
        dynamic_cast<Join_partContext *>(_localctx)->join_hint = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::MERGE || _la == TSqlParser::HASH

        || _la == TSqlParser::LOOP || _la == TSqlParser::REMOTE)) {
          dynamic_cast<Join_partContext *>(_localctx)->join_hint = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(3586);
      match(TSqlParser::JOIN);
      setState(3587);
      table_source();
      setState(3588);
      match(TSqlParser::ON);
      setState(3589);
      search_condition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3591);
      match(TSqlParser::CROSS);
      setState(3592);
      match(TSqlParser::JOIN);
      setState(3593);
      table_source();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3594);
      match(TSqlParser::CROSS);
      setState(3595);
      match(TSqlParser::APPLY);
      setState(3596);
      table_source();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3597);
      match(TSqlParser::OUTER);
      setState(3598);
      match(TSqlParser::APPLY);
      setState(3599);
      table_source();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3600);
      match(TSqlParser::PIVOT);
      setState(3601);
      pivot_clause();
      setState(3602);
      as_table_alias();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3604);
      match(TSqlParser::UNPIVOT);
      setState(3605);
      unpivot_clause();
      setState(3606);
      as_table_alias();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pivot_clauseContext ------------------------------------------------------------------

TSqlParser::Pivot_clauseContext::Pivot_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::Pivot_clauseContext::aggregate_windowed_function() {
  return getRuleContext<TSqlParser::Aggregate_windowed_functionContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Pivot_clauseContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Column_alias_listContext* TSqlParser::Pivot_clauseContext::column_alias_list() {
  return getRuleContext<TSqlParser::Column_alias_listContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Pivot_clauseContext::getRuleIndex() const {
  return TSqlParser::RulePivot_clause;
}

void TSqlParser::Pivot_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPivot_clause(this);
}

void TSqlParser::Pivot_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPivot_clause(this);
}

TSqlParser::Pivot_clauseContext* TSqlParser::pivot_clause() {
  Pivot_clauseContext *_localctx = _tracker.createInstance<Pivot_clauseContext>(_ctx, getState());
  enterRule(_localctx, 350, TSqlParser::RulePivot_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3610);
    match(TSqlParser::LR_BRACKET);
    setState(3611);
    aggregate_windowed_function();
    setState(3612);
    match(TSqlParser::FOR);
    setState(3613);
    full_column_name();
    setState(3614);
    match(TSqlParser::IN);
    setState(3615);
    column_alias_list();
    setState(3616);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unpivot_clauseContext ------------------------------------------------------------------

TSqlParser::Unpivot_clauseContext::Unpivot_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Unpivot_clauseContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::ExpressionContext* TSqlParser::Unpivot_clauseContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Unpivot_clauseContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Full_column_name_listContext* TSqlParser::Unpivot_clauseContext::full_column_name_list() {
  return getRuleContext<TSqlParser::Full_column_name_listContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Unpivot_clauseContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}


size_t TSqlParser::Unpivot_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleUnpivot_clause;
}

void TSqlParser::Unpivot_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnpivot_clause(this);
}

void TSqlParser::Unpivot_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnpivot_clause(this);
}

TSqlParser::Unpivot_clauseContext* TSqlParser::unpivot_clause() {
  Unpivot_clauseContext *_localctx = _tracker.createInstance<Unpivot_clauseContext>(_ctx, getState());
  enterRule(_localctx, 352, TSqlParser::RuleUnpivot_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3618);
    match(TSqlParser::LR_BRACKET);
    setState(3619);
    expression(0);
    setState(3620);
    match(TSqlParser::FOR);
    setState(3621);
    full_column_name();
    setState(3622);
    match(TSqlParser::IN);
    setState(3623);
    match(TSqlParser::LR_BRACKET);
    setState(3624);
    full_column_name_list();
    setState(3625);
    match(TSqlParser::RR_BRACKET);
    setState(3626);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_column_name_listContext ------------------------------------------------------------------

TSqlParser::Full_column_name_listContext::Full_column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Full_column_nameContext *> TSqlParser::Full_column_name_listContext::full_column_name() {
  return getRuleContexts<TSqlParser::Full_column_nameContext>();
}

TSqlParser::Full_column_nameContext* TSqlParser::Full_column_name_listContext::full_column_name(size_t i) {
  return getRuleContext<TSqlParser::Full_column_nameContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Full_column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Full_column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Full_column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleFull_column_name_list;
}

void TSqlParser::Full_column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_column_name_list(this);
}

void TSqlParser::Full_column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_column_name_list(this);
}

TSqlParser::Full_column_name_listContext* TSqlParser::full_column_name_list() {
  Full_column_name_listContext *_localctx = _tracker.createInstance<Full_column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 354, TSqlParser::RuleFull_column_name_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3628);
    full_column_name();
    setState(3633);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3629);
      match(TSqlParser::COMMA);
      setState(3630);
      full_column_name();
      setState(3635);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_name_with_hintContext ------------------------------------------------------------------

TSqlParser::Table_name_with_hintContext::Table_name_with_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_nameContext* TSqlParser::Table_name_with_hintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Table_name_with_hintContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}


size_t TSqlParser::Table_name_with_hintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_name_with_hint;
}

void TSqlParser::Table_name_with_hintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name_with_hint(this);
}

void TSqlParser::Table_name_with_hintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name_with_hint(this);
}

TSqlParser::Table_name_with_hintContext* TSqlParser::table_name_with_hint() {
  Table_name_with_hintContext *_localctx = _tracker.createInstance<Table_name_with_hintContext>(_ctx, getState());
  enterRule(_localctx, 356, TSqlParser::RuleTable_name_with_hint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3636);
    table_name();
    setState(3638);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 542, _ctx)) {
    case 1: {
      setState(3637);
      with_table_hints();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rowset_functionContext ------------------------------------------------------------------

TSqlParser::Rowset_functionContext::Rowset_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Rowset_functionContext::OPENROWSET() {
  return getToken(TSqlParser::OPENROWSET, 0);
}

tree::TerminalNode* TSqlParser::Rowset_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Rowset_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Rowset_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Rowset_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Rowset_functionContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Rowset_functionContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

tree::TerminalNode* TSqlParser::Rowset_functionContext::BULK() {
  return getToken(TSqlParser::BULK, 0);
}

std::vector<TSqlParser::Bulk_optionContext *> TSqlParser::Rowset_functionContext::bulk_option() {
  return getRuleContexts<TSqlParser::Bulk_optionContext>();
}

TSqlParser::Bulk_optionContext* TSqlParser::Rowset_functionContext::bulk_option(size_t i) {
  return getRuleContext<TSqlParser::Bulk_optionContext>(i);
}

TSqlParser::IdContext* TSqlParser::Rowset_functionContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}


size_t TSqlParser::Rowset_functionContext::getRuleIndex() const {
  return TSqlParser::RuleRowset_function;
}

void TSqlParser::Rowset_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowset_function(this);
}

void TSqlParser::Rowset_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowset_function(this);
}

TSqlParser::Rowset_functionContext* TSqlParser::rowset_function() {
  Rowset_functionContext *_localctx = _tracker.createInstance<Rowset_functionContext>(_ctx, getState());
  enterRule(_localctx, 358, TSqlParser::RuleRowset_function);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3666);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 545, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3640);
      match(TSqlParser::OPENROWSET);
      setState(3641);
      match(TSqlParser::LR_BRACKET);
      setState(3642);
      dynamic_cast<Rowset_functionContext *>(_localctx)->provider_name = match(TSqlParser::STRING);
      setState(3643);
      match(TSqlParser::COMMA);
      setState(3644);
      dynamic_cast<Rowset_functionContext *>(_localctx)->connectionString = match(TSqlParser::STRING);
      setState(3645);
      match(TSqlParser::COMMA);
      setState(3646);
      dynamic_cast<Rowset_functionContext *>(_localctx)->sql = match(TSqlParser::STRING);
      setState(3647);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3648);
      match(TSqlParser::OPENROWSET);
      setState(3649);
      match(TSqlParser::LR_BRACKET);
      setState(3650);
      match(TSqlParser::BULK);
      setState(3651);
      dynamic_cast<Rowset_functionContext *>(_localctx)->data_file = match(TSqlParser::STRING);
      setState(3652);
      match(TSqlParser::COMMA);
      setState(3662);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 544, _ctx)) {
      case 1: {
        setState(3653);
        bulk_option();
        setState(3658);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(3654);
          match(TSqlParser::COMMA);
          setState(3655);
          bulk_option();
          setState(3660);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(3661);
        id();
        break;
      }

      }
      setState(3664);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bulk_optionContext ------------------------------------------------------------------

TSqlParser::Bulk_optionContext::Bulk_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Bulk_optionContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Bulk_optionContext::getRuleIndex() const {
  return TSqlParser::RuleBulk_option;
}

void TSqlParser::Bulk_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBulk_option(this);
}

void TSqlParser::Bulk_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBulk_option(this);
}

TSqlParser::Bulk_optionContext* TSqlParser::bulk_option() {
  Bulk_optionContext *_localctx = _tracker.createInstance<Bulk_optionContext>(_ctx, getState());
  enterRule(_localctx, 360, TSqlParser::RuleBulk_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3668);
    id();
    setState(3669);
    match(TSqlParser::EQUAL);
    setState(3670);
    dynamic_cast<Bulk_optionContext *>(_localctx)->bulk_option_value = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::DECIMAL

    || _la == TSqlParser::STRING)) {
      dynamic_cast<Bulk_optionContext *>(_localctx)->bulk_option_value = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Derived_tableContext ------------------------------------------------------------------

TSqlParser::Derived_tableContext::Derived_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::SubqueryContext* TSqlParser::Derived_tableContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::Derived_tableContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Derived_tableContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Table_value_constructorContext* TSqlParser::Derived_tableContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}


size_t TSqlParser::Derived_tableContext::getRuleIndex() const {
  return TSqlParser::RuleDerived_table;
}

void TSqlParser::Derived_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerived_table(this);
}

void TSqlParser::Derived_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerived_table(this);
}

TSqlParser::Derived_tableContext* TSqlParser::derived_table() {
  Derived_tableContext *_localctx = _tracker.createInstance<Derived_tableContext>(_ctx, getState());
  enterRule(_localctx, 362, TSqlParser::RuleDerived_table);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3682);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 546, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3672);
      subquery();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3673);
      match(TSqlParser::LR_BRACKET);
      setState(3674);
      subquery();
      setState(3675);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3677);
      table_value_constructor();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3678);
      match(TSqlParser::LR_BRACKET);
      setState(3679);
      table_value_constructor();
      setState(3680);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

TSqlParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TSqlParser::Function_callContext::getRuleIndex() const {
  return TSqlParser::RuleFunction_call;
}

void TSqlParser::Function_callContext::copyFrom(Function_callContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CURRENT_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CURRENT_USERContext::CURRENT_USER() {
  return getToken(TSqlParser::CURRENT_USER, 0);
}

TSqlParser::CURRENT_USERContext::CURRENT_USERContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::CURRENT_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCURRENT_USER(this);
}
void TSqlParser::CURRENT_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCURRENT_USER(this);
}
//----------------- DATEADDContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEADDContext::DATEADD() {
  return getToken(TSqlParser::DATEADD, 0);
}

tree::TerminalNode* TSqlParser::DATEADDContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEADDContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::DATEADDContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::DATEADDContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::DATEADDContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::DATEADDContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::DATEADDContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::DATEADDContext::DATEADDContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEADDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEADD(this);
}
void TSqlParser::DATEADDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEADD(this);
}
//----------------- CHECKSUMContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CHECKSUMContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::CHECKSUMContext::CHECKSUMContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::CHECKSUMContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCHECKSUM(this);
}
void TSqlParser::CHECKSUMContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCHECKSUM(this);
}
//----------------- CURRENT_TIMESTAMPContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CURRENT_TIMESTAMPContext::CURRENT_TIMESTAMP() {
  return getToken(TSqlParser::CURRENT_TIMESTAMP, 0);
}

TSqlParser::CURRENT_TIMESTAMPContext::CURRENT_TIMESTAMPContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::CURRENT_TIMESTAMPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCURRENT_TIMESTAMP(this);
}
void TSqlParser::CURRENT_TIMESTAMPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCURRENT_TIMESTAMP(this);
}
//----------------- BINARY_CHECKSUMContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::BINARY_CHECKSUMContext::BINARY_CHECKSUMContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::BINARY_CHECKSUMContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBINARY_CHECKSUM(this);
}
void TSqlParser::BINARY_CHECKSUMContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBINARY_CHECKSUM(this);
}
//----------------- IFFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::IFFContext::IIF() {
  return getToken(TSqlParser::IIF, 0);
}

tree::TerminalNode* TSqlParser::IFFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::IFFContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::IFFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::IFFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::IFFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::IFFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::IFFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::IFFContext::IFFContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::IFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIFF(this);
}
void TSqlParser::IFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIFF(this);
}
//----------------- SYSTEM_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::SYSTEM_USERContext::SYSTEM_USER() {
  return getToken(TSqlParser::SYSTEM_USER, 0);
}

TSqlParser::SYSTEM_USERContext::SYSTEM_USERContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::SYSTEM_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSYSTEM_USER(this);
}
void TSqlParser::SYSTEM_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSYSTEM_USER(this);
}
//----------------- NULLIFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::NULLIFContext::NULLIF() {
  return getToken(TSqlParser::NULLIF, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::NULLIFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::NULLIFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::NULLIFContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::NULLIFContext::NULLIFContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::NULLIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNULLIF(this);
}
void TSqlParser::NULLIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNULLIF(this);
}
//----------------- SESSION_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::SESSION_USERContext::SESSION_USER() {
  return getToken(TSqlParser::SESSION_USER, 0);
}

TSqlParser::SESSION_USERContext::SESSION_USERContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::SESSION_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSESSION_USER(this);
}
void TSqlParser::SESSION_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSESSION_USER(this);
}
//----------------- CONVERTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CONVERTContext::CONVERT() {
  return getToken(TSqlParser::CONVERT, 0);
}

tree::TerminalNode* TSqlParser::CONVERTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::CONVERTContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::CONVERTContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::CONVERTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Data_typeContext* TSqlParser::CONVERTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::CONVERTContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::CONVERTContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::CONVERTContext::CONVERTContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::CONVERTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCONVERT(this);
}
void TSqlParser::CONVERTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCONVERT(this);
}
//----------------- XML_DATA_TYPE_FUNCContext ------------------------------------------------------------------

TSqlParser::Xml_data_type_methodsContext* TSqlParser::XML_DATA_TYPE_FUNCContext::xml_data_type_methods() {
  return getRuleContext<TSqlParser::Xml_data_type_methodsContext>(0);
}

TSqlParser::XML_DATA_TYPE_FUNCContext::XML_DATA_TYPE_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::XML_DATA_TYPE_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXML_DATA_TYPE_FUNC(this);
}
void TSqlParser::XML_DATA_TYPE_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXML_DATA_TYPE_FUNC(this);
}
//----------------- COALESCEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::COALESCEContext::COALESCE() {
  return getToken(TSqlParser::COALESCE, 0);
}

tree::TerminalNode* TSqlParser::COALESCEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::COALESCEContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::COALESCEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::COALESCEContext::COALESCEContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::COALESCEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCOALESCE(this);
}
void TSqlParser::COALESCEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCOALESCE(this);
}
//----------------- CASTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CASTContext::CAST() {
  return getToken(TSqlParser::CAST, 0);
}

tree::TerminalNode* TSqlParser::CASTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::CASTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::CASTContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::CASTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::CASTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::CASTContext::CASTContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::CASTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCAST(this);
}
void TSqlParser::CASTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCAST(this);
}
//----------------- MIN_ACTIVE_ROWVERSIONContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::MIN_ACTIVE_ROWVERSIONContext::MIN_ACTIVE_ROWVERSION() {
  return getToken(TSqlParser::MIN_ACTIVE_ROWVERSION, 0);
}

TSqlParser::MIN_ACTIVE_ROWVERSIONContext::MIN_ACTIVE_ROWVERSIONContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::MIN_ACTIVE_ROWVERSIONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMIN_ACTIVE_ROWVERSION(this);
}
void TSqlParser::MIN_ACTIVE_ROWVERSIONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMIN_ACTIVE_ROWVERSION(this);
}
//----------------- SCALAR_FUNCTIONContext ------------------------------------------------------------------

TSqlParser::Scalar_function_nameContext* TSqlParser::SCALAR_FUNCTIONContext::scalar_function_name() {
  return getRuleContext<TSqlParser::Scalar_function_nameContext>(0);
}

tree::TerminalNode* TSqlParser::SCALAR_FUNCTIONContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::SCALAR_FUNCTIONContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::SCALAR_FUNCTIONContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

TSqlParser::SCALAR_FUNCTIONContext::SCALAR_FUNCTIONContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::SCALAR_FUNCTIONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSCALAR_FUNCTION(this);
}
void TSqlParser::SCALAR_FUNCTIONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSCALAR_FUNCTION(this);
}
//----------------- DATEPARTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEPARTContext::DATEPART() {
  return getToken(TSqlParser::DATEPART, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

TSqlParser::ExpressionContext* TSqlParser::DATEPARTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::DATEPARTContext::DATEPARTContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEPARTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEPART(this);
}
void TSqlParser::DATEPARTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEPART(this);
}
//----------------- STUFFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::STUFFContext::STUFF() {
  return getToken(TSqlParser::STUFF, 0);
}

tree::TerminalNode* TSqlParser::STUFFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::STUFFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::STUFFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::STUFFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::STUFFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::STUFFContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::STUFFContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

tree::TerminalNode* TSqlParser::STUFFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::STUFFContext::STUFFContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::STUFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSTUFF(this);
}
void TSqlParser::STUFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSTUFF(this);
}
//----------------- AGGREGATE_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::AGGREGATE_WINDOWED_FUNCContext::aggregate_windowed_function() {
  return getRuleContext<TSqlParser::Aggregate_windowed_functionContext>(0);
}

TSqlParser::AGGREGATE_WINDOWED_FUNCContext::AGGREGATE_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::AGGREGATE_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAGGREGATE_WINDOWED_FUNC(this);
}
void TSqlParser::AGGREGATE_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAGGREGATE_WINDOWED_FUNC(this);
}
//----------------- IDENTITYContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::IDENTITYContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Data_typeContext* TSqlParser::IDENTITYContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::IDENTITYContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::IDENTITYContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

TSqlParser::IDENTITYContext::IDENTITYContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::IDENTITYContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIDENTITY(this);
}
void TSqlParser::IDENTITYContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIDENTITY(this);
}
//----------------- RANKING_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Ranking_windowed_functionContext* TSqlParser::RANKING_WINDOWED_FUNCContext::ranking_windowed_function() {
  return getRuleContext<TSqlParser::Ranking_windowed_functionContext>(0);
}

TSqlParser::RANKING_WINDOWED_FUNCContext::RANKING_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::RANKING_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRANKING_WINDOWED_FUNC(this);
}
void TSqlParser::RANKING_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRANKING_WINDOWED_FUNC(this);
}
//----------------- DATENAMEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATENAMEContext::DATENAME() {
  return getToken(TSqlParser::DATENAME, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

TSqlParser::ExpressionContext* TSqlParser::DATENAMEContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::DATENAMEContext::DATENAMEContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATENAMEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATENAME(this);
}
void TSqlParser::DATENAMEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATENAME(this);
}
//----------------- GETUTCDATEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::GETUTCDATEContext::GETUTCDATE() {
  return getToken(TSqlParser::GETUTCDATE, 0);
}

tree::TerminalNode* TSqlParser::GETUTCDATEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::GETUTCDATEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::GETUTCDATEContext::GETUTCDATEContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::GETUTCDATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGETUTCDATE(this);
}
void TSqlParser::GETUTCDATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGETUTCDATE(this);
}
//----------------- ANALYTIC_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Analytic_windowed_functionContext* TSqlParser::ANALYTIC_WINDOWED_FUNCContext::analytic_windowed_function() {
  return getRuleContext<TSqlParser::Analytic_windowed_functionContext>(0);
}

TSqlParser::ANALYTIC_WINDOWED_FUNCContext::ANALYTIC_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::ANALYTIC_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterANALYTIC_WINDOWED_FUNC(this);
}
void TSqlParser::ANALYTIC_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitANALYTIC_WINDOWED_FUNC(this);
}
//----------------- ISNULLContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::ISNULLContext::ISNULL() {
  return getToken(TSqlParser::ISNULL, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::ISNULLContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::ISNULLContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::ISNULLContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::ISNULLContext::ISNULLContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::ISNULLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterISNULL(this);
}
void TSqlParser::ISNULLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitISNULL(this);
}
//----------------- DATEDIFFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEDIFFContext::DATEDIFF() {
  return getToken(TSqlParser::DATEDIFF, 0);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::DATEDIFFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::DATEDIFFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::DATEDIFFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::DATEDIFFContext::DATEDIFFContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEDIFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEDIFF(this);
}
void TSqlParser::DATEDIFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEDIFF(this);
}
//----------------- GETDATEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::GETDATEContext::GETDATE() {
  return getToken(TSqlParser::GETDATE, 0);
}

tree::TerminalNode* TSqlParser::GETDATEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::GETDATEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::GETDATEContext::GETDATEContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::GETDATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGETDATE(this);
}
void TSqlParser::GETDATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGETDATE(this);
}
//----------------- STRINGAGGContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::STRINGAGGContext::STRING_AGG() {
  return getToken(TSqlParser::STRING_AGG, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STRINGAGGContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STRINGAGGContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::STRINGAGGContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::STRINGAGGContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::WITHIN() {
  return getToken(TSqlParser::WITHIN, 0);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::STRINGAGGContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::STRINGAGGContext::STRINGAGGContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::STRINGAGGContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSTRINGAGG(this);
}
void TSqlParser::STRINGAGGContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSTRINGAGG(this);
}
TSqlParser::Function_callContext* TSqlParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 364, TSqlParser::RuleFunction_call);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3830);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 552, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::BINARY_CHECKSUMContext>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(3684);
      match(TSqlParser::BINARY_CHECKSUM);
      setState(3685);
      match(TSqlParser::LR_BRACKET);
      setState(3686);
      match(TSqlParser::STAR);
      setState(3687);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::CASTContext>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(3688);
      match(TSqlParser::CAST);
      setState(3689);
      match(TSqlParser::LR_BRACKET);
      setState(3690);
      expression(0);
      setState(3691);
      match(TSqlParser::AS);
      setState(3692);
      data_type();
      setState(3693);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::CONVERTContext>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(3695);
      match(TSqlParser::CONVERT);
      setState(3696);
      match(TSqlParser::LR_BRACKET);
      setState(3697);
      dynamic_cast<CONVERTContext *>(_localctx)->convert_data_type = data_type();
      setState(3698);
      match(TSqlParser::COMMA);
      setState(3699);
      dynamic_cast<CONVERTContext *>(_localctx)->convert_expression = expression(0);
      setState(3702);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3700);
        match(TSqlParser::COMMA);
        setState(3701);
        dynamic_cast<CONVERTContext *>(_localctx)->style = expression(0);
      }
      setState(3704);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::CHECKSUMContext>(_localctx));
      enterOuterAlt(_localctx, 4);
      setState(3706);
      match(TSqlParser::CHECKSUM);
      setState(3707);
      match(TSqlParser::LR_BRACKET);
      setState(3708);
      match(TSqlParser::STAR);
      setState(3709);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 5: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::COALESCEContext>(_localctx));
      enterOuterAlt(_localctx, 5);
      setState(3710);
      match(TSqlParser::COALESCE);
      setState(3711);
      match(TSqlParser::LR_BRACKET);
      setState(3712);
      expression_list();
      setState(3713);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::CURRENT_TIMESTAMPContext>(_localctx));
      enterOuterAlt(_localctx, 6);
      setState(3715);
      match(TSqlParser::CURRENT_TIMESTAMP);
      break;
    }

    case 7: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::CURRENT_USERContext>(_localctx));
      enterOuterAlt(_localctx, 7);
      setState(3716);
      match(TSqlParser::CURRENT_USER);
      break;
    }

    case 8: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::DATEADDContext>(_localctx));
      enterOuterAlt(_localctx, 8);
      setState(3717);
      match(TSqlParser::DATEADD);
      setState(3718);
      match(TSqlParser::LR_BRACKET);
      setState(3719);
      match(TSqlParser::ID);
      setState(3720);
      match(TSqlParser::COMMA);
      setState(3721);
      expression(0);
      setState(3722);
      match(TSqlParser::COMMA);
      setState(3723);
      expression(0);
      setState(3724);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 9: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::DATEDIFFContext>(_localctx));
      enterOuterAlt(_localctx, 9);
      setState(3726);
      match(TSqlParser::DATEDIFF);
      setState(3727);
      match(TSqlParser::LR_BRACKET);
      setState(3728);
      match(TSqlParser::ID);
      setState(3729);
      match(TSqlParser::COMMA);
      setState(3730);
      expression(0);
      setState(3731);
      match(TSqlParser::COMMA);
      setState(3732);
      expression(0);
      setState(3733);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 10: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::DATENAMEContext>(_localctx));
      enterOuterAlt(_localctx, 10);
      setState(3735);
      match(TSqlParser::DATENAME);
      setState(3736);
      match(TSqlParser::LR_BRACKET);
      setState(3737);
      match(TSqlParser::ID);
      setState(3738);
      match(TSqlParser::COMMA);
      setState(3739);
      expression(0);
      setState(3740);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 11: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::DATEPARTContext>(_localctx));
      enterOuterAlt(_localctx, 11);
      setState(3742);
      match(TSqlParser::DATEPART);
      setState(3743);
      match(TSqlParser::LR_BRACKET);
      setState(3744);
      match(TSqlParser::ID);
      setState(3745);
      match(TSqlParser::COMMA);
      setState(3746);
      expression(0);
      setState(3747);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 12: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::GETDATEContext>(_localctx));
      enterOuterAlt(_localctx, 12);
      setState(3749);
      match(TSqlParser::GETDATE);
      setState(3750);
      match(TSqlParser::LR_BRACKET);
      setState(3751);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 13: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::GETUTCDATEContext>(_localctx));
      enterOuterAlt(_localctx, 13);
      setState(3752);
      match(TSqlParser::GETUTCDATE);
      setState(3753);
      match(TSqlParser::LR_BRACKET);
      setState(3754);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 14: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::IDENTITYContext>(_localctx));
      enterOuterAlt(_localctx, 14);
      setState(3755);
      match(TSqlParser::IDENTITY);
      setState(3756);
      match(TSqlParser::LR_BRACKET);
      setState(3757);
      data_type();
      setState(3760);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 548, _ctx)) {
      case 1: {
        setState(3758);
        match(TSqlParser::COMMA);
        setState(3759);
        dynamic_cast<IDENTITYContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
        break;
      }

      }
      setState(3764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3762);
        match(TSqlParser::COMMA);
        setState(3763);
        dynamic_cast<IDENTITYContext *>(_localctx)->increment = match(TSqlParser::DECIMAL);
      }
      setState(3766);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 15: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::MIN_ACTIVE_ROWVERSIONContext>(_localctx));
      enterOuterAlt(_localctx, 15);
      setState(3768);
      match(TSqlParser::MIN_ACTIVE_ROWVERSION);
      break;
    }

    case 16: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::NULLIFContext>(_localctx));
      enterOuterAlt(_localctx, 16);
      setState(3769);
      match(TSqlParser::NULLIF);
      setState(3770);
      match(TSqlParser::LR_BRACKET);
      setState(3771);
      expression(0);
      setState(3772);
      match(TSqlParser::COMMA);
      setState(3773);
      expression(0);
      setState(3774);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 17: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::STUFFContext>(_localctx));
      enterOuterAlt(_localctx, 17);
      setState(3776);
      match(TSqlParser::STUFF);
      setState(3777);
      match(TSqlParser::LR_BRACKET);
      setState(3778);
      expression(0);
      setState(3779);
      match(TSqlParser::COMMA);
      setState(3780);
      match(TSqlParser::DECIMAL);
      setState(3781);
      match(TSqlParser::COMMA);
      setState(3782);
      match(TSqlParser::DECIMAL);
      setState(3783);
      match(TSqlParser::COMMA);
      setState(3784);
      expression(0);
      setState(3785);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 18: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::SESSION_USERContext>(_localctx));
      enterOuterAlt(_localctx, 18);
      setState(3787);
      match(TSqlParser::SESSION_USER);
      break;
    }

    case 19: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::SYSTEM_USERContext>(_localctx));
      enterOuterAlt(_localctx, 19);
      setState(3788);
      match(TSqlParser::SYSTEM_USER);
      break;
    }

    case 20: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::ISNULLContext>(_localctx));
      enterOuterAlt(_localctx, 20);
      setState(3789);
      match(TSqlParser::ISNULL);
      setState(3790);
      match(TSqlParser::LR_BRACKET);
      setState(3791);
      expression(0);
      setState(3792);
      match(TSqlParser::COMMA);
      setState(3793);
      expression(0);
      setState(3794);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 21: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::XML_DATA_TYPE_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 21);
      setState(3796);
      xml_data_type_methods();
      break;
    }

    case 22: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::IFFContext>(_localctx));
      enterOuterAlt(_localctx, 22);
      setState(3797);
      match(TSqlParser::IIF);
      setState(3798);
      match(TSqlParser::LR_BRACKET);
      setState(3799);
      search_condition();
      setState(3800);
      match(TSqlParser::COMMA);
      setState(3801);
      expression(0);
      setState(3802);
      match(TSqlParser::COMMA);
      setState(3803);
      expression(0);
      setState(3804);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 23: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::RANKING_WINDOWED_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 23);
      setState(3806);
      ranking_windowed_function();
      break;
    }

    case 24: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::AGGREGATE_WINDOWED_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 24);
      setState(3807);
      aggregate_windowed_function();
      break;
    }

    case 25: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::ANALYTIC_WINDOWED_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 25);
      setState(3808);
      analytic_windowed_function();
      break;
    }

    case 26: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::SCALAR_FUNCTIONContext>(_localctx));
      enterOuterAlt(_localctx, 26);
      setState(3809);
      scalar_function_name();
      setState(3810);
      match(TSqlParser::LR_BRACKET);
      setState(3812);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::ABS)
        | (1ULL << TSqlParser::ASCII)
        | (1ULL << TSqlParser::BLOCKING_HIERARCHY)
        | (1ULL << TSqlParser::CALLED)
        | (1ULL << TSqlParser::CASE)
        | (1ULL << TSqlParser::CEILING)
        | (1ULL << TSqlParser::CHARINDEX)
        | (1ULL << TSqlParser::COALESCE))) != 0) || ((((_la - 74) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 74)) & ((1ULL << (TSqlParser::CONVERT - 74))
        | (1ULL << (TSqlParser::CURRENT_TIMESTAMP - 74))
        | (1ULL << (TSqlParser::CURRENT_USER - 74))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 74))
        | (1ULL << (TSqlParser::DEFAULT - 74))
        | (1ULL << (TSqlParser::EVENTDATA - 74))
        | (1ULL << (TSqlParser::FILENAME - 74))
        | (1ULL << (TSqlParser::FILLFACTOR - 74))
        | (1ULL << (TSqlParser::FLOOR - 74)))) != 0) || ((((_la - 138) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 138)) & ((1ULL << (TSqlParser::FORCESEEK - 138))
        | (1ULL << (TSqlParser::IDENTITY - 138))
        | (1ULL << (TSqlParser::IIF - 138))
        | (1ULL << (TSqlParser::INIT - 138))
        | (1ULL << (TSqlParser::ISDATE - 138))
        | (1ULL << (TSqlParser::ISNULL - 138))
        | (1ULL << (TSqlParser::ISNUMERIC - 138))
        | (1ULL << (TSqlParser::KEY - 138))
        | (1ULL << (TSqlParser::LEFT - 138))
        | (1ULL << (TSqlParser::LEN - 138))
        | (1ULL << (TSqlParser::LOWER - 138))
        | (1ULL << (TSqlParser::LTRIM - 138))
        | (1ULL << (TSqlParser::MASTER - 138))
        | (1ULL << (TSqlParser::MAX_MEMORY - 138)))) != 0) || ((((_la - 215) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 215)) & ((1ULL << (TSqlParser::MONTH - 215))
        | (1ULL << (TSqlParser::NCHAR - 215))
        | (1ULL << (TSqlParser::null - 215))
        | (1ULL << (TSqlParser::NULLIF - 215))
        | (1ULL << (TSqlParser::OFFSETS - 215))
        | (1ULL << (TSqlParser::OVER - 215))
        | (1ULL << (TSqlParser::PAGE - 215))
        | (1ULL << (TSqlParser::PATINDEX - 215))
        | (1ULL << (TSqlParser::PUBLIC - 215))
        | (1ULL << (TSqlParser::R - 215))
        | (1ULL << (TSqlParser::RAND - 215))
        | (1ULL << (TSqlParser::RAW - 215)))) != 0) || ((((_la - 287) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 287)) & ((1ULL << (TSqlParser::REPLACE - 287))
        | (1ULL << (TSqlParser::RETURN - 287))
        | (1ULL << (TSqlParser::RETURNS - 287))
        | (1ULL << (TSqlParser::RIGHT - 287))
        | (1ULL << (TSqlParser::ROUND - 287))
        | (1ULL << (TSqlParser::ROWCOUNT - 287))
        | (1ULL << (TSqlParser::RTRIM - 287))
        | (1ULL << (TSqlParser::SAFETY - 287))
        | (1ULL << (TSqlParser::SERVER - 287))
        | (1ULL << (TSqlParser::SESSION_USER - 287))
        | (1ULL << (TSqlParser::SIGN - 287))
        | (1ULL << (TSqlParser::SID - 287))
        | (1ULL << (TSqlParser::SOURCE - 287))
        | (1ULL << (TSqlParser::SPACE - 287))
        | (1ULL << (TSqlParser::SPLIT - 287))
        | (1ULL << (TSqlParser::STATE - 287))
        | (1ULL << (TSqlParser::START - 287)))) != 0) || ((((_la - 356) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 356)) & ((1ULL << (TSqlParser::STR - 356))
        | (1ULL << (TSqlParser::SYSTEM_USER - 356))
        | (1ULL << (TSqlParser::TARGET - 356))
        | (1ULL << (TSqlParser::UPPER - 356))
        | (1ULL << (TSqlParser::USER_NAME - 356))
        | (1ULL << (TSqlParser::YEAR - 356))
        | (1ULL << (TSqlParser::ABSOLUTE - 356))
        | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 356))
        | (1ULL << (TSqlParser::ACTION - 356))
        | (1ULL << (TSqlParser::ACTIVATION - 356))
        | (1ULL << (TSqlParser::ACTIVE - 356))
        | (1ULL << (TSqlParser::ADDRESS - 356))
        | (1ULL << (TSqlParser::AES_128 - 356))
        | (1ULL << (TSqlParser::AES_192 - 356))
        | (1ULL << (TSqlParser::AES_256 - 356))
        | (1ULL << (TSqlParser::AFFINITY - 356))
        | (1ULL << (TSqlParser::AFTER - 356))
        | (1ULL << (TSqlParser::AGGREGATE - 356))
        | (1ULL << (TSqlParser::ALGORITHM - 356))
        | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 356))
        | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 356)))) != 0) || ((((_la - 420) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 420)) & ((1ULL << (TSqlParser::ALLOWED - 420))
        | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 420))
        | (1ULL << (TSqlParser::ANSI_NULLS - 420))
        | (1ULL << (TSqlParser::ANSI_PADDING - 420))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 420))
        | (1ULL << (TSqlParser::APPLICATION_LOG - 420))
        | (1ULL << (TSqlParser::APPLY - 420))
        | (1ULL << (TSqlParser::ARITHABORT - 420))
        | (1ULL << (TSqlParser::ASSEMBLY - 420))
        | (1ULL << (TSqlParser::AUDIT - 420))
        | (1ULL << (TSqlParser::AUDIT_GUID - 420))
        | (1ULL << (TSqlParser::AUTO - 420))
        | (1ULL << (TSqlParser::AUTO_CLEANUP - 420))
        | (1ULL << (TSqlParser::AUTO_CLOSE - 420))
        | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 420))
        | (1ULL << (TSqlParser::AUTO_SHRINK - 420))
        | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 420))
        | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 420))
        | (1ULL << (TSqlParser::AVAILABILITY - 420))
        | (1ULL << (TSqlParser::AVG - 420))
        | (1ULL << (TSqlParser::BACKUP_PRIORITY - 420))
        | (1ULL << (TSqlParser::BEGIN_DIALOG - 420))
        | (1ULL << (TSqlParser::BIGINT - 420))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 420))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 420))
        | (1ULL << (TSqlParser::BINDING - 420))
        | (1ULL << (TSqlParser::BLOB_STORAGE - 420))
        | (1ULL << (TSqlParser::BROKER - 420))
        | (1ULL << (TSqlParser::BROKER_INSTANCE - 420))
        | (1ULL << (TSqlParser::BULK_LOGGED - 420))
        | (1ULL << (TSqlParser::CALLER - 420))
        | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 420))
        | (1ULL << (TSqlParser::CAST - 420))
        | (1ULL << (TSqlParser::CATALOG - 420))
        | (1ULL << (TSqlParser::CATCH - 420))
        | (1ULL << (TSqlParser::CHANGE_RETENTION - 420))
        | (1ULL << (TSqlParser::CHANGE_TRACKING - 420))
        | (1ULL << (TSqlParser::CHECKSUM - 420))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 420))
        | (1ULL << (TSqlParser::CLEANUP - 420))
        | (1ULL << (TSqlParser::COLLECTION - 420))
        | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 420))
        | (1ULL << (TSqlParser::COMMITTED - 420))
        | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 420))
        | (1ULL << (TSqlParser::CONCAT - 420))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 420))
        | (1ULL << (TSqlParser::CONTENT - 420))
        | (1ULL << (TSqlParser::CONTROL - 420))
        | (1ULL << (TSqlParser::COOKIE - 420))
        | (1ULL << (TSqlParser::COUNT - 420))
        | (1ULL << (TSqlParser::COUNT_BIG - 420))
        | (1ULL << (TSqlParser::COUNTER - 420))
        | (1ULL << (TSqlParser::CPU - 420))
        | (1ULL << (TSqlParser::CREATE_NEW - 420))
        | (1ULL << (TSqlParser::CREATION_DISPOSITION - 420))
        | (1ULL << (TSqlParser::CREDENTIAL - 420))
        | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 420))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 420))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 420))
        | (1ULL << (TSqlParser::DATA - 420))
        | (1ULL << (TSqlParser::DATALENGTH - 420))
        | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 420))
        | (1ULL << (TSqlParser::DATEADD - 420))
        | (1ULL << (TSqlParser::DATEDIFF - 420)))) != 0) || ((((_la - 484) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 484)) & ((1ULL << (TSqlParser::DATENAME - 484))
        | (1ULL << (TSqlParser::DATEPART - 484))
        | (1ULL << (TSqlParser::DAY - 484))
        | (1ULL << (TSqlParser::DAYS - 484))
        | (1ULL << (TSqlParser::DB_CHAINING - 484))
        | (1ULL << (TSqlParser::DB_FAILOVER - 484))
        | (1ULL << (TSqlParser::DECRYPTION - 484))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 484))
        | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 484))
        | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 484))
        | (1ULL << (TSqlParser::DELAY - 484))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 484))
        | (1ULL << (TSqlParser::DELETED - 484))
        | (1ULL << (TSqlParser::DENSE_RANK - 484))
        | (1ULL << (TSqlParser::DEPENDENTS - 484))
        | (1ULL << (TSqlParser::DES - 484))
        | (1ULL << (TSqlParser::DESCRIPTION - 484))
        | (1ULL << (TSqlParser::DESX - 484))
        | (1ULL << (TSqlParser::DHCP - 484))
        | (1ULL << (TSqlParser::DIALOG - 484))
        | (1ULL << (TSqlParser::DIRECTORY_NAME - 484))
        | (1ULL << (TSqlParser::DISABLE - 484))
        | (1ULL << (TSqlParser::DISABLE_BROKER - 484))
        | (1ULL << (TSqlParser::DISABLED - 484))
        | (1ULL << (TSqlParser::DISK_DRIVE - 484))
        | (1ULL << (TSqlParser::DOCUMENT - 484))
        | (1ULL << (TSqlParser::DYNAMIC - 484))
        | (1ULL << (TSqlParser::EMERGENCY - 484))
        | (1ULL << (TSqlParser::EMPTY - 484))
        | (1ULL << (TSqlParser::ENABLE - 484))
        | (1ULL << (TSqlParser::ENABLE_BROKER - 484))
        | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 484))
        | (1ULL << (TSqlParser::ENCRYPTION - 484))
        | (1ULL << (TSqlParser::ENDPOINT_URL - 484))
        | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 484))
        | (1ULL << (TSqlParser::EXCLUSIVE - 484))
        | (1ULL << (TSqlParser::EXECUTABLE - 484))
        | (1ULL << (TSqlParser::EXIST - 484))
        | (1ULL << (TSqlParser::EXPAND - 484))
        | (1ULL << (TSqlParser::EXPIRY_DATE - 484))
        | (1ULL << (TSqlParser::EXPLICIT - 484))
        | (1ULL << (TSqlParser::FAIL_OPERATION - 484))
        | (1ULL << (TSqlParser::FAILOVER_MODE - 484))
        | (1ULL << (TSqlParser::FAILURE - 484))
        | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 484))
        | (1ULL << (TSqlParser::FAST - 484))
        | (1ULL << (TSqlParser::FAST_FORWARD - 484))
        | (1ULL << (TSqlParser::FILEGROUP - 484))
        | (1ULL << (TSqlParser::FILEGROWTH - 484))
        | (1ULL << (TSqlParser::FILEPATH - 484))
        | (1ULL << (TSqlParser::FILESTREAM - 484))
        | (1ULL << (TSqlParser::FILTER - 484))
        | (1ULL << (TSqlParser::FIRST - 484))
        | (1ULL << (TSqlParser::FIRST_VALUE - 484))
        | (1ULL << (TSqlParser::FOLLOWING - 484))
        | (1ULL << (TSqlParser::FORCE - 484))
        | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 484))
        | (1ULL << (TSqlParser::FORCED - 484))
        | (1ULL << (TSqlParser::FORMAT - 484))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 484))
        | (1ULL << (TSqlParser::FULLSCAN - 484))
        | (1ULL << (TSqlParser::FULLTEXT - 484))
        | (1ULL << (TSqlParser::GB - 484)))) != 0) || ((((_la - 548) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 548)) & ((1ULL << (TSqlParser::GETDATE - 548))
        | (1ULL << (TSqlParser::GETUTCDATE - 548))
        | (1ULL << (TSqlParser::GLOBAL - 548))
        | (1ULL << (TSqlParser::GO - 548))
        | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 548))
        | (1ULL << (TSqlParser::GROUPING - 548))
        | (1ULL << (TSqlParser::GROUPING_ID - 548))
        | (1ULL << (TSqlParser::HADR - 548))
        | (1ULL << (TSqlParser::HASH - 548))
        | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 548))
        | (1ULL << (TSqlParser::HIGH - 548))
        | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 548))
        | (1ULL << (TSqlParser::HOURS - 548))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 548))
        | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 548))
        | (1ULL << (TSqlParser::IMMEDIATE - 548))
        | (1ULL << (TSqlParser::IMPERSONATE - 548))
        | (1ULL << (TSqlParser::IMPORTANCE - 548))
        | (1ULL << (TSqlParser::INCREMENTAL - 548))
        | (1ULL << (TSqlParser::INITIATOR - 548))
        | (1ULL << (TSqlParser::INPUT - 548))
        | (1ULL << (TSqlParser::INSENSITIVE - 548))
        | (1ULL << (TSqlParser::INSERTED - 548))
        | (1ULL << (TSqlParser::INT - 548))
        | (1ULL << (TSqlParser::IP - 548))
        | (1ULL << (TSqlParser::ISOLATION - 548))
        | (1ULL << (TSqlParser::KB - 548))
        | (1ULL << (TSqlParser::KEEP - 548))
        | (1ULL << (TSqlParser::KEEPFIXED - 548))
        | (1ULL << (TSqlParser::KEY_SOURCE - 548))
        | (1ULL << (TSqlParser::KEYS - 548))
        | (1ULL << (TSqlParser::KEYSET - 548))
        | (1ULL << (TSqlParser::LAG - 548))
        | (1ULL << (TSqlParser::LAST - 548))
        | (1ULL << (TSqlParser::LAST_VALUE - 548))
        | (1ULL << (TSqlParser::LEAD - 548))
        | (1ULL << (TSqlParser::LEVEL - 548))
        | (1ULL << (TSqlParser::LIST - 548))
        | (1ULL << (TSqlParser::LISTENER - 548))
        | (1ULL << (TSqlParser::LISTENER_URL - 548))
        | (1ULL << (TSqlParser::LOB_COMPACTION - 548))
        | (1ULL << (TSqlParser::LOCAL - 548))
        | (1ULL << (TSqlParser::LOCATION - 548))
        | (1ULL << (TSqlParser::LOCK - 548))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 548))
        | (1ULL << (TSqlParser::LOGIN - 548))
        | (1ULL << (TSqlParser::LOOP - 548))
        | (1ULL << (TSqlParser::LOW - 548))
        | (1ULL << (TSqlParser::MANUAL - 548))
        | (1ULL << (TSqlParser::MARK - 548))
        | (1ULL << (TSqlParser::MATERIALIZED - 548))
        | (1ULL << (TSqlParser::MAX - 548))
        | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 548))
        | (1ULL << (TSqlParser::MAX_DOP - 548))
        | (1ULL << (TSqlParser::MAX_FILES - 548))
        | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 548))
        | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 548))
        | (1ULL << (TSqlParser::MAX_PROCESSES - 548))
        | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 548))
        | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 548))
        | (1ULL << (TSqlParser::MAXDOP - 548)))) != 0) || ((((_la - 612) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 612)) & ((1ULL << (TSqlParser::MAXRECURSION - 612))
        | (1ULL << (TSqlParser::MAXSIZE - 612))
        | (1ULL << (TSqlParser::MB - 612))
        | (1ULL << (TSqlParser::MEDIUM - 612))
        | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 612))
        | (1ULL << (TSqlParser::MESSAGE - 612))
        | (1ULL << (TSqlParser::MIN - 612))
        | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 612))
        | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 612))
        | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 612))
        | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 612))
        | (1ULL << (TSqlParser::MINUTES - 612))
        | (1ULL << (TSqlParser::MIRROR_ADDRESS - 612))
        | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 612))
        | (1ULL << (TSqlParser::MODE - 612))
        | (1ULL << (TSqlParser::MODIFY - 612))
        | (1ULL << (TSqlParser::MOVE - 612))
        | (1ULL << (TSqlParser::MULTI_USER - 612))
        | (1ULL << (TSqlParser::NAME - 612))
        | (1ULL << (TSqlParser::NESTED_TRIGGERS - 612))
        | (1ULL << (TSqlParser::NEW_ACCOUNT - 612))
        | (1ULL << (TSqlParser::NEW_BROKER - 612))
        | (1ULL << (TSqlParser::NEW_PASSWORD - 612))
        | (1ULL << (TSqlParser::NEXT - 612))
        | (1ULL << (TSqlParser::NO - 612))
        | (1ULL << (TSqlParser::NO_TRUNCATE - 612))
        | (1ULL << (TSqlParser::NO_WAIT - 612))
        | (1ULL << (TSqlParser::NOCOUNT - 612))
        | (1ULL << (TSqlParser::NODES - 612))
        | (1ULL << (TSqlParser::NOEXPAND - 612))
        | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 612))
        | (1ULL << (TSqlParser::NORECOMPUTE - 612))
        | (1ULL << (TSqlParser::NORECOVERY - 612))
        | (1ULL << (TSqlParser::NOWAIT - 612))
        | (1ULL << (TSqlParser::NTILE - 612))
        | (1ULL << (TSqlParser::NUMANODE - 612))
        | (1ULL << (TSqlParser::NUMBER - 612))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 612))
        | (1ULL << (TSqlParser::OBJECT - 612))
        | (1ULL << (TSqlParser::OFFLINE - 612))
        | (1ULL << (TSqlParser::OFFSET - 612))
        | (1ULL << (TSqlParser::OLD_ACCOUNT - 612))
        | (1ULL << (TSqlParser::ONLINE - 612))
        | (1ULL << (TSqlParser::ONLY - 612))
        | (1ULL << (TSqlParser::OPEN_EXISTING - 612))
        | (1ULL << (TSqlParser::OPTIMISTIC - 612))
        | (1ULL << (TSqlParser::OPTIMIZE - 612))
        | (1ULL << (TSqlParser::OUT - 612))
        | (1ULL << (TSqlParser::OUTPUT - 612))
        | (1ULL << (TSqlParser::OWNER - 612))
        | (1ULL << (TSqlParser::PAGE_VERIFY - 612))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 612))
        | (1ULL << (TSqlParser::PARTITION - 612))
        | (1ULL << (TSqlParser::PARTITIONS - 612))
        | (1ULL << (TSqlParser::PARTNER - 612))
        | (1ULL << (TSqlParser::PATH - 612))
        | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 612))
        | (1ULL << (TSqlParser::POOL - 612))
        | (1ULL << (TSqlParser::PORT - 612))
        | (1ULL << (TSqlParser::PRECEDING - 612))
        | (1ULL << (TSqlParser::PRIMARY_ROLE - 612))
        | (1ULL << (TSqlParser::PRIOR - 612))
        | (1ULL << (TSqlParser::PRIORITY - 612)))) != 0) || ((((_la - 676) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 676)) & ((1ULL << (TSqlParser::PRIORITY_LEVEL - 676))
        | (1ULL << (TSqlParser::PRIVATE - 676))
        | (1ULL << (TSqlParser::PRIVATE_KEY - 676))
        | (1ULL << (TSqlParser::PRIVILEGES - 676))
        | (1ULL << (TSqlParser::PROCEDURE_NAME - 676))
        | (1ULL << (TSqlParser::PROPERTY - 676))
        | (1ULL << (TSqlParser::PROVIDER - 676))
        | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 676))
        | (1ULL << (TSqlParser::QUERY - 676))
        | (1ULL << (TSqlParser::QUEUE - 676))
        | (1ULL << (TSqlParser::QUEUE_DELAY - 676))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 676))
        | (1ULL << (TSqlParser::RANGE - 676))
        | (1ULL << (TSqlParser::RANK - 676))
        | (1ULL << (TSqlParser::RC2 - 676))
        | (1ULL << (TSqlParser::RC4 - 676))
        | (1ULL << (TSqlParser::RC4_128 - 676))
        | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 676))
        | (1ULL << (TSqlParser::READ_ONLY - 676))
        | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 676))
        | (1ULL << (TSqlParser::READ_WRITE - 676))
        | (1ULL << (TSqlParser::READONLY - 676))
        | (1ULL << (TSqlParser::REBUILD - 676))
        | (1ULL << (TSqlParser::RECEIVE - 676))
        | (1ULL << (TSqlParser::RECOMPILE - 676))
        | (1ULL << (TSqlParser::RECOVERY - 676))
        | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 676))
        | (1ULL << (TSqlParser::RELATIVE - 676))
        | (1ULL << (TSqlParser::REMOTE - 676))
        | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 676))
        | (1ULL << (TSqlParser::REMOVE - 676))
        | (1ULL << (TSqlParser::REORGANIZE - 676))
        | (1ULL << (TSqlParser::REPEATABLE - 676))
        | (1ULL << (TSqlParser::REPLICA - 676))
        | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 676))
        | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 676))
        | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 676))
        | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 676))
        | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 676))
        | (1ULL << (TSqlParser::RESOURCE - 676))
        | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 676))
        | (1ULL << (TSqlParser::RESTRICTED_USER - 676))
        | (1ULL << (TSqlParser::RETENTION - 676))
        | (1ULL << (TSqlParser::ROBUST - 676))
        | (1ULL << (TSqlParser::ROOT - 676))
        | (1ULL << (TSqlParser::ROUTE - 676))
        | (1ULL << (TSqlParser::ROW - 676))
        | (1ULL << (TSqlParser::ROW_NUMBER - 676))
        | (1ULL << (TSqlParser::ROWGUID - 676))
        | (1ULL << (TSqlParser::ROWS - 676))
        | (1ULL << (TSqlParser::SAMPLE - 676))
        | (1ULL << (TSqlParser::SCHEMABINDING - 676))
        | (1ULL << (TSqlParser::SCOPED - 676))
        | (1ULL << (TSqlParser::SCROLL - 676))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 676))
        | (1ULL << (TSqlParser::SEARCH - 676))
        | (1ULL << (TSqlParser::SECONDARY - 676))
        | (1ULL << (TSqlParser::SECONDARY_ONLY - 676))
        | (1ULL << (TSqlParser::SECONDARY_ROLE - 676))
        | (1ULL << (TSqlParser::SECONDS - 676))
        | (1ULL << (TSqlParser::SECRET - 676))
        | (1ULL << (TSqlParser::SECURITY - 676))
        | (1ULL << (TSqlParser::SECURITY_LOG - 676))
        | (1ULL << (TSqlParser::SEEDING_MODE - 676)))) != 0) || ((((_la - 740) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 740)) & ((1ULL << (TSqlParser::SELF - 740))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 740))
        | (1ULL << (TSqlParser::SEND - 740))
        | (1ULL << (TSqlParser::SENT - 740))
        | (1ULL << (TSqlParser::SEQUENCE - 740))
        | (1ULL << (TSqlParser::SERIALIZABLE - 740))
        | (1ULL << (TSqlParser::SESSION_TIMEOUT - 740))
        | (1ULL << (TSqlParser::SETERROR - 740))
        | (1ULL << (TSqlParser::SHARE - 740))
        | (1ULL << (TSqlParser::SHOWPLAN - 740))
        | (1ULL << (TSqlParser::SIGNATURE - 740))
        | (1ULL << (TSqlParser::SIMPLE - 740))
        | (1ULL << (TSqlParser::SINGLE_USER - 740))
        | (1ULL << (TSqlParser::SIZE - 740))
        | (1ULL << (TSqlParser::SMALLINT - 740))
        | (1ULL << (TSqlParser::SNAPSHOT - 740))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 740))
        | (1ULL << (TSqlParser::STANDBY - 740))
        | (1ULL << (TSqlParser::START_DATE - 740))
        | (1ULL << (TSqlParser::STATIC - 740))
        | (1ULL << (TSqlParser::STATS_STREAM - 740))
        | (1ULL << (TSqlParser::STATUS - 740))
        | (1ULL << (TSqlParser::STDEV - 740))
        | (1ULL << (TSqlParser::STDEVP - 740))
        | (1ULL << (TSqlParser::STOPLIST - 740))
        | (1ULL << (TSqlParser::STRING_AGG - 740))
        | (1ULL << (TSqlParser::STUFF - 740))
        | (1ULL << (TSqlParser::SUBJECT - 740))
        | (1ULL << (TSqlParser::SUBSTRING - 740))
        | (1ULL << (TSqlParser::SUM - 740))
        | (1ULL << (TSqlParser::SUSPEND - 740))
        | (1ULL << (TSqlParser::SYMMETRIC - 740))
        | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 740))
        | (1ULL << (TSqlParser::SYNONYM - 740))
        | (1ULL << (TSqlParser::SYSTEM - 740))
        | (1ULL << (TSqlParser::TAKE - 740))
        | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 740))
        | (1ULL << (TSqlParser::TB - 740))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 740))
        | (1ULL << (TSqlParser::THROW - 740))
        | (1ULL << (TSqlParser::TIES - 740))
        | (1ULL << (TSqlParser::TIME - 740))
        | (1ULL << (TSqlParser::TIMEOUT - 740))
        | (1ULL << (TSqlParser::TIMER - 740))
        | (1ULL << (TSqlParser::TINYINT - 740))
        | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 740))
        | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 740))
        | (1ULL << (TSqlParser::TRIPLE_DES - 740))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 740))
        | (1ULL << (TSqlParser::TRUSTWORTHY - 740))
        | (1ULL << (TSqlParser::TRY - 740))
        | (1ULL << (TSqlParser::TSQL - 740))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 740))
        | (1ULL << (TSqlParser::TYPE - 740))
        | (1ULL << (TSqlParser::TYPE_WARNING - 740))
        | (1ULL << (TSqlParser::UNBOUNDED - 740))
        | (1ULL << (TSqlParser::UNCOMMITTED - 740))
        | (1ULL << (TSqlParser::UNKNOWN - 740))
        | (1ULL << (TSqlParser::UNLIMITED - 740))
        | (1ULL << (TSqlParser::USING - 740))
        | (1ULL << (TSqlParser::VALID_XML - 740)))) != 0) || ((((_la - 804) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 804)) & ((1ULL << (TSqlParser::VALIDATION - 804))
        | (1ULL << (TSqlParser::VALUE - 804))
        | (1ULL << (TSqlParser::VAR - 804))
        | (1ULL << (TSqlParser::VARP - 804))
        | (1ULL << (TSqlParser::VIEW_METADATA - 804))
        | (1ULL << (TSqlParser::VIEWS - 804))
        | (1ULL << (TSqlParser::WAIT - 804))
        | (1ULL << (TSqlParser::WELL_FORMED_XML - 804))
        | (1ULL << (TSqlParser::WORK - 804))
        | (1ULL << (TSqlParser::WORKLOAD - 804))
        | (1ULL << (TSqlParser::XML - 804))
        | (1ULL << (TSqlParser::XMLNAMESPACES - 804))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 804))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 804))
        | (1ULL << (TSqlParser::LOCAL_ID - 804))
        | (1ULL << (TSqlParser::DECIMAL - 804))
        | (1ULL << (TSqlParser::ID - 804))
        | (1ULL << (TSqlParser::STRING - 804))
        | (1ULL << (TSqlParser::BINARY - 804))
        | (1ULL << (TSqlParser::FLOAT - 804))
        | (1ULL << (TSqlParser::REAL - 804))
        | (1ULL << (TSqlParser::DOLLAR - 804))
        | (1ULL << (TSqlParser::LR_BRACKET - 804))
        | (1ULL << (TSqlParser::PLUS - 804))
        | (1ULL << (TSqlParser::MINUS - 804))
        | (1ULL << (TSqlParser::BIT_NOT - 804)))) != 0)) {
        setState(3811);
        expression_list();
      }
      setState(3814);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 27: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::STRINGAGGContext>(_localctx));
      enterOuterAlt(_localctx, 27);
      setState(3816);
      match(TSqlParser::STRING_AGG);
      setState(3817);
      match(TSqlParser::LR_BRACKET);
      setState(3818);
      dynamic_cast<STRINGAGGContext *>(_localctx)->expr = expression(0);
      setState(3819);
      match(TSqlParser::COMMA);
      setState(3820);
      dynamic_cast<STRINGAGGContext *>(_localctx)->separator = expression(0);
      setState(3821);
      match(TSqlParser::RR_BRACKET);
      setState(3828);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 551, _ctx)) {
      case 1: {
        setState(3822);
        match(TSqlParser::WITHIN);
        setState(3823);
        match(TSqlParser::GROUP);
        setState(3824);
        match(TSqlParser::LR_BRACKET);
        setState(3825);
        order_by_clause();
        setState(3826);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_data_type_methodsContext ------------------------------------------------------------------

TSqlParser::Xml_data_type_methodsContext::Xml_data_type_methodsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Value_methodContext* TSqlParser::Xml_data_type_methodsContext::value_method() {
  return getRuleContext<TSqlParser::Value_methodContext>(0);
}

TSqlParser::Query_methodContext* TSqlParser::Xml_data_type_methodsContext::query_method() {
  return getRuleContext<TSqlParser::Query_methodContext>(0);
}

TSqlParser::Exist_methodContext* TSqlParser::Xml_data_type_methodsContext::exist_method() {
  return getRuleContext<TSqlParser::Exist_methodContext>(0);
}

TSqlParser::Modify_methodContext* TSqlParser::Xml_data_type_methodsContext::modify_method() {
  return getRuleContext<TSqlParser::Modify_methodContext>(0);
}

TSqlParser::Nodes_methodContext* TSqlParser::Xml_data_type_methodsContext::nodes_method() {
  return getRuleContext<TSqlParser::Nodes_methodContext>(0);
}


size_t TSqlParser::Xml_data_type_methodsContext::getRuleIndex() const {
  return TSqlParser::RuleXml_data_type_methods;
}

void TSqlParser::Xml_data_type_methodsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_data_type_methods(this);
}

void TSqlParser::Xml_data_type_methodsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_data_type_methods(this);
}

TSqlParser::Xml_data_type_methodsContext* TSqlParser::xml_data_type_methods() {
  Xml_data_type_methodsContext *_localctx = _tracker.createInstance<Xml_data_type_methodsContext>(_ctx, getState());
  enterRule(_localctx, 366, TSqlParser::RuleXml_data_type_methods);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3837);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 553, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3832);
      value_method();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3833);
      query_method();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3834);
      exist_method();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3835);
      modify_method();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3836);
      nodes_method();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_methodContext ------------------------------------------------------------------

TSqlParser::Value_methodContext::Value_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Value_methodContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Value_methodContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Value_methodContext::VALUE() {
  return getToken(TSqlParser::VALUE, 0);
}

tree::TerminalNode* TSqlParser::Value_methodContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Value_methodContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Value_methodContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Value_methodContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Value_methodContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

tree::TerminalNode* TSqlParser::Value_methodContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Value_methodContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::Value_methodContext::EVENTDATA() {
  return getToken(TSqlParser::EVENTDATA, 0);
}

TSqlParser::Query_methodContext* TSqlParser::Value_methodContext::query_method() {
  return getRuleContext<TSqlParser::Query_methodContext>(0);
}

tree::TerminalNode* TSqlParser::Value_methodContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}

tree::TerminalNode* TSqlParser::Value_methodContext::PARAM_NODE() {
  return getToken(TSqlParser::PARAM_NODE, 0);
}


size_t TSqlParser::Value_methodContext::getRuleIndex() const {
  return TSqlParser::RuleValue_method;
}

void TSqlParser::Value_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_method(this);
}

void TSqlParser::Value_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_method(this);
}

TSqlParser::Value_methodContext* TSqlParser::value_method() {
  Value_methodContext *_localctx = _tracker.createInstance<Value_methodContext>(_ctx, getState());
  enterRule(_localctx, 368, TSqlParser::RuleValue_method);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3882);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 557, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3843);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 554, _ctx)) {
      case 1: {
        setState(3839);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case 2: {
        setState(3840);
        match(TSqlParser::ID);
        break;
      }

      case 3: {
        setState(3841);
        match(TSqlParser::EVENTDATA);
        break;
      }

      case 4: {
        setState(3842);
        query_method();
        break;
      }

      }
      setState(3845);
      match(TSqlParser::DOT);
      setState(3846);
      match(TSqlParser::VALUE);
      setState(3847);
      match(TSqlParser::LR_BRACKET);
      setState(3848);
      dynamic_cast<Value_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
      setState(3849);
      match(TSqlParser::COMMA);
      setState(3850);
      dynamic_cast<Value_methodContext *>(_localctx)->sqltype = match(TSqlParser::STRING);
      setState(3851);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3856);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 555, _ctx)) {
      case 1: {
        setState(3852);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case 2: {
        setState(3853);
        match(TSqlParser::ID);
        break;
      }

      case 3: {
        setState(3854);
        match(TSqlParser::EVENTDATA);
        break;
      }

      case 4: {
        setState(3855);
        query_method();
        break;
      }

      }
      setState(3858);
      match(TSqlParser::DOT);
      setState(3859);
      match(TSqlParser::ROW);
      setState(3860);
      match(TSqlParser::DOT);
      setState(3861);
      match(TSqlParser::VALUE);
      setState(3862);
      match(TSqlParser::LR_BRACKET);
      setState(3863);
      dynamic_cast<Value_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
      setState(3864);
      match(TSqlParser::COMMA);
      setState(3865);
      dynamic_cast<Value_methodContext *>(_localctx)->sqltype = match(TSqlParser::STRING);
      setState(3866);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3871);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 556, _ctx)) {
      case 1: {
        setState(3867);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case 2: {
        setState(3868);
        match(TSqlParser::ID);
        break;
      }

      case 3: {
        setState(3869);
        match(TSqlParser::EVENTDATA);
        break;
      }

      case 4: {
        setState(3870);
        query_method();
        break;
      }

      }
      setState(3873);
      match(TSqlParser::DOT);
      setState(3874);
      match(TSqlParser::PARAM_NODE);
      setState(3875);
      match(TSqlParser::DOT);
      setState(3876);
      match(TSqlParser::VALUE);
      setState(3877);
      match(TSqlParser::LR_BRACKET);
      setState(3878);
      dynamic_cast<Value_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
      setState(3879);
      match(TSqlParser::COMMA);
      setState(3880);
      dynamic_cast<Value_methodContext *>(_localctx)->sqltype = match(TSqlParser::STRING);
      setState(3881);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_methodContext ------------------------------------------------------------------

TSqlParser::Query_methodContext::Query_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Query_methodContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Query_methodContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Query_methodContext::QUERY() {
  return getToken(TSqlParser::QUERY, 0);
}

tree::TerminalNode* TSqlParser::Query_methodContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Query_methodContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Query_methodContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Query_methodContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Query_methodContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Query_methodContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Query_methodContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}


size_t TSqlParser::Query_methodContext::getRuleIndex() const {
  return TSqlParser::RuleQuery_method;
}

void TSqlParser::Query_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery_method(this);
}

void TSqlParser::Query_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery_method(this);
}

TSqlParser::Query_methodContext* TSqlParser::query_method() {
  Query_methodContext *_localctx = _tracker.createInstance<Query_methodContext>(_ctx, getState());
  enterRule(_localctx, 370, TSqlParser::RuleQuery_method);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3906);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 560, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3887);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 558, _ctx)) {
      case 1: {
        setState(3884);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case 2: {
        setState(3885);
        match(TSqlParser::ID);
        break;
      }

      case 3: {
        setState(3886);
        full_table_name();
        break;
      }

      }
      setState(3889);
      match(TSqlParser::DOT);
      setState(3890);
      match(TSqlParser::QUERY);
      setState(3891);
      match(TSqlParser::LR_BRACKET);
      setState(3892);
      dynamic_cast<Query_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
      setState(3893);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3897);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 559, _ctx)) {
      case 1: {
        setState(3894);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case 2: {
        setState(3895);
        match(TSqlParser::ID);
        break;
      }

      case 3: {
        setState(3896);
        full_table_name();
        break;
      }

      }
      setState(3899);
      match(TSqlParser::DOT);
      setState(3900);
      match(TSqlParser::ROW);
      setState(3901);
      match(TSqlParser::DOT);
      setState(3902);
      match(TSqlParser::QUERY);
      setState(3903);
      match(TSqlParser::LR_BRACKET);
      setState(3904);
      dynamic_cast<Query_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
      setState(3905);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exist_methodContext ------------------------------------------------------------------

TSqlParser::Exist_methodContext::Exist_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Exist_methodContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Exist_methodContext::EXIST() {
  return getToken(TSqlParser::EXIST, 0);
}

tree::TerminalNode* TSqlParser::Exist_methodContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Exist_methodContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Exist_methodContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Exist_methodContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::Exist_methodContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Exist_methodContext::getRuleIndex() const {
  return TSqlParser::RuleExist_method;
}

void TSqlParser::Exist_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExist_method(this);
}

void TSqlParser::Exist_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExist_method(this);
}

TSqlParser::Exist_methodContext* TSqlParser::exist_method() {
  Exist_methodContext *_localctx = _tracker.createInstance<Exist_methodContext>(_ctx, getState());
  enterRule(_localctx, 372, TSqlParser::RuleExist_method);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3908);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3909);
    match(TSqlParser::DOT);
    setState(3910);
    match(TSqlParser::EXIST);
    setState(3911);
    match(TSqlParser::LR_BRACKET);
    setState(3912);
    dynamic_cast<Exist_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
    setState(3913);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modify_methodContext ------------------------------------------------------------------

TSqlParser::Modify_methodContext::Modify_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Modify_methodContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Modify_methodContext::MODIFY() {
  return getToken(TSqlParser::MODIFY, 0);
}

tree::TerminalNode* TSqlParser::Modify_methodContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Modify_methodContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Modify_methodContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Modify_methodContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::Modify_methodContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Modify_methodContext::getRuleIndex() const {
  return TSqlParser::RuleModify_method;
}

void TSqlParser::Modify_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModify_method(this);
}

void TSqlParser::Modify_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModify_method(this);
}

TSqlParser::Modify_methodContext* TSqlParser::modify_method() {
  Modify_methodContext *_localctx = _tracker.createInstance<Modify_methodContext>(_ctx, getState());
  enterRule(_localctx, 374, TSqlParser::RuleModify_method);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3915);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3916);
    match(TSqlParser::DOT);
    setState(3917);
    match(TSqlParser::MODIFY);
    setState(3918);
    match(TSqlParser::LR_BRACKET);
    setState(3919);
    dynamic_cast<Modify_methodContext *>(_localctx)->xml_dml = match(TSqlParser::STRING);
    setState(3920);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nodes_methodContext ------------------------------------------------------------------

TSqlParser::Nodes_methodContext::Nodes_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::NODES() {
  return getToken(TSqlParser::NODES, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Nodes_methodContext::getRuleIndex() const {
  return TSqlParser::RuleNodes_method;
}

void TSqlParser::Nodes_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodes_method(this);
}

void TSqlParser::Nodes_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodes_method(this);
}

TSqlParser::Nodes_methodContext* TSqlParser::nodes_method() {
  Nodes_methodContext *_localctx = _tracker.createInstance<Nodes_methodContext>(_ctx, getState());
  enterRule(_localctx, 376, TSqlParser::RuleNodes_method);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3922);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3923);
    match(TSqlParser::DOT);
    setState(3924);
    match(TSqlParser::NODES);
    setState(3925);
    match(TSqlParser::LR_BRACKET);
    setState(3926);
    dynamic_cast<Nodes_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
    setState(3927);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_sectionContext ------------------------------------------------------------------

TSqlParser::Switch_sectionContext::Switch_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Switch_sectionContext::WHEN() {
  return getToken(TSqlParser::WHEN, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Switch_sectionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Switch_sectionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::Switch_sectionContext::THEN() {
  return getToken(TSqlParser::THEN, 0);
}


size_t TSqlParser::Switch_sectionContext::getRuleIndex() const {
  return TSqlParser::RuleSwitch_section;
}

void TSqlParser::Switch_sectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_section(this);
}

void TSqlParser::Switch_sectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_section(this);
}

TSqlParser::Switch_sectionContext* TSqlParser::switch_section() {
  Switch_sectionContext *_localctx = _tracker.createInstance<Switch_sectionContext>(_ctx, getState());
  enterRule(_localctx, 378, TSqlParser::RuleSwitch_section);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3929);
    match(TSqlParser::WHEN);
    setState(3930);
    expression(0);
    setState(3931);
    match(TSqlParser::THEN);
    setState(3932);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_search_condition_sectionContext ------------------------------------------------------------------

TSqlParser::Switch_search_condition_sectionContext::Switch_search_condition_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Switch_search_condition_sectionContext::WHEN() {
  return getToken(TSqlParser::WHEN, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Switch_search_condition_sectionContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Switch_search_condition_sectionContext::THEN() {
  return getToken(TSqlParser::THEN, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Switch_search_condition_sectionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Switch_search_condition_sectionContext::getRuleIndex() const {
  return TSqlParser::RuleSwitch_search_condition_section;
}

void TSqlParser::Switch_search_condition_sectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_search_condition_section(this);
}

void TSqlParser::Switch_search_condition_sectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_search_condition_section(this);
}

TSqlParser::Switch_search_condition_sectionContext* TSqlParser::switch_search_condition_section() {
  Switch_search_condition_sectionContext *_localctx = _tracker.createInstance<Switch_search_condition_sectionContext>(_ctx, getState());
  enterRule(_localctx, 380, TSqlParser::RuleSwitch_search_condition_section);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3934);
    match(TSqlParser::WHEN);
    setState(3935);
    search_condition();
    setState(3936);
    match(TSqlParser::THEN);
    setState(3937);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_column_aliasContext ------------------------------------------------------------------

TSqlParser::As_column_aliasContext::As_column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_aliasContext* TSqlParser::As_column_aliasContext::column_alias() {
  return getRuleContext<TSqlParser::Column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::As_column_aliasContext::AS() {
  return getToken(TSqlParser::AS, 0);
}


size_t TSqlParser::As_column_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleAs_column_alias;
}

void TSqlParser::As_column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAs_column_alias(this);
}

void TSqlParser::As_column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAs_column_alias(this);
}

TSqlParser::As_column_aliasContext* TSqlParser::as_column_alias() {
  As_column_aliasContext *_localctx = _tracker.createInstance<As_column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 382, TSqlParser::RuleAs_column_alias);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3940);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(3939);
      match(TSqlParser::AS);
    }
    setState(3942);
    column_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_table_aliasContext ------------------------------------------------------------------

TSqlParser::As_table_aliasContext::As_table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_aliasContext* TSqlParser::As_table_aliasContext::table_alias() {
  return getRuleContext<TSqlParser::Table_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::As_table_aliasContext::AS() {
  return getToken(TSqlParser::AS, 0);
}


size_t TSqlParser::As_table_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleAs_table_alias;
}

void TSqlParser::As_table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAs_table_alias(this);
}

void TSqlParser::As_table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAs_table_alias(this);
}

TSqlParser::As_table_aliasContext* TSqlParser::as_table_alias() {
  As_table_aliasContext *_localctx = _tracker.createInstance<As_table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 384, TSqlParser::RuleAs_table_alias);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3945);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(3944);
      match(TSqlParser::AS);
    }
    setState(3947);
    table_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_aliasContext ------------------------------------------------------------------

TSqlParser::Table_aliasContext::Table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Table_aliasContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Table_aliasContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}


size_t TSqlParser::Table_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleTable_alias;
}

void TSqlParser::Table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_alias(this);
}

void TSqlParser::Table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_alias(this);
}

TSqlParser::Table_aliasContext* TSqlParser::table_alias() {
  Table_aliasContext *_localctx = _tracker.createInstance<Table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 386, TSqlParser::RuleTable_alias);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3949);
    id();
    setState(3951);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 563, _ctx)) {
    case 1: {
      setState(3950);
      with_table_hints();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_table_hintsContext ------------------------------------------------------------------

TSqlParser::With_table_hintsContext::With_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Table_hintContext *> TSqlParser::With_table_hintsContext::table_hint() {
  return getRuleContexts<TSqlParser::Table_hintContext>();
}

TSqlParser::Table_hintContext* TSqlParser::With_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<TSqlParser::Table_hintContext>(i);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::With_table_hintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::With_table_hintsContext::getRuleIndex() const {
  return TSqlParser::RuleWith_table_hints;
}

void TSqlParser::With_table_hintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_table_hints(this);
}

void TSqlParser::With_table_hintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_table_hints(this);
}

TSqlParser::With_table_hintsContext* TSqlParser::with_table_hints() {
  With_table_hintsContext *_localctx = _tracker.createInstance<With_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 388, TSqlParser::RuleWith_table_hints);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3954);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(3953);
      match(TSqlParser::WITH);
    }
    setState(3956);
    match(TSqlParser::LR_BRACKET);
    setState(3957);
    table_hint();
    setState(3964);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::FORCESEEK

    || _la == TSqlParser::INDEX || _la == TSqlParser::NOEXPAND || ((((_la - 745) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 745)) & ((1ULL << (TSqlParser::SERIALIZABLE - 745))
      | (1ULL << (TSqlParser::SNAPSHOT - 745))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 745)))) != 0) || _la == TSqlParser::ID

    || _la == TSqlParser::COMMA) {
      setState(3959);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3958);
        match(TSqlParser::COMMA);
      }
      setState(3961);
      table_hint();
      setState(3966);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3967);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_with_table_hintsContext ------------------------------------------------------------------

TSqlParser::Insert_with_table_hintsContext::Insert_with_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Table_hintContext *> TSqlParser::Insert_with_table_hintsContext::table_hint() {
  return getRuleContexts<TSqlParser::Table_hintContext>();
}

TSqlParser::Table_hintContext* TSqlParser::Insert_with_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<TSqlParser::Table_hintContext>(i);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_with_table_hintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Insert_with_table_hintsContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_with_table_hints;
}

void TSqlParser::Insert_with_table_hintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_with_table_hints(this);
}

void TSqlParser::Insert_with_table_hintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_with_table_hints(this);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::insert_with_table_hints() {
  Insert_with_table_hintsContext *_localctx = _tracker.createInstance<Insert_with_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 390, TSqlParser::RuleInsert_with_table_hints);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3969);
    match(TSqlParser::WITH);
    setState(3970);
    match(TSqlParser::LR_BRACKET);
    setState(3971);
    table_hint();
    setState(3978);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::FORCESEEK

    || _la == TSqlParser::INDEX || _la == TSqlParser::NOEXPAND || ((((_la - 745) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 745)) & ((1ULL << (TSqlParser::SERIALIZABLE - 745))
      | (1ULL << (TSqlParser::SNAPSHOT - 745))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 745)))) != 0) || _la == TSqlParser::ID

    || _la == TSqlParser::COMMA) {
      setState(3973);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3972);
        match(TSqlParser::COMMA);
      }
      setState(3975);
      table_hint();
      setState(3980);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3981);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_hintContext ------------------------------------------------------------------

TSqlParser::Table_hintContext::Table_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_hintContext::INDEX() {
  return getToken(TSqlParser::INDEX, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<TSqlParser::Index_valueContext *> TSqlParser::Table_hintContext::index_value() {
  return getRuleContexts<TSqlParser::Index_valueContext>();
}

TSqlParser::Index_valueContext* TSqlParser::Table_hintContext::index_value(size_t i) {
  return getRuleContext<TSqlParser::Index_valueContext>(i);
}

tree::TerminalNode* TSqlParser::Table_hintContext::FORCESEEK() {
  return getToken(TSqlParser::FORCESEEK, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(TSqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::ID() {
  return getTokens(TSqlParser::ID);
}

tree::TerminalNode* TSqlParser::Table_hintContext::ID(size_t i) {
  return getToken(TSqlParser::ID, i);
}

tree::TerminalNode* TSqlParser::Table_hintContext::NOEXPAND() {
  return getToken(TSqlParser::NOEXPAND, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_hintContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_hintContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_hintContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_hintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_hint;
}

void TSqlParser::Table_hintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_hint(this);
}

void TSqlParser::Table_hintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_hint(this);
}

TSqlParser::Table_hintContext* TSqlParser::table_hint() {
  Table_hintContext *_localctx = _tracker.createInstance<Table_hintContext>(_ctx, getState());
  enterRule(_localctx, 392, TSqlParser::RuleTable_hint);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3984);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::NOEXPAND) {
      setState(3983);
      match(TSqlParser::NOEXPAND);
    }
    setState(4034);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 575, _ctx)) {
    case 1: {
      setState(3986);
      match(TSqlParser::INDEX);
      setState(4006);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::LR_BRACKET: {
          setState(3987);
          match(TSqlParser::LR_BRACKET);
          setState(3988);
          index_value();
          setState(3993);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == TSqlParser::COMMA) {
            setState(3989);
            match(TSqlParser::COMMA);
            setState(3990);
            index_value();
            setState(3995);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(3996);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        case TSqlParser::CALLED:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::EVENTDATA:
        case TSqlParser::FILENAME:
        case TSqlParser::FILLFACTOR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::INIT:
        case TSqlParser::KEY:
        case TSqlParser::MASTER:
        case TSqlParser::MAX_MEMORY:
        case TSqlParser::OFFSETS:
        case TSqlParser::PAGE:
        case TSqlParser::PUBLIC:
        case TSqlParser::R:
        case TSqlParser::RAW:
        case TSqlParser::RETURN:
        case TSqlParser::RETURNS:
        case TSqlParser::ROWCOUNT:
        case TSqlParser::SAFETY:
        case TSqlParser::SERVER:
        case TSqlParser::SID:
        case TSqlParser::SOURCE:
        case TSqlParser::SPLIT:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::ACCENT_SENSITIVITY:
        case TSqlParser::ACTION:
        case TSqlParser::ACTIVATION:
        case TSqlParser::ACTIVE:
        case TSqlParser::ADDRESS:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::AFFINITY:
        case TSqlParser::AFTER:
        case TSqlParser::AGGREGATE:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
        case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
        case TSqlParser::ALLOWED:
        case TSqlParser::ANSI_NULL_DEFAULT:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLICATION_LOG:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::ASSEMBLY:
        case TSqlParser::AUDIT:
        case TSqlParser::AUDIT_GUID:
        case TSqlParser::AUTO:
        case TSqlParser::AUTO_CLEANUP:
        case TSqlParser::AUTO_CLOSE:
        case TSqlParser::AUTO_CREATE_STATISTICS:
        case TSqlParser::AUTO_SHRINK:
        case TSqlParser::AUTO_UPDATE_STATISTICS:
        case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
        case TSqlParser::AVAILABILITY:
        case TSqlParser::AVG:
        case TSqlParser::BACKUP_PRIORITY:
        case TSqlParser::BEGIN_DIALOG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::BINDING:
        case TSqlParser::BLOB_STORAGE:
        case TSqlParser::BROKER:
        case TSqlParser::BROKER_INSTANCE:
        case TSqlParser::BULK_LOGGED:
        case TSqlParser::CALLER:
        case TSqlParser::CAP_CPU_PERCENT:
        case TSqlParser::CAST:
        case TSqlParser::CATALOG:
        case TSqlParser::CATCH:
        case TSqlParser::CHANGE_RETENTION:
        case TSqlParser::CHANGE_TRACKING:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::CLEANUP:
        case TSqlParser::COLLECTION:
        case TSqlParser::COLUMN_MASTER_KEY:
        case TSqlParser::COMMITTED:
        case TSqlParser::COMPATIBILITY_LEVEL:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::CONTENT:
        case TSqlParser::CONTROL:
        case TSqlParser::COOKIE:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::COUNTER:
        case TSqlParser::CPU:
        case TSqlParser::CREATE_NEW:
        case TSqlParser::CREATION_DISPOSITION:
        case TSqlParser::CREDENTIAL:
        case TSqlParser::CRYPTOGRAPHIC:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DB_CHAINING:
        case TSqlParser::DB_FAILOVER:
        case TSqlParser::DECRYPTION:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
        case TSqlParser::DEFAULT_LANGUAGE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DEPENDENTS:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DHCP:
        case TSqlParser::DIALOG:
        case TSqlParser::DIRECTORY_NAME:
        case TSqlParser::DISABLE:
        case TSqlParser::DISABLE_BROKER:
        case TSqlParser::DISABLED:
        case TSqlParser::DISK_DRIVE:
        case TSqlParser::DOCUMENT:
        case TSqlParser::DYNAMIC:
        case TSqlParser::EMERGENCY:
        case TSqlParser::EMPTY:
        case TSqlParser::ENABLE:
        case TSqlParser::ENABLE_BROKER:
        case TSqlParser::ENCRYPTED_VALUE:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::ENDPOINT_URL:
        case TSqlParser::ERROR_BROKER_CONVERSATIONS:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::EXECUTABLE:
        case TSqlParser::EXIST:
        case TSqlParser::EXPAND:
        case TSqlParser::EXPIRY_DATE:
        case TSqlParser::EXPLICIT:
        case TSqlParser::FAIL_OPERATION:
        case TSqlParser::FAILOVER_MODE:
        case TSqlParser::FAILURE:
        case TSqlParser::FAILURE_CONDITION_LEVEL:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FILEGROUP:
        case TSqlParser::FILEGROWTH:
        case TSqlParser::FILEPATH:
        case TSqlParser::FILESTREAM:
        case TSqlParser::FILTER:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
        case TSqlParser::FORCED:
        case TSqlParser::FORMAT:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::FULLSCAN:
        case TSqlParser::FULLTEXT:
        case TSqlParser::GB:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO:
        case TSqlParser::GROUP_MAX_REQUESTS:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HADR:
        case TSqlParser::HASH:
        case TSqlParser::HEALTH_CHECK_TIMEOUT:
        case TSqlParser::HIGH:
        case TSqlParser::HONOR_BROKER_PRIORITY:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
        case TSqlParser::IMMEDIATE:
        case TSqlParser::IMPERSONATE:
        case TSqlParser::IMPORTANCE:
        case TSqlParser::INCREMENTAL:
        case TSqlParser::INITIATOR:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::IP:
        case TSqlParser::ISOLATION:
        case TSqlParser::KB:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEY_SOURCE:
        case TSqlParser::KEYS:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LIST:
        case TSqlParser::LISTENER:
        case TSqlParser::LISTENER_URL:
        case TSqlParser::LOB_COMPACTION:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOGIN:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MATERIALIZED:
        case TSqlParser::MAX:
        case TSqlParser::MAX_CPU_PERCENT:
        case TSqlParser::MAX_DOP:
        case TSqlParser::MAX_FILES:
        case TSqlParser::MAX_IOPS_PER_VOLUME:
        case TSqlParser::MAX_MEMORY_PERCENT:
        case TSqlParser::MAX_PROCESSES:
        case TSqlParser::MAX_QUEUE_READERS:
        case TSqlParser::MAX_ROLLOVER_FILES:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MAXSIZE:
        case TSqlParser::MB:
        case TSqlParser::MEDIUM:
        case TSqlParser::MEMORY_OPTIMIZED_DATA:
        case TSqlParser::MESSAGE:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MIN_CPU_PERCENT:
        case TSqlParser::MIN_IOPS_PER_VOLUME:
        case TSqlParser::MIN_MEMORY_PERCENT:
        case TSqlParser::MINUTES:
        case TSqlParser::MIRROR_ADDRESS:
        case TSqlParser::MIXED_PAGE_ALLOCATION:
        case TSqlParser::MODE:
        case TSqlParser::MODIFY:
        case TSqlParser::MOVE:
        case TSqlParser::MULTI_USER:
        case TSqlParser::NAME:
        case TSqlParser::NESTED_TRIGGERS:
        case TSqlParser::NEW_ACCOUNT:
        case TSqlParser::NEW_BROKER:
        case TSqlParser::NEW_PASSWORD:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NO_TRUNCATE:
        case TSqlParser::NO_WAIT:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NON_TRANSACTED_ACCESS:
        case TSqlParser::NORECOMPUTE:
        case TSqlParser::NORECOVERY:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMBER:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFLINE:
        case TSqlParser::OFFSET:
        case TSqlParser::OLD_ACCOUNT:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPEN_EXISTING:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PAGE_VERIFY:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PARTNER:
        case TSqlParser::PATH:
        case TSqlParser::POISON_MESSAGE_HANDLING:
        case TSqlParser::POOL:
        case TSqlParser::PORT:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIMARY_ROLE:
        case TSqlParser::PRIOR:
        case TSqlParser::PRIORITY:
        case TSqlParser::PRIORITY_LEVEL:
        case TSqlParser::PRIVATE:
        case TSqlParser::PRIVATE_KEY:
        case TSqlParser::PRIVILEGES:
        case TSqlParser::PROCEDURE_NAME:
        case TSqlParser::PROPERTY:
        case TSqlParser::PROVIDER:
        case TSqlParser::PROVIDER_KEY_NAME:
        case TSqlParser::QUERY:
        case TSqlParser::QUEUE:
        case TSqlParser::QUEUE_DELAY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_COMMITTED_SNAPSHOT:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READ_ONLY_ROUTING_LIST:
        case TSqlParser::READ_WRITE:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECEIVE:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RECOVERY:
        case TSqlParser::RECURSIVE_TRIGGERS:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REMOTE_SERVICE_NAME:
        case TSqlParser::REMOVE:
        case TSqlParser::REORGANIZE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::REPLICA:
        case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
        case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
        case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
        case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
        case TSqlParser::RESERVE_DISK_SPACE:
        case TSqlParser::RESOURCE:
        case TSqlParser::RESOURCE_MANAGER_LOCATION:
        case TSqlParser::RESTRICTED_USER:
        case TSqlParser::RETENTION:
        case TSqlParser::ROBUST:
        case TSqlParser::ROOT:
        case TSqlParser::ROUTE:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SAMPLE:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCOPED:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SEARCH:
        case TSqlParser::SECONDARY:
        case TSqlParser::SECONDARY_ONLY:
        case TSqlParser::SECONDARY_ROLE:
        case TSqlParser::SECONDS:
        case TSqlParser::SECRET:
        case TSqlParser::SECURITY:
        case TSqlParser::SECURITY_LOG:
        case TSqlParser::SEEDING_MODE:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEND:
        case TSqlParser::SENT:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SESSION_TIMEOUT:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SHOWPLAN:
        case TSqlParser::SIGNATURE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SINGLE_USER:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STANDBY:
        case TSqlParser::START_DATE:
        case TSqlParser::STATIC:
        case TSqlParser::STATS_STREAM:
        case TSqlParser::STATUS:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STOPLIST:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBJECT:
        case TSqlParser::SUM:
        case TSqlParser::SUSPEND:
        case TSqlParser::SYMMETRIC:
        case TSqlParser::SYNCHRONOUS_COMMIT:
        case TSqlParser::SYNONYM:
        case TSqlParser::SYSTEM:
        case TSqlParser::TAKE:
        case TSqlParser::TARGET_RECOVERY_TIME:
        case TSqlParser::TB:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TIMER:
        case TSqlParser::TINYINT:
        case TSqlParser::TORN_PAGE_DETECTION:
        case TSqlParser::TRANSFORM_NOISE_WORDS:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRUSTWORTHY:
        case TSqlParser::TRY:
        case TSqlParser::TSQL:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UNLIMITED:
        case TSqlParser::USING:
        case TSqlParser::VALID_XML:
        case TSqlParser::VALIDATION:
        case TSqlParser::VALUE:
        case TSqlParser::VAR:
        case TSqlParser::VARP:
        case TSqlParser::VIEW_METADATA:
        case TSqlParser::VIEWS:
        case TSqlParser::WAIT:
        case TSqlParser::WELL_FORMED_XML:
        case TSqlParser::WORK:
        case TSqlParser::WORKLOAD:
        case TSqlParser::XML:
        case TSqlParser::XMLNAMESPACES:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID: {
          setState(3998);
          index_value();
          setState(4003);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 571, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3999);
              match(TSqlParser::COMMA);
              setState(4000);
              index_value(); 
            }
            setState(4005);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 571, _ctx);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(4008);
      match(TSqlParser::INDEX);
      setState(4009);
      match(TSqlParser::EQUAL);
      setState(4010);
      index_value();
      break;
    }

    case 3: {
      setState(4011);
      match(TSqlParser::FORCESEEK);
      setState(4026);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LR_BRACKET) {
        setState(4012);
        match(TSqlParser::LR_BRACKET);
        setState(4013);
        index_value();
        setState(4014);
        match(TSqlParser::LR_BRACKET);
        setState(4015);
        match(TSqlParser::ID);
        setState(4020);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(4016);
          match(TSqlParser::COMMA);
          setState(4017);
          match(TSqlParser::ID);
          setState(4022);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4023);
        match(TSqlParser::RR_BRACKET);
        setState(4024);
        match(TSqlParser::RR_BRACKET);
      }
      break;
    }

    case 4: {
      setState(4028);
      match(TSqlParser::SERIALIZABLE);
      break;
    }

    case 5: {
      setState(4029);
      match(TSqlParser::SNAPSHOT);
      break;
    }

    case 6: {
      setState(4030);
      match(TSqlParser::SPATIAL_WINDOW_MAX_CELLS);
      setState(4031);
      match(TSqlParser::EQUAL);
      setState(4032);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 7: {
      setState(4033);
      match(TSqlParser::ID);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_valueContext ------------------------------------------------------------------

TSqlParser::Index_valueContext::Index_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Index_valueContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Index_valueContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Index_valueContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_value;
}

void TSqlParser::Index_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_value(this);
}

void TSqlParser::Index_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_value(this);
}

TSqlParser::Index_valueContext* TSqlParser::index_value() {
  Index_valueContext *_localctx = _tracker.createInstance<Index_valueContext>(_ctx, getState());
  enterRule(_localctx, 394, TSqlParser::RuleIndex_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4038);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(4036);
        id();
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(4037);
        match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_alias_listContext ------------------------------------------------------------------

TSqlParser::Column_alias_listContext::Column_alias_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Column_aliasContext *> TSqlParser::Column_alias_listContext::column_alias() {
  return getRuleContexts<TSqlParser::Column_aliasContext>();
}

TSqlParser::Column_aliasContext* TSqlParser::Column_alias_listContext::column_alias(size_t i) {
  return getRuleContext<TSqlParser::Column_aliasContext>(i);
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_alias_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_alias_listContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_alias_list;
}

void TSqlParser::Column_alias_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias_list(this);
}

void TSqlParser::Column_alias_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias_list(this);
}

TSqlParser::Column_alias_listContext* TSqlParser::column_alias_list() {
  Column_alias_listContext *_localctx = _tracker.createInstance<Column_alias_listContext>(_ctx, getState());
  enterRule(_localctx, 396, TSqlParser::RuleColumn_alias_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4040);
    match(TSqlParser::LR_BRACKET);
    setState(4041);
    column_alias();
    setState(4046);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(4042);
      match(TSqlParser::COMMA);
      setState(4043);
      column_alias();
      setState(4048);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4049);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_aliasContext ------------------------------------------------------------------

TSqlParser::Column_aliasContext::Column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Column_aliasContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Column_aliasContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Column_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_alias;
}

void TSqlParser::Column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias(this);
}

void TSqlParser::Column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias(this);
}

TSqlParser::Column_aliasContext* TSqlParser::column_alias() {
  Column_aliasContext *_localctx = _tracker.createInstance<Column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 398, TSqlParser::RuleColumn_alias);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4053);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(4051);
        id();
        break;
      }

      case TSqlParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(4052);
        match(TSqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_value_constructorContext ------------------------------------------------------------------

TSqlParser::Table_value_constructorContext::Table_value_constructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<TSqlParser::Expression_listContext *> TSqlParser::Table_value_constructorContext::expression_list() {
  return getRuleContexts<TSqlParser::Expression_listContext>();
}

TSqlParser::Expression_listContext* TSqlParser::Table_value_constructorContext::expression_list(size_t i) {
  return getRuleContext<TSqlParser::Expression_listContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_value_constructorContext::getRuleIndex() const {
  return TSqlParser::RuleTable_value_constructor;
}

void TSqlParser::Table_value_constructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_value_constructor(this);
}

void TSqlParser::Table_value_constructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_value_constructor(this);
}

TSqlParser::Table_value_constructorContext* TSqlParser::table_value_constructor() {
  Table_value_constructorContext *_localctx = _tracker.createInstance<Table_value_constructorContext>(_ctx, getState());
  enterRule(_localctx, 400, TSqlParser::RuleTable_value_constructor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4055);
    match(TSqlParser::VALUES);
    setState(4056);
    match(TSqlParser::LR_BRACKET);
    setState(4057);
    expression_list();
    setState(4058);
    match(TSqlParser::RR_BRACKET);
    setState(4066);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 579, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4059);
        match(TSqlParser::COMMA);
        setState(4060);
        match(TSqlParser::LR_BRACKET);
        setState(4061);
        expression_list();
        setState(4062);
        match(TSqlParser::RR_BRACKET); 
      }
      setState(4068);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 579, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_listContext ------------------------------------------------------------------

TSqlParser::Expression_listContext::Expression_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Expression_listContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Expression_listContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Expression_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Expression_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Expression_listContext::getRuleIndex() const {
  return TSqlParser::RuleExpression_list;
}

void TSqlParser::Expression_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_list(this);
}

void TSqlParser::Expression_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_list(this);
}

TSqlParser::Expression_listContext* TSqlParser::expression_list() {
  Expression_listContext *_localctx = _tracker.createInstance<Expression_listContext>(_ctx, getState());
  enterRule(_localctx, 402, TSqlParser::RuleExpression_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4069);
    expression(0);
    setState(4074);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(4070);
      match(TSqlParser::COMMA);
      setState(4071);
      expression(0);
      setState(4076);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ranking_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Ranking_windowed_functionContext::Ranking_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Over_clauseContext* TSqlParser::Ranking_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::RANK() {
  return getToken(TSqlParser::RANK, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::DENSE_RANK() {
  return getToken(TSqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::ROW_NUMBER() {
  return getToken(TSqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::NTILE() {
  return getToken(TSqlParser::NTILE, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Ranking_windowed_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Ranking_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleRanking_windowed_function;
}

void TSqlParser::Ranking_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRanking_windowed_function(this);
}

void TSqlParser::Ranking_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRanking_windowed_function(this);
}

TSqlParser::Ranking_windowed_functionContext* TSqlParser::ranking_windowed_function() {
  Ranking_windowed_functionContext *_localctx = _tracker.createInstance<Ranking_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 404, TSqlParser::RuleRanking_windowed_function);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4087);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DENSE_RANK:
      case TSqlParser::RANK:
      case TSqlParser::ROW_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(4077);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DENSE_RANK || _la == TSqlParser::RANK

        || _la == TSqlParser::ROW_NUMBER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4078);
        match(TSqlParser::LR_BRACKET);
        setState(4079);
        match(TSqlParser::RR_BRACKET);
        setState(4080);
        over_clause();
        break;
      }

      case TSqlParser::NTILE: {
        enterOuterAlt(_localctx, 2);
        setState(4081);
        match(TSqlParser::NTILE);
        setState(4082);
        match(TSqlParser::LR_BRACKET);
        setState(4083);
        expression(0);
        setState(4084);
        match(TSqlParser::RR_BRACKET);
        setState(4085);
        over_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Aggregate_windowed_functionContext::Aggregate_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::All_distinct_expressionContext* TSqlParser::Aggregate_windowed_functionContext::all_distinct_expression() {
  return getRuleContext<TSqlParser::All_distinct_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::AVG() {
  return getToken(TSqlParser::AVG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::MIN() {
  return getToken(TSqlParser::MIN, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::SUM() {
  return getToken(TSqlParser::SUM, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STDEV() {
  return getToken(TSqlParser::STDEV, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STDEVP() {
  return getToken(TSqlParser::STDEVP, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::VAR() {
  return getToken(TSqlParser::VAR, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::VARP() {
  return getToken(TSqlParser::VARP, 0);
}

TSqlParser::Over_clauseContext* TSqlParser::Aggregate_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::COUNT() {
  return getToken(TSqlParser::COUNT, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::COUNT_BIG() {
  return getToken(TSqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::CHECKSUM_AGG() {
  return getToken(TSqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::GROUPING() {
  return getToken(TSqlParser::GROUPING, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Aggregate_windowed_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::GROUPING_ID() {
  return getToken(TSqlParser::GROUPING_ID, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Aggregate_windowed_functionContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}


size_t TSqlParser::Aggregate_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleAggregate_windowed_function;
}

void TSqlParser::Aggregate_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_windowed_function(this);
}

void TSqlParser::Aggregate_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_windowed_function(this);
}

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::aggregate_windowed_function() {
  Aggregate_windowed_functionContext *_localctx = _tracker.createInstance<Aggregate_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 406, TSqlParser::RuleAggregate_windowed_function);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4121);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::AVG:
      case TSqlParser::MAX:
      case TSqlParser::MIN:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::SUM:
      case TSqlParser::VAR:
      case TSqlParser::VARP: {
        enterOuterAlt(_localctx, 1);
        setState(4089);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::AVG || _la == TSqlParser::MAX

        || _la == TSqlParser::MIN || ((((_la - 763) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 763)) & ((1ULL << (TSqlParser::STDEV - 763))
          | (1ULL << (TSqlParser::STDEVP - 763))
          | (1ULL << (TSqlParser::SUM - 763))
          | (1ULL << (TSqlParser::VAR - 763))
          | (1ULL << (TSqlParser::VARP - 763)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4090);
        match(TSqlParser::LR_BRACKET);
        setState(4091);
        all_distinct_expression();
        setState(4092);
        match(TSqlParser::RR_BRACKET);
        setState(4094);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 582, _ctx)) {
        case 1: {
          setState(4093);
          over_clause();
          break;
        }

        }
        break;
      }

      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG: {
        enterOuterAlt(_localctx, 2);
        setState(4096);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::COUNT

        || _la == TSqlParser::COUNT_BIG)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4097);
        match(TSqlParser::LR_BRACKET);
        setState(4100);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::STAR: {
            setState(4098);
            match(TSqlParser::STAR);
            break;
          }

          case TSqlParser::ABS:
          case TSqlParser::ALL:
          case TSqlParser::ASCII:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CALLED:
          case TSqlParser::CASE:
          case TSqlParser::CEILING:
          case TSqlParser::CHARINDEX:
          case TSqlParser::COALESCE:
          case TSqlParser::CONVERT:
          case TSqlParser::CURRENT_TIMESTAMP:
          case TSqlParser::CURRENT_USER:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::DEFAULT:
          case TSqlParser::DISTINCT:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FLOOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IDENTITY:
          case TSqlParser::IIF:
          case TSqlParser::INIT:
          case TSqlParser::ISDATE:
          case TSqlParser::ISNULL:
          case TSqlParser::ISNUMERIC:
          case TSqlParser::KEY:
          case TSqlParser::LEFT:
          case TSqlParser::LEN:
          case TSqlParser::LOWER:
          case TSqlParser::LTRIM:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::MONTH:
          case TSqlParser::NCHAR:
          case TSqlParser::null:
          case TSqlParser::NULLIF:
          case TSqlParser::OFFSETS:
          case TSqlParser::OVER:
          case TSqlParser::PAGE:
          case TSqlParser::PATINDEX:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAND:
          case TSqlParser::RAW:
          case TSqlParser::REPLACE:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::RIGHT:
          case TSqlParser::ROUND:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::RTRIM:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SESSION_USER:
          case TSqlParser::SIGN:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPACE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::STR:
          case TSqlParser::SYSTEM_USER:
          case TSqlParser::TARGET:
          case TSqlParser::UPPER:
          case TSqlParser::USER_NAME:
          case TSqlParser::YEAR:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATALENGTH:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAY:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUBSTRING:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::LOCAL_ID:
          case TSqlParser::DECIMAL:
          case TSqlParser::ID:
          case TSqlParser::STRING:
          case TSqlParser::BINARY:
          case TSqlParser::FLOAT:
          case TSqlParser::REAL:
          case TSqlParser::DOLLAR:
          case TSqlParser::LR_BRACKET:
          case TSqlParser::PLUS:
          case TSqlParser::MINUS:
          case TSqlParser::BIT_NOT: {
            setState(4099);
            all_distinct_expression();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(4102);
        match(TSqlParser::RR_BRACKET);
        setState(4104);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 584, _ctx)) {
        case 1: {
          setState(4103);
          over_clause();
          break;
        }

        }
        break;
      }

      case TSqlParser::CHECKSUM_AGG: {
        enterOuterAlt(_localctx, 3);
        setState(4106);
        match(TSqlParser::CHECKSUM_AGG);
        setState(4107);
        match(TSqlParser::LR_BRACKET);
        setState(4108);
        all_distinct_expression();
        setState(4109);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GROUPING: {
        enterOuterAlt(_localctx, 4);
        setState(4111);
        match(TSqlParser::GROUPING);
        setState(4112);
        match(TSqlParser::LR_BRACKET);
        setState(4113);
        expression(0);
        setState(4114);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GROUPING_ID: {
        enterOuterAlt(_localctx, 5);
        setState(4116);
        match(TSqlParser::GROUPING_ID);
        setState(4117);
        match(TSqlParser::LR_BRACKET);
        setState(4118);
        expression_list();
        setState(4119);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analytic_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Analytic_windowed_functionContext::Analytic_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Analytic_windowed_functionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Analytic_windowed_functionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Over_clauseContext* TSqlParser::Analytic_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::FIRST_VALUE() {
  return getToken(TSqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LAST_VALUE() {
  return getToken(TSqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LAG() {
  return getToken(TSqlParser::LAG, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LEAD() {
  return getToken(TSqlParser::LEAD, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Analytic_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleAnalytic_windowed_function;
}

void TSqlParser::Analytic_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalytic_windowed_function(this);
}

void TSqlParser::Analytic_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalytic_windowed_function(this);
}

TSqlParser::Analytic_windowed_functionContext* TSqlParser::analytic_windowed_function() {
  Analytic_windowed_functionContext *_localctx = _tracker.createInstance<Analytic_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 408, TSqlParser::RuleAnalytic_windowed_function);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4143);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::LAST_VALUE: {
        enterOuterAlt(_localctx, 1);
        setState(4123);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FIRST_VALUE

        || _la == TSqlParser::LAST_VALUE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4124);
        match(TSqlParser::LR_BRACKET);
        setState(4125);
        expression(0);
        setState(4126);
        match(TSqlParser::RR_BRACKET);
        setState(4127);
        over_clause();
        break;
      }

      case TSqlParser::LAG:
      case TSqlParser::LEAD: {
        enterOuterAlt(_localctx, 2);
        setState(4129);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::LAG

        || _la == TSqlParser::LEAD)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4130);
        match(TSqlParser::LR_BRACKET);
        setState(4131);
        expression(0);
        setState(4138);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(4132);
          match(TSqlParser::COMMA);
          setState(4133);
          expression(0);
          setState(4136);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::COMMA) {
            setState(4134);
            match(TSqlParser::COMMA);
            setState(4135);
            expression(0);
          }
        }
        setState(4140);
        match(TSqlParser::RR_BRACKET);
        setState(4141);
        over_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_distinct_expressionContext ------------------------------------------------------------------

TSqlParser::All_distinct_expressionContext::All_distinct_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::All_distinct_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::All_distinct_expressionContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::All_distinct_expressionContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}


size_t TSqlParser::All_distinct_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleAll_distinct_expression;
}

void TSqlParser::All_distinct_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAll_distinct_expression(this);
}

void TSqlParser::All_distinct_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAll_distinct_expression(this);
}

TSqlParser::All_distinct_expressionContext* TSqlParser::all_distinct_expression() {
  All_distinct_expressionContext *_localctx = _tracker.createInstance<All_distinct_expressionContext>(_ctx, getState());
  enterRule(_localctx, 410, TSqlParser::RuleAll_distinct_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4146);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ALL || _la == TSqlParser::DISTINCT) {
      setState(4145);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL || _la == TSqlParser::DISTINCT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(4148);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

TSqlParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Over_clauseContext::OVER() {
  return getToken(TSqlParser::OVER, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Over_clauseContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Over_clauseContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::Row_or_range_clauseContext* TSqlParser::Over_clauseContext::row_or_range_clause() {
  return getRuleContext<TSqlParser::Row_or_range_clauseContext>(0);
}


size_t TSqlParser::Over_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOver_clause;
}

void TSqlParser::Over_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOver_clause(this);
}

void TSqlParser::Over_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOver_clause(this);
}

TSqlParser::Over_clauseContext* TSqlParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 412, TSqlParser::RuleOver_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4150);
    match(TSqlParser::OVER);
    setState(4151);
    match(TSqlParser::LR_BRACKET);
    setState(4155);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::PARTITION) {
      setState(4152);
      match(TSqlParser::PARTITION);
      setState(4153);
      match(TSqlParser::BY);
      setState(4154);
      expression_list();
    }
    setState(4158);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ORDER) {
      setState(4157);
      order_by_clause();
    }
    setState(4161);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::RANGE

    || _la == TSqlParser::ROWS) {
      setState(4160);
      row_or_range_clause();
    }
    setState(4163);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Row_or_range_clauseContext ------------------------------------------------------------------

TSqlParser::Row_or_range_clauseContext::Row_or_range_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_extentContext* TSqlParser::Row_or_range_clauseContext::window_frame_extent() {
  return getRuleContext<TSqlParser::Window_frame_extentContext>(0);
}

tree::TerminalNode* TSqlParser::Row_or_range_clauseContext::ROWS() {
  return getToken(TSqlParser::ROWS, 0);
}

tree::TerminalNode* TSqlParser::Row_or_range_clauseContext::RANGE() {
  return getToken(TSqlParser::RANGE, 0);
}


size_t TSqlParser::Row_or_range_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleRow_or_range_clause;
}

void TSqlParser::Row_or_range_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRow_or_range_clause(this);
}

void TSqlParser::Row_or_range_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRow_or_range_clause(this);
}

TSqlParser::Row_or_range_clauseContext* TSqlParser::row_or_range_clause() {
  Row_or_range_clauseContext *_localctx = _tracker.createInstance<Row_or_range_clauseContext>(_ctx, getState());
  enterRule(_localctx, 414, TSqlParser::RuleRow_or_range_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4165);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::RANGE

    || _la == TSqlParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4166);
    window_frame_extent();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_extentContext ------------------------------------------------------------------

TSqlParser::Window_frame_extentContext::Window_frame_extentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_precedingContext* TSqlParser::Window_frame_extentContext::window_frame_preceding() {
  return getRuleContext<TSqlParser::Window_frame_precedingContext>(0);
}

tree::TerminalNode* TSqlParser::Window_frame_extentContext::BETWEEN() {
  return getToken(TSqlParser::BETWEEN, 0);
}

std::vector<TSqlParser::Window_frame_boundContext *> TSqlParser::Window_frame_extentContext::window_frame_bound() {
  return getRuleContexts<TSqlParser::Window_frame_boundContext>();
}

TSqlParser::Window_frame_boundContext* TSqlParser::Window_frame_extentContext::window_frame_bound(size_t i) {
  return getRuleContext<TSqlParser::Window_frame_boundContext>(i);
}

tree::TerminalNode* TSqlParser::Window_frame_extentContext::AND() {
  return getToken(TSqlParser::AND, 0);
}


size_t TSqlParser::Window_frame_extentContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_extent;
}

void TSqlParser::Window_frame_extentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_extent(this);
}

void TSqlParser::Window_frame_extentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_extent(this);
}

TSqlParser::Window_frame_extentContext* TSqlParser::window_frame_extent() {
  Window_frame_extentContext *_localctx = _tracker.createInstance<Window_frame_extentContext>(_ctx, getState());
  enterRule(_localctx, 416, TSqlParser::RuleWindow_frame_extent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4174);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CURRENT:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(4168);
        window_frame_preceding();
        break;
      }

      case TSqlParser::BETWEEN: {
        enterOuterAlt(_localctx, 2);
        setState(4169);
        match(TSqlParser::BETWEEN);
        setState(4170);
        window_frame_bound();
        setState(4171);
        match(TSqlParser::AND);
        setState(4172);
        window_frame_bound();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_boundContext ------------------------------------------------------------------

TSqlParser::Window_frame_boundContext::Window_frame_boundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_precedingContext* TSqlParser::Window_frame_boundContext::window_frame_preceding() {
  return getRuleContext<TSqlParser::Window_frame_precedingContext>(0);
}

TSqlParser::Window_frame_followingContext* TSqlParser::Window_frame_boundContext::window_frame_following() {
  return getRuleContext<TSqlParser::Window_frame_followingContext>(0);
}


size_t TSqlParser::Window_frame_boundContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_bound;
}

void TSqlParser::Window_frame_boundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_bound(this);
}

void TSqlParser::Window_frame_boundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_bound(this);
}

TSqlParser::Window_frame_boundContext* TSqlParser::window_frame_bound() {
  Window_frame_boundContext *_localctx = _tracker.createInstance<Window_frame_boundContext>(_ctx, getState());
  enterRule(_localctx, 418, TSqlParser::RuleWindow_frame_bound);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4178);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 594, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4176);
      window_frame_preceding();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4177);
      window_frame_following();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_precedingContext ------------------------------------------------------------------

TSqlParser::Window_frame_precedingContext::Window_frame_precedingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::PRECEDING() {
  return getToken(TSqlParser::PRECEDING, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}


size_t TSqlParser::Window_frame_precedingContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_preceding;
}

void TSqlParser::Window_frame_precedingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_preceding(this);
}

void TSqlParser::Window_frame_precedingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_preceding(this);
}

TSqlParser::Window_frame_precedingContext* TSqlParser::window_frame_preceding() {
  Window_frame_precedingContext *_localctx = _tracker.createInstance<Window_frame_precedingContext>(_ctx, getState());
  enterRule(_localctx, 420, TSqlParser::RuleWindow_frame_preceding);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4186);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(4180);
        match(TSqlParser::UNBOUNDED);
        setState(4181);
        match(TSqlParser::PRECEDING);
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(4182);
        match(TSqlParser::DECIMAL);
        setState(4183);
        match(TSqlParser::PRECEDING);
        break;
      }

      case TSqlParser::CURRENT: {
        enterOuterAlt(_localctx, 3);
        setState(4184);
        match(TSqlParser::CURRENT);
        setState(4185);
        match(TSqlParser::ROW);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_followingContext ------------------------------------------------------------------

TSqlParser::Window_frame_followingContext::Window_frame_followingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::FOLLOWING() {
  return getToken(TSqlParser::FOLLOWING, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Window_frame_followingContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_following;
}

void TSqlParser::Window_frame_followingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_following(this);
}

void TSqlParser::Window_frame_followingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_following(this);
}

TSqlParser::Window_frame_followingContext* TSqlParser::window_frame_following() {
  Window_frame_followingContext *_localctx = _tracker.createInstance<Window_frame_followingContext>(_ctx, getState());
  enterRule(_localctx, 422, TSqlParser::RuleWindow_frame_following);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4192);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(4188);
        match(TSqlParser::UNBOUNDED);
        setState(4189);
        match(TSqlParser::FOLLOWING);
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(4190);
        match(TSqlParser::DECIMAL);
        setState(4191);
        match(TSqlParser::FOLLOWING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_database_optionContext ------------------------------------------------------------------

TSqlParser::Create_database_optionContext::Create_database_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::FILESTREAM() {
  return getToken(TSqlParser::FILESTREAM, 0);
}

std::vector<TSqlParser::Database_filestream_optionContext *> TSqlParser::Create_database_optionContext::database_filestream_option() {
  return getRuleContexts<TSqlParser::Database_filestream_optionContext>();
}

TSqlParser::Database_filestream_optionContext* TSqlParser::Create_database_optionContext::database_filestream_option(size_t i) {
  return getRuleContext<TSqlParser::Database_filestream_optionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_database_optionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::DEFAULT_LANGUAGE() {
  return getToken(TSqlParser::DEFAULT_LANGUAGE, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::IdContext* TSqlParser::Create_database_optionContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::DEFAULT_FULLTEXT_LANGUAGE() {
  return getToken(TSqlParser::DEFAULT_FULLTEXT_LANGUAGE, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::NESTED_TRIGGERS() {
  return getToken(TSqlParser::NESTED_TRIGGERS, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::TRANSFORM_NOISE_WORDS() {
  return getToken(TSqlParser::TRANSFORM_NOISE_WORDS, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::TWO_DIGIT_YEAR_CUTOFF() {
  return getToken(TSqlParser::TWO_DIGIT_YEAR_CUTOFF, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::DB_CHAINING() {
  return getToken(TSqlParser::DB_CHAINING, 0);
}

tree::TerminalNode* TSqlParser::Create_database_optionContext::TRUSTWORTHY() {
  return getToken(TSqlParser::TRUSTWORTHY, 0);
}


size_t TSqlParser::Create_database_optionContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_database_option;
}

void TSqlParser::Create_database_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_database_option(this);
}

void TSqlParser::Create_database_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_database_option(this);
}

TSqlParser::Create_database_optionContext* TSqlParser::create_database_option() {
  Create_database_optionContext *_localctx = _tracker.createInstance<Create_database_optionContext>(_ctx, getState());
  enterRule(_localctx, 424, TSqlParser::RuleCreate_database_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(4228);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::FILESTREAM: {
        enterOuterAlt(_localctx, 1);
        setState(4194);
        match(TSqlParser::FILESTREAM);

        setState(4195);
        database_filestream_option();
        setState(4200);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 597, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4196);
            match(TSqlParser::COMMA);
            setState(4197);
            database_filestream_option(); 
          }
          setState(4202);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 597, _ctx);
        }
        break;
      }

      case TSqlParser::DEFAULT_LANGUAGE: {
        enterOuterAlt(_localctx, 2);
        setState(4203);
        match(TSqlParser::DEFAULT_LANGUAGE);
        setState(4204);
        match(TSqlParser::EQUAL);
        setState(4207);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CALLED:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::INIT:
          case TSqlParser::KEY:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::OFFSETS:
          case TSqlParser::PAGE:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAW:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(4205);
            id();
            break;
          }

          case TSqlParser::STRING: {
            setState(4206);
            match(TSqlParser::STRING);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE: {
        enterOuterAlt(_localctx, 3);
        setState(4209);
        match(TSqlParser::DEFAULT_FULLTEXT_LANGUAGE);
        setState(4210);
        match(TSqlParser::EQUAL);
        setState(4213);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CALLED:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::EVENTDATA:
          case TSqlParser::FILENAME:
          case TSqlParser::FILLFACTOR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::INIT:
          case TSqlParser::KEY:
          case TSqlParser::MASTER:
          case TSqlParser::MAX_MEMORY:
          case TSqlParser::OFFSETS:
          case TSqlParser::PAGE:
          case TSqlParser::PUBLIC:
          case TSqlParser::R:
          case TSqlParser::RAW:
          case TSqlParser::RETURN:
          case TSqlParser::RETURNS:
          case TSqlParser::ROWCOUNT:
          case TSqlParser::SAFETY:
          case TSqlParser::SERVER:
          case TSqlParser::SID:
          case TSqlParser::SOURCE:
          case TSqlParser::SPLIT:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::ACCENT_SENSITIVITY:
          case TSqlParser::ACTION:
          case TSqlParser::ACTIVATION:
          case TSqlParser::ACTIVE:
          case TSqlParser::ADDRESS:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::AFFINITY:
          case TSqlParser::AFTER:
          case TSqlParser::AGGREGATE:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
          case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
          case TSqlParser::ALLOWED:
          case TSqlParser::ANSI_NULL_DEFAULT:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLICATION_LOG:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::ASSEMBLY:
          case TSqlParser::AUDIT:
          case TSqlParser::AUDIT_GUID:
          case TSqlParser::AUTO:
          case TSqlParser::AUTO_CLEANUP:
          case TSqlParser::AUTO_CLOSE:
          case TSqlParser::AUTO_CREATE_STATISTICS:
          case TSqlParser::AUTO_SHRINK:
          case TSqlParser::AUTO_UPDATE_STATISTICS:
          case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
          case TSqlParser::AVAILABILITY:
          case TSqlParser::AVG:
          case TSqlParser::BACKUP_PRIORITY:
          case TSqlParser::BEGIN_DIALOG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::BINDING:
          case TSqlParser::BLOB_STORAGE:
          case TSqlParser::BROKER:
          case TSqlParser::BROKER_INSTANCE:
          case TSqlParser::BULK_LOGGED:
          case TSqlParser::CALLER:
          case TSqlParser::CAP_CPU_PERCENT:
          case TSqlParser::CAST:
          case TSqlParser::CATALOG:
          case TSqlParser::CATCH:
          case TSqlParser::CHANGE_RETENTION:
          case TSqlParser::CHANGE_TRACKING:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::CLEANUP:
          case TSqlParser::COLLECTION:
          case TSqlParser::COLUMN_MASTER_KEY:
          case TSqlParser::COMMITTED:
          case TSqlParser::COMPATIBILITY_LEVEL:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::CONTENT:
          case TSqlParser::CONTROL:
          case TSqlParser::COOKIE:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::COUNTER:
          case TSqlParser::CPU:
          case TSqlParser::CREATE_NEW:
          case TSqlParser::CREATION_DISPOSITION:
          case TSqlParser::CREDENTIAL:
          case TSqlParser::CRYPTOGRAPHIC:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DB_CHAINING:
          case TSqlParser::DB_FAILOVER:
          case TSqlParser::DECRYPTION:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
          case TSqlParser::DEFAULT_LANGUAGE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DEPENDENTS:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DHCP:
          case TSqlParser::DIALOG:
          case TSqlParser::DIRECTORY_NAME:
          case TSqlParser::DISABLE:
          case TSqlParser::DISABLE_BROKER:
          case TSqlParser::DISABLED:
          case TSqlParser::DISK_DRIVE:
          case TSqlParser::DOCUMENT:
          case TSqlParser::DYNAMIC:
          case TSqlParser::EMERGENCY:
          case TSqlParser::EMPTY:
          case TSqlParser::ENABLE:
          case TSqlParser::ENABLE_BROKER:
          case TSqlParser::ENCRYPTED_VALUE:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::ENDPOINT_URL:
          case TSqlParser::ERROR_BROKER_CONVERSATIONS:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::EXECUTABLE:
          case TSqlParser::EXIST:
          case TSqlParser::EXPAND:
          case TSqlParser::EXPIRY_DATE:
          case TSqlParser::EXPLICIT:
          case TSqlParser::FAIL_OPERATION:
          case TSqlParser::FAILOVER_MODE:
          case TSqlParser::FAILURE:
          case TSqlParser::FAILURE_CONDITION_LEVEL:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FILEGROUP:
          case TSqlParser::FILEGROWTH:
          case TSqlParser::FILEPATH:
          case TSqlParser::FILESTREAM:
          case TSqlParser::FILTER:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
          case TSqlParser::FORCED:
          case TSqlParser::FORMAT:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::FULLSCAN:
          case TSqlParser::FULLTEXT:
          case TSqlParser::GB:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO:
          case TSqlParser::GROUP_MAX_REQUESTS:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HADR:
          case TSqlParser::HASH:
          case TSqlParser::HEALTH_CHECK_TIMEOUT:
          case TSqlParser::HIGH:
          case TSqlParser::HONOR_BROKER_PRIORITY:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
          case TSqlParser::IMMEDIATE:
          case TSqlParser::IMPERSONATE:
          case TSqlParser::IMPORTANCE:
          case TSqlParser::INCREMENTAL:
          case TSqlParser::INITIATOR:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::IP:
          case TSqlParser::ISOLATION:
          case TSqlParser::KB:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEY_SOURCE:
          case TSqlParser::KEYS:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LIST:
          case TSqlParser::LISTENER:
          case TSqlParser::LISTENER_URL:
          case TSqlParser::LOB_COMPACTION:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOGIN:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MATERIALIZED:
          case TSqlParser::MAX:
          case TSqlParser::MAX_CPU_PERCENT:
          case TSqlParser::MAX_DOP:
          case TSqlParser::MAX_FILES:
          case TSqlParser::MAX_IOPS_PER_VOLUME:
          case TSqlParser::MAX_MEMORY_PERCENT:
          case TSqlParser::MAX_PROCESSES:
          case TSqlParser::MAX_QUEUE_READERS:
          case TSqlParser::MAX_ROLLOVER_FILES:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MAXSIZE:
          case TSqlParser::MB:
          case TSqlParser::MEDIUM:
          case TSqlParser::MEMORY_OPTIMIZED_DATA:
          case TSqlParser::MESSAGE:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MIN_CPU_PERCENT:
          case TSqlParser::MIN_IOPS_PER_VOLUME:
          case TSqlParser::MIN_MEMORY_PERCENT:
          case TSqlParser::MINUTES:
          case TSqlParser::MIRROR_ADDRESS:
          case TSqlParser::MIXED_PAGE_ALLOCATION:
          case TSqlParser::MODE:
          case TSqlParser::MODIFY:
          case TSqlParser::MOVE:
          case TSqlParser::MULTI_USER:
          case TSqlParser::NAME:
          case TSqlParser::NESTED_TRIGGERS:
          case TSqlParser::NEW_ACCOUNT:
          case TSqlParser::NEW_BROKER:
          case TSqlParser::NEW_PASSWORD:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NO_TRUNCATE:
          case TSqlParser::NO_WAIT:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NON_TRANSACTED_ACCESS:
          case TSqlParser::NORECOMPUTE:
          case TSqlParser::NORECOVERY:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMBER:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFLINE:
          case TSqlParser::OFFSET:
          case TSqlParser::OLD_ACCOUNT:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPEN_EXISTING:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PAGE_VERIFY:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PARTNER:
          case TSqlParser::PATH:
          case TSqlParser::POISON_MESSAGE_HANDLING:
          case TSqlParser::POOL:
          case TSqlParser::PORT:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIMARY_ROLE:
          case TSqlParser::PRIOR:
          case TSqlParser::PRIORITY:
          case TSqlParser::PRIORITY_LEVEL:
          case TSqlParser::PRIVATE:
          case TSqlParser::PRIVATE_KEY:
          case TSqlParser::PRIVILEGES:
          case TSqlParser::PROCEDURE_NAME:
          case TSqlParser::PROPERTY:
          case TSqlParser::PROVIDER:
          case TSqlParser::PROVIDER_KEY_NAME:
          case TSqlParser::QUERY:
          case TSqlParser::QUEUE:
          case TSqlParser::QUEUE_DELAY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_COMMITTED_SNAPSHOT:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READ_ONLY_ROUTING_LIST:
          case TSqlParser::READ_WRITE:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECEIVE:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RECOVERY:
          case TSqlParser::RECURSIVE_TRIGGERS:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REMOTE_SERVICE_NAME:
          case TSqlParser::REMOVE:
          case TSqlParser::REORGANIZE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::REPLICA:
          case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
          case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
          case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
          case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
          case TSqlParser::RESERVE_DISK_SPACE:
          case TSqlParser::RESOURCE:
          case TSqlParser::RESOURCE_MANAGER_LOCATION:
          case TSqlParser::RESTRICTED_USER:
          case TSqlParser::RETENTION:
          case TSqlParser::ROBUST:
          case TSqlParser::ROOT:
          case TSqlParser::ROUTE:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SAMPLE:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCOPED:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SEARCH:
          case TSqlParser::SECONDARY:
          case TSqlParser::SECONDARY_ONLY:
          case TSqlParser::SECONDARY_ROLE:
          case TSqlParser::SECONDS:
          case TSqlParser::SECRET:
          case TSqlParser::SECURITY:
          case TSqlParser::SECURITY_LOG:
          case TSqlParser::SEEDING_MODE:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEND:
          case TSqlParser::SENT:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SESSION_TIMEOUT:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SHOWPLAN:
          case TSqlParser::SIGNATURE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SINGLE_USER:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STANDBY:
          case TSqlParser::START_DATE:
          case TSqlParser::STATIC:
          case TSqlParser::STATS_STREAM:
          case TSqlParser::STATUS:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STOPLIST:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBJECT:
          case TSqlParser::SUM:
          case TSqlParser::SUSPEND:
          case TSqlParser::SYMMETRIC:
          case TSqlParser::SYNCHRONOUS_COMMIT:
          case TSqlParser::SYNONYM:
          case TSqlParser::SYSTEM:
          case TSqlParser::TAKE:
          case TSqlParser::TARGET_RECOVERY_TIME:
          case TSqlParser::TB:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TIMER:
          case TSqlParser::TINYINT:
          case TSqlParser::TORN_PAGE_DETECTION:
          case TSqlParser::TRANSFORM_NOISE_WORDS:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRUSTWORTHY:
          case TSqlParser::TRY:
          case TSqlParser::TSQL:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UNLIMITED:
          case TSqlParser::USING:
          case TSqlParser::VALID_XML:
          case TSqlParser::VALIDATION:
          case TSqlParser::VALUE:
          case TSqlParser::VAR:
          case TSqlParser::VARP:
          case TSqlParser::VIEW_METADATA:
          case TSqlParser::VIEWS:
          case TSqlParser::WAIT:
          case TSqlParser::WELL_FORMED_XML:
          case TSqlParser::WORK:
          case TSqlParser::WORKLOAD:
          case TSqlParser::XML:
          case TSqlParser::XMLNAMESPACES:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(4211);
            id();
            break;
          }

          case TSqlParser::STRING: {
            setState(4212);
            match(TSqlParser::STRING);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case TSqlParser::NESTED_TRIGGERS: {
        enterOuterAlt(_localctx, 4);
        setState(4215);
        match(TSqlParser::NESTED_TRIGGERS);
        setState(4216);
        match(TSqlParser::EQUAL);
        setState(4217);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::OFF

        || _la == TSqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::TRANSFORM_NOISE_WORDS: {
        enterOuterAlt(_localctx, 5);
        setState(4218);
        match(TSqlParser::TRANSFORM_NOISE_WORDS);
        setState(4219);
        match(TSqlParser::EQUAL);
        setState(4220);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::OFF

        || _la == TSqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF: {
        enterOuterAlt(_localctx, 6);
        setState(4221);
        match(TSqlParser::TWO_DIGIT_YEAR_CUTOFF);
        setState(4222);
        match(TSqlParser::EQUAL);
        setState(4223);
        match(TSqlParser::DECIMAL);
        break;
      }

      case TSqlParser::DB_CHAINING: {
        enterOuterAlt(_localctx, 7);
        setState(4224);
        match(TSqlParser::DB_CHAINING);
        setState(4225);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::OFF

        || _la == TSqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::TRUSTWORTHY: {
        enterOuterAlt(_localctx, 8);
        setState(4226);
        match(TSqlParser::TRUSTWORTHY);
        setState(4227);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::OFF

        || _la == TSqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_filestream_optionContext ------------------------------------------------------------------

TSqlParser::Database_filestream_optionContext::Database_filestream_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::NON_TRANSACTED_ACCESS() {
  return getToken(TSqlParser::NON_TRANSACTED_ACCESS, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::DIRECTORY_NAME() {
  return getToken(TSqlParser::DIRECTORY_NAME, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::READ_ONLY() {
  return getToken(TSqlParser::READ_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Database_filestream_optionContext::FULL() {
  return getToken(TSqlParser::FULL, 0);
}


size_t TSqlParser::Database_filestream_optionContext::getRuleIndex() const {
  return TSqlParser::RuleDatabase_filestream_option;
}

void TSqlParser::Database_filestream_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatabase_filestream_option(this);
}

void TSqlParser::Database_filestream_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatabase_filestream_option(this);
}

TSqlParser::Database_filestream_optionContext* TSqlParser::database_filestream_option() {
  Database_filestream_optionContext *_localctx = _tracker.createInstance<Database_filestream_optionContext>(_ctx, getState());
  enterRule(_localctx, 426, TSqlParser::RuleDatabase_filestream_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4230);
    match(TSqlParser::LR_BRACKET);
    setState(4237);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NON_TRANSACTED_ACCESS: {
        setState(4231);
        match(TSqlParser::NON_TRANSACTED_ACCESS);
        setState(4232);
        match(TSqlParser::EQUAL);
        setState(4233);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FULL || _la == TSqlParser::OFF || _la == TSqlParser::READ_ONLY)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::DIRECTORY_NAME: {
        setState(4234);
        match(TSqlParser::DIRECTORY_NAME);
        setState(4235);
        match(TSqlParser::EQUAL);
        setState(4236);
        match(TSqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4239);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_file_specContext ------------------------------------------------------------------

TSqlParser::Database_file_specContext::Database_file_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::File_groupContext* TSqlParser::Database_file_specContext::file_group() {
  return getRuleContext<TSqlParser::File_groupContext>(0);
}

TSqlParser::File_specContext* TSqlParser::Database_file_specContext::file_spec() {
  return getRuleContext<TSqlParser::File_specContext>(0);
}


size_t TSqlParser::Database_file_specContext::getRuleIndex() const {
  return TSqlParser::RuleDatabase_file_spec;
}

void TSqlParser::Database_file_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatabase_file_spec(this);
}

void TSqlParser::Database_file_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatabase_file_spec(this);
}

TSqlParser::Database_file_specContext* TSqlParser::database_file_spec() {
  Database_file_specContext *_localctx = _tracker.createInstance<Database_file_specContext>(_ctx, getState());
  enterRule(_localctx, 428, TSqlParser::RuleDatabase_file_spec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4243);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::FILEGROUP: {
        enterOuterAlt(_localctx, 1);
        setState(4241);
        file_group();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(4242);
        file_spec();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_groupContext ------------------------------------------------------------------

TSqlParser::File_groupContext::File_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::File_groupContext::FILEGROUP() {
  return getToken(TSqlParser::FILEGROUP, 0);
}

TSqlParser::IdContext* TSqlParser::File_groupContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

std::vector<TSqlParser::File_specContext *> TSqlParser::File_groupContext::file_spec() {
  return getRuleContexts<TSqlParser::File_specContext>();
}

TSqlParser::File_specContext* TSqlParser::File_groupContext::file_spec(size_t i) {
  return getRuleContext<TSqlParser::File_specContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::File_groupContext::CONTAINS() {
  return getTokens(TSqlParser::CONTAINS);
}

tree::TerminalNode* TSqlParser::File_groupContext::CONTAINS(size_t i) {
  return getToken(TSqlParser::CONTAINS, i);
}

tree::TerminalNode* TSqlParser::File_groupContext::FILESTREAM() {
  return getToken(TSqlParser::FILESTREAM, 0);
}

tree::TerminalNode* TSqlParser::File_groupContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::File_groupContext::MEMORY_OPTIMIZED_DATA() {
  return getToken(TSqlParser::MEMORY_OPTIMIZED_DATA, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::File_groupContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::File_groupContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::File_groupContext::getRuleIndex() const {
  return TSqlParser::RuleFile_group;
}

void TSqlParser::File_groupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_group(this);
}

void TSqlParser::File_groupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_group(this);
}

TSqlParser::File_groupContext* TSqlParser::file_group() {
  File_groupContext *_localctx = _tracker.createInstance<File_groupContext>(_ctx, getState());
  enterRule(_localctx, 430, TSqlParser::RuleFile_group);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4245);
    match(TSqlParser::FILEGROUP);
    setState(4246);
    id();
    setState(4249);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 603, _ctx)) {
    case 1: {
      setState(4247);
      match(TSqlParser::CONTAINS);
      setState(4248);
      match(TSqlParser::FILESTREAM);
      break;
    }

    }
    setState(4252);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::DEFAULT) {
      setState(4251);
      match(TSqlParser::DEFAULT);
    }
    setState(4256);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONTAINS) {
      setState(4254);
      match(TSqlParser::CONTAINS);
      setState(4255);
      match(TSqlParser::MEMORY_OPTIMIZED_DATA);
    }
    setState(4258);
    file_spec();
    setState(4263);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 606, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4259);
        match(TSqlParser::COMMA);
        setState(4260);
        file_spec(); 
      }
      setState(4265);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 606, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_specContext ------------------------------------------------------------------

TSqlParser::File_specContext::File_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::File_specContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::File_specContext::NAME() {
  return getToken(TSqlParser::NAME, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::File_specContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::File_specContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

tree::TerminalNode* TSqlParser::File_specContext::FILENAME() {
  return getToken(TSqlParser::FILENAME, 0);
}

tree::TerminalNode* TSqlParser::File_specContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::File_specContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::File_specContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

TSqlParser::IdContext* TSqlParser::File_specContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::File_specContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::File_specContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::File_specContext::SIZE() {
  return getToken(TSqlParser::SIZE, 0);
}

std::vector<TSqlParser::File_sizeContext *> TSqlParser::File_specContext::file_size() {
  return getRuleContexts<TSqlParser::File_sizeContext>();
}

TSqlParser::File_sizeContext* TSqlParser::File_specContext::file_size(size_t i) {
  return getRuleContext<TSqlParser::File_sizeContext>(i);
}

tree::TerminalNode* TSqlParser::File_specContext::MAXSIZE() {
  return getToken(TSqlParser::MAXSIZE, 0);
}

tree::TerminalNode* TSqlParser::File_specContext::FILEGROWTH() {
  return getToken(TSqlParser::FILEGROWTH, 0);
}

tree::TerminalNode* TSqlParser::File_specContext::UNLIMITED() {
  return getToken(TSqlParser::UNLIMITED, 0);
}


size_t TSqlParser::File_specContext::getRuleIndex() const {
  return TSqlParser::RuleFile_spec;
}

void TSqlParser::File_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_spec(this);
}

void TSqlParser::File_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_spec(this);
}

TSqlParser::File_specContext* TSqlParser::file_spec() {
  File_specContext *_localctx = _tracker.createInstance<File_specContext>(_ctx, getState());
  enterRule(_localctx, 432, TSqlParser::RuleFile_spec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4266);
    match(TSqlParser::LR_BRACKET);
    setState(4267);
    match(TSqlParser::NAME);
    setState(4268);
    match(TSqlParser::EQUAL);
    setState(4271);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(4269);
        id();
        break;
      }

      case TSqlParser::STRING: {
        setState(4270);
        match(TSqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4274);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(4273);
      match(TSqlParser::COMMA);
    }
    setState(4276);
    match(TSqlParser::FILENAME);
    setState(4277);
    match(TSqlParser::EQUAL);
    setState(4278);
    dynamic_cast<File_specContext *>(_localctx)->file = match(TSqlParser::STRING);
    setState(4280);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(4279);
      match(TSqlParser::COMMA);
    }
    setState(4288);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SIZE) {
      setState(4282);
      match(TSqlParser::SIZE);
      setState(4283);
      match(TSqlParser::EQUAL);
      setState(4284);
      file_size();
      setState(4286);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(4285);
        match(TSqlParser::COMMA);
      }
    }
    setState(4299);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::MAXSIZE) {
      setState(4290);
      match(TSqlParser::MAXSIZE);
      setState(4291);
      match(TSqlParser::EQUAL);
      setState(4294);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::DECIMAL: {
          setState(4292);
          file_size();
          break;
        }

        case TSqlParser::UNLIMITED: {
          setState(4293);
          match(TSqlParser::UNLIMITED);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(4297);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(4296);
        match(TSqlParser::COMMA);
      }
    }
    setState(4307);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FILEGROWTH) {
      setState(4301);
      match(TSqlParser::FILEGROWTH);
      setState(4302);
      match(TSqlParser::EQUAL);
      setState(4303);
      file_size();
      setState(4305);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(4304);
        match(TSqlParser::COMMA);
      }
    }
    setState(4309);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_nameContext ------------------------------------------------------------------

TSqlParser::Entity_nameContext::Entity_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Entity_nameContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Entity_nameContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Entity_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Entity_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Entity_nameContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name;
}

void TSqlParser::Entity_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name(this);
}

void TSqlParser::Entity_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name(this);
}

TSqlParser::Entity_nameContext* TSqlParser::entity_name() {
  Entity_nameContext *_localctx = _tracker.createInstance<Entity_nameContext>(_ctx, getState());
  enterRule(_localctx, 434, TSqlParser::RuleEntity_name);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4328);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 618, _ctx)) {
    case 1: {
      setState(4311);
      dynamic_cast<Entity_nameContext *>(_localctx)->server = id();
      setState(4312);
      match(TSqlParser::DOT);
      setState(4313);
      dynamic_cast<Entity_nameContext *>(_localctx)->database = id();
      setState(4314);
      match(TSqlParser::DOT);
      setState(4315);
      dynamic_cast<Entity_nameContext *>(_localctx)->schema = id();
      setState(4316);
      match(TSqlParser::DOT);
      break;
    }

    case 2: {
      setState(4318);
      dynamic_cast<Entity_nameContext *>(_localctx)->database = id();
      setState(4319);
      match(TSqlParser::DOT);
      setState(4321);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
        | (1ULL << (TSqlParser::EVENTDATA - 85))
        | (1ULL << (TSqlParser::FILENAME - 85))
        | (1ULL << (TSqlParser::FILLFACTOR - 85))
        | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
        | (1ULL << (TSqlParser::KEY - 164))
        | (1ULL << (TSqlParser::MASTER - 164))
        | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
        | (1ULL << (TSqlParser::PAGE - 238))
        | (1ULL << (TSqlParser::PUBLIC - 238))
        | (1ULL << (TSqlParser::R - 238))
        | (1ULL << (TSqlParser::RAW - 238))
        | (1ULL << (TSqlParser::RETURN - 238))
        | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
        | (1ULL << (TSqlParser::SAFETY - 305))
        | (1ULL << (TSqlParser::SERVER - 305))
        | (1ULL << (TSqlParser::SID - 305))
        | (1ULL << (TSqlParser::SOURCE - 305))
        | (1ULL << (TSqlParser::SPLIT - 305))
        | (1ULL << (TSqlParser::STATE - 305))
        | (1ULL << (TSqlParser::START - 305))
        | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
        | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
        | (1ULL << (TSqlParser::ACTION - 405))
        | (1ULL << (TSqlParser::ACTIVATION - 405))
        | (1ULL << (TSqlParser::ACTIVE - 405))
        | (1ULL << (TSqlParser::ADDRESS - 405))
        | (1ULL << (TSqlParser::AES_128 - 405))
        | (1ULL << (TSqlParser::AES_192 - 405))
        | (1ULL << (TSqlParser::AES_256 - 405))
        | (1ULL << (TSqlParser::AFFINITY - 405))
        | (1ULL << (TSqlParser::AFTER - 405))
        | (1ULL << (TSqlParser::AGGREGATE - 405))
        | (1ULL << (TSqlParser::ALGORITHM - 405))
        | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
        | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
        | (1ULL << (TSqlParser::ALLOWED - 405))
        | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
        | (1ULL << (TSqlParser::ANSI_NULLS - 405))
        | (1ULL << (TSqlParser::ANSI_PADDING - 405))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
        | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
        | (1ULL << (TSqlParser::APPLY - 405))
        | (1ULL << (TSqlParser::ARITHABORT - 405))
        | (1ULL << (TSqlParser::ASSEMBLY - 405))
        | (1ULL << (TSqlParser::AUDIT - 405))
        | (1ULL << (TSqlParser::AUDIT_GUID - 405))
        | (1ULL << (TSqlParser::AUTO - 405))
        | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
        | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
        | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
        | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
        | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
        | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
        | (1ULL << (TSqlParser::AVAILABILITY - 405))
        | (1ULL << (TSqlParser::AVG - 405))
        | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
        | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
        | (1ULL << (TSqlParser::BIGINT - 405))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
        | (1ULL << (TSqlParser::BINDING - 405))
        | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
        | (1ULL << (TSqlParser::BROKER - 405))
        | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
        | (1ULL << (TSqlParser::BULK_LOGGED - 405))
        | (1ULL << (TSqlParser::CALLER - 405))
        | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
        | (1ULL << (TSqlParser::CAST - 405))
        | (1ULL << (TSqlParser::CATALOG - 405))
        | (1ULL << (TSqlParser::CATCH - 405))
        | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
        | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
        | (1ULL << (TSqlParser::CHECKSUM - 405))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
        | (1ULL << (TSqlParser::CLEANUP - 405))
        | (1ULL << (TSqlParser::COLLECTION - 405))
        | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
        | (1ULL << (TSqlParser::COMMITTED - 405))
        | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
        | (1ULL << (TSqlParser::CONCAT - 405))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
        | (1ULL << (TSqlParser::CONTENT - 405))
        | (1ULL << (TSqlParser::CONTROL - 405))
        | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
        | (1ULL << (TSqlParser::COUNT_BIG - 469))
        | (1ULL << (TSqlParser::COUNTER - 469))
        | (1ULL << (TSqlParser::CPU - 469))
        | (1ULL << (TSqlParser::CREATE_NEW - 469))
        | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
        | (1ULL << (TSqlParser::CREDENTIAL - 469))
        | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
        | (1ULL << (TSqlParser::DATA - 469))
        | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
        | (1ULL << (TSqlParser::DATEADD - 469))
        | (1ULL << (TSqlParser::DATEDIFF - 469))
        | (1ULL << (TSqlParser::DATENAME - 469))
        | (1ULL << (TSqlParser::DATEPART - 469))
        | (1ULL << (TSqlParser::DAYS - 469))
        | (1ULL << (TSqlParser::DB_CHAINING - 469))
        | (1ULL << (TSqlParser::DB_FAILOVER - 469))
        | (1ULL << (TSqlParser::DECRYPTION - 469))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
        | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
        | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
        | (1ULL << (TSqlParser::DELAY - 469))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
        | (1ULL << (TSqlParser::DELETED - 469))
        | (1ULL << (TSqlParser::DENSE_RANK - 469))
        | (1ULL << (TSqlParser::DEPENDENTS - 469))
        | (1ULL << (TSqlParser::DES - 469))
        | (1ULL << (TSqlParser::DESCRIPTION - 469))
        | (1ULL << (TSqlParser::DESX - 469))
        | (1ULL << (TSqlParser::DHCP - 469))
        | (1ULL << (TSqlParser::DIALOG - 469))
        | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
        | (1ULL << (TSqlParser::DISABLE - 469))
        | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
        | (1ULL << (TSqlParser::DISABLED - 469))
        | (1ULL << (TSqlParser::DISK_DRIVE - 469))
        | (1ULL << (TSqlParser::DOCUMENT - 469))
        | (1ULL << (TSqlParser::DYNAMIC - 469))
        | (1ULL << (TSqlParser::EMERGENCY - 469))
        | (1ULL << (TSqlParser::EMPTY - 469))
        | (1ULL << (TSqlParser::ENABLE - 469))
        | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
        | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
        | (1ULL << (TSqlParser::ENCRYPTION - 469))
        | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
        | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
        | (1ULL << (TSqlParser::EXCLUSIVE - 469))
        | (1ULL << (TSqlParser::EXECUTABLE - 469))
        | (1ULL << (TSqlParser::EXIST - 469))
        | (1ULL << (TSqlParser::EXPAND - 469))
        | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
        | (1ULL << (TSqlParser::EXPLICIT - 469))
        | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
        | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
        | (1ULL << (TSqlParser::FAILURE - 469))
        | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
        | (1ULL << (TSqlParser::FAST - 469))
        | (1ULL << (TSqlParser::FAST_FORWARD - 469))
        | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
        | (1ULL << (TSqlParser::FILEPATH - 533))
        | (1ULL << (TSqlParser::FILESTREAM - 533))
        | (1ULL << (TSqlParser::FILTER - 533))
        | (1ULL << (TSqlParser::FIRST - 533))
        | (1ULL << (TSqlParser::FIRST_VALUE - 533))
        | (1ULL << (TSqlParser::FOLLOWING - 533))
        | (1ULL << (TSqlParser::FORCE - 533))
        | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
        | (1ULL << (TSqlParser::FORCED - 533))
        | (1ULL << (TSqlParser::FORMAT - 533))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
        | (1ULL << (TSqlParser::FULLSCAN - 533))
        | (1ULL << (TSqlParser::FULLTEXT - 533))
        | (1ULL << (TSqlParser::GB - 533))
        | (1ULL << (TSqlParser::GETDATE - 533))
        | (1ULL << (TSqlParser::GETUTCDATE - 533))
        | (1ULL << (TSqlParser::GLOBAL - 533))
        | (1ULL << (TSqlParser::GO - 533))
        | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
        | (1ULL << (TSqlParser::GROUPING - 533))
        | (1ULL << (TSqlParser::GROUPING_ID - 533))
        | (1ULL << (TSqlParser::HADR - 533))
        | (1ULL << (TSqlParser::HASH - 533))
        | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
        | (1ULL << (TSqlParser::HIGH - 533))
        | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
        | (1ULL << (TSqlParser::HOURS - 533))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
        | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
        | (1ULL << (TSqlParser::IMMEDIATE - 533))
        | (1ULL << (TSqlParser::IMPERSONATE - 533))
        | (1ULL << (TSqlParser::IMPORTANCE - 533))
        | (1ULL << (TSqlParser::INCREMENTAL - 533))
        | (1ULL << (TSqlParser::INITIATOR - 533))
        | (1ULL << (TSqlParser::INPUT - 533))
        | (1ULL << (TSqlParser::INSENSITIVE - 533))
        | (1ULL << (TSqlParser::INSERTED - 533))
        | (1ULL << (TSqlParser::INT - 533))
        | (1ULL << (TSqlParser::IP - 533))
        | (1ULL << (TSqlParser::ISOLATION - 533))
        | (1ULL << (TSqlParser::KB - 533))
        | (1ULL << (TSqlParser::KEEP - 533))
        | (1ULL << (TSqlParser::KEEPFIXED - 533))
        | (1ULL << (TSqlParser::KEY_SOURCE - 533))
        | (1ULL << (TSqlParser::KEYS - 533))
        | (1ULL << (TSqlParser::KEYSET - 533))
        | (1ULL << (TSqlParser::LAG - 533))
        | (1ULL << (TSqlParser::LAST - 533))
        | (1ULL << (TSqlParser::LAST_VALUE - 533))
        | (1ULL << (TSqlParser::LEAD - 533))
        | (1ULL << (TSqlParser::LEVEL - 533))
        | (1ULL << (TSqlParser::LIST - 533))
        | (1ULL << (TSqlParser::LISTENER - 533))
        | (1ULL << (TSqlParser::LISTENER_URL - 533))
        | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
        | (1ULL << (TSqlParser::LOCAL - 533))
        | (1ULL << (TSqlParser::LOCATION - 533))
        | (1ULL << (TSqlParser::LOCK - 533))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
        | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
        | (1ULL << (TSqlParser::LOW - 597))
        | (1ULL << (TSqlParser::MANUAL - 597))
        | (1ULL << (TSqlParser::MARK - 597))
        | (1ULL << (TSqlParser::MATERIALIZED - 597))
        | (1ULL << (TSqlParser::MAX - 597))
        | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
        | (1ULL << (TSqlParser::MAX_DOP - 597))
        | (1ULL << (TSqlParser::MAX_FILES - 597))
        | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
        | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
        | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
        | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
        | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
        | (1ULL << (TSqlParser::MAXDOP - 597))
        | (1ULL << (TSqlParser::MAXRECURSION - 597))
        | (1ULL << (TSqlParser::MAXSIZE - 597))
        | (1ULL << (TSqlParser::MB - 597))
        | (1ULL << (TSqlParser::MEDIUM - 597))
        | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
        | (1ULL << (TSqlParser::MESSAGE - 597))
        | (1ULL << (TSqlParser::MIN - 597))
        | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
        | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
        | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
        | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
        | (1ULL << (TSqlParser::MINUTES - 597))
        | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
        | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
        | (1ULL << (TSqlParser::MODE - 597))
        | (1ULL << (TSqlParser::MODIFY - 597))
        | (1ULL << (TSqlParser::MOVE - 597))
        | (1ULL << (TSqlParser::MULTI_USER - 597))
        | (1ULL << (TSqlParser::NAME - 597))
        | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
        | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
        | (1ULL << (TSqlParser::NEW_BROKER - 597))
        | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
        | (1ULL << (TSqlParser::NEXT - 597))
        | (1ULL << (TSqlParser::NO - 597))
        | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
        | (1ULL << (TSqlParser::NO_WAIT - 597))
        | (1ULL << (TSqlParser::NOCOUNT - 597))
        | (1ULL << (TSqlParser::NODES - 597))
        | (1ULL << (TSqlParser::NOEXPAND - 597))
        | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
        | (1ULL << (TSqlParser::NORECOMPUTE - 597))
        | (1ULL << (TSqlParser::NORECOVERY - 597))
        | (1ULL << (TSqlParser::NOWAIT - 597))
        | (1ULL << (TSqlParser::NTILE - 597))
        | (1ULL << (TSqlParser::NUMANODE - 597))
        | (1ULL << (TSqlParser::NUMBER - 597))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
        | (1ULL << (TSqlParser::OBJECT - 597))
        | (1ULL << (TSqlParser::OFFLINE - 597))
        | (1ULL << (TSqlParser::OFFSET - 597))
        | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
        | (1ULL << (TSqlParser::ONLINE - 597))
        | (1ULL << (TSqlParser::ONLY - 597))
        | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
        | (1ULL << (TSqlParser::OPTIMISTIC - 597))
        | (1ULL << (TSqlParser::OPTIMIZE - 597))
        | (1ULL << (TSqlParser::OUT - 597))
        | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
        | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
        | (1ULL << (TSqlParser::PARTITION - 662))
        | (1ULL << (TSqlParser::PARTITIONS - 662))
        | (1ULL << (TSqlParser::PARTNER - 662))
        | (1ULL << (TSqlParser::PATH - 662))
        | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
        | (1ULL << (TSqlParser::POOL - 662))
        | (1ULL << (TSqlParser::PORT - 662))
        | (1ULL << (TSqlParser::PRECEDING - 662))
        | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
        | (1ULL << (TSqlParser::PRIOR - 662))
        | (1ULL << (TSqlParser::PRIORITY - 662))
        | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
        | (1ULL << (TSqlParser::PRIVATE - 662))
        | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
        | (1ULL << (TSqlParser::PRIVILEGES - 662))
        | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
        | (1ULL << (TSqlParser::PROPERTY - 662))
        | (1ULL << (TSqlParser::PROVIDER - 662))
        | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
        | (1ULL << (TSqlParser::QUERY - 662))
        | (1ULL << (TSqlParser::QUEUE - 662))
        | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
        | (1ULL << (TSqlParser::RANGE - 662))
        | (1ULL << (TSqlParser::RANK - 662))
        | (1ULL << (TSqlParser::RC2 - 662))
        | (1ULL << (TSqlParser::RC4 - 662))
        | (1ULL << (TSqlParser::RC4_128 - 662))
        | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
        | (1ULL << (TSqlParser::READ_ONLY - 662))
        | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
        | (1ULL << (TSqlParser::READ_WRITE - 662))
        | (1ULL << (TSqlParser::READONLY - 662))
        | (1ULL << (TSqlParser::REBUILD - 662))
        | (1ULL << (TSqlParser::RECEIVE - 662))
        | (1ULL << (TSqlParser::RECOMPILE - 662))
        | (1ULL << (TSqlParser::RECOVERY - 662))
        | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
        | (1ULL << (TSqlParser::RELATIVE - 662))
        | (1ULL << (TSqlParser::REMOTE - 662))
        | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
        | (1ULL << (TSqlParser::REMOVE - 662))
        | (1ULL << (TSqlParser::REORGANIZE - 662))
        | (1ULL << (TSqlParser::REPEATABLE - 662))
        | (1ULL << (TSqlParser::REPLICA - 662))
        | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
        | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
        | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
        | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
        | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
        | (1ULL << (TSqlParser::RESOURCE - 662))
        | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
        | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
        | (1ULL << (TSqlParser::RETENTION - 662))
        | (1ULL << (TSqlParser::ROBUST - 662))
        | (1ULL << (TSqlParser::ROOT - 662))
        | (1ULL << (TSqlParser::ROUTE - 662))
        | (1ULL << (TSqlParser::ROW - 662))
        | (1ULL << (TSqlParser::ROW_NUMBER - 662))
        | (1ULL << (TSqlParser::ROWGUID - 662))
        | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
        | (1ULL << (TSqlParser::SCHEMABINDING - 726))
        | (1ULL << (TSqlParser::SCOPED - 726))
        | (1ULL << (TSqlParser::SCROLL - 726))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
        | (1ULL << (TSqlParser::SEARCH - 726))
        | (1ULL << (TSqlParser::SECONDARY - 726))
        | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
        | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
        | (1ULL << (TSqlParser::SECONDS - 726))
        | (1ULL << (TSqlParser::SECRET - 726))
        | (1ULL << (TSqlParser::SECURITY - 726))
        | (1ULL << (TSqlParser::SECURITY_LOG - 726))
        | (1ULL << (TSqlParser::SEEDING_MODE - 726))
        | (1ULL << (TSqlParser::SELF - 726))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
        | (1ULL << (TSqlParser::SEND - 726))
        | (1ULL << (TSqlParser::SENT - 726))
        | (1ULL << (TSqlParser::SEQUENCE - 726))
        | (1ULL << (TSqlParser::SERIALIZABLE - 726))
        | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
        | (1ULL << (TSqlParser::SETERROR - 726))
        | (1ULL << (TSqlParser::SHARE - 726))
        | (1ULL << (TSqlParser::SHOWPLAN - 726))
        | (1ULL << (TSqlParser::SIGNATURE - 726))
        | (1ULL << (TSqlParser::SIMPLE - 726))
        | (1ULL << (TSqlParser::SINGLE_USER - 726))
        | (1ULL << (TSqlParser::SIZE - 726))
        | (1ULL << (TSqlParser::SMALLINT - 726))
        | (1ULL << (TSqlParser::SNAPSHOT - 726))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
        | (1ULL << (TSqlParser::STANDBY - 726))
        | (1ULL << (TSqlParser::START_DATE - 726))
        | (1ULL << (TSqlParser::STATIC - 726))
        | (1ULL << (TSqlParser::STATS_STREAM - 726))
        | (1ULL << (TSqlParser::STATUS - 726))
        | (1ULL << (TSqlParser::STDEV - 726))
        | (1ULL << (TSqlParser::STDEVP - 726))
        | (1ULL << (TSqlParser::STOPLIST - 726))
        | (1ULL << (TSqlParser::STRING_AGG - 726))
        | (1ULL << (TSqlParser::STUFF - 726))
        | (1ULL << (TSqlParser::SUBJECT - 726))
        | (1ULL << (TSqlParser::SUM - 726))
        | (1ULL << (TSqlParser::SUSPEND - 726))
        | (1ULL << (TSqlParser::SYMMETRIC - 726))
        | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
        | (1ULL << (TSqlParser::SYNONYM - 726))
        | (1ULL << (TSqlParser::SYSTEM - 726))
        | (1ULL << (TSqlParser::TAKE - 726))
        | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
        | (1ULL << (TSqlParser::TB - 726))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
        | (1ULL << (TSqlParser::THROW - 726))
        | (1ULL << (TSqlParser::TIES - 726))
        | (1ULL << (TSqlParser::TIME - 726))
        | (1ULL << (TSqlParser::TIMEOUT - 726))
        | (1ULL << (TSqlParser::TIMER - 726))
        | (1ULL << (TSqlParser::TINYINT - 726))
        | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
        | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
        | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
        | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
        | (1ULL << (TSqlParser::TRY - 790))
        | (1ULL << (TSqlParser::TSQL - 790))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
        | (1ULL << (TSqlParser::TYPE - 790))
        | (1ULL << (TSqlParser::TYPE_WARNING - 790))
        | (1ULL << (TSqlParser::UNBOUNDED - 790))
        | (1ULL << (TSqlParser::UNCOMMITTED - 790))
        | (1ULL << (TSqlParser::UNKNOWN - 790))
        | (1ULL << (TSqlParser::UNLIMITED - 790))
        | (1ULL << (TSqlParser::USING - 790))
        | (1ULL << (TSqlParser::VALID_XML - 790))
        | (1ULL << (TSqlParser::VALIDATION - 790))
        | (1ULL << (TSqlParser::VALUE - 790))
        | (1ULL << (TSqlParser::VAR - 790))
        | (1ULL << (TSqlParser::VARP - 790))
        | (1ULL << (TSqlParser::VIEW_METADATA - 790))
        | (1ULL << (TSqlParser::VIEWS - 790))
        | (1ULL << (TSqlParser::WAIT - 790))
        | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
        | (1ULL << (TSqlParser::WORK - 790))
        | (1ULL << (TSqlParser::WORKLOAD - 790))
        | (1ULL << (TSqlParser::XML - 790))
        | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
        | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
        setState(4320);
        dynamic_cast<Entity_nameContext *>(_localctx)->schema = id();
      }
      setState(4323);
      match(TSqlParser::DOT);
      break;
    }

    case 3: {
      setState(4325);
      dynamic_cast<Entity_nameContext *>(_localctx)->schema = id();
      setState(4326);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(4330);
    dynamic_cast<Entity_nameContext *>(_localctx)->table = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_name_for_azure_dwContext ------------------------------------------------------------------

TSqlParser::Entity_name_for_azure_dwContext::Entity_name_for_azure_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Entity_name_for_azure_dwContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Entity_name_for_azure_dwContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Entity_name_for_azure_dwContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Entity_name_for_azure_dwContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name_for_azure_dw;
}

void TSqlParser::Entity_name_for_azure_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name_for_azure_dw(this);
}

void TSqlParser::Entity_name_for_azure_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name_for_azure_dw(this);
}

TSqlParser::Entity_name_for_azure_dwContext* TSqlParser::entity_name_for_azure_dw() {
  Entity_name_for_azure_dwContext *_localctx = _tracker.createInstance<Entity_name_for_azure_dwContext>(_ctx, getState());
  enterRule(_localctx, 436, TSqlParser::RuleEntity_name_for_azure_dw);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4337);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 619, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4332);
      dynamic_cast<Entity_name_for_azure_dwContext *>(_localctx)->schema = id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4333);
      dynamic_cast<Entity_name_for_azure_dwContext *>(_localctx)->schema = id();
      setState(4334);
      match(TSqlParser::DOT);
      setState(4335);
      dynamic_cast<Entity_name_for_azure_dwContext *>(_localctx)->object_name = id();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_name_for_parallel_dwContext ------------------------------------------------------------------

TSqlParser::Entity_name_for_parallel_dwContext::Entity_name_for_parallel_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Entity_name_for_parallel_dwContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Entity_name_for_parallel_dwContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Entity_name_for_parallel_dwContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Entity_name_for_parallel_dwContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name_for_parallel_dw;
}

void TSqlParser::Entity_name_for_parallel_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name_for_parallel_dw(this);
}

void TSqlParser::Entity_name_for_parallel_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name_for_parallel_dw(this);
}

TSqlParser::Entity_name_for_parallel_dwContext* TSqlParser::entity_name_for_parallel_dw() {
  Entity_name_for_parallel_dwContext *_localctx = _tracker.createInstance<Entity_name_for_parallel_dwContext>(_ctx, getState());
  enterRule(_localctx, 438, TSqlParser::RuleEntity_name_for_parallel_dw);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4344);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 620, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4339);
      dynamic_cast<Entity_name_for_parallel_dwContext *>(_localctx)->schema_database = id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4340);
      dynamic_cast<Entity_name_for_parallel_dwContext *>(_localctx)->schema = id();
      setState(4341);
      match(TSqlParser::DOT);
      setState(4342);
      dynamic_cast<Entity_name_for_parallel_dwContext *>(_localctx)->object_name = id();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_table_nameContext ------------------------------------------------------------------

TSqlParser::Full_table_nameContext::Full_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Full_table_nameContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Full_table_nameContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Full_table_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Full_table_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Full_table_nameContext::getRuleIndex() const {
  return TSqlParser::RuleFull_table_name;
}

void TSqlParser::Full_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_table_name(this);
}

void TSqlParser::Full_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_table_name(this);
}

TSqlParser::Full_table_nameContext* TSqlParser::full_table_name() {
  Full_table_nameContext *_localctx = _tracker.createInstance<Full_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 440, TSqlParser::RuleFull_table_name);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4363);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 622, _ctx)) {
    case 1: {
      setState(4346);
      dynamic_cast<Full_table_nameContext *>(_localctx)->server = id();
      setState(4347);
      match(TSqlParser::DOT);
      setState(4348);
      dynamic_cast<Full_table_nameContext *>(_localctx)->database = id();
      setState(4349);
      match(TSqlParser::DOT);
      setState(4350);
      dynamic_cast<Full_table_nameContext *>(_localctx)->schema = id();
      setState(4351);
      match(TSqlParser::DOT);
      break;
    }

    case 2: {
      setState(4353);
      dynamic_cast<Full_table_nameContext *>(_localctx)->database = id();
      setState(4354);
      match(TSqlParser::DOT);
      setState(4356);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
        | (1ULL << (TSqlParser::EVENTDATA - 85))
        | (1ULL << (TSqlParser::FILENAME - 85))
        | (1ULL << (TSqlParser::FILLFACTOR - 85))
        | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
        | (1ULL << (TSqlParser::KEY - 164))
        | (1ULL << (TSqlParser::MASTER - 164))
        | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
        | (1ULL << (TSqlParser::PAGE - 238))
        | (1ULL << (TSqlParser::PUBLIC - 238))
        | (1ULL << (TSqlParser::R - 238))
        | (1ULL << (TSqlParser::RAW - 238))
        | (1ULL << (TSqlParser::RETURN - 238))
        | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
        | (1ULL << (TSqlParser::SAFETY - 305))
        | (1ULL << (TSqlParser::SERVER - 305))
        | (1ULL << (TSqlParser::SID - 305))
        | (1ULL << (TSqlParser::SOURCE - 305))
        | (1ULL << (TSqlParser::SPLIT - 305))
        | (1ULL << (TSqlParser::STATE - 305))
        | (1ULL << (TSqlParser::START - 305))
        | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
        | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
        | (1ULL << (TSqlParser::ACTION - 405))
        | (1ULL << (TSqlParser::ACTIVATION - 405))
        | (1ULL << (TSqlParser::ACTIVE - 405))
        | (1ULL << (TSqlParser::ADDRESS - 405))
        | (1ULL << (TSqlParser::AES_128 - 405))
        | (1ULL << (TSqlParser::AES_192 - 405))
        | (1ULL << (TSqlParser::AES_256 - 405))
        | (1ULL << (TSqlParser::AFFINITY - 405))
        | (1ULL << (TSqlParser::AFTER - 405))
        | (1ULL << (TSqlParser::AGGREGATE - 405))
        | (1ULL << (TSqlParser::ALGORITHM - 405))
        | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
        | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
        | (1ULL << (TSqlParser::ALLOWED - 405))
        | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
        | (1ULL << (TSqlParser::ANSI_NULLS - 405))
        | (1ULL << (TSqlParser::ANSI_PADDING - 405))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
        | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
        | (1ULL << (TSqlParser::APPLY - 405))
        | (1ULL << (TSqlParser::ARITHABORT - 405))
        | (1ULL << (TSqlParser::ASSEMBLY - 405))
        | (1ULL << (TSqlParser::AUDIT - 405))
        | (1ULL << (TSqlParser::AUDIT_GUID - 405))
        | (1ULL << (TSqlParser::AUTO - 405))
        | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
        | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
        | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
        | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
        | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
        | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
        | (1ULL << (TSqlParser::AVAILABILITY - 405))
        | (1ULL << (TSqlParser::AVG - 405))
        | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
        | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
        | (1ULL << (TSqlParser::BIGINT - 405))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
        | (1ULL << (TSqlParser::BINDING - 405))
        | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
        | (1ULL << (TSqlParser::BROKER - 405))
        | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
        | (1ULL << (TSqlParser::BULK_LOGGED - 405))
        | (1ULL << (TSqlParser::CALLER - 405))
        | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
        | (1ULL << (TSqlParser::CAST - 405))
        | (1ULL << (TSqlParser::CATALOG - 405))
        | (1ULL << (TSqlParser::CATCH - 405))
        | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
        | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
        | (1ULL << (TSqlParser::CHECKSUM - 405))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
        | (1ULL << (TSqlParser::CLEANUP - 405))
        | (1ULL << (TSqlParser::COLLECTION - 405))
        | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
        | (1ULL << (TSqlParser::COMMITTED - 405))
        | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
        | (1ULL << (TSqlParser::CONCAT - 405))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
        | (1ULL << (TSqlParser::CONTENT - 405))
        | (1ULL << (TSqlParser::CONTROL - 405))
        | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
        | (1ULL << (TSqlParser::COUNT_BIG - 469))
        | (1ULL << (TSqlParser::COUNTER - 469))
        | (1ULL << (TSqlParser::CPU - 469))
        | (1ULL << (TSqlParser::CREATE_NEW - 469))
        | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
        | (1ULL << (TSqlParser::CREDENTIAL - 469))
        | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
        | (1ULL << (TSqlParser::DATA - 469))
        | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
        | (1ULL << (TSqlParser::DATEADD - 469))
        | (1ULL << (TSqlParser::DATEDIFF - 469))
        | (1ULL << (TSqlParser::DATENAME - 469))
        | (1ULL << (TSqlParser::DATEPART - 469))
        | (1ULL << (TSqlParser::DAYS - 469))
        | (1ULL << (TSqlParser::DB_CHAINING - 469))
        | (1ULL << (TSqlParser::DB_FAILOVER - 469))
        | (1ULL << (TSqlParser::DECRYPTION - 469))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
        | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
        | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
        | (1ULL << (TSqlParser::DELAY - 469))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
        | (1ULL << (TSqlParser::DELETED - 469))
        | (1ULL << (TSqlParser::DENSE_RANK - 469))
        | (1ULL << (TSqlParser::DEPENDENTS - 469))
        | (1ULL << (TSqlParser::DES - 469))
        | (1ULL << (TSqlParser::DESCRIPTION - 469))
        | (1ULL << (TSqlParser::DESX - 469))
        | (1ULL << (TSqlParser::DHCP - 469))
        | (1ULL << (TSqlParser::DIALOG - 469))
        | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
        | (1ULL << (TSqlParser::DISABLE - 469))
        | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
        | (1ULL << (TSqlParser::DISABLED - 469))
        | (1ULL << (TSqlParser::DISK_DRIVE - 469))
        | (1ULL << (TSqlParser::DOCUMENT - 469))
        | (1ULL << (TSqlParser::DYNAMIC - 469))
        | (1ULL << (TSqlParser::EMERGENCY - 469))
        | (1ULL << (TSqlParser::EMPTY - 469))
        | (1ULL << (TSqlParser::ENABLE - 469))
        | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
        | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
        | (1ULL << (TSqlParser::ENCRYPTION - 469))
        | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
        | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
        | (1ULL << (TSqlParser::EXCLUSIVE - 469))
        | (1ULL << (TSqlParser::EXECUTABLE - 469))
        | (1ULL << (TSqlParser::EXIST - 469))
        | (1ULL << (TSqlParser::EXPAND - 469))
        | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
        | (1ULL << (TSqlParser::EXPLICIT - 469))
        | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
        | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
        | (1ULL << (TSqlParser::FAILURE - 469))
        | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
        | (1ULL << (TSqlParser::FAST - 469))
        | (1ULL << (TSqlParser::FAST_FORWARD - 469))
        | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
        | (1ULL << (TSqlParser::FILEPATH - 533))
        | (1ULL << (TSqlParser::FILESTREAM - 533))
        | (1ULL << (TSqlParser::FILTER - 533))
        | (1ULL << (TSqlParser::FIRST - 533))
        | (1ULL << (TSqlParser::FIRST_VALUE - 533))
        | (1ULL << (TSqlParser::FOLLOWING - 533))
        | (1ULL << (TSqlParser::FORCE - 533))
        | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
        | (1ULL << (TSqlParser::FORCED - 533))
        | (1ULL << (TSqlParser::FORMAT - 533))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
        | (1ULL << (TSqlParser::FULLSCAN - 533))
        | (1ULL << (TSqlParser::FULLTEXT - 533))
        | (1ULL << (TSqlParser::GB - 533))
        | (1ULL << (TSqlParser::GETDATE - 533))
        | (1ULL << (TSqlParser::GETUTCDATE - 533))
        | (1ULL << (TSqlParser::GLOBAL - 533))
        | (1ULL << (TSqlParser::GO - 533))
        | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
        | (1ULL << (TSqlParser::GROUPING - 533))
        | (1ULL << (TSqlParser::GROUPING_ID - 533))
        | (1ULL << (TSqlParser::HADR - 533))
        | (1ULL << (TSqlParser::HASH - 533))
        | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
        | (1ULL << (TSqlParser::HIGH - 533))
        | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
        | (1ULL << (TSqlParser::HOURS - 533))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
        | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
        | (1ULL << (TSqlParser::IMMEDIATE - 533))
        | (1ULL << (TSqlParser::IMPERSONATE - 533))
        | (1ULL << (TSqlParser::IMPORTANCE - 533))
        | (1ULL << (TSqlParser::INCREMENTAL - 533))
        | (1ULL << (TSqlParser::INITIATOR - 533))
        | (1ULL << (TSqlParser::INPUT - 533))
        | (1ULL << (TSqlParser::INSENSITIVE - 533))
        | (1ULL << (TSqlParser::INSERTED - 533))
        | (1ULL << (TSqlParser::INT - 533))
        | (1ULL << (TSqlParser::IP - 533))
        | (1ULL << (TSqlParser::ISOLATION - 533))
        | (1ULL << (TSqlParser::KB - 533))
        | (1ULL << (TSqlParser::KEEP - 533))
        | (1ULL << (TSqlParser::KEEPFIXED - 533))
        | (1ULL << (TSqlParser::KEY_SOURCE - 533))
        | (1ULL << (TSqlParser::KEYS - 533))
        | (1ULL << (TSqlParser::KEYSET - 533))
        | (1ULL << (TSqlParser::LAG - 533))
        | (1ULL << (TSqlParser::LAST - 533))
        | (1ULL << (TSqlParser::LAST_VALUE - 533))
        | (1ULL << (TSqlParser::LEAD - 533))
        | (1ULL << (TSqlParser::LEVEL - 533))
        | (1ULL << (TSqlParser::LIST - 533))
        | (1ULL << (TSqlParser::LISTENER - 533))
        | (1ULL << (TSqlParser::LISTENER_URL - 533))
        | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
        | (1ULL << (TSqlParser::LOCAL - 533))
        | (1ULL << (TSqlParser::LOCATION - 533))
        | (1ULL << (TSqlParser::LOCK - 533))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
        | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
        | (1ULL << (TSqlParser::LOW - 597))
        | (1ULL << (TSqlParser::MANUAL - 597))
        | (1ULL << (TSqlParser::MARK - 597))
        | (1ULL << (TSqlParser::MATERIALIZED - 597))
        | (1ULL << (TSqlParser::MAX - 597))
        | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
        | (1ULL << (TSqlParser::MAX_DOP - 597))
        | (1ULL << (TSqlParser::MAX_FILES - 597))
        | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
        | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
        | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
        | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
        | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
        | (1ULL << (TSqlParser::MAXDOP - 597))
        | (1ULL << (TSqlParser::MAXRECURSION - 597))
        | (1ULL << (TSqlParser::MAXSIZE - 597))
        | (1ULL << (TSqlParser::MB - 597))
        | (1ULL << (TSqlParser::MEDIUM - 597))
        | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
        | (1ULL << (TSqlParser::MESSAGE - 597))
        | (1ULL << (TSqlParser::MIN - 597))
        | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
        | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
        | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
        | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
        | (1ULL << (TSqlParser::MINUTES - 597))
        | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
        | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
        | (1ULL << (TSqlParser::MODE - 597))
        | (1ULL << (TSqlParser::MODIFY - 597))
        | (1ULL << (TSqlParser::MOVE - 597))
        | (1ULL << (TSqlParser::MULTI_USER - 597))
        | (1ULL << (TSqlParser::NAME - 597))
        | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
        | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
        | (1ULL << (TSqlParser::NEW_BROKER - 597))
        | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
        | (1ULL << (TSqlParser::NEXT - 597))
        | (1ULL << (TSqlParser::NO - 597))
        | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
        | (1ULL << (TSqlParser::NO_WAIT - 597))
        | (1ULL << (TSqlParser::NOCOUNT - 597))
        | (1ULL << (TSqlParser::NODES - 597))
        | (1ULL << (TSqlParser::NOEXPAND - 597))
        | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
        | (1ULL << (TSqlParser::NORECOMPUTE - 597))
        | (1ULL << (TSqlParser::NORECOVERY - 597))
        | (1ULL << (TSqlParser::NOWAIT - 597))
        | (1ULL << (TSqlParser::NTILE - 597))
        | (1ULL << (TSqlParser::NUMANODE - 597))
        | (1ULL << (TSqlParser::NUMBER - 597))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
        | (1ULL << (TSqlParser::OBJECT - 597))
        | (1ULL << (TSqlParser::OFFLINE - 597))
        | (1ULL << (TSqlParser::OFFSET - 597))
        | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
        | (1ULL << (TSqlParser::ONLINE - 597))
        | (1ULL << (TSqlParser::ONLY - 597))
        | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
        | (1ULL << (TSqlParser::OPTIMISTIC - 597))
        | (1ULL << (TSqlParser::OPTIMIZE - 597))
        | (1ULL << (TSqlParser::OUT - 597))
        | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
        | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
        | (1ULL << (TSqlParser::PARTITION - 662))
        | (1ULL << (TSqlParser::PARTITIONS - 662))
        | (1ULL << (TSqlParser::PARTNER - 662))
        | (1ULL << (TSqlParser::PATH - 662))
        | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
        | (1ULL << (TSqlParser::POOL - 662))
        | (1ULL << (TSqlParser::PORT - 662))
        | (1ULL << (TSqlParser::PRECEDING - 662))
        | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
        | (1ULL << (TSqlParser::PRIOR - 662))
        | (1ULL << (TSqlParser::PRIORITY - 662))
        | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
        | (1ULL << (TSqlParser::PRIVATE - 662))
        | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
        | (1ULL << (TSqlParser::PRIVILEGES - 662))
        | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
        | (1ULL << (TSqlParser::PROPERTY - 662))
        | (1ULL << (TSqlParser::PROVIDER - 662))
        | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
        | (1ULL << (TSqlParser::QUERY - 662))
        | (1ULL << (TSqlParser::QUEUE - 662))
        | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
        | (1ULL << (TSqlParser::RANGE - 662))
        | (1ULL << (TSqlParser::RANK - 662))
        | (1ULL << (TSqlParser::RC2 - 662))
        | (1ULL << (TSqlParser::RC4 - 662))
        | (1ULL << (TSqlParser::RC4_128 - 662))
        | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
        | (1ULL << (TSqlParser::READ_ONLY - 662))
        | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
        | (1ULL << (TSqlParser::READ_WRITE - 662))
        | (1ULL << (TSqlParser::READONLY - 662))
        | (1ULL << (TSqlParser::REBUILD - 662))
        | (1ULL << (TSqlParser::RECEIVE - 662))
        | (1ULL << (TSqlParser::RECOMPILE - 662))
        | (1ULL << (TSqlParser::RECOVERY - 662))
        | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
        | (1ULL << (TSqlParser::RELATIVE - 662))
        | (1ULL << (TSqlParser::REMOTE - 662))
        | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
        | (1ULL << (TSqlParser::REMOVE - 662))
        | (1ULL << (TSqlParser::REORGANIZE - 662))
        | (1ULL << (TSqlParser::REPEATABLE - 662))
        | (1ULL << (TSqlParser::REPLICA - 662))
        | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
        | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
        | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
        | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
        | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
        | (1ULL << (TSqlParser::RESOURCE - 662))
        | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
        | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
        | (1ULL << (TSqlParser::RETENTION - 662))
        | (1ULL << (TSqlParser::ROBUST - 662))
        | (1ULL << (TSqlParser::ROOT - 662))
        | (1ULL << (TSqlParser::ROUTE - 662))
        | (1ULL << (TSqlParser::ROW - 662))
        | (1ULL << (TSqlParser::ROW_NUMBER - 662))
        | (1ULL << (TSqlParser::ROWGUID - 662))
        | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
        | (1ULL << (TSqlParser::SCHEMABINDING - 726))
        | (1ULL << (TSqlParser::SCOPED - 726))
        | (1ULL << (TSqlParser::SCROLL - 726))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
        | (1ULL << (TSqlParser::SEARCH - 726))
        | (1ULL << (TSqlParser::SECONDARY - 726))
        | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
        | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
        | (1ULL << (TSqlParser::SECONDS - 726))
        | (1ULL << (TSqlParser::SECRET - 726))
        | (1ULL << (TSqlParser::SECURITY - 726))
        | (1ULL << (TSqlParser::SECURITY_LOG - 726))
        | (1ULL << (TSqlParser::SEEDING_MODE - 726))
        | (1ULL << (TSqlParser::SELF - 726))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
        | (1ULL << (TSqlParser::SEND - 726))
        | (1ULL << (TSqlParser::SENT - 726))
        | (1ULL << (TSqlParser::SEQUENCE - 726))
        | (1ULL << (TSqlParser::SERIALIZABLE - 726))
        | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
        | (1ULL << (TSqlParser::SETERROR - 726))
        | (1ULL << (TSqlParser::SHARE - 726))
        | (1ULL << (TSqlParser::SHOWPLAN - 726))
        | (1ULL << (TSqlParser::SIGNATURE - 726))
        | (1ULL << (TSqlParser::SIMPLE - 726))
        | (1ULL << (TSqlParser::SINGLE_USER - 726))
        | (1ULL << (TSqlParser::SIZE - 726))
        | (1ULL << (TSqlParser::SMALLINT - 726))
        | (1ULL << (TSqlParser::SNAPSHOT - 726))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
        | (1ULL << (TSqlParser::STANDBY - 726))
        | (1ULL << (TSqlParser::START_DATE - 726))
        | (1ULL << (TSqlParser::STATIC - 726))
        | (1ULL << (TSqlParser::STATS_STREAM - 726))
        | (1ULL << (TSqlParser::STATUS - 726))
        | (1ULL << (TSqlParser::STDEV - 726))
        | (1ULL << (TSqlParser::STDEVP - 726))
        | (1ULL << (TSqlParser::STOPLIST - 726))
        | (1ULL << (TSqlParser::STRING_AGG - 726))
        | (1ULL << (TSqlParser::STUFF - 726))
        | (1ULL << (TSqlParser::SUBJECT - 726))
        | (1ULL << (TSqlParser::SUM - 726))
        | (1ULL << (TSqlParser::SUSPEND - 726))
        | (1ULL << (TSqlParser::SYMMETRIC - 726))
        | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
        | (1ULL << (TSqlParser::SYNONYM - 726))
        | (1ULL << (TSqlParser::SYSTEM - 726))
        | (1ULL << (TSqlParser::TAKE - 726))
        | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
        | (1ULL << (TSqlParser::TB - 726))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
        | (1ULL << (TSqlParser::THROW - 726))
        | (1ULL << (TSqlParser::TIES - 726))
        | (1ULL << (TSqlParser::TIME - 726))
        | (1ULL << (TSqlParser::TIMEOUT - 726))
        | (1ULL << (TSqlParser::TIMER - 726))
        | (1ULL << (TSqlParser::TINYINT - 726))
        | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
        | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
        | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
        | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
        | (1ULL << (TSqlParser::TRY - 790))
        | (1ULL << (TSqlParser::TSQL - 790))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
        | (1ULL << (TSqlParser::TYPE - 790))
        | (1ULL << (TSqlParser::TYPE_WARNING - 790))
        | (1ULL << (TSqlParser::UNBOUNDED - 790))
        | (1ULL << (TSqlParser::UNCOMMITTED - 790))
        | (1ULL << (TSqlParser::UNKNOWN - 790))
        | (1ULL << (TSqlParser::UNLIMITED - 790))
        | (1ULL << (TSqlParser::USING - 790))
        | (1ULL << (TSqlParser::VALID_XML - 790))
        | (1ULL << (TSqlParser::VALIDATION - 790))
        | (1ULL << (TSqlParser::VALUE - 790))
        | (1ULL << (TSqlParser::VAR - 790))
        | (1ULL << (TSqlParser::VARP - 790))
        | (1ULL << (TSqlParser::VIEW_METADATA - 790))
        | (1ULL << (TSqlParser::VIEWS - 790))
        | (1ULL << (TSqlParser::WAIT - 790))
        | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
        | (1ULL << (TSqlParser::WORK - 790))
        | (1ULL << (TSqlParser::WORKLOAD - 790))
        | (1ULL << (TSqlParser::XML - 790))
        | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
        | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
        setState(4355);
        dynamic_cast<Full_table_nameContext *>(_localctx)->schema = id();
      }
      setState(4358);
      match(TSqlParser::DOT);
      break;
    }

    case 3: {
      setState(4360);
      dynamic_cast<Full_table_nameContext *>(_localctx)->schema = id();
      setState(4361);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(4365);
    dynamic_cast<Full_table_nameContext *>(_localctx)->table = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

TSqlParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Table_nameContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Table_nameContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Table_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Table_nameContext::BLOCKING_HIERARCHY() {
  return getToken(TSqlParser::BLOCKING_HIERARCHY, 0);
}


size_t TSqlParser::Table_nameContext::getRuleIndex() const {
  return TSqlParser::RuleTable_name;
}

void TSqlParser::Table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name(this);
}

void TSqlParser::Table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name(this);
}

TSqlParser::Table_nameContext* TSqlParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 442, TSqlParser::RuleTable_name);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 627, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4377);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 624, _ctx)) {
      case 1: {
        setState(4367);
        dynamic_cast<Table_nameContext *>(_localctx)->database = id();
        setState(4368);
        match(TSqlParser::DOT);
        setState(4370);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
          | (1ULL << (TSqlParser::EVENTDATA - 85))
          | (1ULL << (TSqlParser::FILENAME - 85))
          | (1ULL << (TSqlParser::FILLFACTOR - 85))
          | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
          | (1ULL << (TSqlParser::KEY - 164))
          | (1ULL << (TSqlParser::MASTER - 164))
          | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
          | (1ULL << (TSqlParser::PAGE - 238))
          | (1ULL << (TSqlParser::PUBLIC - 238))
          | (1ULL << (TSqlParser::R - 238))
          | (1ULL << (TSqlParser::RAW - 238))
          | (1ULL << (TSqlParser::RETURN - 238))
          | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
          | (1ULL << (TSqlParser::SAFETY - 305))
          | (1ULL << (TSqlParser::SERVER - 305))
          | (1ULL << (TSqlParser::SID - 305))
          | (1ULL << (TSqlParser::SOURCE - 305))
          | (1ULL << (TSqlParser::SPLIT - 305))
          | (1ULL << (TSqlParser::STATE - 305))
          | (1ULL << (TSqlParser::START - 305))
          | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
          | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
          | (1ULL << (TSqlParser::ACTION - 405))
          | (1ULL << (TSqlParser::ACTIVATION - 405))
          | (1ULL << (TSqlParser::ACTIVE - 405))
          | (1ULL << (TSqlParser::ADDRESS - 405))
          | (1ULL << (TSqlParser::AES_128 - 405))
          | (1ULL << (TSqlParser::AES_192 - 405))
          | (1ULL << (TSqlParser::AES_256 - 405))
          | (1ULL << (TSqlParser::AFFINITY - 405))
          | (1ULL << (TSqlParser::AFTER - 405))
          | (1ULL << (TSqlParser::AGGREGATE - 405))
          | (1ULL << (TSqlParser::ALGORITHM - 405))
          | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
          | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
          | (1ULL << (TSqlParser::ALLOWED - 405))
          | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
          | (1ULL << (TSqlParser::ANSI_NULLS - 405))
          | (1ULL << (TSqlParser::ANSI_PADDING - 405))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
          | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
          | (1ULL << (TSqlParser::APPLY - 405))
          | (1ULL << (TSqlParser::ARITHABORT - 405))
          | (1ULL << (TSqlParser::ASSEMBLY - 405))
          | (1ULL << (TSqlParser::AUDIT - 405))
          | (1ULL << (TSqlParser::AUDIT_GUID - 405))
          | (1ULL << (TSqlParser::AUTO - 405))
          | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
          | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
          | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
          | (1ULL << (TSqlParser::AVAILABILITY - 405))
          | (1ULL << (TSqlParser::AVG - 405))
          | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
          | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
          | (1ULL << (TSqlParser::BIGINT - 405))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
          | (1ULL << (TSqlParser::BINDING - 405))
          | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
          | (1ULL << (TSqlParser::BROKER - 405))
          | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
          | (1ULL << (TSqlParser::BULK_LOGGED - 405))
          | (1ULL << (TSqlParser::CALLER - 405))
          | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
          | (1ULL << (TSqlParser::CAST - 405))
          | (1ULL << (TSqlParser::CATALOG - 405))
          | (1ULL << (TSqlParser::CATCH - 405))
          | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
          | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
          | (1ULL << (TSqlParser::CHECKSUM - 405))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
          | (1ULL << (TSqlParser::CLEANUP - 405))
          | (1ULL << (TSqlParser::COLLECTION - 405))
          | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
          | (1ULL << (TSqlParser::COMMITTED - 405))
          | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
          | (1ULL << (TSqlParser::CONCAT - 405))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
          | (1ULL << (TSqlParser::CONTENT - 405))
          | (1ULL << (TSqlParser::CONTROL - 405))
          | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
          | (1ULL << (TSqlParser::COUNT_BIG - 469))
          | (1ULL << (TSqlParser::COUNTER - 469))
          | (1ULL << (TSqlParser::CPU - 469))
          | (1ULL << (TSqlParser::CREATE_NEW - 469))
          | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
          | (1ULL << (TSqlParser::CREDENTIAL - 469))
          | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
          | (1ULL << (TSqlParser::DATA - 469))
          | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
          | (1ULL << (TSqlParser::DATEADD - 469))
          | (1ULL << (TSqlParser::DATEDIFF - 469))
          | (1ULL << (TSqlParser::DATENAME - 469))
          | (1ULL << (TSqlParser::DATEPART - 469))
          | (1ULL << (TSqlParser::DAYS - 469))
          | (1ULL << (TSqlParser::DB_CHAINING - 469))
          | (1ULL << (TSqlParser::DB_FAILOVER - 469))
          | (1ULL << (TSqlParser::DECRYPTION - 469))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
          | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DELAY - 469))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
          | (1ULL << (TSqlParser::DELETED - 469))
          | (1ULL << (TSqlParser::DENSE_RANK - 469))
          | (1ULL << (TSqlParser::DEPENDENTS - 469))
          | (1ULL << (TSqlParser::DES - 469))
          | (1ULL << (TSqlParser::DESCRIPTION - 469))
          | (1ULL << (TSqlParser::DESX - 469))
          | (1ULL << (TSqlParser::DHCP - 469))
          | (1ULL << (TSqlParser::DIALOG - 469))
          | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
          | (1ULL << (TSqlParser::DISABLE - 469))
          | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
          | (1ULL << (TSqlParser::DISABLED - 469))
          | (1ULL << (TSqlParser::DISK_DRIVE - 469))
          | (1ULL << (TSqlParser::DOCUMENT - 469))
          | (1ULL << (TSqlParser::DYNAMIC - 469))
          | (1ULL << (TSqlParser::EMERGENCY - 469))
          | (1ULL << (TSqlParser::EMPTY - 469))
          | (1ULL << (TSqlParser::ENABLE - 469))
          | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
          | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
          | (1ULL << (TSqlParser::ENCRYPTION - 469))
          | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
          | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
          | (1ULL << (TSqlParser::EXCLUSIVE - 469))
          | (1ULL << (TSqlParser::EXECUTABLE - 469))
          | (1ULL << (TSqlParser::EXIST - 469))
          | (1ULL << (TSqlParser::EXPAND - 469))
          | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
          | (1ULL << (TSqlParser::EXPLICIT - 469))
          | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
          | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
          | (1ULL << (TSqlParser::FAILURE - 469))
          | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
          | (1ULL << (TSqlParser::FAST - 469))
          | (1ULL << (TSqlParser::FAST_FORWARD - 469))
          | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
          | (1ULL << (TSqlParser::FILEPATH - 533))
          | (1ULL << (TSqlParser::FILESTREAM - 533))
          | (1ULL << (TSqlParser::FILTER - 533))
          | (1ULL << (TSqlParser::FIRST - 533))
          | (1ULL << (TSqlParser::FIRST_VALUE - 533))
          | (1ULL << (TSqlParser::FOLLOWING - 533))
          | (1ULL << (TSqlParser::FORCE - 533))
          | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
          | (1ULL << (TSqlParser::FORCED - 533))
          | (1ULL << (TSqlParser::FORMAT - 533))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
          | (1ULL << (TSqlParser::FULLSCAN - 533))
          | (1ULL << (TSqlParser::FULLTEXT - 533))
          | (1ULL << (TSqlParser::GB - 533))
          | (1ULL << (TSqlParser::GETDATE - 533))
          | (1ULL << (TSqlParser::GETUTCDATE - 533))
          | (1ULL << (TSqlParser::GLOBAL - 533))
          | (1ULL << (TSqlParser::GO - 533))
          | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
          | (1ULL << (TSqlParser::GROUPING - 533))
          | (1ULL << (TSqlParser::GROUPING_ID - 533))
          | (1ULL << (TSqlParser::HADR - 533))
          | (1ULL << (TSqlParser::HASH - 533))
          | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
          | (1ULL << (TSqlParser::HIGH - 533))
          | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
          | (1ULL << (TSqlParser::HOURS - 533))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
          | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
          | (1ULL << (TSqlParser::IMMEDIATE - 533))
          | (1ULL << (TSqlParser::IMPERSONATE - 533))
          | (1ULL << (TSqlParser::IMPORTANCE - 533))
          | (1ULL << (TSqlParser::INCREMENTAL - 533))
          | (1ULL << (TSqlParser::INITIATOR - 533))
          | (1ULL << (TSqlParser::INPUT - 533))
          | (1ULL << (TSqlParser::INSENSITIVE - 533))
          | (1ULL << (TSqlParser::INSERTED - 533))
          | (1ULL << (TSqlParser::INT - 533))
          | (1ULL << (TSqlParser::IP - 533))
          | (1ULL << (TSqlParser::ISOLATION - 533))
          | (1ULL << (TSqlParser::KB - 533))
          | (1ULL << (TSqlParser::KEEP - 533))
          | (1ULL << (TSqlParser::KEEPFIXED - 533))
          | (1ULL << (TSqlParser::KEY_SOURCE - 533))
          | (1ULL << (TSqlParser::KEYS - 533))
          | (1ULL << (TSqlParser::KEYSET - 533))
          | (1ULL << (TSqlParser::LAG - 533))
          | (1ULL << (TSqlParser::LAST - 533))
          | (1ULL << (TSqlParser::LAST_VALUE - 533))
          | (1ULL << (TSqlParser::LEAD - 533))
          | (1ULL << (TSqlParser::LEVEL - 533))
          | (1ULL << (TSqlParser::LIST - 533))
          | (1ULL << (TSqlParser::LISTENER - 533))
          | (1ULL << (TSqlParser::LISTENER_URL - 533))
          | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
          | (1ULL << (TSqlParser::LOCAL - 533))
          | (1ULL << (TSqlParser::LOCATION - 533))
          | (1ULL << (TSqlParser::LOCK - 533))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
          | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
          | (1ULL << (TSqlParser::LOW - 597))
          | (1ULL << (TSqlParser::MANUAL - 597))
          | (1ULL << (TSqlParser::MARK - 597))
          | (1ULL << (TSqlParser::MATERIALIZED - 597))
          | (1ULL << (TSqlParser::MAX - 597))
          | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_DOP - 597))
          | (1ULL << (TSqlParser::MAX_FILES - 597))
          | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
          | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
          | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
          | (1ULL << (TSqlParser::MAXDOP - 597))
          | (1ULL << (TSqlParser::MAXRECURSION - 597))
          | (1ULL << (TSqlParser::MAXSIZE - 597))
          | (1ULL << (TSqlParser::MB - 597))
          | (1ULL << (TSqlParser::MEDIUM - 597))
          | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
          | (1ULL << (TSqlParser::MESSAGE - 597))
          | (1ULL << (TSqlParser::MIN - 597))
          | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
          | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MINUTES - 597))
          | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
          | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
          | (1ULL << (TSqlParser::MODE - 597))
          | (1ULL << (TSqlParser::MODIFY - 597))
          | (1ULL << (TSqlParser::MOVE - 597))
          | (1ULL << (TSqlParser::MULTI_USER - 597))
          | (1ULL << (TSqlParser::NAME - 597))
          | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
          | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
          | (1ULL << (TSqlParser::NEW_BROKER - 597))
          | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
          | (1ULL << (TSqlParser::NEXT - 597))
          | (1ULL << (TSqlParser::NO - 597))
          | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
          | (1ULL << (TSqlParser::NO_WAIT - 597))
          | (1ULL << (TSqlParser::NOCOUNT - 597))
          | (1ULL << (TSqlParser::NODES - 597))
          | (1ULL << (TSqlParser::NOEXPAND - 597))
          | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
          | (1ULL << (TSqlParser::NORECOMPUTE - 597))
          | (1ULL << (TSqlParser::NORECOVERY - 597))
          | (1ULL << (TSqlParser::NOWAIT - 597))
          | (1ULL << (TSqlParser::NTILE - 597))
          | (1ULL << (TSqlParser::NUMANODE - 597))
          | (1ULL << (TSqlParser::NUMBER - 597))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
          | (1ULL << (TSqlParser::OBJECT - 597))
          | (1ULL << (TSqlParser::OFFLINE - 597))
          | (1ULL << (TSqlParser::OFFSET - 597))
          | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
          | (1ULL << (TSqlParser::ONLINE - 597))
          | (1ULL << (TSqlParser::ONLY - 597))
          | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
          | (1ULL << (TSqlParser::OPTIMISTIC - 597))
          | (1ULL << (TSqlParser::OPTIMIZE - 597))
          | (1ULL << (TSqlParser::OUT - 597))
          | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
          | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
          | (1ULL << (TSqlParser::PARTITION - 662))
          | (1ULL << (TSqlParser::PARTITIONS - 662))
          | (1ULL << (TSqlParser::PARTNER - 662))
          | (1ULL << (TSqlParser::PATH - 662))
          | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
          | (1ULL << (TSqlParser::POOL - 662))
          | (1ULL << (TSqlParser::PORT - 662))
          | (1ULL << (TSqlParser::PRECEDING - 662))
          | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
          | (1ULL << (TSqlParser::PRIOR - 662))
          | (1ULL << (TSqlParser::PRIORITY - 662))
          | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
          | (1ULL << (TSqlParser::PRIVATE - 662))
          | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
          | (1ULL << (TSqlParser::PRIVILEGES - 662))
          | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
          | (1ULL << (TSqlParser::PROPERTY - 662))
          | (1ULL << (TSqlParser::PROVIDER - 662))
          | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
          | (1ULL << (TSqlParser::QUERY - 662))
          | (1ULL << (TSqlParser::QUEUE - 662))
          | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
          | (1ULL << (TSqlParser::RANGE - 662))
          | (1ULL << (TSqlParser::RANK - 662))
          | (1ULL << (TSqlParser::RC2 - 662))
          | (1ULL << (TSqlParser::RC4 - 662))
          | (1ULL << (TSqlParser::RC4_128 - 662))
          | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
          | (1ULL << (TSqlParser::READ_ONLY - 662))
          | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
          | (1ULL << (TSqlParser::READ_WRITE - 662))
          | (1ULL << (TSqlParser::READONLY - 662))
          | (1ULL << (TSqlParser::REBUILD - 662))
          | (1ULL << (TSqlParser::RECEIVE - 662))
          | (1ULL << (TSqlParser::RECOMPILE - 662))
          | (1ULL << (TSqlParser::RECOVERY - 662))
          | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
          | (1ULL << (TSqlParser::RELATIVE - 662))
          | (1ULL << (TSqlParser::REMOTE - 662))
          | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
          | (1ULL << (TSqlParser::REMOVE - 662))
          | (1ULL << (TSqlParser::REORGANIZE - 662))
          | (1ULL << (TSqlParser::REPEATABLE - 662))
          | (1ULL << (TSqlParser::REPLICA - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
          | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
          | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
          | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
          | (1ULL << (TSqlParser::RESOURCE - 662))
          | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
          | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
          | (1ULL << (TSqlParser::RETENTION - 662))
          | (1ULL << (TSqlParser::ROBUST - 662))
          | (1ULL << (TSqlParser::ROOT - 662))
          | (1ULL << (TSqlParser::ROUTE - 662))
          | (1ULL << (TSqlParser::ROW - 662))
          | (1ULL << (TSqlParser::ROW_NUMBER - 662))
          | (1ULL << (TSqlParser::ROWGUID - 662))
          | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
          | (1ULL << (TSqlParser::SCHEMABINDING - 726))
          | (1ULL << (TSqlParser::SCOPED - 726))
          | (1ULL << (TSqlParser::SCROLL - 726))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
          | (1ULL << (TSqlParser::SEARCH - 726))
          | (1ULL << (TSqlParser::SECONDARY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
          | (1ULL << (TSqlParser::SECONDS - 726))
          | (1ULL << (TSqlParser::SECRET - 726))
          | (1ULL << (TSqlParser::SECURITY - 726))
          | (1ULL << (TSqlParser::SECURITY_LOG - 726))
          | (1ULL << (TSqlParser::SEEDING_MODE - 726))
          | (1ULL << (TSqlParser::SELF - 726))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
          | (1ULL << (TSqlParser::SEND - 726))
          | (1ULL << (TSqlParser::SENT - 726))
          | (1ULL << (TSqlParser::SEQUENCE - 726))
          | (1ULL << (TSqlParser::SERIALIZABLE - 726))
          | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
          | (1ULL << (TSqlParser::SETERROR - 726))
          | (1ULL << (TSqlParser::SHARE - 726))
          | (1ULL << (TSqlParser::SHOWPLAN - 726))
          | (1ULL << (TSqlParser::SIGNATURE - 726))
          | (1ULL << (TSqlParser::SIMPLE - 726))
          | (1ULL << (TSqlParser::SINGLE_USER - 726))
          | (1ULL << (TSqlParser::SIZE - 726))
          | (1ULL << (TSqlParser::SMALLINT - 726))
          | (1ULL << (TSqlParser::SNAPSHOT - 726))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
          | (1ULL << (TSqlParser::STANDBY - 726))
          | (1ULL << (TSqlParser::START_DATE - 726))
          | (1ULL << (TSqlParser::STATIC - 726))
          | (1ULL << (TSqlParser::STATS_STREAM - 726))
          | (1ULL << (TSqlParser::STATUS - 726))
          | (1ULL << (TSqlParser::STDEV - 726))
          | (1ULL << (TSqlParser::STDEVP - 726))
          | (1ULL << (TSqlParser::STOPLIST - 726))
          | (1ULL << (TSqlParser::STRING_AGG - 726))
          | (1ULL << (TSqlParser::STUFF - 726))
          | (1ULL << (TSqlParser::SUBJECT - 726))
          | (1ULL << (TSqlParser::SUM - 726))
          | (1ULL << (TSqlParser::SUSPEND - 726))
          | (1ULL << (TSqlParser::SYMMETRIC - 726))
          | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
          | (1ULL << (TSqlParser::SYNONYM - 726))
          | (1ULL << (TSqlParser::SYSTEM - 726))
          | (1ULL << (TSqlParser::TAKE - 726))
          | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
          | (1ULL << (TSqlParser::TB - 726))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
          | (1ULL << (TSqlParser::THROW - 726))
          | (1ULL << (TSqlParser::TIES - 726))
          | (1ULL << (TSqlParser::TIME - 726))
          | (1ULL << (TSqlParser::TIMEOUT - 726))
          | (1ULL << (TSqlParser::TIMER - 726))
          | (1ULL << (TSqlParser::TINYINT - 726))
          | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
          | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
          | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
          | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
          | (1ULL << (TSqlParser::TRY - 790))
          | (1ULL << (TSqlParser::TSQL - 790))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
          | (1ULL << (TSqlParser::TYPE - 790))
          | (1ULL << (TSqlParser::TYPE_WARNING - 790))
          | (1ULL << (TSqlParser::UNBOUNDED - 790))
          | (1ULL << (TSqlParser::UNCOMMITTED - 790))
          | (1ULL << (TSqlParser::UNKNOWN - 790))
          | (1ULL << (TSqlParser::UNLIMITED - 790))
          | (1ULL << (TSqlParser::USING - 790))
          | (1ULL << (TSqlParser::VALID_XML - 790))
          | (1ULL << (TSqlParser::VALIDATION - 790))
          | (1ULL << (TSqlParser::VALUE - 790))
          | (1ULL << (TSqlParser::VAR - 790))
          | (1ULL << (TSqlParser::VARP - 790))
          | (1ULL << (TSqlParser::VIEW_METADATA - 790))
          | (1ULL << (TSqlParser::VIEWS - 790))
          | (1ULL << (TSqlParser::WAIT - 790))
          | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
          | (1ULL << (TSqlParser::WORK - 790))
          | (1ULL << (TSqlParser::WORKLOAD - 790))
          | (1ULL << (TSqlParser::XML - 790))
          | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
          | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
          setState(4369);
          dynamic_cast<Table_nameContext *>(_localctx)->schema = id();
        }
        setState(4372);
        match(TSqlParser::DOT);
        break;
      }

      case 2: {
        setState(4374);
        dynamic_cast<Table_nameContext *>(_localctx)->schema = id();
        setState(4375);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4379);
      dynamic_cast<Table_nameContext *>(_localctx)->table = id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4390);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 626, _ctx)) {
      case 1: {
        setState(4380);
        dynamic_cast<Table_nameContext *>(_localctx)->database = id();
        setState(4381);
        match(TSqlParser::DOT);
        setState(4383);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
          | (1ULL << (TSqlParser::EVENTDATA - 85))
          | (1ULL << (TSqlParser::FILENAME - 85))
          | (1ULL << (TSqlParser::FILLFACTOR - 85))
          | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
          | (1ULL << (TSqlParser::KEY - 164))
          | (1ULL << (TSqlParser::MASTER - 164))
          | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
          | (1ULL << (TSqlParser::PAGE - 238))
          | (1ULL << (TSqlParser::PUBLIC - 238))
          | (1ULL << (TSqlParser::R - 238))
          | (1ULL << (TSqlParser::RAW - 238))
          | (1ULL << (TSqlParser::RETURN - 238))
          | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
          | (1ULL << (TSqlParser::SAFETY - 305))
          | (1ULL << (TSqlParser::SERVER - 305))
          | (1ULL << (TSqlParser::SID - 305))
          | (1ULL << (TSqlParser::SOURCE - 305))
          | (1ULL << (TSqlParser::SPLIT - 305))
          | (1ULL << (TSqlParser::STATE - 305))
          | (1ULL << (TSqlParser::START - 305))
          | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
          | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
          | (1ULL << (TSqlParser::ACTION - 405))
          | (1ULL << (TSqlParser::ACTIVATION - 405))
          | (1ULL << (TSqlParser::ACTIVE - 405))
          | (1ULL << (TSqlParser::ADDRESS - 405))
          | (1ULL << (TSqlParser::AES_128 - 405))
          | (1ULL << (TSqlParser::AES_192 - 405))
          | (1ULL << (TSqlParser::AES_256 - 405))
          | (1ULL << (TSqlParser::AFFINITY - 405))
          | (1ULL << (TSqlParser::AFTER - 405))
          | (1ULL << (TSqlParser::AGGREGATE - 405))
          | (1ULL << (TSqlParser::ALGORITHM - 405))
          | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
          | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
          | (1ULL << (TSqlParser::ALLOWED - 405))
          | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
          | (1ULL << (TSqlParser::ANSI_NULLS - 405))
          | (1ULL << (TSqlParser::ANSI_PADDING - 405))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
          | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
          | (1ULL << (TSqlParser::APPLY - 405))
          | (1ULL << (TSqlParser::ARITHABORT - 405))
          | (1ULL << (TSqlParser::ASSEMBLY - 405))
          | (1ULL << (TSqlParser::AUDIT - 405))
          | (1ULL << (TSqlParser::AUDIT_GUID - 405))
          | (1ULL << (TSqlParser::AUTO - 405))
          | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
          | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
          | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
          | (1ULL << (TSqlParser::AVAILABILITY - 405))
          | (1ULL << (TSqlParser::AVG - 405))
          | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
          | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
          | (1ULL << (TSqlParser::BIGINT - 405))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
          | (1ULL << (TSqlParser::BINDING - 405))
          | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
          | (1ULL << (TSqlParser::BROKER - 405))
          | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
          | (1ULL << (TSqlParser::BULK_LOGGED - 405))
          | (1ULL << (TSqlParser::CALLER - 405))
          | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
          | (1ULL << (TSqlParser::CAST - 405))
          | (1ULL << (TSqlParser::CATALOG - 405))
          | (1ULL << (TSqlParser::CATCH - 405))
          | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
          | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
          | (1ULL << (TSqlParser::CHECKSUM - 405))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
          | (1ULL << (TSqlParser::CLEANUP - 405))
          | (1ULL << (TSqlParser::COLLECTION - 405))
          | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
          | (1ULL << (TSqlParser::COMMITTED - 405))
          | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
          | (1ULL << (TSqlParser::CONCAT - 405))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
          | (1ULL << (TSqlParser::CONTENT - 405))
          | (1ULL << (TSqlParser::CONTROL - 405))
          | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
          | (1ULL << (TSqlParser::COUNT_BIG - 469))
          | (1ULL << (TSqlParser::COUNTER - 469))
          | (1ULL << (TSqlParser::CPU - 469))
          | (1ULL << (TSqlParser::CREATE_NEW - 469))
          | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
          | (1ULL << (TSqlParser::CREDENTIAL - 469))
          | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
          | (1ULL << (TSqlParser::DATA - 469))
          | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
          | (1ULL << (TSqlParser::DATEADD - 469))
          | (1ULL << (TSqlParser::DATEDIFF - 469))
          | (1ULL << (TSqlParser::DATENAME - 469))
          | (1ULL << (TSqlParser::DATEPART - 469))
          | (1ULL << (TSqlParser::DAYS - 469))
          | (1ULL << (TSqlParser::DB_CHAINING - 469))
          | (1ULL << (TSqlParser::DB_FAILOVER - 469))
          | (1ULL << (TSqlParser::DECRYPTION - 469))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
          | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DELAY - 469))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
          | (1ULL << (TSqlParser::DELETED - 469))
          | (1ULL << (TSqlParser::DENSE_RANK - 469))
          | (1ULL << (TSqlParser::DEPENDENTS - 469))
          | (1ULL << (TSqlParser::DES - 469))
          | (1ULL << (TSqlParser::DESCRIPTION - 469))
          | (1ULL << (TSqlParser::DESX - 469))
          | (1ULL << (TSqlParser::DHCP - 469))
          | (1ULL << (TSqlParser::DIALOG - 469))
          | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
          | (1ULL << (TSqlParser::DISABLE - 469))
          | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
          | (1ULL << (TSqlParser::DISABLED - 469))
          | (1ULL << (TSqlParser::DISK_DRIVE - 469))
          | (1ULL << (TSqlParser::DOCUMENT - 469))
          | (1ULL << (TSqlParser::DYNAMIC - 469))
          | (1ULL << (TSqlParser::EMERGENCY - 469))
          | (1ULL << (TSqlParser::EMPTY - 469))
          | (1ULL << (TSqlParser::ENABLE - 469))
          | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
          | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
          | (1ULL << (TSqlParser::ENCRYPTION - 469))
          | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
          | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
          | (1ULL << (TSqlParser::EXCLUSIVE - 469))
          | (1ULL << (TSqlParser::EXECUTABLE - 469))
          | (1ULL << (TSqlParser::EXIST - 469))
          | (1ULL << (TSqlParser::EXPAND - 469))
          | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
          | (1ULL << (TSqlParser::EXPLICIT - 469))
          | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
          | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
          | (1ULL << (TSqlParser::FAILURE - 469))
          | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
          | (1ULL << (TSqlParser::FAST - 469))
          | (1ULL << (TSqlParser::FAST_FORWARD - 469))
          | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
          | (1ULL << (TSqlParser::FILEPATH - 533))
          | (1ULL << (TSqlParser::FILESTREAM - 533))
          | (1ULL << (TSqlParser::FILTER - 533))
          | (1ULL << (TSqlParser::FIRST - 533))
          | (1ULL << (TSqlParser::FIRST_VALUE - 533))
          | (1ULL << (TSqlParser::FOLLOWING - 533))
          | (1ULL << (TSqlParser::FORCE - 533))
          | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
          | (1ULL << (TSqlParser::FORCED - 533))
          | (1ULL << (TSqlParser::FORMAT - 533))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
          | (1ULL << (TSqlParser::FULLSCAN - 533))
          | (1ULL << (TSqlParser::FULLTEXT - 533))
          | (1ULL << (TSqlParser::GB - 533))
          | (1ULL << (TSqlParser::GETDATE - 533))
          | (1ULL << (TSqlParser::GETUTCDATE - 533))
          | (1ULL << (TSqlParser::GLOBAL - 533))
          | (1ULL << (TSqlParser::GO - 533))
          | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
          | (1ULL << (TSqlParser::GROUPING - 533))
          | (1ULL << (TSqlParser::GROUPING_ID - 533))
          | (1ULL << (TSqlParser::HADR - 533))
          | (1ULL << (TSqlParser::HASH - 533))
          | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
          | (1ULL << (TSqlParser::HIGH - 533))
          | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
          | (1ULL << (TSqlParser::HOURS - 533))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
          | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
          | (1ULL << (TSqlParser::IMMEDIATE - 533))
          | (1ULL << (TSqlParser::IMPERSONATE - 533))
          | (1ULL << (TSqlParser::IMPORTANCE - 533))
          | (1ULL << (TSqlParser::INCREMENTAL - 533))
          | (1ULL << (TSqlParser::INITIATOR - 533))
          | (1ULL << (TSqlParser::INPUT - 533))
          | (1ULL << (TSqlParser::INSENSITIVE - 533))
          | (1ULL << (TSqlParser::INSERTED - 533))
          | (1ULL << (TSqlParser::INT - 533))
          | (1ULL << (TSqlParser::IP - 533))
          | (1ULL << (TSqlParser::ISOLATION - 533))
          | (1ULL << (TSqlParser::KB - 533))
          | (1ULL << (TSqlParser::KEEP - 533))
          | (1ULL << (TSqlParser::KEEPFIXED - 533))
          | (1ULL << (TSqlParser::KEY_SOURCE - 533))
          | (1ULL << (TSqlParser::KEYS - 533))
          | (1ULL << (TSqlParser::KEYSET - 533))
          | (1ULL << (TSqlParser::LAG - 533))
          | (1ULL << (TSqlParser::LAST - 533))
          | (1ULL << (TSqlParser::LAST_VALUE - 533))
          | (1ULL << (TSqlParser::LEAD - 533))
          | (1ULL << (TSqlParser::LEVEL - 533))
          | (1ULL << (TSqlParser::LIST - 533))
          | (1ULL << (TSqlParser::LISTENER - 533))
          | (1ULL << (TSqlParser::LISTENER_URL - 533))
          | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
          | (1ULL << (TSqlParser::LOCAL - 533))
          | (1ULL << (TSqlParser::LOCATION - 533))
          | (1ULL << (TSqlParser::LOCK - 533))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
          | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
          | (1ULL << (TSqlParser::LOW - 597))
          | (1ULL << (TSqlParser::MANUAL - 597))
          | (1ULL << (TSqlParser::MARK - 597))
          | (1ULL << (TSqlParser::MATERIALIZED - 597))
          | (1ULL << (TSqlParser::MAX - 597))
          | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_DOP - 597))
          | (1ULL << (TSqlParser::MAX_FILES - 597))
          | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
          | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
          | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
          | (1ULL << (TSqlParser::MAXDOP - 597))
          | (1ULL << (TSqlParser::MAXRECURSION - 597))
          | (1ULL << (TSqlParser::MAXSIZE - 597))
          | (1ULL << (TSqlParser::MB - 597))
          | (1ULL << (TSqlParser::MEDIUM - 597))
          | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
          | (1ULL << (TSqlParser::MESSAGE - 597))
          | (1ULL << (TSqlParser::MIN - 597))
          | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
          | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MINUTES - 597))
          | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
          | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
          | (1ULL << (TSqlParser::MODE - 597))
          | (1ULL << (TSqlParser::MODIFY - 597))
          | (1ULL << (TSqlParser::MOVE - 597))
          | (1ULL << (TSqlParser::MULTI_USER - 597))
          | (1ULL << (TSqlParser::NAME - 597))
          | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
          | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
          | (1ULL << (TSqlParser::NEW_BROKER - 597))
          | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
          | (1ULL << (TSqlParser::NEXT - 597))
          | (1ULL << (TSqlParser::NO - 597))
          | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
          | (1ULL << (TSqlParser::NO_WAIT - 597))
          | (1ULL << (TSqlParser::NOCOUNT - 597))
          | (1ULL << (TSqlParser::NODES - 597))
          | (1ULL << (TSqlParser::NOEXPAND - 597))
          | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
          | (1ULL << (TSqlParser::NORECOMPUTE - 597))
          | (1ULL << (TSqlParser::NORECOVERY - 597))
          | (1ULL << (TSqlParser::NOWAIT - 597))
          | (1ULL << (TSqlParser::NTILE - 597))
          | (1ULL << (TSqlParser::NUMANODE - 597))
          | (1ULL << (TSqlParser::NUMBER - 597))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
          | (1ULL << (TSqlParser::OBJECT - 597))
          | (1ULL << (TSqlParser::OFFLINE - 597))
          | (1ULL << (TSqlParser::OFFSET - 597))
          | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
          | (1ULL << (TSqlParser::ONLINE - 597))
          | (1ULL << (TSqlParser::ONLY - 597))
          | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
          | (1ULL << (TSqlParser::OPTIMISTIC - 597))
          | (1ULL << (TSqlParser::OPTIMIZE - 597))
          | (1ULL << (TSqlParser::OUT - 597))
          | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
          | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
          | (1ULL << (TSqlParser::PARTITION - 662))
          | (1ULL << (TSqlParser::PARTITIONS - 662))
          | (1ULL << (TSqlParser::PARTNER - 662))
          | (1ULL << (TSqlParser::PATH - 662))
          | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
          | (1ULL << (TSqlParser::POOL - 662))
          | (1ULL << (TSqlParser::PORT - 662))
          | (1ULL << (TSqlParser::PRECEDING - 662))
          | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
          | (1ULL << (TSqlParser::PRIOR - 662))
          | (1ULL << (TSqlParser::PRIORITY - 662))
          | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
          | (1ULL << (TSqlParser::PRIVATE - 662))
          | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
          | (1ULL << (TSqlParser::PRIVILEGES - 662))
          | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
          | (1ULL << (TSqlParser::PROPERTY - 662))
          | (1ULL << (TSqlParser::PROVIDER - 662))
          | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
          | (1ULL << (TSqlParser::QUERY - 662))
          | (1ULL << (TSqlParser::QUEUE - 662))
          | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
          | (1ULL << (TSqlParser::RANGE - 662))
          | (1ULL << (TSqlParser::RANK - 662))
          | (1ULL << (TSqlParser::RC2 - 662))
          | (1ULL << (TSqlParser::RC4 - 662))
          | (1ULL << (TSqlParser::RC4_128 - 662))
          | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
          | (1ULL << (TSqlParser::READ_ONLY - 662))
          | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
          | (1ULL << (TSqlParser::READ_WRITE - 662))
          | (1ULL << (TSqlParser::READONLY - 662))
          | (1ULL << (TSqlParser::REBUILD - 662))
          | (1ULL << (TSqlParser::RECEIVE - 662))
          | (1ULL << (TSqlParser::RECOMPILE - 662))
          | (1ULL << (TSqlParser::RECOVERY - 662))
          | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
          | (1ULL << (TSqlParser::RELATIVE - 662))
          | (1ULL << (TSqlParser::REMOTE - 662))
          | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
          | (1ULL << (TSqlParser::REMOVE - 662))
          | (1ULL << (TSqlParser::REORGANIZE - 662))
          | (1ULL << (TSqlParser::REPEATABLE - 662))
          | (1ULL << (TSqlParser::REPLICA - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
          | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
          | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
          | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
          | (1ULL << (TSqlParser::RESOURCE - 662))
          | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
          | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
          | (1ULL << (TSqlParser::RETENTION - 662))
          | (1ULL << (TSqlParser::ROBUST - 662))
          | (1ULL << (TSqlParser::ROOT - 662))
          | (1ULL << (TSqlParser::ROUTE - 662))
          | (1ULL << (TSqlParser::ROW - 662))
          | (1ULL << (TSqlParser::ROW_NUMBER - 662))
          | (1ULL << (TSqlParser::ROWGUID - 662))
          | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
          | (1ULL << (TSqlParser::SCHEMABINDING - 726))
          | (1ULL << (TSqlParser::SCOPED - 726))
          | (1ULL << (TSqlParser::SCROLL - 726))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
          | (1ULL << (TSqlParser::SEARCH - 726))
          | (1ULL << (TSqlParser::SECONDARY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
          | (1ULL << (TSqlParser::SECONDS - 726))
          | (1ULL << (TSqlParser::SECRET - 726))
          | (1ULL << (TSqlParser::SECURITY - 726))
          | (1ULL << (TSqlParser::SECURITY_LOG - 726))
          | (1ULL << (TSqlParser::SEEDING_MODE - 726))
          | (1ULL << (TSqlParser::SELF - 726))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
          | (1ULL << (TSqlParser::SEND - 726))
          | (1ULL << (TSqlParser::SENT - 726))
          | (1ULL << (TSqlParser::SEQUENCE - 726))
          | (1ULL << (TSqlParser::SERIALIZABLE - 726))
          | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
          | (1ULL << (TSqlParser::SETERROR - 726))
          | (1ULL << (TSqlParser::SHARE - 726))
          | (1ULL << (TSqlParser::SHOWPLAN - 726))
          | (1ULL << (TSqlParser::SIGNATURE - 726))
          | (1ULL << (TSqlParser::SIMPLE - 726))
          | (1ULL << (TSqlParser::SINGLE_USER - 726))
          | (1ULL << (TSqlParser::SIZE - 726))
          | (1ULL << (TSqlParser::SMALLINT - 726))
          | (1ULL << (TSqlParser::SNAPSHOT - 726))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
          | (1ULL << (TSqlParser::STANDBY - 726))
          | (1ULL << (TSqlParser::START_DATE - 726))
          | (1ULL << (TSqlParser::STATIC - 726))
          | (1ULL << (TSqlParser::STATS_STREAM - 726))
          | (1ULL << (TSqlParser::STATUS - 726))
          | (1ULL << (TSqlParser::STDEV - 726))
          | (1ULL << (TSqlParser::STDEVP - 726))
          | (1ULL << (TSqlParser::STOPLIST - 726))
          | (1ULL << (TSqlParser::STRING_AGG - 726))
          | (1ULL << (TSqlParser::STUFF - 726))
          | (1ULL << (TSqlParser::SUBJECT - 726))
          | (1ULL << (TSqlParser::SUM - 726))
          | (1ULL << (TSqlParser::SUSPEND - 726))
          | (1ULL << (TSqlParser::SYMMETRIC - 726))
          | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
          | (1ULL << (TSqlParser::SYNONYM - 726))
          | (1ULL << (TSqlParser::SYSTEM - 726))
          | (1ULL << (TSqlParser::TAKE - 726))
          | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
          | (1ULL << (TSqlParser::TB - 726))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
          | (1ULL << (TSqlParser::THROW - 726))
          | (1ULL << (TSqlParser::TIES - 726))
          | (1ULL << (TSqlParser::TIME - 726))
          | (1ULL << (TSqlParser::TIMEOUT - 726))
          | (1ULL << (TSqlParser::TIMER - 726))
          | (1ULL << (TSqlParser::TINYINT - 726))
          | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
          | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
          | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
          | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
          | (1ULL << (TSqlParser::TRY - 790))
          | (1ULL << (TSqlParser::TSQL - 790))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
          | (1ULL << (TSqlParser::TYPE - 790))
          | (1ULL << (TSqlParser::TYPE_WARNING - 790))
          | (1ULL << (TSqlParser::UNBOUNDED - 790))
          | (1ULL << (TSqlParser::UNCOMMITTED - 790))
          | (1ULL << (TSqlParser::UNKNOWN - 790))
          | (1ULL << (TSqlParser::UNLIMITED - 790))
          | (1ULL << (TSqlParser::USING - 790))
          | (1ULL << (TSqlParser::VALID_XML - 790))
          | (1ULL << (TSqlParser::VALIDATION - 790))
          | (1ULL << (TSqlParser::VALUE - 790))
          | (1ULL << (TSqlParser::VAR - 790))
          | (1ULL << (TSqlParser::VARP - 790))
          | (1ULL << (TSqlParser::VIEW_METADATA - 790))
          | (1ULL << (TSqlParser::VIEWS - 790))
          | (1ULL << (TSqlParser::WAIT - 790))
          | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
          | (1ULL << (TSqlParser::WORK - 790))
          | (1ULL << (TSqlParser::WORKLOAD - 790))
          | (1ULL << (TSqlParser::XML - 790))
          | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
          | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
          setState(4382);
          dynamic_cast<Table_nameContext *>(_localctx)->schema = id();
        }
        setState(4385);
        match(TSqlParser::DOT);
        break;
      }

      case 2: {
        setState(4387);
        dynamic_cast<Table_nameContext *>(_localctx)->schema = id();
        setState(4388);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4392);
      match(TSqlParser::BLOCKING_HIERARCHY);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_nameContext ------------------------------------------------------------------

TSqlParser::Simple_nameContext::Simple_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Simple_nameContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Simple_nameContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Simple_nameContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Simple_nameContext::getRuleIndex() const {
  return TSqlParser::RuleSimple_name;
}

void TSqlParser::Simple_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_name(this);
}

void TSqlParser::Simple_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_name(this);
}

TSqlParser::Simple_nameContext* TSqlParser::simple_name() {
  Simple_nameContext *_localctx = _tracker.createInstance<Simple_nameContext>(_ctx, getState());
  enterRule(_localctx, 444, TSqlParser::RuleSimple_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4398);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 628, _ctx)) {
    case 1: {
      setState(4395);
      dynamic_cast<Simple_nameContext *>(_localctx)->schema = id();
      setState(4396);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(4400);
    dynamic_cast<Simple_nameContext *>(_localctx)->name = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_schemaContext::Func_proc_name_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Func_proc_name_schemaContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Func_proc_name_schemaContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

tree::TerminalNode* TSqlParser::Func_proc_name_schemaContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Func_proc_name_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_schema;
}

void TSqlParser::Func_proc_name_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_schema(this);
}

void TSqlParser::Func_proc_name_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_schema(this);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::func_proc_name_schema() {
  Func_proc_name_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_schemaContext>(_ctx, getState());
  enterRule(_localctx, 446, TSqlParser::RuleFunc_proc_name_schema);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4405);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 629, _ctx)) {
    case 1: {
      setState(4402);
      dynamic_cast<Func_proc_name_schemaContext *>(_localctx)->schema = id();
      setState(4403);
      match(TSqlParser::DOT);
      break;
    }

    }
    setState(4407);
    dynamic_cast<Func_proc_name_schemaContext *>(_localctx)->procedure = id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_database_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_database_schemaContext::Func_proc_name_database_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Func_proc_name_database_schemaContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Func_proc_name_database_schemaContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Func_proc_name_database_schemaContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_proc_name_database_schemaContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Func_proc_name_database_schemaContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Func_proc_name_database_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_database_schema;
}

void TSqlParser::Func_proc_name_database_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_database_schema(this);
}

void TSqlParser::Func_proc_name_database_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_database_schema(this);
}

TSqlParser::Func_proc_name_database_schemaContext* TSqlParser::func_proc_name_database_schema() {
  Func_proc_name_database_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_database_schemaContext>(_ctx, getState());
  enterRule(_localctx, 448, TSqlParser::RuleFunc_proc_name_database_schema);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4420);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 632, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4409);
      func_proc_name_schema();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4417);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 631, _ctx)) {
      case 1: {
        setState(4410);
        dynamic_cast<Func_proc_name_database_schemaContext *>(_localctx)->database = id();
        setState(4411);
        match(TSqlParser::DOT);
        setState(4413);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
          | (1ULL << (TSqlParser::EVENTDATA - 85))
          | (1ULL << (TSqlParser::FILENAME - 85))
          | (1ULL << (TSqlParser::FILLFACTOR - 85))
          | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
          | (1ULL << (TSqlParser::KEY - 164))
          | (1ULL << (TSqlParser::MASTER - 164))
          | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
          | (1ULL << (TSqlParser::PAGE - 238))
          | (1ULL << (TSqlParser::PUBLIC - 238))
          | (1ULL << (TSqlParser::R - 238))
          | (1ULL << (TSqlParser::RAW - 238))
          | (1ULL << (TSqlParser::RETURN - 238))
          | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
          | (1ULL << (TSqlParser::SAFETY - 305))
          | (1ULL << (TSqlParser::SERVER - 305))
          | (1ULL << (TSqlParser::SID - 305))
          | (1ULL << (TSqlParser::SOURCE - 305))
          | (1ULL << (TSqlParser::SPLIT - 305))
          | (1ULL << (TSqlParser::STATE - 305))
          | (1ULL << (TSqlParser::START - 305))
          | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
          | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
          | (1ULL << (TSqlParser::ACTION - 405))
          | (1ULL << (TSqlParser::ACTIVATION - 405))
          | (1ULL << (TSqlParser::ACTIVE - 405))
          | (1ULL << (TSqlParser::ADDRESS - 405))
          | (1ULL << (TSqlParser::AES_128 - 405))
          | (1ULL << (TSqlParser::AES_192 - 405))
          | (1ULL << (TSqlParser::AES_256 - 405))
          | (1ULL << (TSqlParser::AFFINITY - 405))
          | (1ULL << (TSqlParser::AFTER - 405))
          | (1ULL << (TSqlParser::AGGREGATE - 405))
          | (1ULL << (TSqlParser::ALGORITHM - 405))
          | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
          | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
          | (1ULL << (TSqlParser::ALLOWED - 405))
          | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
          | (1ULL << (TSqlParser::ANSI_NULLS - 405))
          | (1ULL << (TSqlParser::ANSI_PADDING - 405))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
          | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
          | (1ULL << (TSqlParser::APPLY - 405))
          | (1ULL << (TSqlParser::ARITHABORT - 405))
          | (1ULL << (TSqlParser::ASSEMBLY - 405))
          | (1ULL << (TSqlParser::AUDIT - 405))
          | (1ULL << (TSqlParser::AUDIT_GUID - 405))
          | (1ULL << (TSqlParser::AUTO - 405))
          | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
          | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
          | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
          | (1ULL << (TSqlParser::AVAILABILITY - 405))
          | (1ULL << (TSqlParser::AVG - 405))
          | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
          | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
          | (1ULL << (TSqlParser::BIGINT - 405))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
          | (1ULL << (TSqlParser::BINDING - 405))
          | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
          | (1ULL << (TSqlParser::BROKER - 405))
          | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
          | (1ULL << (TSqlParser::BULK_LOGGED - 405))
          | (1ULL << (TSqlParser::CALLER - 405))
          | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
          | (1ULL << (TSqlParser::CAST - 405))
          | (1ULL << (TSqlParser::CATALOG - 405))
          | (1ULL << (TSqlParser::CATCH - 405))
          | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
          | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
          | (1ULL << (TSqlParser::CHECKSUM - 405))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
          | (1ULL << (TSqlParser::CLEANUP - 405))
          | (1ULL << (TSqlParser::COLLECTION - 405))
          | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
          | (1ULL << (TSqlParser::COMMITTED - 405))
          | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
          | (1ULL << (TSqlParser::CONCAT - 405))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
          | (1ULL << (TSqlParser::CONTENT - 405))
          | (1ULL << (TSqlParser::CONTROL - 405))
          | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
          | (1ULL << (TSqlParser::COUNT_BIG - 469))
          | (1ULL << (TSqlParser::COUNTER - 469))
          | (1ULL << (TSqlParser::CPU - 469))
          | (1ULL << (TSqlParser::CREATE_NEW - 469))
          | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
          | (1ULL << (TSqlParser::CREDENTIAL - 469))
          | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
          | (1ULL << (TSqlParser::DATA - 469))
          | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
          | (1ULL << (TSqlParser::DATEADD - 469))
          | (1ULL << (TSqlParser::DATEDIFF - 469))
          | (1ULL << (TSqlParser::DATENAME - 469))
          | (1ULL << (TSqlParser::DATEPART - 469))
          | (1ULL << (TSqlParser::DAYS - 469))
          | (1ULL << (TSqlParser::DB_CHAINING - 469))
          | (1ULL << (TSqlParser::DB_FAILOVER - 469))
          | (1ULL << (TSqlParser::DECRYPTION - 469))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
          | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DELAY - 469))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
          | (1ULL << (TSqlParser::DELETED - 469))
          | (1ULL << (TSqlParser::DENSE_RANK - 469))
          | (1ULL << (TSqlParser::DEPENDENTS - 469))
          | (1ULL << (TSqlParser::DES - 469))
          | (1ULL << (TSqlParser::DESCRIPTION - 469))
          | (1ULL << (TSqlParser::DESX - 469))
          | (1ULL << (TSqlParser::DHCP - 469))
          | (1ULL << (TSqlParser::DIALOG - 469))
          | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
          | (1ULL << (TSqlParser::DISABLE - 469))
          | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
          | (1ULL << (TSqlParser::DISABLED - 469))
          | (1ULL << (TSqlParser::DISK_DRIVE - 469))
          | (1ULL << (TSqlParser::DOCUMENT - 469))
          | (1ULL << (TSqlParser::DYNAMIC - 469))
          | (1ULL << (TSqlParser::EMERGENCY - 469))
          | (1ULL << (TSqlParser::EMPTY - 469))
          | (1ULL << (TSqlParser::ENABLE - 469))
          | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
          | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
          | (1ULL << (TSqlParser::ENCRYPTION - 469))
          | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
          | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
          | (1ULL << (TSqlParser::EXCLUSIVE - 469))
          | (1ULL << (TSqlParser::EXECUTABLE - 469))
          | (1ULL << (TSqlParser::EXIST - 469))
          | (1ULL << (TSqlParser::EXPAND - 469))
          | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
          | (1ULL << (TSqlParser::EXPLICIT - 469))
          | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
          | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
          | (1ULL << (TSqlParser::FAILURE - 469))
          | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
          | (1ULL << (TSqlParser::FAST - 469))
          | (1ULL << (TSqlParser::FAST_FORWARD - 469))
          | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
          | (1ULL << (TSqlParser::FILEPATH - 533))
          | (1ULL << (TSqlParser::FILESTREAM - 533))
          | (1ULL << (TSqlParser::FILTER - 533))
          | (1ULL << (TSqlParser::FIRST - 533))
          | (1ULL << (TSqlParser::FIRST_VALUE - 533))
          | (1ULL << (TSqlParser::FOLLOWING - 533))
          | (1ULL << (TSqlParser::FORCE - 533))
          | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
          | (1ULL << (TSqlParser::FORCED - 533))
          | (1ULL << (TSqlParser::FORMAT - 533))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
          | (1ULL << (TSqlParser::FULLSCAN - 533))
          | (1ULL << (TSqlParser::FULLTEXT - 533))
          | (1ULL << (TSqlParser::GB - 533))
          | (1ULL << (TSqlParser::GETDATE - 533))
          | (1ULL << (TSqlParser::GETUTCDATE - 533))
          | (1ULL << (TSqlParser::GLOBAL - 533))
          | (1ULL << (TSqlParser::GO - 533))
          | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
          | (1ULL << (TSqlParser::GROUPING - 533))
          | (1ULL << (TSqlParser::GROUPING_ID - 533))
          | (1ULL << (TSqlParser::HADR - 533))
          | (1ULL << (TSqlParser::HASH - 533))
          | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
          | (1ULL << (TSqlParser::HIGH - 533))
          | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
          | (1ULL << (TSqlParser::HOURS - 533))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
          | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
          | (1ULL << (TSqlParser::IMMEDIATE - 533))
          | (1ULL << (TSqlParser::IMPERSONATE - 533))
          | (1ULL << (TSqlParser::IMPORTANCE - 533))
          | (1ULL << (TSqlParser::INCREMENTAL - 533))
          | (1ULL << (TSqlParser::INITIATOR - 533))
          | (1ULL << (TSqlParser::INPUT - 533))
          | (1ULL << (TSqlParser::INSENSITIVE - 533))
          | (1ULL << (TSqlParser::INSERTED - 533))
          | (1ULL << (TSqlParser::INT - 533))
          | (1ULL << (TSqlParser::IP - 533))
          | (1ULL << (TSqlParser::ISOLATION - 533))
          | (1ULL << (TSqlParser::KB - 533))
          | (1ULL << (TSqlParser::KEEP - 533))
          | (1ULL << (TSqlParser::KEEPFIXED - 533))
          | (1ULL << (TSqlParser::KEY_SOURCE - 533))
          | (1ULL << (TSqlParser::KEYS - 533))
          | (1ULL << (TSqlParser::KEYSET - 533))
          | (1ULL << (TSqlParser::LAG - 533))
          | (1ULL << (TSqlParser::LAST - 533))
          | (1ULL << (TSqlParser::LAST_VALUE - 533))
          | (1ULL << (TSqlParser::LEAD - 533))
          | (1ULL << (TSqlParser::LEVEL - 533))
          | (1ULL << (TSqlParser::LIST - 533))
          | (1ULL << (TSqlParser::LISTENER - 533))
          | (1ULL << (TSqlParser::LISTENER_URL - 533))
          | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
          | (1ULL << (TSqlParser::LOCAL - 533))
          | (1ULL << (TSqlParser::LOCATION - 533))
          | (1ULL << (TSqlParser::LOCK - 533))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
          | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
          | (1ULL << (TSqlParser::LOW - 597))
          | (1ULL << (TSqlParser::MANUAL - 597))
          | (1ULL << (TSqlParser::MARK - 597))
          | (1ULL << (TSqlParser::MATERIALIZED - 597))
          | (1ULL << (TSqlParser::MAX - 597))
          | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_DOP - 597))
          | (1ULL << (TSqlParser::MAX_FILES - 597))
          | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
          | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
          | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
          | (1ULL << (TSqlParser::MAXDOP - 597))
          | (1ULL << (TSqlParser::MAXRECURSION - 597))
          | (1ULL << (TSqlParser::MAXSIZE - 597))
          | (1ULL << (TSqlParser::MB - 597))
          | (1ULL << (TSqlParser::MEDIUM - 597))
          | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
          | (1ULL << (TSqlParser::MESSAGE - 597))
          | (1ULL << (TSqlParser::MIN - 597))
          | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
          | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MINUTES - 597))
          | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
          | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
          | (1ULL << (TSqlParser::MODE - 597))
          | (1ULL << (TSqlParser::MODIFY - 597))
          | (1ULL << (TSqlParser::MOVE - 597))
          | (1ULL << (TSqlParser::MULTI_USER - 597))
          | (1ULL << (TSqlParser::NAME - 597))
          | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
          | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
          | (1ULL << (TSqlParser::NEW_BROKER - 597))
          | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
          | (1ULL << (TSqlParser::NEXT - 597))
          | (1ULL << (TSqlParser::NO - 597))
          | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
          | (1ULL << (TSqlParser::NO_WAIT - 597))
          | (1ULL << (TSqlParser::NOCOUNT - 597))
          | (1ULL << (TSqlParser::NODES - 597))
          | (1ULL << (TSqlParser::NOEXPAND - 597))
          | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
          | (1ULL << (TSqlParser::NORECOMPUTE - 597))
          | (1ULL << (TSqlParser::NORECOVERY - 597))
          | (1ULL << (TSqlParser::NOWAIT - 597))
          | (1ULL << (TSqlParser::NTILE - 597))
          | (1ULL << (TSqlParser::NUMANODE - 597))
          | (1ULL << (TSqlParser::NUMBER - 597))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
          | (1ULL << (TSqlParser::OBJECT - 597))
          | (1ULL << (TSqlParser::OFFLINE - 597))
          | (1ULL << (TSqlParser::OFFSET - 597))
          | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
          | (1ULL << (TSqlParser::ONLINE - 597))
          | (1ULL << (TSqlParser::ONLY - 597))
          | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
          | (1ULL << (TSqlParser::OPTIMISTIC - 597))
          | (1ULL << (TSqlParser::OPTIMIZE - 597))
          | (1ULL << (TSqlParser::OUT - 597))
          | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
          | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
          | (1ULL << (TSqlParser::PARTITION - 662))
          | (1ULL << (TSqlParser::PARTITIONS - 662))
          | (1ULL << (TSqlParser::PARTNER - 662))
          | (1ULL << (TSqlParser::PATH - 662))
          | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
          | (1ULL << (TSqlParser::POOL - 662))
          | (1ULL << (TSqlParser::PORT - 662))
          | (1ULL << (TSqlParser::PRECEDING - 662))
          | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
          | (1ULL << (TSqlParser::PRIOR - 662))
          | (1ULL << (TSqlParser::PRIORITY - 662))
          | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
          | (1ULL << (TSqlParser::PRIVATE - 662))
          | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
          | (1ULL << (TSqlParser::PRIVILEGES - 662))
          | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
          | (1ULL << (TSqlParser::PROPERTY - 662))
          | (1ULL << (TSqlParser::PROVIDER - 662))
          | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
          | (1ULL << (TSqlParser::QUERY - 662))
          | (1ULL << (TSqlParser::QUEUE - 662))
          | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
          | (1ULL << (TSqlParser::RANGE - 662))
          | (1ULL << (TSqlParser::RANK - 662))
          | (1ULL << (TSqlParser::RC2 - 662))
          | (1ULL << (TSqlParser::RC4 - 662))
          | (1ULL << (TSqlParser::RC4_128 - 662))
          | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
          | (1ULL << (TSqlParser::READ_ONLY - 662))
          | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
          | (1ULL << (TSqlParser::READ_WRITE - 662))
          | (1ULL << (TSqlParser::READONLY - 662))
          | (1ULL << (TSqlParser::REBUILD - 662))
          | (1ULL << (TSqlParser::RECEIVE - 662))
          | (1ULL << (TSqlParser::RECOMPILE - 662))
          | (1ULL << (TSqlParser::RECOVERY - 662))
          | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
          | (1ULL << (TSqlParser::RELATIVE - 662))
          | (1ULL << (TSqlParser::REMOTE - 662))
          | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
          | (1ULL << (TSqlParser::REMOVE - 662))
          | (1ULL << (TSqlParser::REORGANIZE - 662))
          | (1ULL << (TSqlParser::REPEATABLE - 662))
          | (1ULL << (TSqlParser::REPLICA - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
          | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
          | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
          | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
          | (1ULL << (TSqlParser::RESOURCE - 662))
          | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
          | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
          | (1ULL << (TSqlParser::RETENTION - 662))
          | (1ULL << (TSqlParser::ROBUST - 662))
          | (1ULL << (TSqlParser::ROOT - 662))
          | (1ULL << (TSqlParser::ROUTE - 662))
          | (1ULL << (TSqlParser::ROW - 662))
          | (1ULL << (TSqlParser::ROW_NUMBER - 662))
          | (1ULL << (TSqlParser::ROWGUID - 662))
          | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
          | (1ULL << (TSqlParser::SCHEMABINDING - 726))
          | (1ULL << (TSqlParser::SCOPED - 726))
          | (1ULL << (TSqlParser::SCROLL - 726))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
          | (1ULL << (TSqlParser::SEARCH - 726))
          | (1ULL << (TSqlParser::SECONDARY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
          | (1ULL << (TSqlParser::SECONDS - 726))
          | (1ULL << (TSqlParser::SECRET - 726))
          | (1ULL << (TSqlParser::SECURITY - 726))
          | (1ULL << (TSqlParser::SECURITY_LOG - 726))
          | (1ULL << (TSqlParser::SEEDING_MODE - 726))
          | (1ULL << (TSqlParser::SELF - 726))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
          | (1ULL << (TSqlParser::SEND - 726))
          | (1ULL << (TSqlParser::SENT - 726))
          | (1ULL << (TSqlParser::SEQUENCE - 726))
          | (1ULL << (TSqlParser::SERIALIZABLE - 726))
          | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
          | (1ULL << (TSqlParser::SETERROR - 726))
          | (1ULL << (TSqlParser::SHARE - 726))
          | (1ULL << (TSqlParser::SHOWPLAN - 726))
          | (1ULL << (TSqlParser::SIGNATURE - 726))
          | (1ULL << (TSqlParser::SIMPLE - 726))
          | (1ULL << (TSqlParser::SINGLE_USER - 726))
          | (1ULL << (TSqlParser::SIZE - 726))
          | (1ULL << (TSqlParser::SMALLINT - 726))
          | (1ULL << (TSqlParser::SNAPSHOT - 726))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
          | (1ULL << (TSqlParser::STANDBY - 726))
          | (1ULL << (TSqlParser::START_DATE - 726))
          | (1ULL << (TSqlParser::STATIC - 726))
          | (1ULL << (TSqlParser::STATS_STREAM - 726))
          | (1ULL << (TSqlParser::STATUS - 726))
          | (1ULL << (TSqlParser::STDEV - 726))
          | (1ULL << (TSqlParser::STDEVP - 726))
          | (1ULL << (TSqlParser::STOPLIST - 726))
          | (1ULL << (TSqlParser::STRING_AGG - 726))
          | (1ULL << (TSqlParser::STUFF - 726))
          | (1ULL << (TSqlParser::SUBJECT - 726))
          | (1ULL << (TSqlParser::SUM - 726))
          | (1ULL << (TSqlParser::SUSPEND - 726))
          | (1ULL << (TSqlParser::SYMMETRIC - 726))
          | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
          | (1ULL << (TSqlParser::SYNONYM - 726))
          | (1ULL << (TSqlParser::SYSTEM - 726))
          | (1ULL << (TSqlParser::TAKE - 726))
          | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
          | (1ULL << (TSqlParser::TB - 726))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
          | (1ULL << (TSqlParser::THROW - 726))
          | (1ULL << (TSqlParser::TIES - 726))
          | (1ULL << (TSqlParser::TIME - 726))
          | (1ULL << (TSqlParser::TIMEOUT - 726))
          | (1ULL << (TSqlParser::TIMER - 726))
          | (1ULL << (TSqlParser::TINYINT - 726))
          | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
          | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
          | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
          | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
          | (1ULL << (TSqlParser::TRY - 790))
          | (1ULL << (TSqlParser::TSQL - 790))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
          | (1ULL << (TSqlParser::TYPE - 790))
          | (1ULL << (TSqlParser::TYPE_WARNING - 790))
          | (1ULL << (TSqlParser::UNBOUNDED - 790))
          | (1ULL << (TSqlParser::UNCOMMITTED - 790))
          | (1ULL << (TSqlParser::UNKNOWN - 790))
          | (1ULL << (TSqlParser::UNLIMITED - 790))
          | (1ULL << (TSqlParser::USING - 790))
          | (1ULL << (TSqlParser::VALID_XML - 790))
          | (1ULL << (TSqlParser::VALIDATION - 790))
          | (1ULL << (TSqlParser::VALUE - 790))
          | (1ULL << (TSqlParser::VAR - 790))
          | (1ULL << (TSqlParser::VARP - 790))
          | (1ULL << (TSqlParser::VIEW_METADATA - 790))
          | (1ULL << (TSqlParser::VIEWS - 790))
          | (1ULL << (TSqlParser::WAIT - 790))
          | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
          | (1ULL << (TSqlParser::WORK - 790))
          | (1ULL << (TSqlParser::WORKLOAD - 790))
          | (1ULL << (TSqlParser::XML - 790))
          | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
          | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
          setState(4412);
          dynamic_cast<Func_proc_name_database_schemaContext *>(_localctx)->schema = id();
        }
        setState(4415);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4419);
      dynamic_cast<Func_proc_name_database_schemaContext *>(_localctx)->procedure = id();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_server_database_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_server_database_schemaContext::Func_proc_name_server_database_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_database_schemaContext* TSqlParser::Func_proc_name_server_database_schemaContext::func_proc_name_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_database_schemaContext>(0);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Func_proc_name_server_database_schemaContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Func_proc_name_server_database_schemaContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_proc_name_server_database_schemaContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Func_proc_name_server_database_schemaContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Func_proc_name_server_database_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_server_database_schema;
}

void TSqlParser::Func_proc_name_server_database_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_server_database_schema(this);
}

void TSqlParser::Func_proc_name_server_database_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_server_database_schema(this);
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::func_proc_name_server_database_schema() {
  Func_proc_name_server_database_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_server_database_schemaContext>(_ctx, getState());
  enterRule(_localctx, 450, TSqlParser::RuleFunc_proc_name_server_database_schema);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4435);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 635, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4422);
      func_proc_name_database_schema();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4432);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 634, _ctx)) {
      case 1: {
        setState(4423);
        dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->server = id();
        setState(4424);
        match(TSqlParser::DOT);
        setState(4425);
        dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->database = id();
        setState(4426);
        match(TSqlParser::DOT);
        setState(4428);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
          | (1ULL << (TSqlParser::EVENTDATA - 85))
          | (1ULL << (TSqlParser::FILENAME - 85))
          | (1ULL << (TSqlParser::FILLFACTOR - 85))
          | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
          | (1ULL << (TSqlParser::KEY - 164))
          | (1ULL << (TSqlParser::MASTER - 164))
          | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
          | (1ULL << (TSqlParser::PAGE - 238))
          | (1ULL << (TSqlParser::PUBLIC - 238))
          | (1ULL << (TSqlParser::R - 238))
          | (1ULL << (TSqlParser::RAW - 238))
          | (1ULL << (TSqlParser::RETURN - 238))
          | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
          | (1ULL << (TSqlParser::SAFETY - 305))
          | (1ULL << (TSqlParser::SERVER - 305))
          | (1ULL << (TSqlParser::SID - 305))
          | (1ULL << (TSqlParser::SOURCE - 305))
          | (1ULL << (TSqlParser::SPLIT - 305))
          | (1ULL << (TSqlParser::STATE - 305))
          | (1ULL << (TSqlParser::START - 305))
          | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
          | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
          | (1ULL << (TSqlParser::ACTION - 405))
          | (1ULL << (TSqlParser::ACTIVATION - 405))
          | (1ULL << (TSqlParser::ACTIVE - 405))
          | (1ULL << (TSqlParser::ADDRESS - 405))
          | (1ULL << (TSqlParser::AES_128 - 405))
          | (1ULL << (TSqlParser::AES_192 - 405))
          | (1ULL << (TSqlParser::AES_256 - 405))
          | (1ULL << (TSqlParser::AFFINITY - 405))
          | (1ULL << (TSqlParser::AFTER - 405))
          | (1ULL << (TSqlParser::AGGREGATE - 405))
          | (1ULL << (TSqlParser::ALGORITHM - 405))
          | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
          | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
          | (1ULL << (TSqlParser::ALLOWED - 405))
          | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
          | (1ULL << (TSqlParser::ANSI_NULLS - 405))
          | (1ULL << (TSqlParser::ANSI_PADDING - 405))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
          | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
          | (1ULL << (TSqlParser::APPLY - 405))
          | (1ULL << (TSqlParser::ARITHABORT - 405))
          | (1ULL << (TSqlParser::ASSEMBLY - 405))
          | (1ULL << (TSqlParser::AUDIT - 405))
          | (1ULL << (TSqlParser::AUDIT_GUID - 405))
          | (1ULL << (TSqlParser::AUTO - 405))
          | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
          | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
          | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
          | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
          | (1ULL << (TSqlParser::AVAILABILITY - 405))
          | (1ULL << (TSqlParser::AVG - 405))
          | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
          | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
          | (1ULL << (TSqlParser::BIGINT - 405))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
          | (1ULL << (TSqlParser::BINDING - 405))
          | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
          | (1ULL << (TSqlParser::BROKER - 405))
          | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
          | (1ULL << (TSqlParser::BULK_LOGGED - 405))
          | (1ULL << (TSqlParser::CALLER - 405))
          | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
          | (1ULL << (TSqlParser::CAST - 405))
          | (1ULL << (TSqlParser::CATALOG - 405))
          | (1ULL << (TSqlParser::CATCH - 405))
          | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
          | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
          | (1ULL << (TSqlParser::CHECKSUM - 405))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
          | (1ULL << (TSqlParser::CLEANUP - 405))
          | (1ULL << (TSqlParser::COLLECTION - 405))
          | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
          | (1ULL << (TSqlParser::COMMITTED - 405))
          | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
          | (1ULL << (TSqlParser::CONCAT - 405))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
          | (1ULL << (TSqlParser::CONTENT - 405))
          | (1ULL << (TSqlParser::CONTROL - 405))
          | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
          | (1ULL << (TSqlParser::COUNT_BIG - 469))
          | (1ULL << (TSqlParser::COUNTER - 469))
          | (1ULL << (TSqlParser::CPU - 469))
          | (1ULL << (TSqlParser::CREATE_NEW - 469))
          | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
          | (1ULL << (TSqlParser::CREDENTIAL - 469))
          | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
          | (1ULL << (TSqlParser::DATA - 469))
          | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
          | (1ULL << (TSqlParser::DATEADD - 469))
          | (1ULL << (TSqlParser::DATEDIFF - 469))
          | (1ULL << (TSqlParser::DATENAME - 469))
          | (1ULL << (TSqlParser::DATEPART - 469))
          | (1ULL << (TSqlParser::DAYS - 469))
          | (1ULL << (TSqlParser::DB_CHAINING - 469))
          | (1ULL << (TSqlParser::DB_FAILOVER - 469))
          | (1ULL << (TSqlParser::DECRYPTION - 469))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
          | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
          | (1ULL << (TSqlParser::DELAY - 469))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
          | (1ULL << (TSqlParser::DELETED - 469))
          | (1ULL << (TSqlParser::DENSE_RANK - 469))
          | (1ULL << (TSqlParser::DEPENDENTS - 469))
          | (1ULL << (TSqlParser::DES - 469))
          | (1ULL << (TSqlParser::DESCRIPTION - 469))
          | (1ULL << (TSqlParser::DESX - 469))
          | (1ULL << (TSqlParser::DHCP - 469))
          | (1ULL << (TSqlParser::DIALOG - 469))
          | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
          | (1ULL << (TSqlParser::DISABLE - 469))
          | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
          | (1ULL << (TSqlParser::DISABLED - 469))
          | (1ULL << (TSqlParser::DISK_DRIVE - 469))
          | (1ULL << (TSqlParser::DOCUMENT - 469))
          | (1ULL << (TSqlParser::DYNAMIC - 469))
          | (1ULL << (TSqlParser::EMERGENCY - 469))
          | (1ULL << (TSqlParser::EMPTY - 469))
          | (1ULL << (TSqlParser::ENABLE - 469))
          | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
          | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
          | (1ULL << (TSqlParser::ENCRYPTION - 469))
          | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
          | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
          | (1ULL << (TSqlParser::EXCLUSIVE - 469))
          | (1ULL << (TSqlParser::EXECUTABLE - 469))
          | (1ULL << (TSqlParser::EXIST - 469))
          | (1ULL << (TSqlParser::EXPAND - 469))
          | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
          | (1ULL << (TSqlParser::EXPLICIT - 469))
          | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
          | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
          | (1ULL << (TSqlParser::FAILURE - 469))
          | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
          | (1ULL << (TSqlParser::FAST - 469))
          | (1ULL << (TSqlParser::FAST_FORWARD - 469))
          | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
          | (1ULL << (TSqlParser::FILEPATH - 533))
          | (1ULL << (TSqlParser::FILESTREAM - 533))
          | (1ULL << (TSqlParser::FILTER - 533))
          | (1ULL << (TSqlParser::FIRST - 533))
          | (1ULL << (TSqlParser::FIRST_VALUE - 533))
          | (1ULL << (TSqlParser::FOLLOWING - 533))
          | (1ULL << (TSqlParser::FORCE - 533))
          | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
          | (1ULL << (TSqlParser::FORCED - 533))
          | (1ULL << (TSqlParser::FORMAT - 533))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
          | (1ULL << (TSqlParser::FULLSCAN - 533))
          | (1ULL << (TSqlParser::FULLTEXT - 533))
          | (1ULL << (TSqlParser::GB - 533))
          | (1ULL << (TSqlParser::GETDATE - 533))
          | (1ULL << (TSqlParser::GETUTCDATE - 533))
          | (1ULL << (TSqlParser::GLOBAL - 533))
          | (1ULL << (TSqlParser::GO - 533))
          | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
          | (1ULL << (TSqlParser::GROUPING - 533))
          | (1ULL << (TSqlParser::GROUPING_ID - 533))
          | (1ULL << (TSqlParser::HADR - 533))
          | (1ULL << (TSqlParser::HASH - 533))
          | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
          | (1ULL << (TSqlParser::HIGH - 533))
          | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
          | (1ULL << (TSqlParser::HOURS - 533))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
          | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
          | (1ULL << (TSqlParser::IMMEDIATE - 533))
          | (1ULL << (TSqlParser::IMPERSONATE - 533))
          | (1ULL << (TSqlParser::IMPORTANCE - 533))
          | (1ULL << (TSqlParser::INCREMENTAL - 533))
          | (1ULL << (TSqlParser::INITIATOR - 533))
          | (1ULL << (TSqlParser::INPUT - 533))
          | (1ULL << (TSqlParser::INSENSITIVE - 533))
          | (1ULL << (TSqlParser::INSERTED - 533))
          | (1ULL << (TSqlParser::INT - 533))
          | (1ULL << (TSqlParser::IP - 533))
          | (1ULL << (TSqlParser::ISOLATION - 533))
          | (1ULL << (TSqlParser::KB - 533))
          | (1ULL << (TSqlParser::KEEP - 533))
          | (1ULL << (TSqlParser::KEEPFIXED - 533))
          | (1ULL << (TSqlParser::KEY_SOURCE - 533))
          | (1ULL << (TSqlParser::KEYS - 533))
          | (1ULL << (TSqlParser::KEYSET - 533))
          | (1ULL << (TSqlParser::LAG - 533))
          | (1ULL << (TSqlParser::LAST - 533))
          | (1ULL << (TSqlParser::LAST_VALUE - 533))
          | (1ULL << (TSqlParser::LEAD - 533))
          | (1ULL << (TSqlParser::LEVEL - 533))
          | (1ULL << (TSqlParser::LIST - 533))
          | (1ULL << (TSqlParser::LISTENER - 533))
          | (1ULL << (TSqlParser::LISTENER_URL - 533))
          | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
          | (1ULL << (TSqlParser::LOCAL - 533))
          | (1ULL << (TSqlParser::LOCATION - 533))
          | (1ULL << (TSqlParser::LOCK - 533))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
          | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
          | (1ULL << (TSqlParser::LOW - 597))
          | (1ULL << (TSqlParser::MANUAL - 597))
          | (1ULL << (TSqlParser::MARK - 597))
          | (1ULL << (TSqlParser::MATERIALIZED - 597))
          | (1ULL << (TSqlParser::MAX - 597))
          | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_DOP - 597))
          | (1ULL << (TSqlParser::MAX_FILES - 597))
          | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
          | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
          | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
          | (1ULL << (TSqlParser::MAXDOP - 597))
          | (1ULL << (TSqlParser::MAXRECURSION - 597))
          | (1ULL << (TSqlParser::MAXSIZE - 597))
          | (1ULL << (TSqlParser::MB - 597))
          | (1ULL << (TSqlParser::MEDIUM - 597))
          | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
          | (1ULL << (TSqlParser::MESSAGE - 597))
          | (1ULL << (TSqlParser::MIN - 597))
          | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
          | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
          | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
          | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
          | (1ULL << (TSqlParser::MINUTES - 597))
          | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
          | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
          | (1ULL << (TSqlParser::MODE - 597))
          | (1ULL << (TSqlParser::MODIFY - 597))
          | (1ULL << (TSqlParser::MOVE - 597))
          | (1ULL << (TSqlParser::MULTI_USER - 597))
          | (1ULL << (TSqlParser::NAME - 597))
          | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
          | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
          | (1ULL << (TSqlParser::NEW_BROKER - 597))
          | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
          | (1ULL << (TSqlParser::NEXT - 597))
          | (1ULL << (TSqlParser::NO - 597))
          | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
          | (1ULL << (TSqlParser::NO_WAIT - 597))
          | (1ULL << (TSqlParser::NOCOUNT - 597))
          | (1ULL << (TSqlParser::NODES - 597))
          | (1ULL << (TSqlParser::NOEXPAND - 597))
          | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
          | (1ULL << (TSqlParser::NORECOMPUTE - 597))
          | (1ULL << (TSqlParser::NORECOVERY - 597))
          | (1ULL << (TSqlParser::NOWAIT - 597))
          | (1ULL << (TSqlParser::NTILE - 597))
          | (1ULL << (TSqlParser::NUMANODE - 597))
          | (1ULL << (TSqlParser::NUMBER - 597))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
          | (1ULL << (TSqlParser::OBJECT - 597))
          | (1ULL << (TSqlParser::OFFLINE - 597))
          | (1ULL << (TSqlParser::OFFSET - 597))
          | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
          | (1ULL << (TSqlParser::ONLINE - 597))
          | (1ULL << (TSqlParser::ONLY - 597))
          | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
          | (1ULL << (TSqlParser::OPTIMISTIC - 597))
          | (1ULL << (TSqlParser::OPTIMIZE - 597))
          | (1ULL << (TSqlParser::OUT - 597))
          | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
          | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
          | (1ULL << (TSqlParser::PARTITION - 662))
          | (1ULL << (TSqlParser::PARTITIONS - 662))
          | (1ULL << (TSqlParser::PARTNER - 662))
          | (1ULL << (TSqlParser::PATH - 662))
          | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
          | (1ULL << (TSqlParser::POOL - 662))
          | (1ULL << (TSqlParser::PORT - 662))
          | (1ULL << (TSqlParser::PRECEDING - 662))
          | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
          | (1ULL << (TSqlParser::PRIOR - 662))
          | (1ULL << (TSqlParser::PRIORITY - 662))
          | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
          | (1ULL << (TSqlParser::PRIVATE - 662))
          | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
          | (1ULL << (TSqlParser::PRIVILEGES - 662))
          | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
          | (1ULL << (TSqlParser::PROPERTY - 662))
          | (1ULL << (TSqlParser::PROVIDER - 662))
          | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
          | (1ULL << (TSqlParser::QUERY - 662))
          | (1ULL << (TSqlParser::QUEUE - 662))
          | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
          | (1ULL << (TSqlParser::RANGE - 662))
          | (1ULL << (TSqlParser::RANK - 662))
          | (1ULL << (TSqlParser::RC2 - 662))
          | (1ULL << (TSqlParser::RC4 - 662))
          | (1ULL << (TSqlParser::RC4_128 - 662))
          | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
          | (1ULL << (TSqlParser::READ_ONLY - 662))
          | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
          | (1ULL << (TSqlParser::READ_WRITE - 662))
          | (1ULL << (TSqlParser::READONLY - 662))
          | (1ULL << (TSqlParser::REBUILD - 662))
          | (1ULL << (TSqlParser::RECEIVE - 662))
          | (1ULL << (TSqlParser::RECOMPILE - 662))
          | (1ULL << (TSqlParser::RECOVERY - 662))
          | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
          | (1ULL << (TSqlParser::RELATIVE - 662))
          | (1ULL << (TSqlParser::REMOTE - 662))
          | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
          | (1ULL << (TSqlParser::REMOVE - 662))
          | (1ULL << (TSqlParser::REORGANIZE - 662))
          | (1ULL << (TSqlParser::REPEATABLE - 662))
          | (1ULL << (TSqlParser::REPLICA - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
          | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
          | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
          | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
          | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
          | (1ULL << (TSqlParser::RESOURCE - 662))
          | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
          | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
          | (1ULL << (TSqlParser::RETENTION - 662))
          | (1ULL << (TSqlParser::ROBUST - 662))
          | (1ULL << (TSqlParser::ROOT - 662))
          | (1ULL << (TSqlParser::ROUTE - 662))
          | (1ULL << (TSqlParser::ROW - 662))
          | (1ULL << (TSqlParser::ROW_NUMBER - 662))
          | (1ULL << (TSqlParser::ROWGUID - 662))
          | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
          | (1ULL << (TSqlParser::SCHEMABINDING - 726))
          | (1ULL << (TSqlParser::SCOPED - 726))
          | (1ULL << (TSqlParser::SCROLL - 726))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
          | (1ULL << (TSqlParser::SEARCH - 726))
          | (1ULL << (TSqlParser::SECONDARY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
          | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
          | (1ULL << (TSqlParser::SECONDS - 726))
          | (1ULL << (TSqlParser::SECRET - 726))
          | (1ULL << (TSqlParser::SECURITY - 726))
          | (1ULL << (TSqlParser::SECURITY_LOG - 726))
          | (1ULL << (TSqlParser::SEEDING_MODE - 726))
          | (1ULL << (TSqlParser::SELF - 726))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
          | (1ULL << (TSqlParser::SEND - 726))
          | (1ULL << (TSqlParser::SENT - 726))
          | (1ULL << (TSqlParser::SEQUENCE - 726))
          | (1ULL << (TSqlParser::SERIALIZABLE - 726))
          | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
          | (1ULL << (TSqlParser::SETERROR - 726))
          | (1ULL << (TSqlParser::SHARE - 726))
          | (1ULL << (TSqlParser::SHOWPLAN - 726))
          | (1ULL << (TSqlParser::SIGNATURE - 726))
          | (1ULL << (TSqlParser::SIMPLE - 726))
          | (1ULL << (TSqlParser::SINGLE_USER - 726))
          | (1ULL << (TSqlParser::SIZE - 726))
          | (1ULL << (TSqlParser::SMALLINT - 726))
          | (1ULL << (TSqlParser::SNAPSHOT - 726))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
          | (1ULL << (TSqlParser::STANDBY - 726))
          | (1ULL << (TSqlParser::START_DATE - 726))
          | (1ULL << (TSqlParser::STATIC - 726))
          | (1ULL << (TSqlParser::STATS_STREAM - 726))
          | (1ULL << (TSqlParser::STATUS - 726))
          | (1ULL << (TSqlParser::STDEV - 726))
          | (1ULL << (TSqlParser::STDEVP - 726))
          | (1ULL << (TSqlParser::STOPLIST - 726))
          | (1ULL << (TSqlParser::STRING_AGG - 726))
          | (1ULL << (TSqlParser::STUFF - 726))
          | (1ULL << (TSqlParser::SUBJECT - 726))
          | (1ULL << (TSqlParser::SUM - 726))
          | (1ULL << (TSqlParser::SUSPEND - 726))
          | (1ULL << (TSqlParser::SYMMETRIC - 726))
          | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
          | (1ULL << (TSqlParser::SYNONYM - 726))
          | (1ULL << (TSqlParser::SYSTEM - 726))
          | (1ULL << (TSqlParser::TAKE - 726))
          | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
          | (1ULL << (TSqlParser::TB - 726))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
          | (1ULL << (TSqlParser::THROW - 726))
          | (1ULL << (TSqlParser::TIES - 726))
          | (1ULL << (TSqlParser::TIME - 726))
          | (1ULL << (TSqlParser::TIMEOUT - 726))
          | (1ULL << (TSqlParser::TIMER - 726))
          | (1ULL << (TSqlParser::TINYINT - 726))
          | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
          | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
          | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
          | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
          | (1ULL << (TSqlParser::TRY - 790))
          | (1ULL << (TSqlParser::TSQL - 790))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
          | (1ULL << (TSqlParser::TYPE - 790))
          | (1ULL << (TSqlParser::TYPE_WARNING - 790))
          | (1ULL << (TSqlParser::UNBOUNDED - 790))
          | (1ULL << (TSqlParser::UNCOMMITTED - 790))
          | (1ULL << (TSqlParser::UNKNOWN - 790))
          | (1ULL << (TSqlParser::UNLIMITED - 790))
          | (1ULL << (TSqlParser::USING - 790))
          | (1ULL << (TSqlParser::VALID_XML - 790))
          | (1ULL << (TSqlParser::VALIDATION - 790))
          | (1ULL << (TSqlParser::VALUE - 790))
          | (1ULL << (TSqlParser::VAR - 790))
          | (1ULL << (TSqlParser::VARP - 790))
          | (1ULL << (TSqlParser::VIEW_METADATA - 790))
          | (1ULL << (TSqlParser::VIEWS - 790))
          | (1ULL << (TSqlParser::WAIT - 790))
          | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
          | (1ULL << (TSqlParser::WORK - 790))
          | (1ULL << (TSqlParser::WORKLOAD - 790))
          | (1ULL << (TSqlParser::XML - 790))
          | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 790))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 790))
          | (1ULL << (TSqlParser::ID - 790)))) != 0)) {
          setState(4427);
          dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->schema = id();
        }
        setState(4430);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4434);
      dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->procedure = id();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_objectContext ------------------------------------------------------------------

TSqlParser::Ddl_objectContext::Ddl_objectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Full_table_nameContext* TSqlParser::Ddl_objectContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Ddl_objectContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Ddl_objectContext::getRuleIndex() const {
  return TSqlParser::RuleDdl_object;
}

void TSqlParser::Ddl_objectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDdl_object(this);
}

void TSqlParser::Ddl_objectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDdl_object(this);
}

TSqlParser::Ddl_objectContext* TSqlParser::ddl_object() {
  Ddl_objectContext *_localctx = _tracker.createInstance<Ddl_objectContext>(_ctx, getState());
  enterRule(_localctx, 452, TSqlParser::RuleDdl_object);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4439);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(4437);
        full_table_name();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(4438);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_column_nameContext ------------------------------------------------------------------

TSqlParser::Full_column_nameContext::Full_column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Full_column_nameContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

TSqlParser::Table_nameContext* TSqlParser::Full_column_nameContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::COMPATIBILITY_LEVEL() {
  return getToken(TSqlParser::COMPATIBILITY_LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::STATUS() {
  return getToken(TSqlParser::STATUS, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::QUOTED_IDENTIFIER() {
  return getToken(TSqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::ARITHABORT() {
  return getToken(TSqlParser::ARITHABORT, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::ANSI_WARNINGS() {
  return getToken(TSqlParser::ANSI_WARNINGS, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::ANSI_PADDING() {
  return getToken(TSqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::ANSI_NULLS() {
  return getToken(TSqlParser::ANSI_NULLS, 0);
}


size_t TSqlParser::Full_column_nameContext::getRuleIndex() const {
  return TSqlParser::RuleFull_column_name;
}

void TSqlParser::Full_column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_column_name(this);
}

void TSqlParser::Full_column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_column_name(this);
}

TSqlParser::Full_column_nameContext* TSqlParser::full_column_name() {
  Full_column_nameContext *_localctx = _tracker.createInstance<Full_column_nameContext>(_ctx, getState());
  enterRule(_localctx, 454, TSqlParser::RuleFull_column_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4489);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 645, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4444);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 637, _ctx)) {
      case 1: {
        setState(4441);
        table_name();
        setState(4442);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4446);
      dynamic_cast<Full_column_nameContext *>(_localctx)->column_name = id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4450);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 638, _ctx)) {
      case 1: {
        setState(4447);
        table_name();
        setState(4448);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4452);
      match(TSqlParser::COMPATIBILITY_LEVEL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4456);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 639, _ctx)) {
      case 1: {
        setState(4453);
        table_name();
        setState(4454);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4458);
      match(TSqlParser::STATUS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4462);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 640, _ctx)) {
      case 1: {
        setState(4459);
        table_name();
        setState(4460);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4464);
      match(TSqlParser::QUOTED_IDENTIFIER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4468);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 641, _ctx)) {
      case 1: {
        setState(4465);
        table_name();
        setState(4466);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4470);
      match(TSqlParser::ARITHABORT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4474);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 642, _ctx)) {
      case 1: {
        setState(4471);
        table_name();
        setState(4472);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4476);
      match(TSqlParser::ANSI_WARNINGS);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4480);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 643, _ctx)) {
      case 1: {
        setState(4477);
        table_name();
        setState(4478);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4482);
      match(TSqlParser::ANSI_PADDING);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4486);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 644, _ctx)) {
      case 1: {
        setState(4483);
        table_name();
        setState(4484);
        match(TSqlParser::DOT);
        break;
      }

      }
      setState(4488);
      match(TSqlParser::ANSI_NULLS);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_list_with_orderContext ------------------------------------------------------------------

TSqlParser::Column_name_list_with_orderContext::Column_name_list_with_orderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Column_name_list_with_orderContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Column_name_list_with_orderContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::ASC() {
  return getTokens(TSqlParser::ASC);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::ASC(size_t i) {
  return getToken(TSqlParser::ASC, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::DESC() {
  return getTokens(TSqlParser::DESC);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::DESC(size_t i) {
  return getToken(TSqlParser::DESC, i);
}


size_t TSqlParser::Column_name_list_with_orderContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_name_list_with_order;
}

void TSqlParser::Column_name_list_with_orderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list_with_order(this);
}

void TSqlParser::Column_name_list_with_orderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list_with_order(this);
}

TSqlParser::Column_name_list_with_orderContext* TSqlParser::column_name_list_with_order() {
  Column_name_list_with_orderContext *_localctx = _tracker.createInstance<Column_name_list_with_orderContext>(_ctx, getState());
  enterRule(_localctx, 456, TSqlParser::RuleColumn_name_list_with_order);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4491);
    id();
    setState(4493);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ASC || _la == TSqlParser::DESC) {
      setState(4492);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ASC || _la == TSqlParser::DESC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(4502);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(4495);
      match(TSqlParser::COMMA);
      setState(4496);
      id();
      setState(4498);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ASC || _la == TSqlParser::DESC) {
        setState(4497);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ASC || _la == TSqlParser::DESC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(4504);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_listContext ------------------------------------------------------------------

TSqlParser::Column_name_listContext::Column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::IdContext *> TSqlParser::Column_name_listContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Column_name_listContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_name_list;
}

void TSqlParser::Column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list(this);
}

void TSqlParser::Column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list(this);
}

TSqlParser::Column_name_listContext* TSqlParser::column_name_list() {
  Column_name_listContext *_localctx = _tracker.createInstance<Column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 458, TSqlParser::RuleColumn_name_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4505);
    id();
    setState(4510);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(4506);
      match(TSqlParser::COMMA);
      setState(4507);
      id();
      setState(4512);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_nameContext ------------------------------------------------------------------

TSqlParser::Cursor_nameContext::Cursor_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Cursor_nameContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_nameContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Cursor_nameContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_name;
}

void TSqlParser::Cursor_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_name(this);
}

void TSqlParser::Cursor_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_name(this);
}

TSqlParser::Cursor_nameContext* TSqlParser::cursor_name() {
  Cursor_nameContext *_localctx = _tracker.createInstance<Cursor_nameContext>(_ctx, getState());
  enterRule(_localctx, 460, TSqlParser::RuleCursor_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4515);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(4513);
        id();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(4514);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_offContext ------------------------------------------------------------------

TSqlParser::On_offContext::On_offContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::On_offContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::On_offContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}


size_t TSqlParser::On_offContext::getRuleIndex() const {
  return TSqlParser::RuleOn_off;
}

void TSqlParser::On_offContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOn_off(this);
}

void TSqlParser::On_offContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOn_off(this);
}

TSqlParser::On_offContext* TSqlParser::on_off() {
  On_offContext *_localctx = _tracker.createInstance<On_offContext>(_ctx, getState());
  enterRule(_localctx, 462, TSqlParser::RuleOn_off);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4517);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::OFF

    || _la == TSqlParser::ON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClusteredContext ------------------------------------------------------------------

TSqlParser::ClusteredContext::ClusteredContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::ClusteredContext::CLUSTERED() {
  return getToken(TSqlParser::CLUSTERED, 0);
}

tree::TerminalNode* TSqlParser::ClusteredContext::NONCLUSTERED() {
  return getToken(TSqlParser::NONCLUSTERED, 0);
}


size_t TSqlParser::ClusteredContext::getRuleIndex() const {
  return TSqlParser::RuleClustered;
}

void TSqlParser::ClusteredContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClustered(this);
}

void TSqlParser::ClusteredContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClustered(this);
}

TSqlParser::ClusteredContext* TSqlParser::clustered() {
  ClusteredContext *_localctx = _tracker.createInstance<ClusteredContext>(_ctx, getState());
  enterRule(_localctx, 464, TSqlParser::RuleClustered);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4519);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::CLUSTERED || _la == TSqlParser::NONCLUSTERED)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_notnullContext ------------------------------------------------------------------

TSqlParser::Null_notnullContext::Null_notnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Null_notnullContext::null() {
  return getToken(TSqlParser::null, 0);
}

tree::TerminalNode* TSqlParser::Null_notnullContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}


size_t TSqlParser::Null_notnullContext::getRuleIndex() const {
  return TSqlParser::RuleNull_notnull;
}

void TSqlParser::Null_notnullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_notnull(this);
}

void TSqlParser::Null_notnullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_notnull(this);
}

TSqlParser::Null_notnullContext* TSqlParser::null_notnull() {
  Null_notnullContext *_localctx = _tracker.createInstance<Null_notnullContext>(_ctx, getState());
  enterRule(_localctx, 466, TSqlParser::RuleNull_notnull);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4522);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::NOT) {
      setState(4521);
      match(TSqlParser::NOT);
    }
    setState(4524);
    match(TSqlParser::null);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_or_defaultContext ------------------------------------------------------------------

TSqlParser::Null_or_defaultContext::Null_or_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Null_notnullContext* TSqlParser::Null_or_defaultContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Null_or_defaultContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}


size_t TSqlParser::Null_or_defaultContext::getRuleIndex() const {
  return TSqlParser::RuleNull_or_default;
}

void TSqlParser::Null_or_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_or_default(this);
}

void TSqlParser::Null_or_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_or_default(this);
}

TSqlParser::Null_or_defaultContext* TSqlParser::null_or_default() {
  Null_or_defaultContext *_localctx = _tracker.createInstance<Null_or_defaultContext>(_ctx, getState());
  enterRule(_localctx, 468, TSqlParser::RuleNull_or_default);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4533);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NOT:
      case TSqlParser::null: {
        setState(4526);
        null_notnull();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(4527);
        match(TSqlParser::DEFAULT);
        setState(4528);
        constant_expression();
        setState(4531);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 652, _ctx)) {
        case 1: {
          setState(4529);
          match(TSqlParser::WITH);
          setState(4530);
          match(TSqlParser::VALUES);
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_function_nameContext ------------------------------------------------------------------

TSqlParser::Scalar_function_nameContext::Scalar_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Scalar_function_nameContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RIGHT() {
  return getToken(TSqlParser::RIGHT, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LEFT() {
  return getToken(TSqlParser::LEFT, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ABS() {
  return getToken(TSqlParser::ABS, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ASCII() {
  return getToken(TSqlParser::ASCII, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CEILING() {
  return getToken(TSqlParser::CEILING, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHARINDEX() {
  return getToken(TSqlParser::CHARINDEX, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::DATALENGTH() {
  return getToken(TSqlParser::DATALENGTH, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::DAY() {
  return getToken(TSqlParser::DAY, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::FLOOR() {
  return getToken(TSqlParser::FLOOR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ISDATE() {
  return getToken(TSqlParser::ISDATE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ISNUMERIC() {
  return getToken(TSqlParser::ISNUMERIC, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LEN() {
  return getToken(TSqlParser::LEN, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LOWER() {
  return getToken(TSqlParser::LOWER, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LTRIM() {
  return getToken(TSqlParser::LTRIM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::MONTH() {
  return getToken(TSqlParser::MONTH, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::NCHAR() {
  return getToken(TSqlParser::NCHAR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::PATINDEX() {
  return getToken(TSqlParser::PATINDEX, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RAND() {
  return getToken(TSqlParser::RAND, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::REPLACE() {
  return getToken(TSqlParser::REPLACE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ROUND() {
  return getToken(TSqlParser::ROUND, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RTRIM() {
  return getToken(TSqlParser::RTRIM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SIGN() {
  return getToken(TSqlParser::SIGN, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SPACE() {
  return getToken(TSqlParser::SPACE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::STR() {
  return getToken(TSqlParser::STR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SUBSTRING() {
  return getToken(TSqlParser::SUBSTRING, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::UPPER() {
  return getToken(TSqlParser::UPPER, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::USER_NAME() {
  return getToken(TSqlParser::USER_NAME, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::YEAR() {
  return getToken(TSqlParser::YEAR, 0);
}


size_t TSqlParser::Scalar_function_nameContext::getRuleIndex() const {
  return TSqlParser::RuleScalar_function_name;
}

void TSqlParser::Scalar_function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_function_name(this);
}

void TSqlParser::Scalar_function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_function_name(this);
}

TSqlParser::Scalar_function_nameContext* TSqlParser::scalar_function_name() {
  Scalar_function_nameContext *_localctx = _tracker.createInstance<Scalar_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 470, TSqlParser::RuleScalar_function_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4567);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 654, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4535);
      func_proc_name_server_database_schema();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4536);
      match(TSqlParser::RIGHT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4537);
      match(TSqlParser::LEFT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4538);
      match(TSqlParser::BINARY_CHECKSUM);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4539);
      match(TSqlParser::CHECKSUM);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4540);
      match(TSqlParser::ABS);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4541);
      match(TSqlParser::ASCII);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4542);
      match(TSqlParser::CEILING);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4543);
      match(TSqlParser::CHARINDEX);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4544);
      match(TSqlParser::CHECKSUM);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4545);
      match(TSqlParser::DATALENGTH);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4546);
      match(TSqlParser::DAY);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(4547);
      match(TSqlParser::FLOOR);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(4548);
      match(TSqlParser::ISDATE);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(4549);
      match(TSqlParser::ISNUMERIC);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(4550);
      match(TSqlParser::LEN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(4551);
      match(TSqlParser::LOWER);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(4552);
      match(TSqlParser::LTRIM);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(4553);
      match(TSqlParser::MONTH);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(4554);
      match(TSqlParser::NCHAR);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(4555);
      match(TSqlParser::PATINDEX);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(4556);
      match(TSqlParser::RAND);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(4557);
      match(TSqlParser::REPLACE);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(4558);
      match(TSqlParser::ROUND);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(4559);
      match(TSqlParser::RTRIM);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(4560);
      match(TSqlParser::SIGN);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(4561);
      match(TSqlParser::SPACE);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(4562);
      match(TSqlParser::STR);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(4563);
      match(TSqlParser::SUBSTRING);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(4564);
      match(TSqlParser::UPPER);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(4565);
      match(TSqlParser::USER_NAME);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(4566);
      match(TSqlParser::YEAR);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_conversation_timerContext ------------------------------------------------------------------

TSqlParser::Begin_conversation_timerContext::Begin_conversation_timerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::CONVERSATION() {
  return getToken(TSqlParser::CONVERSATION, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::TIMER() {
  return getToken(TSqlParser::TIMER, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::TimeContext* TSqlParser::Begin_conversation_timerContext::time() {
  return getRuleContext<TSqlParser::TimeContext>(0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_timerContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Begin_conversation_timerContext::getRuleIndex() const {
  return TSqlParser::RuleBegin_conversation_timer;
}

void TSqlParser::Begin_conversation_timerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_conversation_timer(this);
}

void TSqlParser::Begin_conversation_timerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_conversation_timer(this);
}

TSqlParser::Begin_conversation_timerContext* TSqlParser::begin_conversation_timer() {
  Begin_conversation_timerContext *_localctx = _tracker.createInstance<Begin_conversation_timerContext>(_ctx, getState());
  enterRule(_localctx, 472, TSqlParser::RuleBegin_conversation_timer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4569);
    match(TSqlParser::BEGIN);
    setState(4570);
    match(TSqlParser::CONVERSATION);
    setState(4571);
    match(TSqlParser::TIMER);
    setState(4572);
    match(TSqlParser::LR_BRACKET);
    setState(4573);
    match(TSqlParser::LOCAL_ID);
    setState(4574);
    match(TSqlParser::RR_BRACKET);
    setState(4575);
    match(TSqlParser::TIMEOUT);
    setState(4576);
    match(TSqlParser::EQUAL);
    setState(4577);
    time();
    setState(4579);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 655, _ctx)) {
    case 1: {
      setState(4578);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_conversation_dialogContext ------------------------------------------------------------------

TSqlParser::Begin_conversation_dialogContext::Begin_conversation_dialogContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::DIALOG() {
  return getToken(TSqlParser::DIALOG, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Begin_conversation_dialogContext::SERVICE() {
  return getTokens(TSqlParser::SERVICE);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::SERVICE(size_t i) {
  return getToken(TSqlParser::SERVICE, i);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::TO() {
  return getToken(TSqlParser::TO, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Begin_conversation_dialogContext::ON() {
  return getTokens(TSqlParser::ON);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::ON(size_t i) {
  return getToken(TSqlParser::ON, i);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::CONTRACT() {
  return getToken(TSqlParser::CONTRACT, 0);
}

TSqlParser::Contract_nameContext* TSqlParser::Begin_conversation_dialogContext::contract_name() {
  return getRuleContext<TSqlParser::Contract_nameContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Begin_conversation_dialogContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

std::vector<TSqlParser::Service_nameContext *> TSqlParser::Begin_conversation_dialogContext::service_name() {
  return getRuleContexts<TSqlParser::Service_nameContext>();
}

TSqlParser::Service_nameContext* TSqlParser::Begin_conversation_dialogContext::service_name(size_t i) {
  return getRuleContext<TSqlParser::Service_nameContext>(i);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::CONVERSATION() {
  return getToken(TSqlParser::CONVERSATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Begin_conversation_dialogContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Begin_conversation_dialogContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::LIFETIME() {
  return getToken(TSqlParser::LIFETIME, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::RELATED_CONVERSATION() {
  return getToken(TSqlParser::RELATED_CONVERSATION, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::RELATED_CONVERSATION_GROUP() {
  return getToken(TSqlParser::RELATED_CONVERSATION_GROUP, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Begin_conversation_dialogContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}


size_t TSqlParser::Begin_conversation_dialogContext::getRuleIndex() const {
  return TSqlParser::RuleBegin_conversation_dialog;
}

void TSqlParser::Begin_conversation_dialogContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_conversation_dialog(this);
}

void TSqlParser::Begin_conversation_dialogContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_conversation_dialog(this);
}

TSqlParser::Begin_conversation_dialogContext* TSqlParser::begin_conversation_dialog() {
  Begin_conversation_dialogContext *_localctx = _tracker.createInstance<Begin_conversation_dialogContext>(_ctx, getState());
  enterRule(_localctx, 474, TSqlParser::RuleBegin_conversation_dialog);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4581);
    match(TSqlParser::BEGIN);
    setState(4582);
    match(TSqlParser::DIALOG);
    setState(4584);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONVERSATION) {
      setState(4583);
      match(TSqlParser::CONVERSATION);
    }
    setState(4586);
    dynamic_cast<Begin_conversation_dialogContext *>(_localctx)->dialog_handle = match(TSqlParser::LOCAL_ID);
    setState(4587);
    match(TSqlParser::FROM);
    setState(4588);
    match(TSqlParser::SERVICE);
    setState(4589);
    dynamic_cast<Begin_conversation_dialogContext *>(_localctx)->initiator_service_name = service_name();
    setState(4590);
    match(TSqlParser::TO);
    setState(4591);
    match(TSqlParser::SERVICE);
    setState(4592);
    dynamic_cast<Begin_conversation_dialogContext *>(_localctx)->target_service_name = service_name();
    setState(4595);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(4593);
      match(TSqlParser::COMMA);
      setState(4594);
      dynamic_cast<Begin_conversation_dialogContext *>(_localctx)->service_broker_guid = match(TSqlParser::STRING);
    }
    setState(4597);
    match(TSqlParser::ON);
    setState(4598);
    match(TSqlParser::CONTRACT);
    setState(4599);
    contract_name();
    setState(4622);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 663, _ctx)) {
    case 1: {
      setState(4600);
      match(TSqlParser::WITH);
      setState(4607);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::RELATED_CONVERSATION

      || _la == TSqlParser::RELATED_CONVERSATION_GROUP) {
        setState(4601);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::RELATED_CONVERSATION

        || _la == TSqlParser::RELATED_CONVERSATION_GROUP)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4602);
        match(TSqlParser::EQUAL);
        setState(4603);
        match(TSqlParser::LOCAL_ID);
        setState(4605);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(4604);
          match(TSqlParser::COMMA);
        }
      }
      setState(4615);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LIFETIME) {
        setState(4609);
        match(TSqlParser::LIFETIME);
        setState(4610);
        match(TSqlParser::EQUAL);
        setState(4611);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::LOCAL_ID

        || _la == TSqlParser::DECIMAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4613);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(4612);
          match(TSqlParser::COMMA);
        }
      }
      setState(4620);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 662, _ctx)) {
      case 1: {
        setState(4617);
        match(TSqlParser::ENCRYPTION);
        setState(4618);
        match(TSqlParser::EQUAL);
        setState(4619);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::OFF

        || _la == TSqlParser::ON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    }
    setState(4625);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 664, _ctx)) {
    case 1: {
      setState(4624);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Contract_nameContext ------------------------------------------------------------------

TSqlParser::Contract_nameContext::Contract_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Contract_nameContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Contract_nameContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Contract_nameContext::getRuleIndex() const {
  return TSqlParser::RuleContract_name;
}

void TSqlParser::Contract_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContract_name(this);
}

void TSqlParser::Contract_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContract_name(this);
}

TSqlParser::Contract_nameContext* TSqlParser::contract_name() {
  Contract_nameContext *_localctx = _tracker.createInstance<Contract_nameContext>(_ctx, getState());
  enterRule(_localctx, 476, TSqlParser::RuleContract_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4629);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 665, _ctx)) {
    case 1: {
      setState(4627);
      id();
      break;
    }

    case 2: {
      setState(4628);
      expression(0);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Service_nameContext ------------------------------------------------------------------

TSqlParser::Service_nameContext::Service_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Service_nameContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Service_nameContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Service_nameContext::getRuleIndex() const {
  return TSqlParser::RuleService_name;
}

void TSqlParser::Service_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterService_name(this);
}

void TSqlParser::Service_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitService_name(this);
}

TSqlParser::Service_nameContext* TSqlParser::service_name() {
  Service_nameContext *_localctx = _tracker.createInstance<Service_nameContext>(_ctx, getState());
  enterRule(_localctx, 478, TSqlParser::RuleService_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4633);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 666, _ctx)) {
    case 1: {
      setState(4631);
      id();
      break;
    }

    case 2: {
      setState(4632);
      expression(0);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_conversationContext ------------------------------------------------------------------

TSqlParser::End_conversationContext::End_conversationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::End_conversationContext::END() {
  return getToken(TSqlParser::END, 0);
}

tree::TerminalNode* TSqlParser::End_conversationContext::CONVERSATION() {
  return getToken(TSqlParser::CONVERSATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::End_conversationContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::End_conversationContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::End_conversationContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::End_conversationContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::End_conversationContext::ERROR() {
  return getToken(TSqlParser::ERROR, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::End_conversationContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::End_conversationContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

tree::TerminalNode* TSqlParser::End_conversationContext::DESCRIPTION() {
  return getToken(TSqlParser::DESCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::End_conversationContext::CLEANUP() {
  return getToken(TSqlParser::CLEANUP, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::End_conversationContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::End_conversationContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}


size_t TSqlParser::End_conversationContext::getRuleIndex() const {
  return TSqlParser::RuleEnd_conversation;
}

void TSqlParser::End_conversationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_conversation(this);
}

void TSqlParser::End_conversationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_conversation(this);
}

TSqlParser::End_conversationContext* TSqlParser::end_conversation() {
  End_conversationContext *_localctx = _tracker.createInstance<End_conversationContext>(_ctx, getState());
  enterRule(_localctx, 480, TSqlParser::RuleEnd_conversation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4635);
    match(TSqlParser::END);
    setState(4636);
    match(TSqlParser::CONVERSATION);
    setState(4637);
    dynamic_cast<End_conversationContext *>(_localctx)->conversation_handle = match(TSqlParser::LOCAL_ID);
    setState(4639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 667, _ctx)) {
    case 1: {
      setState(4638);
      match(TSqlParser::SEMI);
      break;
    }

    }
    setState(4653);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 670, _ctx)) {
    case 1: {
      setState(4641);
      match(TSqlParser::WITH);
      setState(4648);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ERROR) {
        setState(4642);
        match(TSqlParser::ERROR);
        setState(4643);
        match(TSqlParser::EQUAL);
        setState(4644);
        dynamic_cast<End_conversationContext *>(_localctx)->faliure_code = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::LOCAL_ID

        || _la == TSqlParser::STRING)) {
          dynamic_cast<End_conversationContext *>(_localctx)->faliure_code = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4645);
        match(TSqlParser::DESCRIPTION);
        setState(4646);
        match(TSqlParser::EQUAL);
        setState(4647);
        dynamic_cast<End_conversationContext *>(_localctx)->failure_text = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::LOCAL_ID

        || _la == TSqlParser::STRING)) {
          dynamic_cast<End_conversationContext *>(_localctx)->failure_text = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(4651);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 669, _ctx)) {
      case 1: {
        setState(4650);
        match(TSqlParser::CLEANUP);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Waitfor_conversationContext ------------------------------------------------------------------

TSqlParser::Waitfor_conversationContext::Waitfor_conversationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Waitfor_conversationContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Get_conversationContext* TSqlParser::Waitfor_conversationContext::get_conversation() {
  return getRuleContext<TSqlParser::Get_conversationContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_conversationContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_conversationContext::WAITFOR() {
  return getToken(TSqlParser::WAITFOR, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_conversationContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_conversationContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::TimeContext* TSqlParser::Waitfor_conversationContext::time() {
  return getRuleContext<TSqlParser::TimeContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_conversationContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}


size_t TSqlParser::Waitfor_conversationContext::getRuleIndex() const {
  return TSqlParser::RuleWaitfor_conversation;
}

void TSqlParser::Waitfor_conversationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWaitfor_conversation(this);
}

void TSqlParser::Waitfor_conversationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWaitfor_conversation(this);
}

TSqlParser::Waitfor_conversationContext* TSqlParser::waitfor_conversation() {
  Waitfor_conversationContext *_localctx = _tracker.createInstance<Waitfor_conversationContext>(_ctx, getState());
  enterRule(_localctx, 482, TSqlParser::RuleWaitfor_conversation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4656);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WAITFOR) {
      setState(4655);
      match(TSqlParser::WAITFOR);
    }
    setState(4658);
    match(TSqlParser::LR_BRACKET);
    setState(4659);
    get_conversation();
    setState(4660);
    match(TSqlParser::RR_BRACKET);
    setState(4666);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 673, _ctx)) {
    case 1: {
      setState(4662);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(4661);
        match(TSqlParser::COMMA);
      }
      setState(4664);
      match(TSqlParser::TIMEOUT);
      setState(4665);
      dynamic_cast<Waitfor_conversationContext *>(_localctx)->timeout = time();
      break;
    }

    }
    setState(4669);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 674, _ctx)) {
    case 1: {
      setState(4668);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_conversationContext ------------------------------------------------------------------

TSqlParser::Get_conversationContext::Get_conversationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Get_conversationContext::GET() {
  return getToken(TSqlParser::GET, 0);
}

tree::TerminalNode* TSqlParser::Get_conversationContext::CONVERSATION() {
  return getToken(TSqlParser::CONVERSATION, 0);
}

tree::TerminalNode* TSqlParser::Get_conversationContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::Get_conversationContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Queue_idContext* TSqlParser::Get_conversationContext::queue_id() {
  return getRuleContext<TSqlParser::Queue_idContext>(0);
}

tree::TerminalNode* TSqlParser::Get_conversationContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Get_conversationContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Get_conversationContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Get_conversationContext::getRuleIndex() const {
  return TSqlParser::RuleGet_conversation;
}

void TSqlParser::Get_conversationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_conversation(this);
}

void TSqlParser::Get_conversationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_conversation(this);
}

TSqlParser::Get_conversationContext* TSqlParser::get_conversation() {
  Get_conversationContext *_localctx = _tracker.createInstance<Get_conversationContext>(_ctx, getState());
  enterRule(_localctx, 484, TSqlParser::RuleGet_conversation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4671);
    match(TSqlParser::GET);
    setState(4672);
    match(TSqlParser::CONVERSATION);
    setState(4673);
    match(TSqlParser::GROUP);
    setState(4674);
    dynamic_cast<Get_conversationContext *>(_localctx)->conversation_group_id = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
      dynamic_cast<Get_conversationContext *>(_localctx)->conversation_group_id = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4675);
    match(TSqlParser::FROM);
    setState(4676);
    dynamic_cast<Get_conversationContext *>(_localctx)->queue = queue_id();
    setState(4678);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 675, _ctx)) {
    case 1: {
      setState(4677);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Queue_idContext ------------------------------------------------------------------

TSqlParser::Queue_idContext::Queue_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Queue_idContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Queue_idContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

std::vector<TSqlParser::IdContext *> TSqlParser::Queue_idContext::id() {
  return getRuleContexts<TSqlParser::IdContext>();
}

TSqlParser::IdContext* TSqlParser::Queue_idContext::id(size_t i) {
  return getRuleContext<TSqlParser::IdContext>(i);
}


size_t TSqlParser::Queue_idContext::getRuleIndex() const {
  return TSqlParser::RuleQueue_id;
}

void TSqlParser::Queue_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueue_id(this);
}

void TSqlParser::Queue_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueue_id(this);
}

TSqlParser::Queue_idContext* TSqlParser::queue_id() {
  Queue_idContext *_localctx = _tracker.createInstance<Queue_idContext>(_ctx, getState());
  enterRule(_localctx, 486, TSqlParser::RuleQueue_id);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4687);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 676, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4680);
      dynamic_cast<Queue_idContext *>(_localctx)->database_name = id();
      setState(4681);
      match(TSqlParser::DOT);
      setState(4682);
      dynamic_cast<Queue_idContext *>(_localctx)->schema_name = id();
      setState(4683);
      match(TSqlParser::DOT);
      setState(4684);
      dynamic_cast<Queue_idContext *>(_localctx)->name = id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4686);
      id();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Send_conversationContext ------------------------------------------------------------------

TSqlParser::Send_conversationContext::Send_conversationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Send_conversationContext::SEND() {
  return getToken(TSqlParser::SEND, 0);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::CONVERSATION() {
  return getToken(TSqlParser::CONVERSATION, 0);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::MESSAGE() {
  return getToken(TSqlParser::MESSAGE, 0);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Send_conversationContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Send_conversationContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Send_conversationContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Send_conversationContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Send_conversationContext::getRuleIndex() const {
  return TSqlParser::RuleSend_conversation;
}

void TSqlParser::Send_conversationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSend_conversation(this);
}

void TSqlParser::Send_conversationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSend_conversation(this);
}

TSqlParser::Send_conversationContext* TSqlParser::send_conversation() {
  Send_conversationContext *_localctx = _tracker.createInstance<Send_conversationContext>(_ctx, getState());
  enterRule(_localctx, 488, TSqlParser::RuleSend_conversation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4689);
    match(TSqlParser::SEND);
    setState(4690);
    match(TSqlParser::ON);
    setState(4691);
    match(TSqlParser::CONVERSATION);
    setState(4692);
    dynamic_cast<Send_conversationContext *>(_localctx)->conversation_handle = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
      dynamic_cast<Send_conversationContext *>(_localctx)->conversation_handle = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4693);
    match(TSqlParser::MESSAGE);
    setState(4694);
    match(TSqlParser::TYPE);
    setState(4695);
    dynamic_cast<Send_conversationContext *>(_localctx)->message_type_name = expression(0);
    setState(4699);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 677, _ctx)) {
    case 1: {
      setState(4696);
      match(TSqlParser::LR_BRACKET);
      setState(4697);
      dynamic_cast<Send_conversationContext *>(_localctx)->message_body_expression = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::LOCAL_ID

      || _la == TSqlParser::STRING)) {
        dynamic_cast<Send_conversationContext *>(_localctx)->message_body_expression = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4698);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    }
    setState(4702);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 678, _ctx)) {
    case 1: {
      setState(4701);
      match(TSqlParser::SEMI);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_typeContext ------------------------------------------------------------------

TSqlParser::Data_typeContext::Data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::IdContext* TSqlParser::Data_typeContext::id() {
  return getRuleContext<TSqlParser::IdContext>(0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Data_typeContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Data_typeContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

tree::TerminalNode* TSqlParser::Data_typeContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::DOUBLE() {
  return getToken(TSqlParser::DOUBLE, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::PRECISION() {
  return getToken(TSqlParser::PRECISION, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::INT() {
  return getToken(TSqlParser::INT, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::TINYINT() {
  return getToken(TSqlParser::TINYINT, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::SMALLINT() {
  return getToken(TSqlParser::SMALLINT, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::BIGINT() {
  return getToken(TSqlParser::BIGINT, 0);
}


size_t TSqlParser::Data_typeContext::getRuleIndex() const {
  return TSqlParser::RuleData_type;
}

void TSqlParser::Data_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_type(this);
}

void TSqlParser::Data_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_type(this);
}

TSqlParser::Data_typeContext* TSqlParser::data_type() {
  Data_typeContext *_localctx = _tracker.createInstance<Data_typeContext>(_ctx, getState());
  enterRule(_localctx, 490, TSqlParser::RuleData_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4725);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 683, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4704);
      id();
      setState(4706);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 679, _ctx)) {
      case 1: {
        setState(4705);
        match(TSqlParser::IDENTITY);
        break;
      }

      }
      setState(4715);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 681, _ctx)) {
      case 1: {
        setState(4708);
        match(TSqlParser::LR_BRACKET);
        setState(4709);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::MAX || _la == TSqlParser::DECIMAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4712);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(4710);
          match(TSqlParser::COMMA);
          setState(4711);
          match(TSqlParser::DECIMAL);
        }
        setState(4714);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4717);
      match(TSqlParser::DOUBLE);
      setState(4719);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PRECISION) {
        setState(4718);
        match(TSqlParser::PRECISION);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4721);
      match(TSqlParser::INT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4722);
      match(TSqlParser::TINYINT);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4723);
      match(TSqlParser::SMALLINT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4724);
      match(TSqlParser::BIGINT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_valueContext ------------------------------------------------------------------

TSqlParser::Default_valueContext::Default_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Default_valueContext::null() {
  return getToken(TSqlParser::null, 0);
}

tree::TerminalNode* TSqlParser::Default_valueContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

TSqlParser::ConstantContext* TSqlParser::Default_valueContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::Default_valueContext::getRuleIndex() const {
  return TSqlParser::RuleDefault_value;
}

void TSqlParser::Default_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_value(this);
}

void TSqlParser::Default_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_value(this);
}

TSqlParser::Default_valueContext* TSqlParser::default_value() {
  Default_valueContext *_localctx = _tracker.createInstance<Default_valueContext>(_ctx, getState());
  enterRule(_localctx, 492, TSqlParser::RuleDefault_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4730);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::null: {
        enterOuterAlt(_localctx, 1);
        setState(4727);
        match(TSqlParser::null);
        break;
      }

      case TSqlParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(4728);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 3);
        setState(4729);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

TSqlParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::ConstantContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::BINARY() {
  return getToken(TSqlParser::BINARY, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

TSqlParser::SignContext* TSqlParser::ConstantContext::sign() {
  return getRuleContext<TSqlParser::SignContext>(0);
}

tree::TerminalNode* TSqlParser::ConstantContext::REAL() {
  return getToken(TSqlParser::REAL, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::FLOAT() {
  return getToken(TSqlParser::FLOAT, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::DOLLAR() {
  return getToken(TSqlParser::DOLLAR, 0);
}


size_t TSqlParser::ConstantContext::getRuleIndex() const {
  return TSqlParser::RuleConstant;
}

void TSqlParser::ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant(this);
}

void TSqlParser::ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant(this);
}

TSqlParser::ConstantContext* TSqlParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 494, TSqlParser::RuleConstant);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4747);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 688, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4732);
      match(TSqlParser::STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4733);
      match(TSqlParser::BINARY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4735);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(4734);
        sign();
      }
      setState(4737);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4739);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(4738);
        sign();
      }
      setState(4741);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::FLOAT

      || _la == TSqlParser::REAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4743);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(4742);
        sign();
      }
      setState(4745);
      dynamic_cast<ConstantContext *>(_localctx)->dollar = match(TSqlParser::DOLLAR);
      setState(4746);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DECIMAL

      || _la == TSqlParser::FLOAT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignContext ------------------------------------------------------------------

TSqlParser::SignContext::SignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::SignContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::SignContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::SignContext::getRuleIndex() const {
  return TSqlParser::RuleSign;
}

void TSqlParser::SignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSign(this);
}

void TSqlParser::SignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSign(this);
}

TSqlParser::SignContext* TSqlParser::sign() {
  SignContext *_localctx = _tracker.createInstance<SignContext>(_ctx, getState());
  enterRule(_localctx, 496, TSqlParser::RuleSign);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4749);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PLUS

    || _la == TSqlParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdContext ------------------------------------------------------------------

TSqlParser::IdContext::IdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Simple_idContext* TSqlParser::IdContext::simple_id() {
  return getRuleContext<TSqlParser::Simple_idContext>(0);
}

tree::TerminalNode* TSqlParser::IdContext::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}

tree::TerminalNode* TSqlParser::IdContext::SQUARE_BRACKET_ID() {
  return getToken(TSqlParser::SQUARE_BRACKET_ID, 0);
}


size_t TSqlParser::IdContext::getRuleIndex() const {
  return TSqlParser::RuleId;
}

void TSqlParser::IdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterId(this);
}

void TSqlParser::IdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitId(this);
}

TSqlParser::IdContext* TSqlParser::id() {
  IdContext *_localctx = _tracker.createInstance<IdContext>(_ctx, getState());
  enterRule(_localctx, 498, TSqlParser::RuleId);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4754);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CALLED:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::EVENTDATA:
      case TSqlParser::FILENAME:
      case TSqlParser::FILLFACTOR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::INIT:
      case TSqlParser::KEY:
      case TSqlParser::MASTER:
      case TSqlParser::MAX_MEMORY:
      case TSqlParser::OFFSETS:
      case TSqlParser::PAGE:
      case TSqlParser::PUBLIC:
      case TSqlParser::R:
      case TSqlParser::RAW:
      case TSqlParser::RETURN:
      case TSqlParser::RETURNS:
      case TSqlParser::ROWCOUNT:
      case TSqlParser::SAFETY:
      case TSqlParser::SERVER:
      case TSqlParser::SID:
      case TSqlParser::SOURCE:
      case TSqlParser::SPLIT:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::ACCENT_SENSITIVITY:
      case TSqlParser::ACTION:
      case TSqlParser::ACTIVATION:
      case TSqlParser::ACTIVE:
      case TSqlParser::ADDRESS:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::AFFINITY:
      case TSqlParser::AFTER:
      case TSqlParser::AGGREGATE:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS:
      case TSqlParser::ALLOW_SNAPSHOT_ISOLATION:
      case TSqlParser::ALLOWED:
      case TSqlParser::ANSI_NULL_DEFAULT:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLICATION_LOG:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::ASSEMBLY:
      case TSqlParser::AUDIT:
      case TSqlParser::AUDIT_GUID:
      case TSqlParser::AUTO:
      case TSqlParser::AUTO_CLEANUP:
      case TSqlParser::AUTO_CLOSE:
      case TSqlParser::AUTO_CREATE_STATISTICS:
      case TSqlParser::AUTO_SHRINK:
      case TSqlParser::AUTO_UPDATE_STATISTICS:
      case TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC:
      case TSqlParser::AVAILABILITY:
      case TSqlParser::AVG:
      case TSqlParser::BACKUP_PRIORITY:
      case TSqlParser::BEGIN_DIALOG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::BINDING:
      case TSqlParser::BLOB_STORAGE:
      case TSqlParser::BROKER:
      case TSqlParser::BROKER_INSTANCE:
      case TSqlParser::BULK_LOGGED:
      case TSqlParser::CALLER:
      case TSqlParser::CAP_CPU_PERCENT:
      case TSqlParser::CAST:
      case TSqlParser::CATALOG:
      case TSqlParser::CATCH:
      case TSqlParser::CHANGE_RETENTION:
      case TSqlParser::CHANGE_TRACKING:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::CLEANUP:
      case TSqlParser::COLLECTION:
      case TSqlParser::COLUMN_MASTER_KEY:
      case TSqlParser::COMMITTED:
      case TSqlParser::COMPATIBILITY_LEVEL:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::CONTENT:
      case TSqlParser::CONTROL:
      case TSqlParser::COOKIE:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::COUNTER:
      case TSqlParser::CPU:
      case TSqlParser::CREATE_NEW:
      case TSqlParser::CREATION_DISPOSITION:
      case TSqlParser::CREDENTIAL:
      case TSqlParser::CRYPTOGRAPHIC:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATE_CORRELATION_OPTIMIZATION:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DB_CHAINING:
      case TSqlParser::DB_FAILOVER:
      case TSqlParser::DECRYPTION:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DEFAULT_FULLTEXT_LANGUAGE:
      case TSqlParser::DEFAULT_LANGUAGE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DEPENDENTS:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DHCP:
      case TSqlParser::DIALOG:
      case TSqlParser::DIRECTORY_NAME:
      case TSqlParser::DISABLE:
      case TSqlParser::DISABLE_BROKER:
      case TSqlParser::DISABLED:
      case TSqlParser::DISK_DRIVE:
      case TSqlParser::DOCUMENT:
      case TSqlParser::DYNAMIC:
      case TSqlParser::EMERGENCY:
      case TSqlParser::EMPTY:
      case TSqlParser::ENABLE:
      case TSqlParser::ENABLE_BROKER:
      case TSqlParser::ENCRYPTED_VALUE:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::ENDPOINT_URL:
      case TSqlParser::ERROR_BROKER_CONVERSATIONS:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::EXECUTABLE:
      case TSqlParser::EXIST:
      case TSqlParser::EXPAND:
      case TSqlParser::EXPIRY_DATE:
      case TSqlParser::EXPLICIT:
      case TSqlParser::FAIL_OPERATION:
      case TSqlParser::FAILOVER_MODE:
      case TSqlParser::FAILURE:
      case TSqlParser::FAILURE_CONDITION_LEVEL:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FILEGROUP:
      case TSqlParser::FILEGROWTH:
      case TSqlParser::FILEPATH:
      case TSqlParser::FILESTREAM:
      case TSqlParser::FILTER:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS:
      case TSqlParser::FORCED:
      case TSqlParser::FORMAT:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::FULLSCAN:
      case TSqlParser::FULLTEXT:
      case TSqlParser::GB:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO:
      case TSqlParser::GROUP_MAX_REQUESTS:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HADR:
      case TSqlParser::HASH:
      case TSqlParser::HEALTH_CHECK_TIMEOUT:
      case TSqlParser::HIGH:
      case TSqlParser::HONOR_BROKER_PRIORITY:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:
      case TSqlParser::IMMEDIATE:
      case TSqlParser::IMPERSONATE:
      case TSqlParser::IMPORTANCE:
      case TSqlParser::INCREMENTAL:
      case TSqlParser::INITIATOR:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::IP:
      case TSqlParser::ISOLATION:
      case TSqlParser::KB:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEY_SOURCE:
      case TSqlParser::KEYS:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LIST:
      case TSqlParser::LISTENER:
      case TSqlParser::LISTENER_URL:
      case TSqlParser::LOB_COMPACTION:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOGIN:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MATERIALIZED:
      case TSqlParser::MAX:
      case TSqlParser::MAX_CPU_PERCENT:
      case TSqlParser::MAX_DOP:
      case TSqlParser::MAX_FILES:
      case TSqlParser::MAX_IOPS_PER_VOLUME:
      case TSqlParser::MAX_MEMORY_PERCENT:
      case TSqlParser::MAX_PROCESSES:
      case TSqlParser::MAX_QUEUE_READERS:
      case TSqlParser::MAX_ROLLOVER_FILES:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MAXSIZE:
      case TSqlParser::MB:
      case TSqlParser::MEDIUM:
      case TSqlParser::MEMORY_OPTIMIZED_DATA:
      case TSqlParser::MESSAGE:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MIN_CPU_PERCENT:
      case TSqlParser::MIN_IOPS_PER_VOLUME:
      case TSqlParser::MIN_MEMORY_PERCENT:
      case TSqlParser::MINUTES:
      case TSqlParser::MIRROR_ADDRESS:
      case TSqlParser::MIXED_PAGE_ALLOCATION:
      case TSqlParser::MODE:
      case TSqlParser::MODIFY:
      case TSqlParser::MOVE:
      case TSqlParser::MULTI_USER:
      case TSqlParser::NAME:
      case TSqlParser::NESTED_TRIGGERS:
      case TSqlParser::NEW_ACCOUNT:
      case TSqlParser::NEW_BROKER:
      case TSqlParser::NEW_PASSWORD:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NO_TRUNCATE:
      case TSqlParser::NO_WAIT:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NON_TRANSACTED_ACCESS:
      case TSqlParser::NORECOMPUTE:
      case TSqlParser::NORECOVERY:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMBER:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFLINE:
      case TSqlParser::OFFSET:
      case TSqlParser::OLD_ACCOUNT:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPEN_EXISTING:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PAGE_VERIFY:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PARTNER:
      case TSqlParser::PATH:
      case TSqlParser::POISON_MESSAGE_HANDLING:
      case TSqlParser::POOL:
      case TSqlParser::PORT:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIMARY_ROLE:
      case TSqlParser::PRIOR:
      case TSqlParser::PRIORITY:
      case TSqlParser::PRIORITY_LEVEL:
      case TSqlParser::PRIVATE:
      case TSqlParser::PRIVATE_KEY:
      case TSqlParser::PRIVILEGES:
      case TSqlParser::PROCEDURE_NAME:
      case TSqlParser::PROPERTY:
      case TSqlParser::PROVIDER:
      case TSqlParser::PROVIDER_KEY_NAME:
      case TSqlParser::QUERY:
      case TSqlParser::QUEUE:
      case TSqlParser::QUEUE_DELAY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_COMMITTED_SNAPSHOT:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READ_ONLY_ROUTING_LIST:
      case TSqlParser::READ_WRITE:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECEIVE:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RECOVERY:
      case TSqlParser::RECURSIVE_TRIGGERS:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REMOTE_SERVICE_NAME:
      case TSqlParser::REMOVE:
      case TSqlParser::REORGANIZE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::REPLICA:
      case TSqlParser::REQUEST_MAX_CPU_TIME_SEC:
      case TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT:
      case TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC:
      case TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT:
      case TSqlParser::RESERVE_DISK_SPACE:
      case TSqlParser::RESOURCE:
      case TSqlParser::RESOURCE_MANAGER_LOCATION:
      case TSqlParser::RESTRICTED_USER:
      case TSqlParser::RETENTION:
      case TSqlParser::ROBUST:
      case TSqlParser::ROOT:
      case TSqlParser::ROUTE:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SAMPLE:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCOPED:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SEARCH:
      case TSqlParser::SECONDARY:
      case TSqlParser::SECONDARY_ONLY:
      case TSqlParser::SECONDARY_ROLE:
      case TSqlParser::SECONDS:
      case TSqlParser::SECRET:
      case TSqlParser::SECURITY:
      case TSqlParser::SECURITY_LOG:
      case TSqlParser::SEEDING_MODE:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEND:
      case TSqlParser::SENT:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SESSION_TIMEOUT:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SHOWPLAN:
      case TSqlParser::SIGNATURE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SINGLE_USER:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STANDBY:
      case TSqlParser::START_DATE:
      case TSqlParser::STATIC:
      case TSqlParser::STATS_STREAM:
      case TSqlParser::STATUS:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STOPLIST:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBJECT:
      case TSqlParser::SUM:
      case TSqlParser::SUSPEND:
      case TSqlParser::SYMMETRIC:
      case TSqlParser::SYNCHRONOUS_COMMIT:
      case TSqlParser::SYNONYM:
      case TSqlParser::SYSTEM:
      case TSqlParser::TAKE:
      case TSqlParser::TARGET_RECOVERY_TIME:
      case TSqlParser::TB:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TIMER:
      case TSqlParser::TINYINT:
      case TSqlParser::TORN_PAGE_DETECTION:
      case TSqlParser::TRANSFORM_NOISE_WORDS:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRUSTWORTHY:
      case TSqlParser::TRY:
      case TSqlParser::TSQL:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UNLIMITED:
      case TSqlParser::USING:
      case TSqlParser::VALID_XML:
      case TSqlParser::VALIDATION:
      case TSqlParser::VALUE:
      case TSqlParser::VAR:
      case TSqlParser::VARP:
      case TSqlParser::VIEW_METADATA:
      case TSqlParser::VIEWS:
      case TSqlParser::WAIT:
      case TSqlParser::WELL_FORMED_XML:
      case TSqlParser::WORK:
      case TSqlParser::WORKLOAD:
      case TSqlParser::XML:
      case TSqlParser::XMLNAMESPACES:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(4751);
        simple_id();
        break;
      }

      case TSqlParser::DOUBLE_QUOTE_ID: {
        enterOuterAlt(_localctx, 2);
        setState(4752);
        match(TSqlParser::DOUBLE_QUOTE_ID);
        break;
      }

      case TSqlParser::SQUARE_BRACKET_ID: {
        enterOuterAlt(_localctx, 3);
        setState(4753);
        match(TSqlParser::SQUARE_BRACKET_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_idContext ------------------------------------------------------------------

TSqlParser::Simple_idContext::Simple_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Simple_idContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ABSOLUTE() {
  return getToken(TSqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ACCENT_SENSITIVITY() {
  return getToken(TSqlParser::ACCENT_SENSITIVITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ACTION() {
  return getToken(TSqlParser::ACTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ACTIVATION() {
  return getToken(TSqlParser::ACTIVATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ACTIVE() {
  return getToken(TSqlParser::ACTIVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ADDRESS() {
  return getToken(TSqlParser::ADDRESS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AES_128() {
  return getToken(TSqlParser::AES_128, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AES_192() {
  return getToken(TSqlParser::AES_192, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AES_256() {
  return getToken(TSqlParser::AES_256, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AFFINITY() {
  return getToken(TSqlParser::AFFINITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AFTER() {
  return getToken(TSqlParser::AFTER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AGGREGATE() {
  return getToken(TSqlParser::AGGREGATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ALGORITHM() {
  return getToken(TSqlParser::ALGORITHM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS() {
  return getToken(TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ALLOW_SNAPSHOT_ISOLATION() {
  return getToken(TSqlParser::ALLOW_SNAPSHOT_ISOLATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ALLOWED() {
  return getToken(TSqlParser::ALLOWED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ANSI_NULL_DEFAULT() {
  return getToken(TSqlParser::ANSI_NULL_DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ANSI_NULLS() {
  return getToken(TSqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ANSI_PADDING() {
  return getToken(TSqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ANSI_WARNINGS() {
  return getToken(TSqlParser::ANSI_WARNINGS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::APPLICATION_LOG() {
  return getToken(TSqlParser::APPLICATION_LOG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::APPLY() {
  return getToken(TSqlParser::APPLY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ARITHABORT() {
  return getToken(TSqlParser::ARITHABORT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ASSEMBLY() {
  return getToken(TSqlParser::ASSEMBLY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUDIT() {
  return getToken(TSqlParser::AUDIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUDIT_GUID() {
  return getToken(TSqlParser::AUDIT_GUID, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUTO() {
  return getToken(TSqlParser::AUTO, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUTO_CLEANUP() {
  return getToken(TSqlParser::AUTO_CLEANUP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUTO_CLOSE() {
  return getToken(TSqlParser::AUTO_CLOSE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUTO_CREATE_STATISTICS() {
  return getToken(TSqlParser::AUTO_CREATE_STATISTICS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUTO_SHRINK() {
  return getToken(TSqlParser::AUTO_SHRINK, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUTO_UPDATE_STATISTICS() {
  return getToken(TSqlParser::AUTO_UPDATE_STATISTICS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AUTO_UPDATE_STATISTICS_ASYNC() {
  return getToken(TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AVAILABILITY() {
  return getToken(TSqlParser::AVAILABILITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::AVG() {
  return getToken(TSqlParser::AVG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BACKUP_PRIORITY() {
  return getToken(TSqlParser::BACKUP_PRIORITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BEGIN_DIALOG() {
  return getToken(TSqlParser::BEGIN_DIALOG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BIGINT() {
  return getToken(TSqlParser::BIGINT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BINARY_BASE64() {
  return getToken(TSqlParser::BINARY_BASE64, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BINDING() {
  return getToken(TSqlParser::BINDING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BLOB_STORAGE() {
  return getToken(TSqlParser::BLOB_STORAGE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BROKER() {
  return getToken(TSqlParser::BROKER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BROKER_INSTANCE() {
  return getToken(TSqlParser::BROKER_INSTANCE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::BULK_LOGGED() {
  return getToken(TSqlParser::BULK_LOGGED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CALLED() {
  return getToken(TSqlParser::CALLED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CALLER() {
  return getToken(TSqlParser::CALLER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CAP_CPU_PERCENT() {
  return getToken(TSqlParser::CAP_CPU_PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CAST() {
  return getToken(TSqlParser::CAST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CATALOG() {
  return getToken(TSqlParser::CATALOG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CATCH() {
  return getToken(TSqlParser::CATCH, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CHANGE_RETENTION() {
  return getToken(TSqlParser::CHANGE_RETENTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CHANGE_TRACKING() {
  return getToken(TSqlParser::CHANGE_TRACKING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CHECKSUM_AGG() {
  return getToken(TSqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CLEANUP() {
  return getToken(TSqlParser::CLEANUP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COLLECTION() {
  return getToken(TSqlParser::COLLECTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COLUMN_MASTER_KEY() {
  return getToken(TSqlParser::COLUMN_MASTER_KEY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COMMITTED() {
  return getToken(TSqlParser::COMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COMPATIBILITY_LEVEL() {
  return getToken(TSqlParser::COMPATIBILITY_LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CONCAT() {
  return getToken(TSqlParser::CONCAT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CONCAT_NULL_YIELDS_NULL() {
  return getToken(TSqlParser::CONCAT_NULL_YIELDS_NULL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CONTENT() {
  return getToken(TSqlParser::CONTENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CONTROL() {
  return getToken(TSqlParser::CONTROL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COOKIE() {
  return getToken(TSqlParser::COOKIE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COUNT() {
  return getToken(TSqlParser::COUNT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COUNT_BIG() {
  return getToken(TSqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::COUNTER() {
  return getToken(TSqlParser::COUNTER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CPU() {
  return getToken(TSqlParser::CPU, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CREATE_NEW() {
  return getToken(TSqlParser::CREATE_NEW, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CREATION_DISPOSITION() {
  return getToken(TSqlParser::CREATION_DISPOSITION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CREDENTIAL() {
  return getToken(TSqlParser::CREDENTIAL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CRYPTOGRAPHIC() {
  return getToken(TSqlParser::CRYPTOGRAPHIC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::CURSOR_DEFAULT() {
  return getToken(TSqlParser::CURSOR_DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DATA() {
  return getToken(TSqlParser::DATA, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DATA_COMPRESSION() {
  return getToken(TSqlParser::DATA_COMPRESSION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DATE_CORRELATION_OPTIMIZATION() {
  return getToken(TSqlParser::DATE_CORRELATION_OPTIMIZATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DATEADD() {
  return getToken(TSqlParser::DATEADD, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DATEDIFF() {
  return getToken(TSqlParser::DATEDIFF, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DATENAME() {
  return getToken(TSqlParser::DATENAME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DATEPART() {
  return getToken(TSqlParser::DATEPART, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DAYS() {
  return getToken(TSqlParser::DAYS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DB_CHAINING() {
  return getToken(TSqlParser::DB_CHAINING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DB_FAILOVER() {
  return getToken(TSqlParser::DB_FAILOVER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DECRYPTION() {
  return getToken(TSqlParser::DECRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DEFAULT_DOUBLE_QUOTE() {
  return getToken(TSqlParser::DEFAULT_DOUBLE_QUOTE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DEFAULT_FULLTEXT_LANGUAGE() {
  return getToken(TSqlParser::DEFAULT_FULLTEXT_LANGUAGE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DEFAULT_LANGUAGE() {
  return getToken(TSqlParser::DEFAULT_LANGUAGE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DELAY() {
  return getToken(TSqlParser::DELAY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DELAYED_DURABILITY() {
  return getToken(TSqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DENSE_RANK() {
  return getToken(TSqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DEPENDENTS() {
  return getToken(TSqlParser::DEPENDENTS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DES() {
  return getToken(TSqlParser::DES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DESCRIPTION() {
  return getToken(TSqlParser::DESCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DESX() {
  return getToken(TSqlParser::DESX, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DHCP() {
  return getToken(TSqlParser::DHCP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DIALOG() {
  return getToken(TSqlParser::DIALOG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DIRECTORY_NAME() {
  return getToken(TSqlParser::DIRECTORY_NAME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DISABLE() {
  return getToken(TSqlParser::DISABLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DISABLE_BROKER() {
  return getToken(TSqlParser::DISABLE_BROKER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DISABLED() {
  return getToken(TSqlParser::DISABLED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DISK_DRIVE() {
  return getToken(TSqlParser::DISK_DRIVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DOCUMENT() {
  return getToken(TSqlParser::DOCUMENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::DYNAMIC() {
  return getToken(TSqlParser::DYNAMIC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EMERGENCY() {
  return getToken(TSqlParser::EMERGENCY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EMPTY() {
  return getToken(TSqlParser::EMPTY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ENABLE() {
  return getToken(TSqlParser::ENABLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ENABLE_BROKER() {
  return getToken(TSqlParser::ENABLE_BROKER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ENCRYPTED_VALUE() {
  return getToken(TSqlParser::ENCRYPTED_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ENDPOINT_URL() {
  return getToken(TSqlParser::ENDPOINT_URL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ERROR_BROKER_CONVERSATIONS() {
  return getToken(TSqlParser::ERROR_BROKER_CONVERSATIONS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EVENTDATA() {
  return getToken(TSqlParser::EVENTDATA, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EXCLUSIVE() {
  return getToken(TSqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EXECUTABLE() {
  return getToken(TSqlParser::EXECUTABLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EXIST() {
  return getToken(TSqlParser::EXIST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EXPAND() {
  return getToken(TSqlParser::EXPAND, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EXPIRY_DATE() {
  return getToken(TSqlParser::EXPIRY_DATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::EXPLICIT() {
  return getToken(TSqlParser::EXPLICIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FAIL_OPERATION() {
  return getToken(TSqlParser::FAIL_OPERATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FAILOVER_MODE() {
  return getToken(TSqlParser::FAILOVER_MODE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FAILURE() {
  return getToken(TSqlParser::FAILURE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FAILURE_CONDITION_LEVEL() {
  return getToken(TSqlParser::FAILURE_CONDITION_LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FAST() {
  return getToken(TSqlParser::FAST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FAST_FORWARD() {
  return getToken(TSqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FILEGROUP() {
  return getToken(TSqlParser::FILEGROUP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FILEGROWTH() {
  return getToken(TSqlParser::FILEGROWTH, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FILENAME() {
  return getToken(TSqlParser::FILENAME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FILEPATH() {
  return getToken(TSqlParser::FILEPATH, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FILESTREAM() {
  return getToken(TSqlParser::FILESTREAM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FILLFACTOR() {
  return getToken(TSqlParser::FILLFACTOR, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FILTER() {
  return getToken(TSqlParser::FILTER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FIRST_VALUE() {
  return getToken(TSqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FOLLOWING() {
  return getToken(TSqlParser::FOLLOWING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FORCE() {
  return getToken(TSqlParser::FORCE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FORCE_FAILOVER_ALLOW_DATA_LOSS() {
  return getToken(TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FORCED() {
  return getToken(TSqlParser::FORCED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FORCESEEK() {
  return getToken(TSqlParser::FORCESEEK, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FORMAT() {
  return getToken(TSqlParser::FORMAT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FORWARD_ONLY() {
  return getToken(TSqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FULLSCAN() {
  return getToken(TSqlParser::FULLSCAN, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::FULLTEXT() {
  return getToken(TSqlParser::FULLTEXT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GB() {
  return getToken(TSqlParser::GB, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GETDATE() {
  return getToken(TSqlParser::GETDATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GETUTCDATE() {
  return getToken(TSqlParser::GETUTCDATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GO() {
  return getToken(TSqlParser::GO, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GROUP_MAX_REQUESTS() {
  return getToken(TSqlParser::GROUP_MAX_REQUESTS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GROUPING() {
  return getToken(TSqlParser::GROUPING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::GROUPING_ID() {
  return getToken(TSqlParser::GROUPING_ID, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::HADR() {
  return getToken(TSqlParser::HADR, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::HEALTH_CHECK_TIMEOUT() {
  return getToken(TSqlParser::HEALTH_CHECK_TIMEOUT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::HIGH() {
  return getToken(TSqlParser::HIGH, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::HONOR_BROKER_PRIORITY() {
  return getToken(TSqlParser::HONOR_BROKER_PRIORITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::HOURS() {
  return getToken(TSqlParser::HOURS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::IDENTITY_VALUE() {
  return getToken(TSqlParser::IDENTITY_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX() {
  return getToken(TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::IMMEDIATE() {
  return getToken(TSqlParser::IMMEDIATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::IMPERSONATE() {
  return getToken(TSqlParser::IMPERSONATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::IMPORTANCE() {
  return getToken(TSqlParser::IMPORTANCE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::INCREMENTAL() {
  return getToken(TSqlParser::INCREMENTAL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::INIT() {
  return getToken(TSqlParser::INIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::INITIATOR() {
  return getToken(TSqlParser::INITIATOR, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::INPUT() {
  return getToken(TSqlParser::INPUT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::INSENSITIVE() {
  return getToken(TSqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::INT() {
  return getToken(TSqlParser::INT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::IP() {
  return getToken(TSqlParser::IP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ISOLATION() {
  return getToken(TSqlParser::ISOLATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::KB() {
  return getToken(TSqlParser::KB, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::KEEP() {
  return getToken(TSqlParser::KEEP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::KEEPFIXED() {
  return getToken(TSqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::KEY_SOURCE() {
  return getToken(TSqlParser::KEY_SOURCE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::KEYS() {
  return getToken(TSqlParser::KEYS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::KEYSET() {
  return getToken(TSqlParser::KEYSET, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LAG() {
  return getToken(TSqlParser::LAG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LAST() {
  return getToken(TSqlParser::LAST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LAST_VALUE() {
  return getToken(TSqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LEAD() {
  return getToken(TSqlParser::LEAD, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LEVEL() {
  return getToken(TSqlParser::LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LIST() {
  return getToken(TSqlParser::LIST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LISTENER() {
  return getToken(TSqlParser::LISTENER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LISTENER_URL() {
  return getToken(TSqlParser::LISTENER_URL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOB_COMPACTION() {
  return getToken(TSqlParser::LOB_COMPACTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOCATION() {
  return getToken(TSqlParser::LOCATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOCK_ESCALATION() {
  return getToken(TSqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOGIN() {
  return getToken(TSqlParser::LOGIN, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::LOW() {
  return getToken(TSqlParser::LOW, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MANUAL() {
  return getToken(TSqlParser::MANUAL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MARK() {
  return getToken(TSqlParser::MARK, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MASTER() {
  return getToken(TSqlParser::MASTER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MATERIALIZED() {
  return getToken(TSqlParser::MATERIALIZED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_CPU_PERCENT() {
  return getToken(TSqlParser::MAX_CPU_PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_DOP() {
  return getToken(TSqlParser::MAX_DOP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_FILES() {
  return getToken(TSqlParser::MAX_FILES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_IOPS_PER_VOLUME() {
  return getToken(TSqlParser::MAX_IOPS_PER_VOLUME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_MEMORY() {
  return getToken(TSqlParser::MAX_MEMORY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_MEMORY_PERCENT() {
  return getToken(TSqlParser::MAX_MEMORY_PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_PROCESSES() {
  return getToken(TSqlParser::MAX_PROCESSES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_QUEUE_READERS() {
  return getToken(TSqlParser::MAX_QUEUE_READERS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAX_ROLLOVER_FILES() {
  return getToken(TSqlParser::MAX_ROLLOVER_FILES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAXDOP() {
  return getToken(TSqlParser::MAXDOP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAXRECURSION() {
  return getToken(TSqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MAXSIZE() {
  return getToken(TSqlParser::MAXSIZE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MB() {
  return getToken(TSqlParser::MB, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MEDIUM() {
  return getToken(TSqlParser::MEDIUM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MEMORY_OPTIMIZED_DATA() {
  return getToken(TSqlParser::MEMORY_OPTIMIZED_DATA, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MESSAGE() {
  return getToken(TSqlParser::MESSAGE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MIN() {
  return getToken(TSqlParser::MIN, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MIN_ACTIVE_ROWVERSION() {
  return getToken(TSqlParser::MIN_ACTIVE_ROWVERSION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MIN_CPU_PERCENT() {
  return getToken(TSqlParser::MIN_CPU_PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MIN_IOPS_PER_VOLUME() {
  return getToken(TSqlParser::MIN_IOPS_PER_VOLUME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MIN_MEMORY_PERCENT() {
  return getToken(TSqlParser::MIN_MEMORY_PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MINUTES() {
  return getToken(TSqlParser::MINUTES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MIRROR_ADDRESS() {
  return getToken(TSqlParser::MIRROR_ADDRESS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MIXED_PAGE_ALLOCATION() {
  return getToken(TSqlParser::MIXED_PAGE_ALLOCATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MODE() {
  return getToken(TSqlParser::MODE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MODIFY() {
  return getToken(TSqlParser::MODIFY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MOVE() {
  return getToken(TSqlParser::MOVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::MULTI_USER() {
  return getToken(TSqlParser::MULTI_USER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NAME() {
  return getToken(TSqlParser::NAME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NESTED_TRIGGERS() {
  return getToken(TSqlParser::NESTED_TRIGGERS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NEW_ACCOUNT() {
  return getToken(TSqlParser::NEW_ACCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NEW_BROKER() {
  return getToken(TSqlParser::NEW_BROKER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NEW_PASSWORD() {
  return getToken(TSqlParser::NEW_PASSWORD, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NO() {
  return getToken(TSqlParser::NO, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NO_TRUNCATE() {
  return getToken(TSqlParser::NO_TRUNCATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NO_WAIT() {
  return getToken(TSqlParser::NO_WAIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NOCOUNT() {
  return getToken(TSqlParser::NOCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NODES() {
  return getToken(TSqlParser::NODES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NOEXPAND() {
  return getToken(TSqlParser::NOEXPAND, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NON_TRANSACTED_ACCESS() {
  return getToken(TSqlParser::NON_TRANSACTED_ACCESS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NORECOMPUTE() {
  return getToken(TSqlParser::NORECOMPUTE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NORECOVERY() {
  return getToken(TSqlParser::NORECOVERY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NTILE() {
  return getToken(TSqlParser::NTILE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NUMANODE() {
  return getToken(TSqlParser::NUMANODE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NUMBER() {
  return getToken(TSqlParser::NUMBER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::NUMERIC_ROUNDABORT() {
  return getToken(TSqlParser::NUMERIC_ROUNDABORT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OFFLINE() {
  return getToken(TSqlParser::OFFLINE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OFFSET() {
  return getToken(TSqlParser::OFFSET, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OFFSETS() {
  return getToken(TSqlParser::OFFSETS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OLD_ACCOUNT() {
  return getToken(TSqlParser::OLD_ACCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ONLINE() {
  return getToken(TSqlParser::ONLINE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OPEN_EXISTING() {
  return getToken(TSqlParser::OPEN_EXISTING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OPTIMISTIC() {
  return getToken(TSqlParser::OPTIMISTIC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OPTIMIZE() {
  return getToken(TSqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::OWNER() {
  return getToken(TSqlParser::OWNER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PAGE() {
  return getToken(TSqlParser::PAGE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PAGE_VERIFY() {
  return getToken(TSqlParser::PAGE_VERIFY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PARAMETERIZATION() {
  return getToken(TSqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PARTITIONS() {
  return getToken(TSqlParser::PARTITIONS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PARTNER() {
  return getToken(TSqlParser::PARTNER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PATH() {
  return getToken(TSqlParser::PATH, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::POISON_MESSAGE_HANDLING() {
  return getToken(TSqlParser::POISON_MESSAGE_HANDLING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::POOL() {
  return getToken(TSqlParser::POOL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PORT() {
  return getToken(TSqlParser::PORT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRECEDING() {
  return getToken(TSqlParser::PRECEDING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRIMARY_ROLE() {
  return getToken(TSqlParser::PRIMARY_ROLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRIOR() {
  return getToken(TSqlParser::PRIOR, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRIORITY() {
  return getToken(TSqlParser::PRIORITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRIORITY_LEVEL() {
  return getToken(TSqlParser::PRIORITY_LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRIVATE() {
  return getToken(TSqlParser::PRIVATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRIVATE_KEY() {
  return getToken(TSqlParser::PRIVATE_KEY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PRIVILEGES() {
  return getToken(TSqlParser::PRIVILEGES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PROCEDURE_NAME() {
  return getToken(TSqlParser::PROCEDURE_NAME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PROPERTY() {
  return getToken(TSqlParser::PROPERTY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PROVIDER() {
  return getToken(TSqlParser::PROVIDER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PROVIDER_KEY_NAME() {
  return getToken(TSqlParser::PROVIDER_KEY_NAME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::PUBLIC() {
  return getToken(TSqlParser::PUBLIC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::QUERY() {
  return getToken(TSqlParser::QUERY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::QUEUE() {
  return getToken(TSqlParser::QUEUE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::QUEUE_DELAY() {
  return getToken(TSqlParser::QUEUE_DELAY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::QUOTED_IDENTIFIER() {
  return getToken(TSqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::R() {
  return getToken(TSqlParser::R, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RANGE() {
  return getToken(TSqlParser::RANGE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RANK() {
  return getToken(TSqlParser::RANK, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RAW() {
  return getToken(TSqlParser::RAW, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RC2() {
  return getToken(TSqlParser::RC2, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RC4() {
  return getToken(TSqlParser::RC4, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RC4_128() {
  return getToken(TSqlParser::RC4_128, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::READ_COMMITTED_SNAPSHOT() {
  return getToken(TSqlParser::READ_COMMITTED_SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::READ_ONLY() {
  return getToken(TSqlParser::READ_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::READ_ONLY_ROUTING_LIST() {
  return getToken(TSqlParser::READ_ONLY_ROUTING_LIST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::READ_WRITE() {
  return getToken(TSqlParser::READ_WRITE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::READONLY() {
  return getToken(TSqlParser::READONLY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REBUILD() {
  return getToken(TSqlParser::REBUILD, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RECEIVE() {
  return getToken(TSqlParser::RECEIVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RECOVERY() {
  return getToken(TSqlParser::RECOVERY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RECURSIVE_TRIGGERS() {
  return getToken(TSqlParser::RECURSIVE_TRIGGERS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RELATIVE() {
  return getToken(TSqlParser::RELATIVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REMOTE() {
  return getToken(TSqlParser::REMOTE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REMOTE_SERVICE_NAME() {
  return getToken(TSqlParser::REMOTE_SERVICE_NAME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REMOVE() {
  return getToken(TSqlParser::REMOVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REORGANIZE() {
  return getToken(TSqlParser::REORGANIZE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REPEATABLE() {
  return getToken(TSqlParser::REPEATABLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REPLICA() {
  return getToken(TSqlParser::REPLICA, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REQUEST_MAX_CPU_TIME_SEC() {
  return getToken(TSqlParser::REQUEST_MAX_CPU_TIME_SEC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REQUEST_MAX_MEMORY_GRANT_PERCENT() {
  return getToken(TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REQUEST_MEMORY_GRANT_TIMEOUT_SEC() {
  return getToken(TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT() {
  return getToken(TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RESERVE_DISK_SPACE() {
  return getToken(TSqlParser::RESERVE_DISK_SPACE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RESOURCE() {
  return getToken(TSqlParser::RESOURCE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RESOURCE_MANAGER_LOCATION() {
  return getToken(TSqlParser::RESOURCE_MANAGER_LOCATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RESTRICTED_USER() {
  return getToken(TSqlParser::RESTRICTED_USER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RETENTION() {
  return getToken(TSqlParser::RETENTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROBUST() {
  return getToken(TSqlParser::ROBUST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROOT() {
  return getToken(TSqlParser::ROOT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROUTE() {
  return getToken(TSqlParser::ROUTE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROW_NUMBER() {
  return getToken(TSqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROWCOUNT() {
  return getToken(TSqlParser::ROWCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROWGUID() {
  return getToken(TSqlParser::ROWGUID, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::ROWS() {
  return getToken(TSqlParser::ROWS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SAFETY() {
  return getToken(TSqlParser::SAFETY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SAMPLE() {
  return getToken(TSqlParser::SAMPLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SCHEMABINDING() {
  return getToken(TSqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SCOPED() {
  return getToken(TSqlParser::SCOPED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SCROLL_LOCKS() {
  return getToken(TSqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SEARCH() {
  return getToken(TSqlParser::SEARCH, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SECONDARY() {
  return getToken(TSqlParser::SECONDARY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SECONDARY_ONLY() {
  return getToken(TSqlParser::SECONDARY_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SECONDARY_ROLE() {
  return getToken(TSqlParser::SECONDARY_ROLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SECONDS() {
  return getToken(TSqlParser::SECONDS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SECRET() {
  return getToken(TSqlParser::SECRET, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SECURITY() {
  return getToken(TSqlParser::SECURITY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SECURITY_LOG() {
  return getToken(TSqlParser::SECURITY_LOG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SEEDING_MODE() {
  return getToken(TSqlParser::SEEDING_MODE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SELF() {
  return getToken(TSqlParser::SELF, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SEMI_SENSITIVE() {
  return getToken(TSqlParser::SEMI_SENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SEND() {
  return getToken(TSqlParser::SEND, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SENT() {
  return getToken(TSqlParser::SENT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SEQUENCE() {
  return getToken(TSqlParser::SEQUENCE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SERVER() {
  return getToken(TSqlParser::SERVER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SESSION_TIMEOUT() {
  return getToken(TSqlParser::SESSION_TIMEOUT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SETERROR() {
  return getToken(TSqlParser::SETERROR, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SHARE() {
  return getToken(TSqlParser::SHARE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SHOWPLAN() {
  return getToken(TSqlParser::SHOWPLAN, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SID() {
  return getToken(TSqlParser::SID, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SIGNATURE() {
  return getToken(TSqlParser::SIGNATURE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SIMPLE() {
  return getToken(TSqlParser::SIMPLE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SINGLE_USER() {
  return getToken(TSqlParser::SINGLE_USER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SIZE() {
  return getToken(TSqlParser::SIZE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SMALLINT() {
  return getToken(TSqlParser::SMALLINT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SOURCE() {
  return getToken(TSqlParser::SOURCE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(TSqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SPLIT() {
  return getToken(TSqlParser::SPLIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STANDBY() {
  return getToken(TSqlParser::STANDBY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::START() {
  return getToken(TSqlParser::START, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::START_DATE() {
  return getToken(TSqlParser::START_DATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STATE() {
  return getToken(TSqlParser::STATE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STATIC() {
  return getToken(TSqlParser::STATIC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STATS_STREAM() {
  return getToken(TSqlParser::STATS_STREAM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STATUS() {
  return getToken(TSqlParser::STATUS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STDEV() {
  return getToken(TSqlParser::STDEV, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STDEVP() {
  return getToken(TSqlParser::STDEVP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STOPLIST() {
  return getToken(TSqlParser::STOPLIST, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STRING_AGG() {
  return getToken(TSqlParser::STRING_AGG, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::STUFF() {
  return getToken(TSqlParser::STUFF, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SUBJECT() {
  return getToken(TSqlParser::SUBJECT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SUM() {
  return getToken(TSqlParser::SUM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SUSPEND() {
  return getToken(TSqlParser::SUSPEND, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SYMMETRIC() {
  return getToken(TSqlParser::SYMMETRIC, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SYNCHRONOUS_COMMIT() {
  return getToken(TSqlParser::SYNCHRONOUS_COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SYNONYM() {
  return getToken(TSqlParser::SYNONYM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::SYSTEM() {
  return getToken(TSqlParser::SYSTEM, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TAKE() {
  return getToken(TSqlParser::TAKE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TARGET() {
  return getToken(TSqlParser::TARGET, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TARGET_RECOVERY_TIME() {
  return getToken(TSqlParser::TARGET_RECOVERY_TIME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TB() {
  return getToken(TSqlParser::TB, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TEXTIMAGE_ON() {
  return getToken(TSqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::THROW() {
  return getToken(TSqlParser::THROW, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TIES() {
  return getToken(TSqlParser::TIES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TIMER() {
  return getToken(TSqlParser::TIMER, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TINYINT() {
  return getToken(TSqlParser::TINYINT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TORN_PAGE_DETECTION() {
  return getToken(TSqlParser::TORN_PAGE_DETECTION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TRANSFORM_NOISE_WORDS() {
  return getToken(TSqlParser::TRANSFORM_NOISE_WORDS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TRIPLE_DES() {
  return getToken(TSqlParser::TRIPLE_DES, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TRIPLE_DES_3KEY() {
  return getToken(TSqlParser::TRIPLE_DES_3KEY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TRUSTWORTHY() {
  return getToken(TSqlParser::TRUSTWORTHY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TRY() {
  return getToken(TSqlParser::TRY, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TSQL() {
  return getToken(TSqlParser::TSQL, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TWO_DIGIT_YEAR_CUTOFF() {
  return getToken(TSqlParser::TWO_DIGIT_YEAR_CUTOFF, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::TYPE_WARNING() {
  return getToken(TSqlParser::TYPE_WARNING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::UNCOMMITTED() {
  return getToken(TSqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::UNLIMITED() {
  return getToken(TSqlParser::UNLIMITED, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::USING() {
  return getToken(TSqlParser::USING, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::VALID_XML() {
  return getToken(TSqlParser::VALID_XML, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::VALIDATION() {
  return getToken(TSqlParser::VALIDATION, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::VALUE() {
  return getToken(TSqlParser::VALUE, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::VAR() {
  return getToken(TSqlParser::VAR, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::VARP() {
  return getToken(TSqlParser::VARP, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::VIEW_METADATA() {
  return getToken(TSqlParser::VIEW_METADATA, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::VIEWS() {
  return getToken(TSqlParser::VIEWS, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::WAIT() {
  return getToken(TSqlParser::WAIT, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::WELL_FORMED_XML() {
  return getToken(TSqlParser::WELL_FORMED_XML, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::WORK() {
  return getToken(TSqlParser::WORK, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::WORKLOAD() {
  return getToken(TSqlParser::WORKLOAD, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::XML() {
  return getToken(TSqlParser::XML, 0);
}

tree::TerminalNode* TSqlParser::Simple_idContext::XMLNAMESPACES() {
  return getToken(TSqlParser::XMLNAMESPACES, 0);
}


size_t TSqlParser::Simple_idContext::getRuleIndex() const {
  return TSqlParser::RuleSimple_id;
}

void TSqlParser::Simple_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_id(this);
}

void TSqlParser::Simple_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_id(this);
}

TSqlParser::Simple_idContext* TSqlParser::simple_id() {
  Simple_idContext *_localctx = _tracker.createInstance<Simple_idContext>(_ctx, getState());
  enterRule(_localctx, 500, TSqlParser::RuleSimple_id);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4756);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::CALLED || ((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::DATA_COMPRESSION - 85))
      | (1ULL << (TSqlParser::EVENTDATA - 85))
      | (1ULL << (TSqlParser::FILENAME - 85))
      | (1ULL << (TSqlParser::FILLFACTOR - 85))
      | (1ULL << (TSqlParser::FORCESEEK - 85)))) != 0) || ((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & ((1ULL << (TSqlParser::INIT - 164))
      | (1ULL << (TSqlParser::KEY - 164))
      | (1ULL << (TSqlParser::MASTER - 164))
      | (1ULL << (TSqlParser::MAX_MEMORY - 164)))) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & ((1ULL << (TSqlParser::OFFSETS - 238))
      | (1ULL << (TSqlParser::PAGE - 238))
      | (1ULL << (TSqlParser::PUBLIC - 238))
      | (1ULL << (TSqlParser::R - 238))
      | (1ULL << (TSqlParser::RAW - 238))
      | (1ULL << (TSqlParser::RETURN - 238))
      | (1ULL << (TSqlParser::RETURNS - 238)))) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 305)) & ((1ULL << (TSqlParser::ROWCOUNT - 305))
      | (1ULL << (TSqlParser::SAFETY - 305))
      | (1ULL << (TSqlParser::SERVER - 305))
      | (1ULL << (TSqlParser::SID - 305))
      | (1ULL << (TSqlParser::SOURCE - 305))
      | (1ULL << (TSqlParser::SPLIT - 305))
      | (1ULL << (TSqlParser::STATE - 305))
      | (1ULL << (TSqlParser::START - 305))
      | (1ULL << (TSqlParser::TARGET - 305)))) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 405)) & ((1ULL << (TSqlParser::ABSOLUTE - 405))
      | (1ULL << (TSqlParser::ACCENT_SENSITIVITY - 405))
      | (1ULL << (TSqlParser::ACTION - 405))
      | (1ULL << (TSqlParser::ACTIVATION - 405))
      | (1ULL << (TSqlParser::ACTIVE - 405))
      | (1ULL << (TSqlParser::ADDRESS - 405))
      | (1ULL << (TSqlParser::AES_128 - 405))
      | (1ULL << (TSqlParser::AES_192 - 405))
      | (1ULL << (TSqlParser::AES_256 - 405))
      | (1ULL << (TSqlParser::AFFINITY - 405))
      | (1ULL << (TSqlParser::AFTER - 405))
      | (1ULL << (TSqlParser::AGGREGATE - 405))
      | (1ULL << (TSqlParser::ALGORITHM - 405))
      | (1ULL << (TSqlParser::ALLOW_ENCRYPTED_VALUE_MODIFICATIONS - 405))
      | (1ULL << (TSqlParser::ALLOW_SNAPSHOT_ISOLATION - 405))
      | (1ULL << (TSqlParser::ALLOWED - 405))
      | (1ULL << (TSqlParser::ANSI_NULL_DEFAULT - 405))
      | (1ULL << (TSqlParser::ANSI_NULLS - 405))
      | (1ULL << (TSqlParser::ANSI_PADDING - 405))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 405))
      | (1ULL << (TSqlParser::APPLICATION_LOG - 405))
      | (1ULL << (TSqlParser::APPLY - 405))
      | (1ULL << (TSqlParser::ARITHABORT - 405))
      | (1ULL << (TSqlParser::ASSEMBLY - 405))
      | (1ULL << (TSqlParser::AUDIT - 405))
      | (1ULL << (TSqlParser::AUDIT_GUID - 405))
      | (1ULL << (TSqlParser::AUTO - 405))
      | (1ULL << (TSqlParser::AUTO_CLEANUP - 405))
      | (1ULL << (TSqlParser::AUTO_CLOSE - 405))
      | (1ULL << (TSqlParser::AUTO_CREATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_SHRINK - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS - 405))
      | (1ULL << (TSqlParser::AUTO_UPDATE_STATISTICS_ASYNC - 405))
      | (1ULL << (TSqlParser::AVAILABILITY - 405))
      | (1ULL << (TSqlParser::AVG - 405))
      | (1ULL << (TSqlParser::BACKUP_PRIORITY - 405))
      | (1ULL << (TSqlParser::BEGIN_DIALOG - 405))
      | (1ULL << (TSqlParser::BIGINT - 405))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 405))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 405))
      | (1ULL << (TSqlParser::BINDING - 405))
      | (1ULL << (TSqlParser::BLOB_STORAGE - 405))
      | (1ULL << (TSqlParser::BROKER - 405))
      | (1ULL << (TSqlParser::BROKER_INSTANCE - 405))
      | (1ULL << (TSqlParser::BULK_LOGGED - 405))
      | (1ULL << (TSqlParser::CALLER - 405))
      | (1ULL << (TSqlParser::CAP_CPU_PERCENT - 405))
      | (1ULL << (TSqlParser::CAST - 405))
      | (1ULL << (TSqlParser::CATALOG - 405))
      | (1ULL << (TSqlParser::CATCH - 405))
      | (1ULL << (TSqlParser::CHANGE_RETENTION - 405))
      | (1ULL << (TSqlParser::CHANGE_TRACKING - 405))
      | (1ULL << (TSqlParser::CHECKSUM - 405))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 405))
      | (1ULL << (TSqlParser::CLEANUP - 405))
      | (1ULL << (TSqlParser::COLLECTION - 405))
      | (1ULL << (TSqlParser::COLUMN_MASTER_KEY - 405))
      | (1ULL << (TSqlParser::COMMITTED - 405))
      | (1ULL << (TSqlParser::COMPATIBILITY_LEVEL - 405))
      | (1ULL << (TSqlParser::CONCAT - 405))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 405))
      | (1ULL << (TSqlParser::CONTENT - 405))
      | (1ULL << (TSqlParser::CONTROL - 405))
      | (1ULL << (TSqlParser::COOKIE - 405)))) != 0) || ((((_la - 469) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 469)) & ((1ULL << (TSqlParser::COUNT - 469))
      | (1ULL << (TSqlParser::COUNT_BIG - 469))
      | (1ULL << (TSqlParser::COUNTER - 469))
      | (1ULL << (TSqlParser::CPU - 469))
      | (1ULL << (TSqlParser::CREATE_NEW - 469))
      | (1ULL << (TSqlParser::CREATION_DISPOSITION - 469))
      | (1ULL << (TSqlParser::CREDENTIAL - 469))
      | (1ULL << (TSqlParser::CRYPTOGRAPHIC - 469))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 469))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 469))
      | (1ULL << (TSqlParser::DATA - 469))
      | (1ULL << (TSqlParser::DATE_CORRELATION_OPTIMIZATION - 469))
      | (1ULL << (TSqlParser::DATEADD - 469))
      | (1ULL << (TSqlParser::DATEDIFF - 469))
      | (1ULL << (TSqlParser::DATENAME - 469))
      | (1ULL << (TSqlParser::DATEPART - 469))
      | (1ULL << (TSqlParser::DAYS - 469))
      | (1ULL << (TSqlParser::DB_CHAINING - 469))
      | (1ULL << (TSqlParser::DB_FAILOVER - 469))
      | (1ULL << (TSqlParser::DECRYPTION - 469))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 469))
      | (1ULL << (TSqlParser::DEFAULT_FULLTEXT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DEFAULT_LANGUAGE - 469))
      | (1ULL << (TSqlParser::DELAY - 469))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 469))
      | (1ULL << (TSqlParser::DELETED - 469))
      | (1ULL << (TSqlParser::DENSE_RANK - 469))
      | (1ULL << (TSqlParser::DEPENDENTS - 469))
      | (1ULL << (TSqlParser::DES - 469))
      | (1ULL << (TSqlParser::DESCRIPTION - 469))
      | (1ULL << (TSqlParser::DESX - 469))
      | (1ULL << (TSqlParser::DHCP - 469))
      | (1ULL << (TSqlParser::DIALOG - 469))
      | (1ULL << (TSqlParser::DIRECTORY_NAME - 469))
      | (1ULL << (TSqlParser::DISABLE - 469))
      | (1ULL << (TSqlParser::DISABLE_BROKER - 469))
      | (1ULL << (TSqlParser::DISABLED - 469))
      | (1ULL << (TSqlParser::DISK_DRIVE - 469))
      | (1ULL << (TSqlParser::DOCUMENT - 469))
      | (1ULL << (TSqlParser::DYNAMIC - 469))
      | (1ULL << (TSqlParser::EMERGENCY - 469))
      | (1ULL << (TSqlParser::EMPTY - 469))
      | (1ULL << (TSqlParser::ENABLE - 469))
      | (1ULL << (TSqlParser::ENABLE_BROKER - 469))
      | (1ULL << (TSqlParser::ENCRYPTED_VALUE - 469))
      | (1ULL << (TSqlParser::ENCRYPTION - 469))
      | (1ULL << (TSqlParser::ENDPOINT_URL - 469))
      | (1ULL << (TSqlParser::ERROR_BROKER_CONVERSATIONS - 469))
      | (1ULL << (TSqlParser::EXCLUSIVE - 469))
      | (1ULL << (TSqlParser::EXECUTABLE - 469))
      | (1ULL << (TSqlParser::EXIST - 469))
      | (1ULL << (TSqlParser::EXPAND - 469))
      | (1ULL << (TSqlParser::EXPIRY_DATE - 469))
      | (1ULL << (TSqlParser::EXPLICIT - 469))
      | (1ULL << (TSqlParser::FAIL_OPERATION - 469))
      | (1ULL << (TSqlParser::FAILOVER_MODE - 469))
      | (1ULL << (TSqlParser::FAILURE - 469))
      | (1ULL << (TSqlParser::FAILURE_CONDITION_LEVEL - 469))
      | (1ULL << (TSqlParser::FAST - 469))
      | (1ULL << (TSqlParser::FAST_FORWARD - 469))
      | (1ULL << (TSqlParser::FILEGROUP - 469)))) != 0) || ((((_la - 533) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 533)) & ((1ULL << (TSqlParser::FILEGROWTH - 533))
      | (1ULL << (TSqlParser::FILEPATH - 533))
      | (1ULL << (TSqlParser::FILESTREAM - 533))
      | (1ULL << (TSqlParser::FILTER - 533))
      | (1ULL << (TSqlParser::FIRST - 533))
      | (1ULL << (TSqlParser::FIRST_VALUE - 533))
      | (1ULL << (TSqlParser::FOLLOWING - 533))
      | (1ULL << (TSqlParser::FORCE - 533))
      | (1ULL << (TSqlParser::FORCE_FAILOVER_ALLOW_DATA_LOSS - 533))
      | (1ULL << (TSqlParser::FORCED - 533))
      | (1ULL << (TSqlParser::FORMAT - 533))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 533))
      | (1ULL << (TSqlParser::FULLSCAN - 533))
      | (1ULL << (TSqlParser::FULLTEXT - 533))
      | (1ULL << (TSqlParser::GB - 533))
      | (1ULL << (TSqlParser::GETDATE - 533))
      | (1ULL << (TSqlParser::GETUTCDATE - 533))
      | (1ULL << (TSqlParser::GLOBAL - 533))
      | (1ULL << (TSqlParser::GO - 533))
      | (1ULL << (TSqlParser::GROUP_MAX_REQUESTS - 533))
      | (1ULL << (TSqlParser::GROUPING - 533))
      | (1ULL << (TSqlParser::GROUPING_ID - 533))
      | (1ULL << (TSqlParser::HADR - 533))
      | (1ULL << (TSqlParser::HASH - 533))
      | (1ULL << (TSqlParser::HEALTH_CHECK_TIMEOUT - 533))
      | (1ULL << (TSqlParser::HIGH - 533))
      | (1ULL << (TSqlParser::HONOR_BROKER_PRIORITY - 533))
      | (1ULL << (TSqlParser::HOURS - 533))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 533))
      | (1ULL << (TSqlParser::IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX - 533))
      | (1ULL << (TSqlParser::IMMEDIATE - 533))
      | (1ULL << (TSqlParser::IMPERSONATE - 533))
      | (1ULL << (TSqlParser::IMPORTANCE - 533))
      | (1ULL << (TSqlParser::INCREMENTAL - 533))
      | (1ULL << (TSqlParser::INITIATOR - 533))
      | (1ULL << (TSqlParser::INPUT - 533))
      | (1ULL << (TSqlParser::INSENSITIVE - 533))
      | (1ULL << (TSqlParser::INSERTED - 533))
      | (1ULL << (TSqlParser::INT - 533))
      | (1ULL << (TSqlParser::IP - 533))
      | (1ULL << (TSqlParser::ISOLATION - 533))
      | (1ULL << (TSqlParser::KB - 533))
      | (1ULL << (TSqlParser::KEEP - 533))
      | (1ULL << (TSqlParser::KEEPFIXED - 533))
      | (1ULL << (TSqlParser::KEY_SOURCE - 533))
      | (1ULL << (TSqlParser::KEYS - 533))
      | (1ULL << (TSqlParser::KEYSET - 533))
      | (1ULL << (TSqlParser::LAG - 533))
      | (1ULL << (TSqlParser::LAST - 533))
      | (1ULL << (TSqlParser::LAST_VALUE - 533))
      | (1ULL << (TSqlParser::LEAD - 533))
      | (1ULL << (TSqlParser::LEVEL - 533))
      | (1ULL << (TSqlParser::LIST - 533))
      | (1ULL << (TSqlParser::LISTENER - 533))
      | (1ULL << (TSqlParser::LISTENER_URL - 533))
      | (1ULL << (TSqlParser::LOB_COMPACTION - 533))
      | (1ULL << (TSqlParser::LOCAL - 533))
      | (1ULL << (TSqlParser::LOCATION - 533))
      | (1ULL << (TSqlParser::LOCK - 533))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 533))
      | (1ULL << (TSqlParser::LOGIN - 533)))) != 0) || ((((_la - 597) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 597)) & ((1ULL << (TSqlParser::LOOP - 597))
      | (1ULL << (TSqlParser::LOW - 597))
      | (1ULL << (TSqlParser::MANUAL - 597))
      | (1ULL << (TSqlParser::MARK - 597))
      | (1ULL << (TSqlParser::MATERIALIZED - 597))
      | (1ULL << (TSqlParser::MAX - 597))
      | (1ULL << (TSqlParser::MAX_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_DOP - 597))
      | (1ULL << (TSqlParser::MAX_FILES - 597))
      | (1ULL << (TSqlParser::MAX_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MAX_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MAX_PROCESSES - 597))
      | (1ULL << (TSqlParser::MAX_QUEUE_READERS - 597))
      | (1ULL << (TSqlParser::MAX_ROLLOVER_FILES - 597))
      | (1ULL << (TSqlParser::MAXDOP - 597))
      | (1ULL << (TSqlParser::MAXRECURSION - 597))
      | (1ULL << (TSqlParser::MAXSIZE - 597))
      | (1ULL << (TSqlParser::MB - 597))
      | (1ULL << (TSqlParser::MEDIUM - 597))
      | (1ULL << (TSqlParser::MEMORY_OPTIMIZED_DATA - 597))
      | (1ULL << (TSqlParser::MESSAGE - 597))
      | (1ULL << (TSqlParser::MIN - 597))
      | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 597))
      | (1ULL << (TSqlParser::MIN_CPU_PERCENT - 597))
      | (1ULL << (TSqlParser::MIN_IOPS_PER_VOLUME - 597))
      | (1ULL << (TSqlParser::MIN_MEMORY_PERCENT - 597))
      | (1ULL << (TSqlParser::MINUTES - 597))
      | (1ULL << (TSqlParser::MIRROR_ADDRESS - 597))
      | (1ULL << (TSqlParser::MIXED_PAGE_ALLOCATION - 597))
      | (1ULL << (TSqlParser::MODE - 597))
      | (1ULL << (TSqlParser::MODIFY - 597))
      | (1ULL << (TSqlParser::MOVE - 597))
      | (1ULL << (TSqlParser::MULTI_USER - 597))
      | (1ULL << (TSqlParser::NAME - 597))
      | (1ULL << (TSqlParser::NESTED_TRIGGERS - 597))
      | (1ULL << (TSqlParser::NEW_ACCOUNT - 597))
      | (1ULL << (TSqlParser::NEW_BROKER - 597))
      | (1ULL << (TSqlParser::NEW_PASSWORD - 597))
      | (1ULL << (TSqlParser::NEXT - 597))
      | (1ULL << (TSqlParser::NO - 597))
      | (1ULL << (TSqlParser::NO_TRUNCATE - 597))
      | (1ULL << (TSqlParser::NO_WAIT - 597))
      | (1ULL << (TSqlParser::NOCOUNT - 597))
      | (1ULL << (TSqlParser::NODES - 597))
      | (1ULL << (TSqlParser::NOEXPAND - 597))
      | (1ULL << (TSqlParser::NON_TRANSACTED_ACCESS - 597))
      | (1ULL << (TSqlParser::NORECOMPUTE - 597))
      | (1ULL << (TSqlParser::NORECOVERY - 597))
      | (1ULL << (TSqlParser::NOWAIT - 597))
      | (1ULL << (TSqlParser::NTILE - 597))
      | (1ULL << (TSqlParser::NUMANODE - 597))
      | (1ULL << (TSqlParser::NUMBER - 597))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 597))
      | (1ULL << (TSqlParser::OBJECT - 597))
      | (1ULL << (TSqlParser::OFFLINE - 597))
      | (1ULL << (TSqlParser::OFFSET - 597))
      | (1ULL << (TSqlParser::OLD_ACCOUNT - 597))
      | (1ULL << (TSqlParser::ONLINE - 597))
      | (1ULL << (TSqlParser::ONLY - 597))
      | (1ULL << (TSqlParser::OPEN_EXISTING - 597))
      | (1ULL << (TSqlParser::OPTIMISTIC - 597))
      | (1ULL << (TSqlParser::OPTIMIZE - 597))
      | (1ULL << (TSqlParser::OUT - 597))
      | (1ULL << (TSqlParser::OUTPUT - 597)))) != 0) || ((((_la - 662) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 662)) & ((1ULL << (TSqlParser::OWNER - 662))
      | (1ULL << (TSqlParser::PAGE_VERIFY - 662))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 662))
      | (1ULL << (TSqlParser::PARTITION - 662))
      | (1ULL << (TSqlParser::PARTITIONS - 662))
      | (1ULL << (TSqlParser::PARTNER - 662))
      | (1ULL << (TSqlParser::PATH - 662))
      | (1ULL << (TSqlParser::POISON_MESSAGE_HANDLING - 662))
      | (1ULL << (TSqlParser::POOL - 662))
      | (1ULL << (TSqlParser::PORT - 662))
      | (1ULL << (TSqlParser::PRECEDING - 662))
      | (1ULL << (TSqlParser::PRIMARY_ROLE - 662))
      | (1ULL << (TSqlParser::PRIOR - 662))
      | (1ULL << (TSqlParser::PRIORITY - 662))
      | (1ULL << (TSqlParser::PRIORITY_LEVEL - 662))
      | (1ULL << (TSqlParser::PRIVATE - 662))
      | (1ULL << (TSqlParser::PRIVATE_KEY - 662))
      | (1ULL << (TSqlParser::PRIVILEGES - 662))
      | (1ULL << (TSqlParser::PROCEDURE_NAME - 662))
      | (1ULL << (TSqlParser::PROPERTY - 662))
      | (1ULL << (TSqlParser::PROVIDER - 662))
      | (1ULL << (TSqlParser::PROVIDER_KEY_NAME - 662))
      | (1ULL << (TSqlParser::QUERY - 662))
      | (1ULL << (TSqlParser::QUEUE - 662))
      | (1ULL << (TSqlParser::QUEUE_DELAY - 662))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 662))
      | (1ULL << (TSqlParser::RANGE - 662))
      | (1ULL << (TSqlParser::RANK - 662))
      | (1ULL << (TSqlParser::RC2 - 662))
      | (1ULL << (TSqlParser::RC4 - 662))
      | (1ULL << (TSqlParser::RC4_128 - 662))
      | (1ULL << (TSqlParser::READ_COMMITTED_SNAPSHOT - 662))
      | (1ULL << (TSqlParser::READ_ONLY - 662))
      | (1ULL << (TSqlParser::READ_ONLY_ROUTING_LIST - 662))
      | (1ULL << (TSqlParser::READ_WRITE - 662))
      | (1ULL << (TSqlParser::READONLY - 662))
      | (1ULL << (TSqlParser::REBUILD - 662))
      | (1ULL << (TSqlParser::RECEIVE - 662))
      | (1ULL << (TSqlParser::RECOMPILE - 662))
      | (1ULL << (TSqlParser::RECOVERY - 662))
      | (1ULL << (TSqlParser::RECURSIVE_TRIGGERS - 662))
      | (1ULL << (TSqlParser::RELATIVE - 662))
      | (1ULL << (TSqlParser::REMOTE - 662))
      | (1ULL << (TSqlParser::REMOTE_SERVICE_NAME - 662))
      | (1ULL << (TSqlParser::REMOVE - 662))
      | (1ULL << (TSqlParser::REORGANIZE - 662))
      | (1ULL << (TSqlParser::REPEATABLE - 662))
      | (1ULL << (TSqlParser::REPLICA - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_CPU_TIME_SEC - 662))
      | (1ULL << (TSqlParser::REQUEST_MAX_MEMORY_GRANT_PERCENT - 662))
      | (1ULL << (TSqlParser::REQUEST_MEMORY_GRANT_TIMEOUT_SEC - 662))
      | (1ULL << (TSqlParser::REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT - 662))
      | (1ULL << (TSqlParser::RESERVE_DISK_SPACE - 662))
      | (1ULL << (TSqlParser::RESOURCE - 662))
      | (1ULL << (TSqlParser::RESOURCE_MANAGER_LOCATION - 662))
      | (1ULL << (TSqlParser::RESTRICTED_USER - 662))
      | (1ULL << (TSqlParser::RETENTION - 662))
      | (1ULL << (TSqlParser::ROBUST - 662))
      | (1ULL << (TSqlParser::ROOT - 662))
      | (1ULL << (TSqlParser::ROUTE - 662))
      | (1ULL << (TSqlParser::ROW - 662))
      | (1ULL << (TSqlParser::ROW_NUMBER - 662))
      | (1ULL << (TSqlParser::ROWGUID - 662))
      | (1ULL << (TSqlParser::ROWS - 662)))) != 0) || ((((_la - 726) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 726)) & ((1ULL << (TSqlParser::SAMPLE - 726))
      | (1ULL << (TSqlParser::SCHEMABINDING - 726))
      | (1ULL << (TSqlParser::SCOPED - 726))
      | (1ULL << (TSqlParser::SCROLL - 726))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 726))
      | (1ULL << (TSqlParser::SEARCH - 726))
      | (1ULL << (TSqlParser::SECONDARY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ONLY - 726))
      | (1ULL << (TSqlParser::SECONDARY_ROLE - 726))
      | (1ULL << (TSqlParser::SECONDS - 726))
      | (1ULL << (TSqlParser::SECRET - 726))
      | (1ULL << (TSqlParser::SECURITY - 726))
      | (1ULL << (TSqlParser::SECURITY_LOG - 726))
      | (1ULL << (TSqlParser::SEEDING_MODE - 726))
      | (1ULL << (TSqlParser::SELF - 726))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 726))
      | (1ULL << (TSqlParser::SEND - 726))
      | (1ULL << (TSqlParser::SENT - 726))
      | (1ULL << (TSqlParser::SEQUENCE - 726))
      | (1ULL << (TSqlParser::SERIALIZABLE - 726))
      | (1ULL << (TSqlParser::SESSION_TIMEOUT - 726))
      | (1ULL << (TSqlParser::SETERROR - 726))
      | (1ULL << (TSqlParser::SHARE - 726))
      | (1ULL << (TSqlParser::SHOWPLAN - 726))
      | (1ULL << (TSqlParser::SIGNATURE - 726))
      | (1ULL << (TSqlParser::SIMPLE - 726))
      | (1ULL << (TSqlParser::SINGLE_USER - 726))
      | (1ULL << (TSqlParser::SIZE - 726))
      | (1ULL << (TSqlParser::SMALLINT - 726))
      | (1ULL << (TSqlParser::SNAPSHOT - 726))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 726))
      | (1ULL << (TSqlParser::STANDBY - 726))
      | (1ULL << (TSqlParser::START_DATE - 726))
      | (1ULL << (TSqlParser::STATIC - 726))
      | (1ULL << (TSqlParser::STATS_STREAM - 726))
      | (1ULL << (TSqlParser::STATUS - 726))
      | (1ULL << (TSqlParser::STDEV - 726))
      | (1ULL << (TSqlParser::STDEVP - 726))
      | (1ULL << (TSqlParser::STOPLIST - 726))
      | (1ULL << (TSqlParser::STRING_AGG - 726))
      | (1ULL << (TSqlParser::STUFF - 726))
      | (1ULL << (TSqlParser::SUBJECT - 726))
      | (1ULL << (TSqlParser::SUM - 726))
      | (1ULL << (TSqlParser::SUSPEND - 726))
      | (1ULL << (TSqlParser::SYMMETRIC - 726))
      | (1ULL << (TSqlParser::SYNCHRONOUS_COMMIT - 726))
      | (1ULL << (TSqlParser::SYNONYM - 726))
      | (1ULL << (TSqlParser::SYSTEM - 726))
      | (1ULL << (TSqlParser::TAKE - 726))
      | (1ULL << (TSqlParser::TARGET_RECOVERY_TIME - 726))
      | (1ULL << (TSqlParser::TB - 726))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 726))
      | (1ULL << (TSqlParser::THROW - 726))
      | (1ULL << (TSqlParser::TIES - 726))
      | (1ULL << (TSqlParser::TIME - 726))
      | (1ULL << (TSqlParser::TIMEOUT - 726))
      | (1ULL << (TSqlParser::TIMER - 726))
      | (1ULL << (TSqlParser::TINYINT - 726))
      | (1ULL << (TSqlParser::TORN_PAGE_DETECTION - 726))
      | (1ULL << (TSqlParser::TRANSFORM_NOISE_WORDS - 726))
      | (1ULL << (TSqlParser::TRIPLE_DES - 726)))) != 0) || ((((_la - 790) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 790)) & ((1ULL << (TSqlParser::TRIPLE_DES_3KEY - 790))
      | (1ULL << (TSqlParser::TRUSTWORTHY - 790))
      | (1ULL << (TSqlParser::TRY - 790))
      | (1ULL << (TSqlParser::TSQL - 790))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 790))
      | (1ULL << (TSqlParser::TYPE - 790))
      | (1ULL << (TSqlParser::TYPE_WARNING - 790))
      | (1ULL << (TSqlParser::UNBOUNDED - 790))
      | (1ULL << (TSqlParser::UNCOMMITTED - 790))
      | (1ULL << (TSqlParser::UNKNOWN - 790))
      | (1ULL << (TSqlParser::UNLIMITED - 790))
      | (1ULL << (TSqlParser::USING - 790))
      | (1ULL << (TSqlParser::VALID_XML - 790))
      | (1ULL << (TSqlParser::VALIDATION - 790))
      | (1ULL << (TSqlParser::VALUE - 790))
      | (1ULL << (TSqlParser::VAR - 790))
      | (1ULL << (TSqlParser::VARP - 790))
      | (1ULL << (TSqlParser::VIEW_METADATA - 790))
      | (1ULL << (TSqlParser::VIEWS - 790))
      | (1ULL << (TSqlParser::WAIT - 790))
      | (1ULL << (TSqlParser::WELL_FORMED_XML - 790))
      | (1ULL << (TSqlParser::WORK - 790))
      | (1ULL << (TSqlParser::WORKLOAD - 790))
      | (1ULL << (TSqlParser::XML - 790))
      | (1ULL << (TSqlParser::XMLNAMESPACES - 790))
      | (1ULL << (TSqlParser::ID - 790)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comparison_operatorContext ------------------------------------------------------------------

TSqlParser::Comparison_operatorContext::Comparison_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::GREATER() {
  return getToken(TSqlParser::GREATER, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::LESS() {
  return getToken(TSqlParser::LESS, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::EXCLAMATION() {
  return getToken(TSqlParser::EXCLAMATION, 0);
}


size_t TSqlParser::Comparison_operatorContext::getRuleIndex() const {
  return TSqlParser::RuleComparison_operator;
}

void TSqlParser::Comparison_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison_operator(this);
}

void TSqlParser::Comparison_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison_operator(this);
}

TSqlParser::Comparison_operatorContext* TSqlParser::comparison_operator() {
  Comparison_operatorContext *_localctx = _tracker.createInstance<Comparison_operatorContext>(_ctx, getState());
  enterRule(_localctx, 502, TSqlParser::RuleComparison_operator);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4773);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 690, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4758);
      match(TSqlParser::EQUAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4759);
      match(TSqlParser::GREATER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4760);
      match(TSqlParser::LESS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4761);
      match(TSqlParser::LESS);
      setState(4762);
      match(TSqlParser::EQUAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4763);
      match(TSqlParser::GREATER);
      setState(4764);
      match(TSqlParser::EQUAL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4765);
      match(TSqlParser::LESS);
      setState(4766);
      match(TSqlParser::GREATER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4767);
      match(TSqlParser::EXCLAMATION);
      setState(4768);
      match(TSqlParser::EQUAL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4769);
      match(TSqlParser::EXCLAMATION);
      setState(4770);
      match(TSqlParser::GREATER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4771);
      match(TSqlParser::EXCLAMATION);
      setState(4772);
      match(TSqlParser::LESS);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_operatorContext ------------------------------------------------------------------

TSqlParser::Assignment_operatorContext::Assignment_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::PLUS_ASSIGN() {
  return getToken(TSqlParser::PLUS_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MINUS_ASSIGN() {
  return getToken(TSqlParser::MINUS_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MULT_ASSIGN() {
  return getToken(TSqlParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::DIV_ASSIGN() {
  return getToken(TSqlParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MOD_ASSIGN() {
  return getToken(TSqlParser::MOD_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::AND_ASSIGN() {
  return getToken(TSqlParser::AND_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::XOR_ASSIGN() {
  return getToken(TSqlParser::XOR_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::OR_ASSIGN() {
  return getToken(TSqlParser::OR_ASSIGN, 0);
}


size_t TSqlParser::Assignment_operatorContext::getRuleIndex() const {
  return TSqlParser::RuleAssignment_operator;
}

void TSqlParser::Assignment_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_operator(this);
}

void TSqlParser::Assignment_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_operator(this);
}

TSqlParser::Assignment_operatorContext* TSqlParser::assignment_operator() {
  Assignment_operatorContext *_localctx = _tracker.createInstance<Assignment_operatorContext>(_ctx, getState());
  enterRule(_localctx, 504, TSqlParser::RuleAssignment_operator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4775);
    _la = _input->LA(1);
    if (!(((((_la - 840) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 840)) & ((1ULL << (TSqlParser::PLUS_ASSIGN - 840))
      | (1ULL << (TSqlParser::MINUS_ASSIGN - 840))
      | (1ULL << (TSqlParser::MULT_ASSIGN - 840))
      | (1ULL << (TSqlParser::DIV_ASSIGN - 840))
      | (1ULL << (TSqlParser::MOD_ASSIGN - 840))
      | (1ULL << (TSqlParser::AND_ASSIGN - 840))
      | (1ULL << (TSqlParser::XOR_ASSIGN - 840))
      | (1ULL << (TSqlParser::OR_ASSIGN - 840)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_sizeContext ------------------------------------------------------------------

TSqlParser::File_sizeContext::File_sizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::File_sizeContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::File_sizeContext::KB() {
  return getToken(TSqlParser::KB, 0);
}

tree::TerminalNode* TSqlParser::File_sizeContext::MB() {
  return getToken(TSqlParser::MB, 0);
}

tree::TerminalNode* TSqlParser::File_sizeContext::GB() {
  return getToken(TSqlParser::GB, 0);
}

tree::TerminalNode* TSqlParser::File_sizeContext::TB() {
  return getToken(TSqlParser::TB, 0);
}

tree::TerminalNode* TSqlParser::File_sizeContext::MODULE() {
  return getToken(TSqlParser::MODULE, 0);
}


size_t TSqlParser::File_sizeContext::getRuleIndex() const {
  return TSqlParser::RuleFile_size;
}

void TSqlParser::File_sizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_size(this);
}

void TSqlParser::File_sizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_size(this);
}

TSqlParser::File_sizeContext* TSqlParser::file_size() {
  File_sizeContext *_localctx = _tracker.createInstance<File_sizeContext>(_ctx, getState());
  enterRule(_localctx, 506, TSqlParser::RuleFile_size);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4777);
    match(TSqlParser::DECIMAL);
    setState(4779);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::GB

    || _la == TSqlParser::KB || _la == TSqlParser::MB || _la == TSqlParser::TB || _la == TSqlParser::MODULE) {
      setState(4778);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::GB

      || _la == TSqlParser::KB || _la == TSqlParser::MB || _la == TSqlParser::TB || _la == TSqlParser::MODULE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool TSqlParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 130: return expressionSempred(dynamic_cast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool TSqlParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 5);
    case 1: return precpred(_ctx, 4);
    case 2: return precpred(_ctx, 3);
    case 3: return precpred(_ctx, 2);
    case 4: return precpred(_ctx, 10);

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> TSqlParser::_decisionToDFA;
atn::PredictionContextCache TSqlParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN TSqlParser::_atn;
std::vector<uint16_t> TSqlParser::_serializedATN;

std::vector<std::string> TSqlParser::_ruleNames = {
  "tsql_file", "batch", "sql_clauses", "sql_clause", "dml_clause", "ddl_clause", 
  "cfl_statement", "block_statement", "break_statement", "continue_statement", 
  "goto_statement", "return_statement", "if_statement", "throw_statement", 
  "throw_error_number", "throw_message", "throw_state", "try_catch_statement", 
  "waitfor_statement", "while_statement", "print_statement", "raiseerror_statement", 
  "empty_statement", "another_statement", "drop_aggregate", "entity_to", 
  "colon_colon", "class_type", "class_type_for_sql_database", "class_type_for_parallel_dw", 
  "drop_schema", "lock_table", "truncate_table", "event_session_predicate_expression", 
  "event_session_predicate_factor", "event_session_predicate_leaf", "alter_schema_sql", 
  "create_schema", "create_xml_schema_collection", "create_queue", "queue_settings", 
  "alter_queue", "queue_action", "queue_rebuild_options", "conversation_statement", 
  "message_statement", "merge_statement", "merge_matched", "merge_not_matched", 
  "delete_statement", "delete_statement_from", "insert_statement", "insert_statement_value", 
  "receive_statement", "select_statement", "time", "update_statement", "output_clause", 
  "output_dml_list_elem", "output_column_name", "create_database", "create_index", 
  "create_or_alter_procedure", "create_or_alter_function", "func_body_returns_select", 
  "func_body_returns_table", "func_body_returns_scalar", "procedure_param", 
  "procedure_option", "function_option", "create_table", "table_options", 
  "create_view", "view_attribute", "alter_table", "cursor_option", "target_recovery_time_option", 
  "termination", "drop_index", "drop_relational_or_xml_or_spatial_index", 
  "drop_backward_compatible_index", "drop_procedure", "drop_function", "drop_table", 
  "drop_view", "create_type", "drop_type", "rowset_function_limited", "openquery", 
  "opendatasource", "declare_statement", "cursor_statement", "kill_statement", 
  "kill_process", "kill_query_notification", "kill_stats_job", "execute_statement", 
  "execute_body", "execute_statement_arg", "execute_var_string", "set_statement", 
  "transaction_statement", "go_statement", "use_statement", "setuser_statement", 
  "reconfigure_statement", "shutdown_statement", "dbcc_clause", "dbcc_options", 
  "execute_clause", "declare_local", "table_type_definition", "xml_type_definition", 
  "xml_schema_collection", "column_def_table_constraints", "column_def_table_constraint", 
  "column_definition", "materialized_column_definition", "column_constraint", 
  "table_constraint", "on_delete", "on_update", "index_options", "index_option", 
  "declare_cursor", "declare_set_cursor_common", "declare_set_cursor_common_partial", 
  "fetch_cursor", "set_special", "constant_LOCAL_ID", "expression", "primitive_expression", 
  "case_expression", "unary_operator_expression", "bracket_expression", 
  "constant_expression", "subquery", "with_expression", "common_table_expression", 
  "update_elem", "search_condition_list", "search_condition", "search_condition_and", 
  "search_condition_not", "predicate", "query_expression", "sql_union", 
  "query_specification", "top_clause", "top_percent", "top_count", "order_by_clause", 
  "for_clause", "xml_common_directives", "order_by_expression", "group_by_item", 
  "option_clause", "option", "optimize_for_arg", "select_list", "udt_method_arguments", 
  "asterisk", "column_elem", "udt_elem", "expression_elem", "select_list_elem", 
  "table_sources", "table_source", "table_source_item_joined", "table_source_item", 
  "open_xml", "schema_declaration", "column_declaration", "change_table", 
  "join_part", "pivot_clause", "unpivot_clause", "full_column_name_list", 
  "table_name_with_hint", "rowset_function", "bulk_option", "derived_table", 
  "function_call", "xml_data_type_methods", "value_method", "query_method", 
  "exist_method", "modify_method", "nodes_method", "switch_section", "switch_search_condition_section", 
  "as_column_alias", "as_table_alias", "table_alias", "with_table_hints", 
  "insert_with_table_hints", "table_hint", "index_value", "column_alias_list", 
  "column_alias", "table_value_constructor", "expression_list", "ranking_windowed_function", 
  "aggregate_windowed_function", "analytic_windowed_function", "all_distinct_expression", 
  "over_clause", "row_or_range_clause", "window_frame_extent", "window_frame_bound", 
  "window_frame_preceding", "window_frame_following", "create_database_option", 
  "database_filestream_option", "database_file_spec", "file_group", "file_spec", 
  "entity_name", "entity_name_for_azure_dw", "entity_name_for_parallel_dw", 
  "full_table_name", "table_name", "simple_name", "func_proc_name_schema", 
  "func_proc_name_database_schema", "func_proc_name_server_database_schema", 
  "ddl_object", "full_column_name", "column_name_list_with_order", "column_name_list", 
  "cursor_name", "on_off", "clustered", "null_notnull", "null_or_default", 
  "scalar_function_name", "begin_conversation_timer", "begin_conversation_dialog", 
  "contract_name", "service_name", "end_conversation", "waitfor_conversation", 
  "get_conversation", "queue_id", "send_conversation", "data_type", "default_value", 
  "constant", "sign", "id", "simple_id", "comparison_operator", "assignment_operator", 
  "file_size"
};

std::vector<std::string> TSqlParser::_literalNames = {
  "", "'ABS'", "'ABSENT'", "'ADD'", "'AES'", "'ALL'", "'ALLOW_CONNECTIONS'", 
  "'ALLOW_MULTIPLE_EVENT_LOSS'", "'ALLOW_SINGLE_EVENT_LOSS'", "'ALTER'", 
  "'AND'", "'ANONYMOUS'", "'ANY'", "'APPEND'", "'APPLICATION'", "'AS'", 
  "'ASC'", "'ASCII'", "'ASYMMETRIC'", "'ASYNCHRONOUS_COMMIT'", "'AUTHORIZATION'", 
  "'AUTHENTICATION'", "'AUTOMATED_BACKUP_PREFERENCE'", "'AUTOMATIC'", "'AVAILABILITY_MODE'", 
  "'\\'", "'BACKUP'", "'BEFORE'", "'BEGIN'", "'BETWEEN'", "'BLOCK'", "'BLOCKSIZE'", 
  "'BLOCKING_HIERARCHY'", "'BREAK'", "'BROWSE'", "'BUFFER'", "'BUFFERCOUNT'", 
  "'BULK'", "'BY'", "'CACHE'", "'CALLED'", "'CASCADE'", "'CASE'", "'CEILING'", 
  "'CERTIFICATE'", "'CHANGETABLE'", "'CHANGES'", "'CHAR'", "'CHARINDEX'", 
  "'CHECK'", "'CHECKPOINT'", "'CHECK_POLICY'", "'CHECK_EXPIRATION'", "'CLASSIFIER_FUNCTION'", 
  "'CLOSE'", "'CLUSTER'", "'CLUSTERED'", "'COALESCE'", "'COLLATE'", "'COLUMN'", 
  "'COMPRESSION'", "'COMMIT'", "'COMPUTE'", "'CONFIGURATION'", "'CONSTRAINT'", 
  "'CONTAINMENT'", "'CONTAINS'", "'CONTAINSTABLE'", "'CONTEXT'", "'CONTINUE'", 
  "'CONTINUE_AFTER_ERROR'", "'CONTRACT'", "'CONTRACT_NAME'", "'CONVERSATION'", 
  "", "'COPY_ONLY'", "'CREATE'", "'CROSS'", "'CURRENT'", "'CURRENT_DATE'", 
  "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'CURSOR'", 
  "'CYCLE'", "'DATA_COMPRESSION'", "'DATA_SOURCE'", "'DATABASE'", "'DATABASE_MIRRORING'", 
  "'DBCC'", "'DEALLOCATE'", "'DECLARE'", "'DEFAULT'", "'DEFAULT_DATABASE'", 
  "'DEFAULT_SCHEMA'", "'DELETE'", "'DENY'", "'DESC'", "'DIAGNOSTICS'", "'DIFFERENTIAL'", 
  "'DISK'", "'DISTINCT'", "'DISTRIBUTED'", "'DOUBLE'", "'\\\\'", "'//'", 
  "'DROP'", "'DTC_SUPPORT'", "'DUMP'", "'ELSE'", "'ENABLED'", "'END'", "'ENDPOINT'", 
  "'ERRLVL'", "'ESCAPE'", "'ERROR'", "'EVENT'", "", "'EVENT_RETENTION_MODE'", 
  "'EXCEPT'", "'EXECUTABLE_FILE'", "", "'EXISTS'", "'EXPIREDATE'", "'EXIT'", 
  "'EXTENSION'", "'EXTERNAL'", "'EXTERNAL_ACCESS'", "'FAILOVER'", "'FAILURECONDITIONLEVEL'", 
  "'FAN_IN'", "'FETCH'", "'FILE'", "'FILENAME'", "'FILLFACTOR'", "'FILE_SNAPSHOT'", 
  "'FLOOR'", "'FOR'", "'FORCESEEK'", "'FORCE_SERVICE_ALLOW_DATA_LOSS'", 
  "'FOREIGN'", "'FREETEXT'", "'FREETEXTTABLE'", "'FROM'", "'FULL'", "'FUNCTION'", 
  "'GET'", "'GOTO'", "'GOVERNOR'", "'GRANT'", "'GROUP'", "'HAVING'", "'HASHED'", 
  "'HEALTHCHECKTIMEOUT'", "'IDENTITY'", "'IDENTITYCOL'", "'IDENTITY_INSERT'", 
  "'IF'", "'IIF'", "'IN'", "'INCLUDE'", "'INCREMENT'", "'INDEX'", "'INFINITE'", 
  "'INIT'", "'INNER'", "'INSERT'", "'INSTEAD'", "'INTERSECT'", "'INTO'", 
  "", "", "'IS'", "'ISDATE'", "'ISNULL'", "'ISNUMERIC'", "'JOIN'", "'KERBEROS'", 
  "'KEY'", "'KEY_PATH'", "'KEY_STORE_PROVIDER_NAME'", "'KILL'", "'LANGUAGE'", 
  "'LEFT'", "'LEN'", "'LIBRARY'", "'LIFETIME'", "'LIKE'", "'LINENO'", "'LINUX'", 
  "'LISTENER_IP'", "'LISTENER_PORT'", "'LOAD'", "'LOCAL_SERVICE_NAME'", 
  "'LOG'", "'LOWER'", "'LTRIM'", "'MATCHED'", "'MASTER'", "'MAX_MEMORY'", 
  "'MAXTRANSFER'", "'MAXVALUE'", "'MAX_DISPATCH_LATENCY'", "'MAX_EVENT_SIZE'", 
  "'MAX_SIZE'", "'MAX_OUTSTANDING_IO_PER_VOLUME'", "'MEDIADESCRIPTION'", 
  "'MEDIANAME'", "'MEMBER'", "'MEMORY_PARTITION_MODE'", "'MERGE'", "'MESSAGE_FORWARDING'", 
  "'MESSAGE_FORWARD_SIZE'", "'MINVALUE'", "'MIRROR'", "'MONTH'", "'MUST_CHANGE'", 
  "'NATIONAL'", "'NCHAR'", "'NEGOTIATE'", "'NOCHECK'", "'NOFORMAT'", "'NOINIT'", 
  "'NONCLUSTERED'", "'NONE'", "'NOREWIND'", "'NOSKIP'", "'NOUNLOAD'", "'NO_CHECKSUM'", 
  "'NO_COMPRESSION'", "'NO_EVENT_LOSS'", "'NOT'", "'NOTIFICATION'", "'NTLM'", 
  "'NULL'", "'NULLIF'", "'OF'", "'OFF'", "'OFFSETS'", "'OLD_PASSWORD'", 
  "'ON'", "'ON_FAILURE'", "'OPEN'", "'OPENDATASOURCE'", "'OPENQUERY'", "'OPENROWSET'", 
  "'OPENXML'", "'OPTION'", "'OR'", "'ORDER'", "'OUTER'", "'OVER'", "'PAGE'", 
  "'PARAM_NODE'", "'PARTIAL'", "'PASSWORD'", "'PATINDEX'", "'PERCENT'", 
  "'PERMISSION_SET'", "'PER_CPU'", "'PER_DB'", "'PER_NODE'", "'PIVOT'", 
  "'PLAN'", "'PLATFORM'", "'POLICY'", "'PRECISION'", "'PREDICATE'", "'PRIMARY'", 
  "'PRINT'", "'PROC'", "'PROCEDURE'", "'PROCESS'", "'PUBLIC'", "'PYTHON'", 
  "'R'", "'RAISERROR'", "'RAND'", "'RAW'", "'READ'", "'READTEXT'", "'READ_WRITE_FILEGROUPS'", 
  "'RECONFIGURE'", "'REFERENCES'", "'REGENERATE'", "'RELATED_CONVERSATION'", 
  "'RELATED_CONVERSATION_GROUP'", "'REPLACE'", "'REPLICATION'", "'REQUIRED'", 
  "'RESET'", "'RESTART'", "'RESTORE'", "'RESTRICT'", "'RESUME'", "'RETAINDAYS'", 
  "'RETURN'", "'RETURNS'", "'REVERT'", "'REVOKE'", "'REWIND'", "'RIGHT'", 
  "'ROLLBACK'", "'ROLE'", "'ROUND'", "'ROWCOUNT'", "'ROWGUIDCOL'", "'RSA_512'", 
  "'RSA_1024'", "'RSA_2048'", "'RSA_3072'", "'RSA_4096'", "'RTRIM'", "'SAFETY'", 
  "'RULE'", "'SAFE'", "'SAVE'", "'SCHEDULER'", "'SCHEMA'", "'SCHEME'", "'SECURITYAUDIT'", 
  "'SELECT'", "'SEMANTICKEYPHRASETABLE'", "'SEMANTICSIMILARITYDETAILSTABLE'", 
  "'SEMANTICSIMILARITYTABLE'", "'SERVER'", "'SERVICE'", "'SERVICE_BROKER'", 
  "'SERVICE_NAME'", "'SESSION'", "'SESSION_USER'", "'SESSIONPROPERTY'", 
  "'SET'", "'SETUSER'", "'SIGN'", "'SHUTDOWN'", "'SID'", "'SKIP'", "'SOFTNUMA'", 
  "'SOME'", "'SOURCE'", "'SPACE'", "'SPECIFICATION'", "'SPLIT'", "'SQLDUMPERFLAGS'", 
  "'SQLDUMPERPATH'", "'SQLDUMPERTIMEOUTS'", "'STATISTICS'", "'STATE'", "'STATS'", 
  "'START'", "'STARTED'", "'STARTUP_STATE'", "'STOP'", "'STOPPED'", "'STOP_ON_ERROR'", 
  "'STR'", "'SUPPORTED'", "'SYSTEM_USER'", "'TABLE'", "'TABLESAMPLE'", "'TAPE'", 
  "'TARGET'", "'TCP'", "'TEXTSIZE'", "'THEN'", "'TO'", "'TOP'", "'TRACK_CAUSALITY'", 
  "'TRAN'", "'TRANSACTION'", "'TRANSFER'", "'TRIGGER'", "'TRUNCATE'", "'TSEQUAL'", 
  "'UNCHECKED'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNPIVOT'", "'UNSAFE'", 
  "'UPDATE'", "'UPDATETEXT'", "'UPPER'", "'URL'", "'USE'", "'USED'", "'USER'", 
  "'USER_NAME'", "'VALUES'", "'VARYING'", "'VERBOSELOGGING'", "'VIEW'", 
  "'VISIBILITY'", "'WAITFOR'", "'WHEN'", "'WHERE'", "'WHILE'", "'WINDOWS'", 
  "'WITH'", "'WITHIN'", "'WITHOUT'", "'WITNESS'", "'WRITETEXT'", "'YEAR'", 
  "'ABSOLUTE'", "'ACCENT_SENSITIVITY'", "'ACTION'", "'ACTIVATION'", "'ACTIVE'", 
  "'ADDRESS'", "'AES_128'", "'AES_192'", "'AES_256'", "'AFFINITY'", "'AFTER'", 
  "'AGGREGATE'", "'ALGORITHM'", "'ALLOW_ENCRYPTED_VALUE_MODIFICATIONS'", 
  "'ALLOW_SNAPSHOT_ISOLATION'", "'ALLOWED'", "'ANSI_NULL_DEFAULT'", "'ANSI_NULLS'", 
  "'ANSI_PADDING'", "'ANSI_WARNINGS'", "'APPLICATION_LOG'", "'APPLY'", "'ARITHABORT'", 
  "'ASSEMBLY'", "'AUDIT'", "'AUDIT_GUID'", "'AUTO'", "'AUTO_CLEANUP'", "'AUTO_CLOSE'", 
  "'AUTO_CREATE_STATISTICS'", "'AUTO_SHRINK'", "'AUTO_UPDATE_STATISTICS'", 
  "'AUTO_UPDATE_STATISTICS_ASYNC'", "'AVAILABILITY'", "'AVG'", "'BACKUP_PRIORITY'", 
  "'BEGIN_DIALOG'", "'BIGINT'", "'BINARY BASE64'", "'BINARY_CHECKSUM'", 
  "'BINDING'", "'BLOB_STORAGE'", "'BROKER'", "'BROKER_INSTANCE'", "'BULK_LOGGED'", 
  "'CALLER'", "'CAP_CPU_PERCENT'", "", "'CATALOG'", "'CATCH'", "'CHANGE_RETENTION'", 
  "'CHANGE_TRACKING'", "'CHECKSUM'", "'CHECKSUM_AGG'", "'CLEANUP'", "'COLLECTION'", 
  "'COLUMN_MASTER_KEY'", "'COMMITTED'", "'COMPATIBILITY_LEVEL'", "'CONCAT'", 
  "'CONCAT_NULL_YIELDS_NULL'", "'CONTENT'", "'CONTROL'", "'COOKIE'", "'COUNT'", 
  "'COUNT_BIG'", "'COUNTER'", "'CPU'", "'CREATE_NEW'", "'CREATION_DISPOSITION'", 
  "'CREDENTIAL'", "'CRYPTOGRAPHIC'", "'CURSOR_CLOSE_ON_COMMIT'", "'CURSOR_DEFAULT'", 
  "'DATA'", "'DATALENGTH'", "'DATE_CORRELATION_OPTIMIZATION'", "'DATEADD'", 
  "'DATEDIFF'", "'DATENAME'", "'DATEPART'", "'DAY'", "'DAYS'", "'DB_CHAINING'", 
  "'DB_FAILOVER'", "'DECRYPTION'", "", "'DEFAULT_FULLTEXT_LANGUAGE'", "'DEFAULT_LANGUAGE'", 
  "'DELAY'", "'DELAYED_DURABILITY'", "'DELETED'", "'DENSE_RANK'", "'DEPENDENTS'", 
  "'DES'", "'DESCRIPTION'", "'DESX'", "'DHCP'", "'DIALOG'", "'DIRECTORY_NAME'", 
  "'DISABLE'", "'DISABLE_BROKER'", "'DISABLED'", "", "'DOCUMENT'", "'DYNAMIC'", 
  "'ELEMENTS'", "'EMERGENCY'", "'EMPTY'", "'ENABLE'", "'ENABLE_BROKER'", 
  "'ENCRYPTED_VALUE'", "'ENCRYPTION'", "'ENDPOINT_URL'", "'ERROR_BROKER_CONVERSATIONS'", 
  "'EXCLUSIVE'", "'EXECUTABLE'", "'EXIST'", "'EXPAND'", "'EXPIRY_DATE'", 
  "'EXPLICIT'", "'FAIL_OPERATION'", "'FAILOVER_MODE'", "'FAILURE'", "'FAILURE_CONDITION_LEVEL'", 
  "'FAST'", "'FAST_FORWARD'", "'FILEGROUP'", "'FILEGROWTH'", "'FILEPATH'", 
  "'FILESTREAM'", "'FILTER'", "'FIRST'", "'FIRST_VALUE'", "'FOLLOWING'", 
  "'FORCE'", "'FORCE_FAILOVER_ALLOW_DATA_LOSS'", "'FORCED'", "'FORMAT'", 
  "'FORWARD_ONLY'", "'FULLSCAN'", "'FULLTEXT'", "'GB'", "'GETDATE'", "'GETUTCDATE'", 
  "'GLOBAL'", "'GO'", "'GROUP_MAX_REQUESTS'", "'GROUPING'", "'GROUPING_ID'", 
  "'HADR'", "'HASH'", "'HEALTH_CHECK_TIMEOUT'", "'HIGH'", "'HONOR_BROKER_PRIORITY'", 
  "'HOURS'", "'IDENTITY_VALUE'", "'IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX'", 
  "'IMMEDIATE'", "'IMPERSONATE'", "'IMPORTANCE'", "'INCLUDE_NULL_VALUES'", 
  "'INCREMENTAL'", "'INITIATOR'", "'INPUT'", "'INSENSITIVE'", "'INSERTED'", 
  "'INT'", "'IP'", "'ISOLATION'", "'JOB'", "'JSON'", "'KB'", "'KEEP'", "'KEEPFIXED'", 
  "'KEY_SOURCE'", "'KEYS'", "'KEYSET'", "'LAG'", "'LAST'", "'LAST_VALUE'", 
  "'LEAD'", "'LEVEL'", "'LIST'", "'LISTENER'", "'LISTENER_URL'", "'LOB_COMPACTION'", 
  "'LOCAL'", "'LOCATION'", "'LOCK'", "'LOCK_ESCALATION'", "'LOGIN'", "'LOOP'", 
  "'LOW'", "'MANUAL'", "'MARK'", "'MATERIALIZED'", "'MAX'", "'MAX_CPU_PERCENT'", 
  "'MAX_DOP'", "'MAX_FILES'", "'MAX_IOPS_PER_VOLUME'", "'MAX_MEMORY_PERCENT'", 
  "'MAX_PROCESSES'", "'MAX_QUEUE_READERS'", "'MAX_ROLLOVER_FILES'", "'MAXDOP'", 
  "'MAXRECURSION'", "'MAXSIZE'", "'MB'", "'MEDIUM'", "'MEMORY_OPTIMIZED_DATA'", 
  "'MESSAGE'", "'MIN'", "'MIN_ACTIVE_ROWVERSION'", "'MIN_CPU_PERCENT'", 
  "'MIN_IOPS_PER_VOLUME'", "'MIN_MEMORY_PERCENT'", "'MINUTES'", "'MIRROR_ADDRESS'", 
  "'MIXED_PAGE_ALLOCATION'", "'MODE'", "'MODIFY'", "'MOVE'", "'MULTI_USER'", 
  "'NAME'", "'NESTED_TRIGGERS'", "'NEW_ACCOUNT'", "'NEW_BROKER'", "'NEW_PASSWORD'", 
  "'NEXT'", "'NO'", "'NO_TRUNCATE'", "'NO_WAIT'", "'NOCOUNT'", "'NODES'", 
  "'NOEXPAND'", "'NON_TRANSACTED_ACCESS'", "'NORECOMPUTE'", "'NORECOVERY'", 
  "'NOWAIT'", "'NTILE'", "'NUMANODE'", "'NUMBER'", "'NUMERIC_ROUNDABORT'", 
  "'OBJECT'", "'OFFLINE'", "'OFFSET'", "'OLD_ACCOUNT'", "'ONLINE'", "'ONLY'", 
  "'OPEN_EXISTING'", "'OPTIMISTIC'", "'OPTIMIZE'", "'OUT'", "'OUTPUT'", 
  "'OVERRIDE'", "'OWNER'", "'PAGE_VERIFY'", "'PARAMETERIZATION'", "'PARTITION'", 
  "'PARTITIONS'", "'PARTNER'", "'PATH'", "'POISON_MESSAGE_HANDLING'", "'POOL'", 
  "'PORT'", "'PRECEDING'", "'PRIMARY_ROLE'", "'PRIOR'", "'PRIORITY'", "'PRIORITY_LEVEL'", 
  "'PRIVATE'", "'PRIVATE_KEY'", "'PRIVILEGES'", "'PROCEDURE_NAME'", "'PROPERTY'", 
  "'PROVIDER'", "'PROVIDER_KEY_NAME'", "'QUERY'", "'QUEUE'", "'QUEUE_DELAY'", 
  "'QUOTED_IDENTIFIER'", "'RANGE'", "'RANK'", "'RC2'", "'RC4'", "'RC4_128'", 
  "'READ_COMMITTED_SNAPSHOT'", "'READ_ONLY'", "'READ_ONLY_ROUTING_LIST'", 
  "'READ_WRITE'", "'READONLY'", "'REBUILD'", "'RECEIVE'", "'RECOMPILE'", 
  "'RECOVERY'", "'RECURSIVE_TRIGGERS'", "'RELATIVE'", "'REMOTE'", "'REMOTE_SERVICE_NAME'", 
  "'REMOVE'", "'REORGANIZE'", "'REPEATABLE'", "'REPLICA'", "'REQUEST_MAX_CPU_TIME_SEC'", 
  "'REQUEST_MAX_MEMORY_GRANT_PERCENT'", "'REQUEST_MEMORY_GRANT_TIMEOUT_SEC'", 
  "'REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT'", "'RESERVE_DISK_SPACE'", 
  "'RESOURCE'", "'RESOURCE_MANAGER_LOCATION'", "'RESTRICTED_USER'", "'RETENTION'", 
  "'ROBUST'", "'ROOT'", "'ROUTE'", "'ROW'", "'ROW_NUMBER'", "'ROWGUID'", 
  "'ROWS'", "'SAMPLE'", "'SCHEMABINDING'", "'SCOPED'", "'SCROLL'", "'SCROLL_LOCKS'", 
  "'SEARCH'", "'SECONDARY'", "'SECONDARY_ONLY'", "'SECONDARY_ROLE'", "'SECONDS'", 
  "'SECRET'", "'SECURITY'", "'SECURITY_LOG'", "'SEEDING_MODE'", "'SELF'", 
  "'SEMI_SENSITIVE'", "'SEND'", "'SENT'", "'SEQUENCE'", "'SERIALIZABLE'", 
  "'SESSION_TIMEOUT'", "'SETERROR'", "'SHARE'", "'SHOWPLAN'", "'SIGNATURE'", 
  "'SIMPLE'", "'SINGLE_USER'", "'SIZE'", "'SMALLINT'", "'SNAPSHOT'", "'SPATIAL_WINDOW_MAX_CELLS'", 
  "'STANDBY'", "'START_DATE'", "'STATIC'", "'STATS_STREAM'", "'STATUS'", 
  "'STATUSONLY'", "'STDEV'", "'STDEVP'", "'STOPLIST'", "'STRING_AGG'", "'STUFF'", 
  "'SUBJECT'", "'SUBSCRIPTION'", "'SUBSTRING'", "'SUM'", "'SUSPEND'", "'SYMMETRIC'", 
  "'SYNCHRONOUS_COMMIT'", "'SYNONYM'", "'SYSTEM'", "'TAKE'", "'TARGET_RECOVERY_TIME'", 
  "'TB'", "'TEXTIMAGE_ON'", "'THROW'", "'TIES'", "'TIME'", "'TIMEOUT'", 
  "'TIMER'", "'TINYINT'", "'TORN_PAGE_DETECTION'", "'TRANSFORM_NOISE_WORDS'", 
  "'TRIPLE_DES'", "'TRIPLE_DES_3KEY'", "'TRUSTWORTHY'", "'TRY'", "'TSQL'", 
  "'TWO_DIGIT_YEAR_CUTOFF'", "'TYPE'", "'TYPE_WARNING'", "'UNBOUNDED'", 
  "'UNCOMMITTED'", "'UNKNOWN'", "'UNLIMITED'", "'UOW'", "'USING'", "'VALID_XML'", 
  "'VALIDATION'", "'VALUE'", "'VAR'", "'VARP'", "'VIEW_METADATA'", "'VIEWS'", 
  "'WAIT'", "'WELL_FORMED_XML'", "'WITHOUT_ARRAY_WRAPPER'", "'WORK'", "'WORKLOAD'", 
  "'XML'", "'XMLDATA'", "'XMLNAMESPACES'", "'XMLSCHEMA'", "'XSINIL'", "'$ACTION'", 
  "", "", "", "", "'''", "", "", "", "", "", "", "", "", "", "", "'='", 
  "'>'", "'<'", "'!'", "'+='", "'-='", "'*='", "'/='", "'%='", "'&='", "'^='", 
  "'|='", "'||'", "'.'", "'_'", "'@'", "'#'", "'$'", "'('", "')'", "','", 
  "';'", "':'", "'*'", "'/'", "'%'", "'+'", "'-'", "'~'", "'|'", "'&'", 
  "'^'"
};

std::vector<std::string> TSqlParser::_symbolicNames = {
  "", "ABS", "ABSENT", "ADD", "AES", "ALL", "ALLOW_CONNECTIONS", "ALLOW_MULTIPLE_EVENT_LOSS", 
  "ALLOW_SINGLE_EVENT_LOSS", "ALTER", "AND", "ANONYMOUS", "ANY", "APPEND", 
  "APPLICATION", "AS", "ASC", "ASCII", "ASYMMETRIC", "ASYNCHRONOUS_COMMIT", 
  "AUTHORIZATION", "AUTHENTICATION", "AUTOMATED_BACKUP_PREFERENCE", "AUTOMATIC", 
  "AVAILABILITY_MODE", "BACKSLASH", "BACKUP", "BEFORE", "BEGIN", "BETWEEN", 
  "BLOCK", "BLOCKSIZE", "BLOCKING_HIERARCHY", "BREAK", "BROWSE", "BUFFER", 
  "BUFFERCOUNT", "BULK", "BY", "CACHE", "CALLED", "CASCADE", "CASE", "CEILING", 
  "CERTIFICATE", "CHANGETABLE", "CHANGES", "CHAR", "CHARINDEX", "CHECK", 
  "CHECKPOINT", "CHECK_POLICY", "CHECK_EXPIRATION", "CLASSIFIER_FUNCTION", 
  "CLOSE", "CLUSTER", "CLUSTERED", "COALESCE", "COLLATE", "COLUMN", "COMPRESSION", 
  "COMMIT", "COMPUTE", "CONFIGURATION", "CONSTRAINT", "CONTAINMENT", "CONTAINS", 
  "CONTAINSTABLE", "CONTEXT", "CONTINUE", "CONTINUE_AFTER_ERROR", "CONTRACT", 
  "CONTRACT_NAME", "CONVERSATION", "CONVERT", "COPY_ONLY", "CREATE", "CROSS", 
  "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", 
  "CURSOR", "CYCLE", "DATA_COMPRESSION", "DATA_SOURCE", "DATABASE", "DATABASE_MIRRORING", 
  "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", "DEFAULT_DATABASE", "DEFAULT_SCHEMA", 
  "DELETE", "DENY", "DESC", "DIAGNOSTICS", "DIFFERENTIAL", "DISK", "DISTINCT", 
  "DISTRIBUTED", "DOUBLE", "DOUBLE_BACK_SLASH", "DOUBLE_FORWARD_SLASH", 
  "DROP", "DTC_SUPPORT", "DUMP", "ELSE", "ENABLED", "END", "ENDPOINT", "ERRLVL", 
  "ESCAPE", "ERROR", "EVENT", "EVENTDATA", "EVENT_RETENTION_MODE", "EXCEPT", 
  "EXECUTABLE_FILE", "EXECUTE", "EXISTS", "EXPIREDATE", "EXIT", "EXTENSION", 
  "EXTERNAL", "EXTERNAL_ACCESS", "FAILOVER", "FAILURECONDITIONLEVEL", "FAN_IN", 
  "FETCH", "FILE", "FILENAME", "FILLFACTOR", "FILE_SNAPSHOT", "FLOOR", "FOR", 
  "FORCESEEK", "FORCE_SERVICE_ALLOW_DATA_LOSS", "FOREIGN", "FREETEXT", "FREETEXTTABLE", 
  "FROM", "FULL", "FUNCTION", "GET", "GOTO", "GOVERNOR", "GRANT", "GROUP", 
  "HAVING", "HASHED", "HEALTHCHECKTIMEOUT", "IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", 
  "IF", "IIF", "IN", "INCLUDE", "INCREMENT", "INDEX", "INFINITE", "INIT", 
  "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IPV4_ADDR", "IPV6_ADDR", 
  "IS", "ISDATE", "ISNULL", "ISNUMERIC", "JOIN", "KERBEROS", "KEY", "KEY_PATH", 
  "KEY_STORE_PROVIDER_NAME", "KILL", "LANGUAGE", "LEFT", "LEN", "LIBRARY", 
  "LIFETIME", "LIKE", "LINENO", "LINUX", "LISTENER_IP", "LISTENER_PORT", 
  "LOAD", "LOCAL_SERVICE_NAME", "LOG", "LOWER", "LTRIM", "MATCHED", "MASTER", 
  "MAX_MEMORY", "MAXTRANSFER", "MAXVALUE", "MAX_DISPATCH_LATENCY", "MAX_EVENT_SIZE", 
  "MAX_SIZE", "MAX_OUTSTANDING_IO_PER_VOLUME", "MEDIADESCRIPTION", "MEDIANAME", 
  "MEMBER", "MEMORY_PARTITION_MODE", "MERGE", "MESSAGE_FORWARDING", "MESSAGE_FORWARD_SIZE", 
  "MINVALUE", "MIRROR", "MONTH", "MUST_CHANGE", "NATIONAL", "NCHAR", "NEGOTIATE", 
  "NOCHECK", "NOFORMAT", "NOINIT", "NONCLUSTERED", "NONE", "NOREWIND", "NOSKIP", 
  "NOUNLOAD", "NO_CHECKSUM", "NO_COMPRESSION", "NO_EVENT_LOSS", "NOT", "NOTIFICATION", 
  "NTLM", "NULL", "NULLIF", "OF", "OFF", "OFFSETS", "OLD_PASSWORD", "ON", 
  "ON_FAILURE", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", 
  "OPTION", "OR", "ORDER", "OUTER", "OVER", "PAGE", "PARAM_NODE", "PARTIAL", 
  "PASSWORD", "PATINDEX", "PERCENT", "PERMISSION_SET", "PER_CPU", "PER_DB", 
  "PER_NODE", "PIVOT", "PLAN", "PLATFORM", "POLICY", "PRECISION", "PREDICATE", 
  "PRIMARY", "PRINT", "PROC", "PROCEDURE", "PROCESS", "PUBLIC", "PYTHON", 
  "R", "RAISERROR", "RAND", "RAW", "READ", "READTEXT", "READ_WRITE_FILEGROUPS", 
  "RECONFIGURE", "REFERENCES", "REGENERATE", "RELATED_CONVERSATION", "RELATED_CONVERSATION_GROUP", 
  "REPLACE", "REPLICATION", "REQUIRED", "RESET", "RESTART", "RESTORE", "RESTRICT", 
  "RESUME", "RETAINDAYS", "RETURN", "RETURNS", "REVERT", "REVOKE", "REWIND", 
  "RIGHT", "ROLLBACK", "ROLE", "ROUND", "ROWCOUNT", "ROWGUIDCOL", "RSA_512", 
  "RSA_1024", "RSA_2048", "RSA_3072", "RSA_4096", "RTRIM", "SAFETY", "RULE", 
  "SAFE", "SAVE", "SCHEDULER", "SCHEMA", "SCHEME", "SECURITYAUDIT", "SELECT", 
  "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", "SEMANTICSIMILARITYTABLE", 
  "SERVER", "SERVICE", "SERVICE_BROKER", "SERVICE_NAME", "SESSION", "SESSION_USER", 
  "SESSIONPROPERTY", "SET", "SETUSER", "SIGN", "SHUTDOWN", "SID", "SKIP_KEYWORD", 
  "SOFTNUMA", "SOME", "SOURCE", "SPACE", "SPECIFICATION", "SPLIT", "SQLDUMPERFLAGS", 
  "SQLDUMPERPATH", "SQLDUMPERTIMEOUT", "STATISTICS", "STATE", "STATS", "START", 
  "STARTED", "STARTUP_STATE", "STOP", "STOPPED", "STOP_ON_ERROR", "STR", 
  "SUPPORTED", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "TAPE", "TARGET", 
  "TCP", "TEXTSIZE", "THEN", "TO", "TOP", "TRACK_CAUSALITY", "TRAN", "TRANSACTION", 
  "TRANSFER", "TRIGGER", "TRUNCATE", "TSEQUAL", "UNCHECKED", "UNION", "UNIQUE", 
  "UNLOCK", "UNPIVOT", "UNSAFE", "UPDATE", "UPDATETEXT", "UPPER", "URL", 
  "USE", "USED", "USER", "USER_NAME", "VALUES", "VARYING", "VERBOSELOGGING", 
  "VIEW", "VISIBILITY", "WAITFOR", "WHEN", "WHERE", "WHILE", "WINDOWS", 
  "WITH", "WITHIN", "WITHOUT", "WITNESS", "WRITETEXT", "YEAR", "ABSOLUTE", 
  "ACCENT_SENSITIVITY", "ACTION", "ACTIVATION", "ACTIVE", "ADDRESS", "AES_128", 
  "AES_192", "AES_256", "AFFINITY", "AFTER", "AGGREGATE", "ALGORITHM", "ALLOW_ENCRYPTED_VALUE_MODIFICATIONS", 
  "ALLOW_SNAPSHOT_ISOLATION", "ALLOWED", "ANSI_NULL_DEFAULT", "ANSI_NULLS", 
  "ANSI_PADDING", "ANSI_WARNINGS", "APPLICATION_LOG", "APPLY", "ARITHABORT", 
  "ASSEMBLY", "AUDIT", "AUDIT_GUID", "AUTO", "AUTO_CLEANUP", "AUTO_CLOSE", 
  "AUTO_CREATE_STATISTICS", "AUTO_SHRINK", "AUTO_UPDATE_STATISTICS", "AUTO_UPDATE_STATISTICS_ASYNC", 
  "AVAILABILITY", "AVG", "BACKUP_PRIORITY", "BEGIN_DIALOG", "BIGINT", "BINARY_BASE64", 
  "BINARY_CHECKSUM", "BINDING", "BLOB_STORAGE", "BROKER", "BROKER_INSTANCE", 
  "BULK_LOGGED", "CALLER", "CAP_CPU_PERCENT", "CAST", "CATALOG", "CATCH", 
  "CHANGE_RETENTION", "CHANGE_TRACKING", "CHECKSUM", "CHECKSUM_AGG", "CLEANUP", 
  "COLLECTION", "COLUMN_MASTER_KEY", "COMMITTED", "COMPATIBILITY_LEVEL", 
  "CONCAT", "CONCAT_NULL_YIELDS_NULL", "CONTENT", "CONTROL", "COOKIE", "COUNT", 
  "COUNT_BIG", "COUNTER", "CPU", "CREATE_NEW", "CREATION_DISPOSITION", "CREDENTIAL", 
  "CRYPTOGRAPHIC", "CURSOR_CLOSE_ON_COMMIT", "CURSOR_DEFAULT", "DATA", "DATALENGTH", 
  "DATE_CORRELATION_OPTIMIZATION", "DATEADD", "DATEDIFF", "DATENAME", "DATEPART", 
  "DAY", "DAYS", "DB_CHAINING", "DB_FAILOVER", "DECRYPTION", "DEFAULT_DOUBLE_QUOTE", 
  "DEFAULT_FULLTEXT_LANGUAGE", "DEFAULT_LANGUAGE", "DELAY", "DELAYED_DURABILITY", 
  "DELETED", "DENSE_RANK", "DEPENDENTS", "DES", "DESCRIPTION", "DESX", "DHCP", 
  "DIALOG", "DIRECTORY_NAME", "DISABLE", "DISABLE_BROKER", "DISABLED", "DISK_DRIVE", 
  "DOCUMENT", "DYNAMIC", "ELEMENTS", "EMERGENCY", "EMPTY", "ENABLE", "ENABLE_BROKER", 
  "ENCRYPTED_VALUE", "ENCRYPTION", "ENDPOINT_URL", "ERROR_BROKER_CONVERSATIONS", 
  "EXCLUSIVE", "EXECUTABLE", "EXIST", "EXPAND", "EXPIRY_DATE", "EXPLICIT", 
  "FAIL_OPERATION", "FAILOVER_MODE", "FAILURE", "FAILURE_CONDITION_LEVEL", 
  "FAST", "FAST_FORWARD", "FILEGROUP", "FILEGROWTH", "FILEPATH", "FILESTREAM", 
  "FILTER", "FIRST", "FIRST_VALUE", "FOLLOWING", "FORCE", "FORCE_FAILOVER_ALLOW_DATA_LOSS", 
  "FORCED", "FORMAT", "FORWARD_ONLY", "FULLSCAN", "FULLTEXT", "GB", "GETDATE", 
  "GETUTCDATE", "GLOBAL", "GO", "GROUP_MAX_REQUESTS", "GROUPING", "GROUPING_ID", 
  "HADR", "HASH", "HEALTH_CHECK_TIMEOUT", "HIGH", "HONOR_BROKER_PRIORITY", 
  "HOURS", "IDENTITY_VALUE", "IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX", "IMMEDIATE", 
  "IMPERSONATE", "IMPORTANCE", "INCLUDE_NULL_VALUES", "INCREMENTAL", "INITIATOR", 
  "INPUT", "INSENSITIVE", "INSERTED", "INT", "IP", "ISOLATION", "JOB", "JSON", 
  "KB", "KEEP", "KEEPFIXED", "KEY_SOURCE", "KEYS", "KEYSET", "LAG", "LAST", 
  "LAST_VALUE", "LEAD", "LEVEL", "LIST", "LISTENER", "LISTENER_URL", "LOB_COMPACTION", 
  "LOCAL", "LOCATION", "LOCK", "LOCK_ESCALATION", "LOGIN", "LOOP", "LOW", 
  "MANUAL", "MARK", "MATERIALIZED", "MAX", "MAX_CPU_PERCENT", "MAX_DOP", 
  "MAX_FILES", "MAX_IOPS_PER_VOLUME", "MAX_MEMORY_PERCENT", "MAX_PROCESSES", 
  "MAX_QUEUE_READERS", "MAX_ROLLOVER_FILES", "MAXDOP", "MAXRECURSION", "MAXSIZE", 
  "MB", "MEDIUM", "MEMORY_OPTIMIZED_DATA", "MESSAGE", "MIN", "MIN_ACTIVE_ROWVERSION", 
  "MIN_CPU_PERCENT", "MIN_IOPS_PER_VOLUME", "MIN_MEMORY_PERCENT", "MINUTES", 
  "MIRROR_ADDRESS", "MIXED_PAGE_ALLOCATION", "MODE", "MODIFY", "MOVE", "MULTI_USER", 
  "NAME", "NESTED_TRIGGERS", "NEW_ACCOUNT", "NEW_BROKER", "NEW_PASSWORD", 
  "NEXT", "NO", "NO_TRUNCATE", "NO_WAIT", "NOCOUNT", "NODES", "NOEXPAND", 
  "NON_TRANSACTED_ACCESS", "NORECOMPUTE", "NORECOVERY", "NOWAIT", "NTILE", 
  "NUMANODE", "NUMBER", "NUMERIC_ROUNDABORT", "OBJECT", "OFFLINE", "OFFSET", 
  "OLD_ACCOUNT", "ONLINE", "ONLY", "OPEN_EXISTING", "OPTIMISTIC", "OPTIMIZE", 
  "OUT", "OUTPUT", "OVERRIDE", "OWNER", "PAGE_VERIFY", "PARAMETERIZATION", 
  "PARTITION", "PARTITIONS", "PARTNER", "PATH", "POISON_MESSAGE_HANDLING", 
  "POOL", "PORT", "PRECEDING", "PRIMARY_ROLE", "PRIOR", "PRIORITY", "PRIORITY_LEVEL", 
  "PRIVATE", "PRIVATE_KEY", "PRIVILEGES", "PROCEDURE_NAME", "PROPERTY", 
  "PROVIDER", "PROVIDER_KEY_NAME", "QUERY", "QUEUE", "QUEUE_DELAY", "QUOTED_IDENTIFIER", 
  "RANGE", "RANK", "RC2", "RC4", "RC4_128", "READ_COMMITTED_SNAPSHOT", "READ_ONLY", 
  "READ_ONLY_ROUTING_LIST", "READ_WRITE", "READONLY", "REBUILD", "RECEIVE", 
  "RECOMPILE", "RECOVERY", "RECURSIVE_TRIGGERS", "RELATIVE", "REMOTE", "REMOTE_SERVICE_NAME", 
  "REMOVE", "REORGANIZE", "REPEATABLE", "REPLICA", "REQUEST_MAX_CPU_TIME_SEC", 
  "REQUEST_MAX_MEMORY_GRANT_PERCENT", "REQUEST_MEMORY_GRANT_TIMEOUT_SEC", 
  "REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT", "RESERVE_DISK_SPACE", "RESOURCE", 
  "RESOURCE_MANAGER_LOCATION", "RESTRICTED_USER", "RETENTION", "ROBUST", 
  "ROOT", "ROUTE", "ROW", "ROW_NUMBER", "ROWGUID", "ROWS", "SAMPLE", "SCHEMABINDING", 
  "SCOPED", "SCROLL", "SCROLL_LOCKS", "SEARCH", "SECONDARY", "SECONDARY_ONLY", 
  "SECONDARY_ROLE", "SECONDS", "SECRET", "SECURITY", "SECURITY_LOG", "SEEDING_MODE", 
  "SELF", "SEMI_SENSITIVE", "SEND", "SENT", "SEQUENCE", "SERIALIZABLE", 
  "SESSION_TIMEOUT", "SETERROR", "SHARE", "SHOWPLAN", "SIGNATURE", "SIMPLE", 
  "SINGLE_USER", "SIZE", "SMALLINT", "SNAPSHOT", "SPATIAL_WINDOW_MAX_CELLS", 
  "STANDBY", "START_DATE", "STATIC", "STATS_STREAM", "STATUS", "STATUSONLY", 
  "STDEV", "STDEVP", "STOPLIST", "STRING_AGG", "STUFF", "SUBJECT", "SUBSCRIPTION", 
  "SUBSTRING", "SUM", "SUSPEND", "SYMMETRIC", "SYNCHRONOUS_COMMIT", "SYNONYM", 
  "SYSTEM", "TAKE", "TARGET_RECOVERY_TIME", "TB", "TEXTIMAGE_ON", "THROW", 
  "TIES", "TIME", "TIMEOUT", "TIMER", "TINYINT", "TORN_PAGE_DETECTION", 
  "TRANSFORM_NOISE_WORDS", "TRIPLE_DES", "TRIPLE_DES_3KEY", "TRUSTWORTHY", 
  "TRY", "TSQL", "TWO_DIGIT_YEAR_CUTOFF", "TYPE", "TYPE_WARNING", "UNBOUNDED", 
  "UNCOMMITTED", "UNKNOWN", "UNLIMITED", "UOW", "USING", "VALID_XML", "VALIDATION", 
  "VALUE", "VAR", "VARP", "VIEW_METADATA", "VIEWS", "WAIT", "WELL_FORMED_XML", 
  "WITHOUT_ARRAY_WRAPPER", "WORK", "WORKLOAD", "XML", "XMLDATA", "XMLNAMESPACES", 
  "XMLSCHEMA", "XSINIL", "DOLLAR_ACTION", "WHITE_SPACE", "COMMENT", "LINE_COMMENT", 
  "DOUBLE_QUOTE_ID", "SINGLE_QUOTE", "SQUARE_BRACKET_ID", "LOCAL_ID", "DECIMAL", 
  "ID", "QUOTED_URL", "QUOTED_HOST_AND_PORT", "STRING", "BINARY", "FLOAT", 
  "REAL", "EQUAL", "GREATER", "LESS", "EXCLAMATION", "PLUS_ASSIGN", "MINUS_ASSIGN", 
  "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", 
  "OR_ASSIGN", "DOUBLE_BAR", "DOT", "UNDERLINE", "AT", "SHARP", "DOLLAR", 
  "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "COLON", "STAR", "DIVIDE", 
  "MODULE", "PLUS", "MINUS", "BIT_NOT", "BIT_OR", "BIT_AND", "BIT_XOR", 
  "IPV4_OCTECT"
};

dfa::Vocabulary TSqlParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> TSqlParser::_tokenNames;

TSqlParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x366, 0x12b0, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 
       0x4, 0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 
       0x9, 0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 
       0xa, 0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 
       0x4, 0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 
       0x11, 0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 
       0x14, 0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 
       0x17, 0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 
       0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 
       0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 
       0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 
       0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 
       0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 
       0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 
       0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 
       0x2f, 0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 
       0x32, 0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 
       0x35, 0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 
       0x38, 0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 
       0x3b, 0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 
       0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 
       0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 
       0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 
       0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 
       0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 
       0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 
       0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 
       0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 
       0x56, 0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 
       0x59, 0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 
       0x5c, 0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 
       0x5f, 0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 
       0x62, 0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 
       0x65, 0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 
       0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 
       0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 
       0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 
       0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 
       0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 
       0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 
       0x7a, 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 
       0x7d, 0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 
       0x80, 0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 
       0x83, 0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 
       0x86, 0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 
       0x89, 0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 
       0x8c, 0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 
       0x8f, 0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 
       0x92, 0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 
       0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 
       0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 
       0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 
       0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 
       0xa1, 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 
       0xa4, 0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 
       0xa7, 0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 
       0xaa, 0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 
       0xad, 0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 
       0xb0, 0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 
       0xb3, 0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 
       0xb6, 0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 
       0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 
       0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 
       0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 
       0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 
       0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 
       0xc8, 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 
       0xcb, 0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 
       0xce, 0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 
       0xd1, 0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 
       0xd4, 0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 
       0xd7, 0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 
       0xda, 0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 
       0xdd, 0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 
       0xe0, 0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 
       0xe3, 0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, 0x4, 0xe5, 0x9, 0xe5, 0x4, 
       0xe6, 0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, 0xe8, 0x9, 0xe8, 0x4, 
       0xe9, 0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, 0x9, 0xeb, 0x4, 
       0xec, 0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, 0xee, 0x4, 
       0xef, 0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, 0x4, 
       0xf2, 0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, 
       0xf5, 0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 
       0xf8, 0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 
       0xfb, 0x9, 0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x4, 
       0xfe, 0x9, 0xfe, 0x4, 0xff, 0x9, 0xff, 0x3, 0x2, 0x7, 0x2, 0x200, 
       0xa, 0x2, 0xc, 0x2, 0xe, 0x2, 0x203, 0xb, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x3, 0x3, 0x3, 0x7, 0x3, 0x209, 0xa, 0x3, 0xc, 0x3, 0xe, 0x3, 
       0x20c, 0xb, 0x3, 0x3, 0x3, 0x5, 0x3, 0x20f, 0xa, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x7, 0x3, 0x213, 0xa, 0x3, 0xc, 0x3, 0xe, 0x3, 0x216, 0xb, 0x3, 
       0x5, 0x3, 0x218, 0xa, 0x3, 0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x21c, 0xa, 
       0x4, 0x6, 0x4, 0x21e, 0xa, 0x4, 0xd, 0x4, 0xe, 0x4, 0x21f, 0x3, 0x5, 
       0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x228, 
       0xa, 0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 
       0x6, 0x22f, 0xa, 0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 
       0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 
       0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 
       0x7, 0x3, 0x7, 0x5, 0x7, 0x244, 0xa, 0x7, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x5, 0x8, 0x252, 0xa, 0x8, 0x3, 0x9, 
       0x3, 0x9, 0x5, 0x9, 0x256, 0xa, 0x9, 0x3, 0x9, 0x5, 0x9, 0x259, 0xa, 
       0x9, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x25d, 0xa, 0x9, 0x3, 0xa, 0x3, 
       0xa, 0x5, 0xa, 0x261, 0xa, 0xa, 0x3, 0xb, 0x3, 0xb, 0x5, 0xb, 0x265, 
       0xa, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x26a, 0xa, 0xc, 
       0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x26f, 0xa, 0xc, 0x5, 0xc, 
       0x271, 0xa, 0xc, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x275, 0xa, 0xd, 0x3, 
       0xd, 0x5, 0xd, 0x278, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 
       0xe, 0x3, 0xe, 0x5, 0xe, 0x27f, 0xa, 0xe, 0x3, 0xe, 0x5, 0xe, 0x282, 
       0xa, 0xe, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 
       0xf, 0x3, 0xf, 0x5, 0xf, 0x28b, 0xa, 0xf, 0x3, 0xf, 0x5, 0xf, 0x28e, 
       0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 0x3, 0x11, 0x3, 0x11, 0x3, 0x12, 
       0x3, 0x12, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x299, 0xa, 
       0x13, 0x3, 0x13, 0x5, 0x13, 0x29c, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x5, 0x13, 0x2a1, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 
       0x13, 0x5, 0x13, 0x2a6, 0xa, 0x13, 0x3, 0x13, 0x5, 0x13, 0x2a9, 0xa, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x2ae, 0xa, 0x13, 
       0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2b2, 0xa, 0x14, 0x3, 0x14, 0x5, 
       0x14, 0x2b5, 0xa, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2b9, 0xa, 
       0x14, 0x3, 0x14, 0x5, 0x14, 0x2bc, 0xa, 0x14, 0x3, 0x14, 0x5, 0x14, 
       0x2bf, 0xa, 0x14, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x5, 0x15, 0x2c6, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 
       0x2ca, 0xa, 0x15, 0x5, 0x15, 0x2cc, 0xa, 0x15, 0x3, 0x16, 0x3, 0x16, 
       0x3, 0x16, 0x5, 0x16, 0x2d1, 0xa, 0x16, 0x3, 0x16, 0x3, 0x16, 0x7, 
       0x16, 0x2d5, 0xa, 0x16, 0xc, 0x16, 0xe, 0x16, 0x2d8, 0xb, 0x16, 0x3, 
       0x16, 0x5, 0x16, 0x2db, 0xa, 0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x7, 0x17, 0x2e6, 0xa, 0x17, 0xc, 0x17, 0xe, 0x17, 0x2e9, 0xb, 0x17, 
       0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x5, 0x17, 0x2ee, 0xa, 0x17, 0x3, 
       0x17, 0x5, 0x17, 0x2f1, 0xa, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x3, 0x17, 0x3, 0x17, 0x7, 0x17, 0x2f8, 0xa, 0x17, 0xc, 0x17, 0xe, 
       0x17, 0x2fb, 0xb, 0x17, 0x5, 0x17, 0x2fd, 0xa, 0x17, 0x3, 0x18, 0x3, 
       0x18, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 
       0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 
       0x19, 0x3, 0x19, 0x3, 0x19, 0x5, 0x19, 0x30f, 0xa, 0x19, 0x3, 0x1a, 
       0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x315, 0xa, 0x1a, 0x3, 
       0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x31a, 0xa, 0x1a, 0x3, 0x1a, 
       0x3, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 
       0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1f, 0x3, 0x1f, 
       0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x32d, 0xa, 
       0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 
       0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x5, 
       0x21, 0x33a, 0xa, 0x21, 0x3, 0x21, 0x5, 0x21, 0x33d, 0xa, 0x21, 0x3, 
       0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x3, 0x22, 0x5, 0x22, 0x347, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 
       0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x34d, 0xa, 0x22, 0x6, 0x22, 0x34f, 
       0xa, 0x22, 0xd, 0x22, 0xe, 0x22, 0x350, 0x3, 0x22, 0x3, 0x22, 0x5, 
       0x22, 0x355, 0xa, 0x22, 0x3, 0x23, 0x5, 0x23, 0x358, 0xa, 0x23, 0x3, 
       0x23, 0x5, 0x23, 0x35b, 0xa, 0x23, 0x3, 0x23, 0x5, 0x23, 0x35e, 0xa, 
       0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 
       0x23, 0x365, 0xa, 0x23, 0x6, 0x23, 0x367, 0xa, 0x23, 0xd, 0x23, 0xe, 
       0x23, 0x368, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 
       0x5, 0x24, 0x370, 0xa, 0x24, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x5, 0x25, 0x377, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 
       0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x37d, 0xa, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x38a, 0xa, 0x25, 
       0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x38e, 0xa, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x5, 0x25, 0x393, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 
       0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 
       0x5, 0x25, 0x39d, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x3a6, 0xa, 0x25, 
       0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x3aa, 0xa, 0x25, 0x3, 0x26, 0x3, 
       0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 
       0x26, 0x3, 0x26, 0x5, 0x26, 0x3b5, 0xa, 0x26, 0x3, 0x26, 0x3, 0x26, 
       0x5, 0x26, 0x3b9, 0xa, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x5, 
       0x26, 0x3be, 0xa, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 
       0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 
       0x3c9, 0xa, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 
       0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 0x3d3, 0xa, 0x27, 
       0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 
       0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 0x3df, 0xa, 
       0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x7, 0x27, 0x3e5, 
       0xa, 0x27, 0xc, 0x27, 0xe, 0x27, 0x3e8, 0xb, 0x27, 0x3, 0x28, 0x3, 
       0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x5, 
       0x28, 0x3f1, 0xa, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 
       0x3, 0x28, 0x5, 0x28, 0x3f8, 0xa, 0x28, 0x3, 0x29, 0x3, 0x29, 0x3, 
       0x29, 0x3, 0x29, 0x5, 0x29, 0x3fe, 0xa, 0x29, 0x3, 0x29, 0x5, 0x29, 
       0x401, 0xa, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x5, 0x29, 0x406, 
       0xa, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x5, 0x2a, 0x40d, 0xa, 0x2a, 0x5, 0x2a, 0x40f, 0xa, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x415, 0xa, 0x2a, 0x5, 
       0x2a, 0x417, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x41f, 0xa, 0x2a, 0x5, 0x2a, 0x421, 
       0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 
       0x427, 0xa, 0x2a, 0x5, 0x2a, 0x429, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x42f, 0xa, 0x2a, 0x5, 0x2a, 0x431, 
       0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x5, 0x2a, 0x438, 0xa, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x43b, 0xa, 0x2a, 
       0x5, 0x2a, 0x43d, 0xa, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x440, 0xa, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x444, 0xa, 0x2a, 0x5, 0x2a, 0x446, 
       0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x44f, 0xa, 0x2a, 0x3, 0x2b, 0x3, 
       0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x455, 0xa, 0x2b, 0x3, 0x2b, 
       0x3, 0x2b, 0x5, 0x2b, 0x459, 0xa, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x3, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x461, 0xa, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 
       0x468, 0xa, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 
       0x2c, 0x46e, 0xa, 0x2c, 0x5, 0x2c, 0x470, 0xa, 0x2c, 0x3, 0x2d, 0x3, 
       0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 
       0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x47c, 0xa, 0x2e, 0x3, 0x2f, 
       0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x5, 0x2f, 
       0x484, 0xa, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 
       0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x5, 
       0x2f, 0x490, 0xa, 0x2f, 0x3, 0x30, 0x5, 0x30, 0x493, 0xa, 0x30, 0x3, 
       0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 
       0x30, 0x49b, 0xa, 0x30, 0x5, 0x30, 0x49d, 0xa, 0x30, 0x3, 0x30, 0x5, 
       0x30, 0x4a0, 0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x4a4, 0xa, 
       0x30, 0x3, 0x30, 0x5, 0x30, 0x4a7, 0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 
       0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 
       0x5, 0x30, 0x4b1, 0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x7, 0x30, 0x4b5, 
       0xa, 0x30, 0xc, 0x30, 0xe, 0x30, 0x4b8, 0xb, 0x30, 0x3, 0x30, 0x3, 
       0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x4bf, 0xa, 0x30, 
       0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x4c3, 0xa, 0x30, 0x3, 0x30, 0x3, 
       0x30, 0x5, 0x30, 0x4c7, 0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 
       0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x4d0, 0xa, 
       0x30, 0x3, 0x30, 0x3, 0x30, 0x7, 0x30, 0x4d4, 0xa, 0x30, 0xc, 0x30, 
       0xe, 0x30, 0x4d7, 0xb, 0x30, 0x3, 0x30, 0x5, 0x30, 0x4da, 0xa, 0x30, 
       0x3, 0x30, 0x5, 0x30, 0x4dd, 0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 
       0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x7, 0x31, 0x4e6, 
       0xa, 0x31, 0xc, 0x31, 0xe, 0x31, 0x4e9, 0xb, 0x31, 0x3, 0x31, 0x5, 
       0x31, 0x4ec, 0xa, 0x31, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 
       0x3, 0x32, 0x5, 0x32, 0x4f3, 0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 
       0x32, 0x5, 0x32, 0x4f8, 0xa, 0x32, 0x3, 0x33, 0x5, 0x33, 0x4fb, 0xa, 
       0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 
       0x33, 0x5, 0x33, 0x503, 0xa, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 
       0x507, 0xa, 0x33, 0x3, 0x33, 0x5, 0x33, 0x50a, 0xa, 0x33, 0x3, 0x33, 
       0x3, 0x33, 0x5, 0x33, 0x50e, 0xa, 0x33, 0x3, 0x33, 0x5, 0x33, 0x511, 
       0xa, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x515, 0xa, 0x33, 0x3, 
       0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x51c, 
       0xa, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x520, 0xa, 0x33, 0x5, 
       0x33, 0x522, 0xa, 0x33, 0x5, 0x33, 0x524, 0xa, 0x33, 0x3, 0x33, 0x5, 
       0x33, 0x527, 0xa, 0x33, 0x3, 0x33, 0x5, 0x33, 0x52a, 0xa, 0x33, 0x3, 
       0x33, 0x5, 0x33, 0x52d, 0xa, 0x33, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 
       0x3, 0x34, 0x5, 0x34, 0x533, 0xa, 0x34, 0x3, 0x35, 0x5, 0x35, 0x536, 
       0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 
       0x3, 0x35, 0x5, 0x35, 0x53e, 0xa, 0x35, 0x5, 0x35, 0x540, 0xa, 0x35, 
       0x3, 0x35, 0x5, 0x35, 0x543, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x5, 
       0x35, 0x547, 0xa, 0x35, 0x3, 0x35, 0x5, 0x35, 0x54a, 0xa, 0x35, 0x3, 
       0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x5, 0x35, 0x550, 0xa, 0x35, 
       0x3, 0x35, 0x5, 0x35, 0x553, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x5, 
       0x35, 0x557, 0xa, 0x35, 0x3, 0x35, 0x5, 0x35, 0x55a, 0xa, 0x35, 0x3, 
       0x35, 0x5, 0x35, 0x55d, 0xa, 0x35, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 
       0x3, 0x36, 0x3, 0x36, 0x5, 0x36, 0x564, 0xa, 0x36, 0x3, 0x37, 0x5, 
       0x37, 0x567, 0xa, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 
       0x3, 0x37, 0x5, 0x37, 0x56e, 0xa, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 
       0x37, 0x3, 0x37, 0x5, 0x37, 0x574, 0xa, 0x37, 0x7, 0x37, 0x576, 0xa, 
       0x37, 0xc, 0x37, 0xe, 0x37, 0x579, 0xb, 0x37, 0x3, 0x37, 0x3, 0x37, 
       0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 
       0x582, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x585, 0xa, 0x37, 0x3, 0x38, 
       0x5, 0x38, 0x588, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x58c, 
       0xa, 0x38, 0x3, 0x38, 0x5, 0x38, 0x58f, 0xa, 0x38, 0x3, 0x38, 0x5, 
       0x38, 0x592, 0xa, 0x38, 0x3, 0x38, 0x5, 0x38, 0x595, 0xa, 0x38, 0x3, 
       0x39, 0x3, 0x39, 0x5, 0x39, 0x599, 0xa, 0x39, 0x3, 0x3a, 0x5, 0x3a, 
       0x59c, 0xa, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 
       0x3a, 0x3, 0x3a, 0x5, 0x3a, 0x5a4, 0xa, 0x3a, 0x5, 0x3a, 0x5a6, 0xa, 
       0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x5, 0x3a, 0x5aa, 0xa, 0x3a, 0x3, 0x3a, 
       0x5, 0x3a, 0x5ad, 0xa, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 
       0x3a, 0x7, 0x3a, 0x5b3, 0xa, 0x3a, 0xc, 0x3a, 0xe, 0x3a, 0x5b6, 0xb, 
       0x3a, 0x3, 0x3a, 0x5, 0x3a, 0x5b9, 0xa, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 
       0x5, 0x3a, 0x5bd, 0xa, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 
       0x3a, 0x3, 0x3a, 0x5, 0x3a, 0x5c4, 0xa, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 
       0x5, 0x3a, 0x5c8, 0xa, 0x3a, 0x5, 0x3a, 0x5ca, 0xa, 0x3a, 0x5, 0x3a, 
       0x5cc, 0xa, 0x3a, 0x3, 0x3a, 0x5, 0x3a, 0x5cf, 0xa, 0x3a, 0x3, 0x3a, 
       0x5, 0x3a, 0x5d2, 0xa, 0x3a, 0x3, 0x3a, 0x5, 0x3a, 0x5d5, 0xa, 0x3a, 
       0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x7, 0x3b, 0x5db, 0xa, 
       0x3b, 0xc, 0x3b, 0xe, 0x3b, 0x5de, 0xb, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 
       0x3, 0x3b, 0x5, 0x3b, 0x5e3, 0xa, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 
       0x3b, 0x3, 0x3b, 0x5, 0x3b, 0x5e9, 0xa, 0x3b, 0x5, 0x3b, 0x5eb, 0xa, 
       0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x5, 0x3c, 0x5ef, 0xa, 0x3c, 0x3, 0x3c, 
       0x5, 0x3c, 0x5f2, 0xa, 0x3c, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 
       0x3d, 0x5f7, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 
       0x5fc, 0xa, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x5ff, 0xa, 0x3d, 0x3, 0x3e, 
       0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x5, 0x3e, 
       0x607, 0xa, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x5, 0x3e, 0x60b, 0xa, 0x3e, 
       0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x7, 0x3e, 0x610, 0xa, 0x3e, 0xc, 
       0x3e, 0xe, 0x3e, 0x613, 0xb, 0x3e, 0x5, 0x3e, 0x615, 0xa, 0x3e, 0x3, 
       0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x7, 0x3e, 0x61c, 
       0xa, 0x3e, 0xc, 0x3e, 0xe, 0x3e, 0x61f, 0xb, 0x3e, 0x5, 0x3e, 0x621, 
       0xa, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x5, 0x3e, 0x625, 0xa, 0x3e, 0x3, 
       0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x7, 0x3e, 0x62b, 0xa, 0x3e, 
       0xc, 0x3e, 0xe, 0x3e, 0x62e, 0xb, 0x3e, 0x5, 0x3e, 0x630, 0xa, 0x3e, 
       0x3, 0x3f, 0x3, 0x3f, 0x5, 0x3f, 0x634, 0xa, 0x3f, 0x3, 0x3f, 0x5, 
       0x3f, 0x637, 0xa, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x3, 0x3f, 0x5, 0x3f, 0x645, 0xa, 0x3f, 0x3, 0x3f, 0x3, 
       0x3f, 0x5, 0x3f, 0x649, 0xa, 0x3f, 0x3, 0x3f, 0x5, 0x3f, 0x64c, 0xa, 
       0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x5, 0x3f, 0x650, 0xa, 0x3f, 0x3, 0x3f, 
       0x5, 0x3f, 0x653, 0xa, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x5, 
       0x40, 0x658, 0xa, 0x40, 0x3, 0x40, 0x5, 0x40, 0x65b, 0xa, 0x40, 0x3, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x5, 0x40, 0x661, 0xa, 0x40, 
       0x3, 0x40, 0x5, 0x40, 0x664, 0xa, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x7, 0x40, 0x669, 0xa, 0x40, 0xc, 0x40, 0xe, 0x40, 0x66c, 0xb, 
       0x40, 0x3, 0x40, 0x5, 0x40, 0x66f, 0xa, 0x40, 0x5, 0x40, 0x671, 0xa, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x7, 0x40, 0x677, 
       0xa, 0x40, 0xc, 0x40, 0xe, 0x40, 0x67a, 0xb, 0x40, 0x5, 0x40, 0x67c, 
       0xa, 0x40, 0x3, 0x40, 0x3, 0x40, 0x5, 0x40, 0x680, 0xa, 0x40, 0x3, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 
       0x41, 0x688, 0xa, 0x41, 0x3, 0x41, 0x5, 0x41, 0x68b, 0xa, 0x41, 0x3, 
       0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x7, 
       0x41, 0x693, 0xa, 0x41, 0xc, 0x41, 0xe, 0x41, 0x696, 0xb, 0x41, 0x3, 
       0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 0x41, 0x69c, 0xa, 0x41, 
       0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 0x41, 0x6a1, 0xa, 0x41, 0x3, 
       0x41, 0x5, 0x41, 0x6a4, 0xa, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 
       0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x7, 0x42, 0x6ac, 0xa, 0x42, 0xc, 
       0x42, 0xe, 0x42, 0x6af, 0xb, 0x42, 0x5, 0x42, 0x6b1, 0xa, 0x42, 0x3, 
       0x42, 0x5, 0x42, 0x6b4, 0xa, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 
       0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 0x42, 0x6bc, 0xa, 0x42, 0x3, 
       0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 
       0x43, 0x7, 0x43, 0x6c5, 0xa, 0x43, 0xc, 0x43, 0xe, 0x43, 0x6c8, 0xb, 
       0x43, 0x5, 0x43, 0x6ca, 0xa, 0x43, 0x3, 0x43, 0x5, 0x43, 0x6cd, 0xa, 
       0x43, 0x3, 0x43, 0x3, 0x43, 0x7, 0x43, 0x6d1, 0xa, 0x43, 0xc, 0x43, 
       0xe, 0x43, 0x6d4, 0xb, 0x43, 0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x6d8, 
       0xa, 0x43, 0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x6dc, 0xa, 0x43, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x7, 
       0x44, 0x6e4, 0xa, 0x44, 0xc, 0x44, 0xe, 0x44, 0x6e7, 0xb, 0x44, 0x5, 
       0x44, 0x6e9, 0xa, 0x44, 0x3, 0x44, 0x5, 0x44, 0x6ec, 0xa, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x7, 0x44, 0x6f0, 0xa, 0x44, 0xc, 0x44, 0xe, 0x44, 
       0x6f3, 0xb, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x6f8, 
       0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 
       0x3, 0x45, 0x5, 0x45, 0x700, 0xa, 0x45, 0x3, 0x45, 0x5, 0x45, 0x703, 
       0xa, 0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x707, 0xa, 0x45, 0x3, 
       0x45, 0x3, 0x45, 0x5, 0x45, 0x70b, 0xa, 0x45, 0x3, 0x45, 0x5, 0x45, 
       0x70e, 0xa, 0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x713, 
       0xa, 0x46, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 
       0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 
       0x3, 0x47, 0x5, 0x47, 0x721, 0xa, 0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 
       0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x729, 0xa, 0x48, 
       0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x72e, 0xa, 0x48, 0x3, 
       0x48, 0x7, 0x48, 0x731, 0xa, 0x48, 0xc, 0x48, 0xe, 0x48, 0x734, 0xb, 
       0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x739, 0xa, 0x48, 
       0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x73e, 0xa, 0x48, 0x3, 
       0x48, 0x5, 0x48, 0x741, 0xa, 0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 
       0x3, 0x49, 0x3, 0x49, 0x7, 0x49, 0x748, 0xa, 0x49, 0xc, 0x49, 0xe, 
       0x49, 0x74b, 0xb, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 
       0x3, 0x49, 0x7, 0x49, 0x752, 0xa, 0x49, 0xc, 0x49, 0xe, 0x49, 0x755, 
       0xb, 0x49, 0x5, 0x49, 0x757, 0xa, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x3, 
       0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x760, 
       0xa, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x7, 0x4a, 
       0x766, 0xa, 0x4a, 0xc, 0x4a, 0xe, 0x4a, 0x769, 0xb, 0x4a, 0x5, 0x4a, 
       0x76b, 0xa, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 
       0x4a, 0x5, 0x4a, 0x772, 0xa, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x775, 0xa, 
       0x4a, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x5, 0x4c, 0x7a3, 0xa, 0x4c, 0x3, 0x4c, 
       0x3, 0x4c, 0x5, 0x4c, 0x7a7, 0xa, 0x4c, 0x3, 0x4c, 0x5, 0x4c, 0x7aa, 
       0xa, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x5, 0x4d, 
       0x7b0, 0xa, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 
       0x4e, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 
       0x4f, 0x5, 0x4f, 0x7bd, 0xa, 0x4f, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 
       0x3, 0x50, 0x5, 0x50, 0x7c3, 0xa, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 
       0x50, 0x7, 0x50, 0x7c8, 0xa, 0x50, 0xc, 0x50, 0xe, 0x50, 0x7cb, 0xb, 
       0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x7, 0x50, 0x7d0, 0xa, 0x50, 
       0xc, 0x50, 0xe, 0x50, 0x7d3, 0xb, 0x50, 0x5, 0x50, 0x7d5, 0xa, 0x50, 
       0x3, 0x50, 0x5, 0x50, 0x7d8, 0xa, 0x50, 0x3, 0x51, 0x3, 0x51, 0x3, 
       0x51, 0x3, 0x51, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x7e1, 
       0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x53, 
       0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x5, 0x53, 0x7eb, 0xa, 0x53, 0x3, 
       0x53, 0x3, 0x53, 0x3, 0x53, 0x7, 0x53, 0x7f0, 0xa, 0x53, 0xc, 0x53, 
       0xe, 0x53, 0x7f3, 0xb, 0x53, 0x3, 0x53, 0x5, 0x53, 0x7f6, 0xa, 0x53, 
       0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x5, 0x54, 0x7fc, 0xa, 
       0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x7, 0x54, 0x801, 0xa, 0x54, 
       0xc, 0x54, 0xe, 0x54, 0x804, 0xb, 0x54, 0x3, 0x54, 0x5, 0x54, 0x807, 
       0xa, 0x54, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 
       0x80d, 0xa, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 0x811, 0xa, 0x55, 
       0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x817, 0xa, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x7, 0x56, 0x81c, 0xa, 0x56, 
       0xc, 0x56, 0xe, 0x56, 0x81f, 0xb, 0x56, 0x3, 0x56, 0x5, 0x56, 0x822, 
       0xa, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 
       0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x82b, 0xa, 0x57, 0x3, 0x57, 0x3, 
       0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x833, 
       0xa, 0x57, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 
       0x839, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x59, 0x3, 0x59, 0x5, 
       0x59, 0x83f, 0xa, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 
       0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 
       0x850, 0xa, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x854, 0xa, 0x5b, 
       0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 
       0x5, 0x5c, 0x85c, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x5, 0x5c, 0x860, 
       0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x7, 0x5c, 
       0x866, 0xa, 0x5c, 0xc, 0x5c, 0xe, 0x5c, 0x869, 0xb, 0x5c, 0x3, 0x5c, 
       0x5, 0x5c, 0x86c, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x5, 
       0x5c, 0x871, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x5, 0x5c, 0x875, 0xa, 
       0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x5, 
       0x5c, 0x87c, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 
       0x5, 0x5c, 0x882, 0xa, 0x5c, 0x5, 0x5c, 0x884, 0xa, 0x5c, 0x3, 0x5d, 
       0x3, 0x5d, 0x5, 0x5d, 0x888, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 
       0x5d, 0x88c, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x890, 0xa, 
       0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x893, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 
       0x5, 0x5d, 0x897, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 
       0x5d, 0x5, 0x5d, 0x89d, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 
       0x8a1, 0xa, 0x5d, 0x5, 0x5d, 0x8a3, 0xa, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 
       0x3, 0x5e, 0x3, 0x5e, 0x5, 0x5e, 0x8a9, 0xa, 0x5e, 0x3, 0x5f, 0x3, 
       0x5f, 0x5, 0x5f, 0x8ad, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 
       0x8b1, 0xa, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 
       0x60, 0x5, 0x60, 0x8b8, 0xa, 0x60, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 
       0x3, 0x61, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x63, 0x3, 0x63, 
       0x5, 0x63, 0x8c3, 0xa, 0x63, 0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x8c7, 
       0xa, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x7, 0x63, 0x8cc, 0xa, 
       0x63, 0xc, 0x63, 0xe, 0x63, 0x8cf, 0xb, 0x63, 0x5, 0x63, 0x8d1, 0xa, 
       0x63, 0x3, 0x63, 0x5, 0x63, 0x8d4, 0xa, 0x63, 0x3, 0x63, 0x3, 0x63, 
       0x3, 0x63, 0x3, 0x63, 0x7, 0x63, 0x8da, 0xa, 0x63, 0xc, 0x63, 0xe, 
       0x63, 0x8dd, 0xb, 0x63, 0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x8e1, 0xa, 
       0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x8e6, 0xa, 0x63, 
       0x3, 0x63, 0x5, 0x63, 0x8e9, 0xa, 0x63, 0x5, 0x63, 0x8eb, 0xa, 0x63, 
       0x3, 0x64, 0x3, 0x64, 0x5, 0x64, 0x8ef, 0xa, 0x64, 0x3, 0x64, 0x3, 
       0x64, 0x5, 0x64, 0x8f3, 0xa, 0x64, 0x3, 0x64, 0x5, 0x64, 0x8f6, 0xa, 
       0x64, 0x3, 0x64, 0x3, 0x64, 0x5, 0x64, 0x8fa, 0xa, 0x64, 0x3, 0x65, 
       0x3, 0x65, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x5, 0x66, 
       0x902, 0xa, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x5, 0x66, 0x907, 
       0xa, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 
       0x5, 0x66, 0x90e, 0xa, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 
       0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 
       0x66, 0x3, 0x66, 0x5, 0x66, 0x91b, 0xa, 0x66, 0x5, 0x66, 0x91d, 0xa, 
       0x66, 0x5, 0x66, 0x91f, 0xa, 0x66, 0x3, 0x66, 0x5, 0x66, 0x922, 0xa, 
       0x66, 0x3, 0x66, 0x5, 0x66, 0x925, 0xa, 0x66, 0x3, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x92c, 0xa, 0x67, 0x3, 
       0x67, 0x5, 0x67, 0x92f, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x5, 0x67, 0x935, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x5, 0x67, 0x93a, 0xa, 0x67, 0x5, 0x67, 0x93c, 0xa, 0x67, 0x3, 
       0x67, 0x5, 0x67, 0x93f, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x5, 0x67, 0x945, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x94d, 0xa, 0x67, 
       0x5, 0x67, 0x94f, 0xa, 0x67, 0x3, 0x67, 0x5, 0x67, 0x952, 0xa, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x956, 0xa, 0x67, 0x3, 0x67, 0x5, 
       0x67, 0x959, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x963, 0xa, 
       0x67, 0x3, 0x67, 0x5, 0x67, 0x966, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x5, 0x67, 0x96a, 0xa, 0x67, 0x3, 0x67, 0x5, 0x67, 0x96d, 0xa, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x973, 0xa, 
       0x67, 0x3, 0x67, 0x5, 0x67, 0x976, 0xa, 0x67, 0x5, 0x67, 0x978, 0xa, 
       0x67, 0x3, 0x68, 0x3, 0x68, 0x5, 0x68, 0x97c, 0xa, 0x68, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x981, 0xa, 0x69, 0x3, 0x6a, 0x3, 
       0x6a, 0x5, 0x6a, 0x985, 0xa, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 
       0x5, 0x6b, 0x98a, 0xa, 0x6b, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x5, 
       0x6c, 0x98f, 0xa, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 
       0x3, 0x6d, 0x3, 0x6d, 0x5, 0x6d, 0x997, 0xa, 0x6d, 0x3, 0x6d, 0x3, 
       0x6d, 0x5, 0x6d, 0x99b, 0xa, 0x6d, 0x3, 0x6d, 0x5, 0x6d, 0x99e, 0xa, 
       0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x9a3, 0xa, 0x6e, 
       0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x70, 0x3, 0x70, 
       0x5, 0x70, 0x9ab, 0xa, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 
       0x70, 0x9b0, 0xa, 0x70, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 
       0x3, 0x71, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x5, 0x72, 0x9ba, 0xa, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x74, 0x3, 0x74, 0x5, 0x74, 0x9c5, 0xa, 0x74, 
       0x3, 0x74, 0x7, 0x74, 0x9c8, 0xa, 0x74, 0xc, 0x74, 0xe, 0x74, 0x9cb, 
       0xb, 0x74, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0x9d0, 0xa, 
       0x75, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 0x9d6, 
       0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 0x9da, 0xa, 0x76, 0x3, 
       0x76, 0x5, 0x76, 0x9dd, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 
       0x9e1, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 0x9e5, 0xa, 0x76, 
       0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 
       0x5, 0x76, 0x9ed, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 
       0x76, 0x9f2, 0xa, 0x76, 0x5, 0x76, 0x9f4, 0xa, 0x76, 0x3, 0x76, 0x5, 
       0x76, 0x9f7, 0xa, 0x76, 0x3, 0x76, 0x7, 0x76, 0x9fa, 0xa, 0x76, 0xc, 
       0x76, 0xe, 0x76, 0x9fd, 0xb, 0x76, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 
       0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 0xa05, 0xa, 0x77, 0x3, 
       0x78, 0x3, 0x78, 0x5, 0x78, 0xa09, 0xa, 0x78, 0x3, 0x78, 0x3, 0x78, 
       0x3, 0x78, 0x5, 0x78, 0xa0e, 0xa, 0x78, 0x3, 0x78, 0x5, 0x78, 0xa11, 
       0xa, 0x78, 0x3, 0x78, 0x5, 0x78, 0xa14, 0xa, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x3, 0x78, 0x5, 0x78, 0xa1a, 0xa, 0x78, 0x3, 0x78, 
       0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x5, 0x78, 
       0xa22, 0xa, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x5, 0x78, 0xa2a, 0xa, 0x78, 0x3, 0x78, 0x5, 0x78, 
       0xa2d, 0xa, 0x78, 0x3, 0x78, 0x5, 0x78, 0xa30, 0xa, 0x78, 0x3, 0x79, 
       0x3, 0x79, 0x5, 0x79, 0xa34, 0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 
       0x79, 0x5, 0x79, 0xa39, 0xa, 0x79, 0x3, 0x79, 0x5, 0x79, 0xa3c, 0xa, 
       0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xa42, 
       0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xa46, 0xa, 0x79, 0x3, 
       0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xa4c, 0xa, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x5, 0x79, 0xa54, 0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 
       0x79, 0x6, 0x79, 0xa5a, 0xa, 0x79, 0xd, 0x79, 0xe, 0x79, 0xa5b, 0x3, 
       0x79, 0x5, 0x79, 0xa5f, 0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xa6e, 0xa, 
       0x79, 0x3, 0x79, 0x5, 0x79, 0xa71, 0xa, 0x79, 0x3, 0x79, 0x5, 0x79, 
       0xa74, 0xa, 0x79, 0x5, 0x79, 0xa76, 0xa, 0x79, 0x3, 0x7a, 0x3, 0x7a, 
       0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 
       0x3, 0x7a, 0x5, 0x7a, 0xa81, 0xa, 0x7a, 0x3, 0x7b, 0x3, 0x7b, 0x3, 
       0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 
       0x7b, 0x5, 0x7b, 0xa8c, 0xa, 0x7b, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 
       0x3, 0x7c, 0x3, 0x7c, 0x7, 0x7c, 0xa93, 0xa, 0x7c, 0xc, 0x7c, 0xe, 
       0x7c, 0xa96, 0xb, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 
       0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 0xa9f, 0xa, 0x7d, 0x3, 
       0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 
       0x7e, 0x3, 0x7e, 0x5, 0x7e, 0xaa9, 0xa, 0x7e, 0x5, 0x7e, 0xaab, 0xa, 
       0x7e, 0x5, 0x7e, 0xaad, 0xa, 0x7e, 0x3, 0x7e, 0x5, 0x7e, 0xab0, 0xa, 
       0x7e, 0x3, 0x7e, 0x5, 0x7e, 0xab3, 0xa, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 
       0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 
       0x3, 0x7e, 0x5, 0x7e, 0xabe, 0xa, 0x7e, 0x5, 0x7e, 0xac0, 0xa, 0x7e, 
       0x5, 0x7e, 0xac2, 0xa, 0x7e, 0x3, 0x7e, 0x5, 0x7e, 0xac5, 0xa, 0x7e, 
       0x3, 0x7f, 0x7, 0x7f, 0xac8, 0xa, 0x7f, 0xc, 0x7f, 0xe, 0x7f, 0xacb, 
       0xb, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x80, 0x3, 0x80, 
       0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x5, 0x80, 0xad5, 0xa, 0x80, 0x3, 
       0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 
       0x81, 0x5, 0x81, 0xade, 0xa, 0x81, 0x3, 0x81, 0x5, 0x81, 0xae1, 0xa, 
       0x81, 0x3, 0x81, 0x5, 0x81, 0xae4, 0xa, 0x81, 0x3, 0x81, 0x3, 0x81, 
       0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x7, 0x81, 0xaeb, 0xa, 0x81, 0xc, 
       0x81, 0xe, 0x81, 0xaee, 0xb, 0x81, 0x5, 0x81, 0xaf0, 0xa, 0x81, 0x3, 
       0x81, 0x5, 0x81, 0xaf3, 0xa, 0x81, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xafa, 0xa, 0x82, 0x3, 0x82, 0x5, 
       0x82, 0xafd, 0xa, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb0c, 0xa, 0x82, 0x3, 
       0x82, 0x5, 0x82, 0xb0f, 0xa, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb16, 0xa, 0x82, 0x3, 0x82, 0x3, 
       0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 
       0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 
       0x82, 0x5, 0x82, 0xb26, 0xa, 0x82, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 
       0xb2a, 0xa, 0x83, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 
       0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x5, 0x84, 0xb34, 0xa, 0x84, 
       0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 
       0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 
       0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x7, 0x84, 
       0xb47, 0xa, 0x84, 0xc, 0x84, 0xe, 0x84, 0xb4a, 0xb, 0x84, 0x3, 0x85, 
       0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x5, 0x85, 0xb50, 0xa, 0x85, 0x3, 
       0x86, 0x3, 0x86, 0x3, 0x86, 0x6, 0x86, 0xb55, 0xa, 0x86, 0xd, 0x86, 
       0xe, 0x86, 0xb56, 0x3, 0x86, 0x3, 0x86, 0x5, 0x86, 0xb5b, 0xa, 0x86, 
       0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x6, 0x86, 0xb61, 0xa, 
       0x86, 0xd, 0x86, 0xe, 0x86, 0xb62, 0x3, 0x86, 0x3, 0x86, 0x5, 0x86, 
       0xb67, 0xa, 0x86, 0x3, 0x86, 0x3, 0x86, 0x5, 0x86, 0xb6b, 0xa, 0x86, 
       0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 0xb71, 0xa, 
       0x87, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 
       0x88, 0x3, 0x88, 0x3, 0x88, 0x5, 0x88, 0xb7b, 0xa, 0x88, 0x3, 0x89, 
       0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x3, 0x89, 0x5, 0x89, 0xb85, 0xa, 0x89, 0x3, 0x8a, 0x3, 0x8a, 0x3, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb8c, 0xa, 0x8b, 0x3, 0x8b, 
       0x3, 0x8b, 0x3, 0x8b, 0x7, 0x8b, 0xb91, 0xa, 0x8b, 0xc, 0x8b, 0xe, 
       0x8b, 0xb94, 0xb, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 
       0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb9c, 0xa, 0x8b, 0x3, 0x8b, 0x3, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xba3, 0xa, 0x8b, 
       0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 
       0xbaa, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 
       0x8c, 0x3, 0x8d, 0x3, 0x8d, 0x5, 0x8d, 0xbb3, 0xa, 0x8d, 0x3, 0x8d, 
       0x3, 0x8d, 0x5, 0x8d, 0xbb7, 0xa, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 
       0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x5, 
       0x8d, 0xbc1, 0xa, 0x8d, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x7, 0x8e, 
       0xbc6, 0xa, 0x8e, 0xc, 0x8e, 0xe, 0x8e, 0xbc9, 0xb, 0x8e, 0x3, 0x8f, 
       0x3, 0x8f, 0x3, 0x8f, 0x7, 0x8f, 0xbce, 0xa, 0x8f, 0xc, 0x8f, 0xe, 
       0x8f, 0xbd1, 0xb, 0x8f, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x7, 0x90, 
       0xbd6, 0xa, 0x90, 0xc, 0x90, 0xe, 0x90, 0xbd9, 0xb, 0x90, 0x3, 0x91, 
       0x5, 0x91, 0xbdc, 0xa, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x92, 0x3, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xbf2, 
       0xa, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 
       0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xbfb, 0xa, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc01, 0xa, 0x92, 0x3, 0x92, 
       0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc07, 0xa, 0x92, 0x3, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc0d, 0xa, 0x92, 
       0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 
       0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc17, 0xa, 0x92, 0x3, 0x93, 0x3, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0xc1e, 0xa, 0x93, 
       0x3, 0x93, 0x7, 0x93, 0xc21, 0xa, 0x93, 0xc, 0x93, 0xe, 0x93, 0xc24, 
       0xb, 0x93, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xc28, 0xa, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x5, 0x94, 0xc2c, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xc33, 0xa, 0x94, 0x3, 
       0x95, 0x3, 0x95, 0x5, 0x95, 0xc37, 0xa, 0x95, 0x3, 0x95, 0x5, 0x95, 
       0xc3a, 0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xc3f, 
       0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xc43, 0xa, 0x95, 0x3, 
       0x95, 0x3, 0x95, 0x5, 0x95, 0xc47, 0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 
       0x3, 0x95, 0x5, 0x95, 0xc4c, 0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 
       0x95, 0x7, 0x95, 0xc51, 0xa, 0x95, 0xc, 0x95, 0xe, 0x95, 0xc54, 0xb, 
       0x95, 0x5, 0x95, 0xc56, 0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 
       0xc5a, 0xa, 0x95, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xc5f, 
       0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xc63, 0xa, 0x96, 0x3, 
       0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 
       0x97, 0x5, 0x97, 0xc6c, 0xa, 0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 
       0x3, 0x98, 0x3, 0x98, 0x5, 0x98, 0xc73, 0xa, 0x98, 0x3, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x7, 0x99, 0xc7a, 0xa, 0x99, 
       0xc, 0x99, 0xe, 0x99, 0xc7d, 0xb, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 
       0x99, 0x5, 0x99, 0xc88, 0xa, 0x99, 0x5, 0x99, 0xc8a, 0xa, 0x99, 0x3, 
       0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 
       0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xc94, 0xa, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 
       0xc97, 0xa, 0x9a, 0x3, 0x9a, 0x7, 0x9a, 0xc9a, 0xa, 0x9a, 0xc, 0x9a, 
       0xe, 0x9a, 0xc9d, 0xb, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 
       0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xca5, 0xa, 0x9a, 0x5, 0x9a, 
       0xca7, 0xa, 0x9a, 0x5, 0x9a, 0xca9, 0xa, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 
       0x3, 0x9a, 0x5, 0x9a, 0xcae, 0xa, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 
       0x9a, 0x3, 0x9a, 0x7, 0x9a, 0xcb4, 0xa, 0x9a, 0xc, 0x9a, 0xe, 0x9a, 
       0xcb7, 0xb, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xcbb, 0xa, 0x9a, 
       0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 
       0x5, 0x9a, 0xcc3, 0xa, 0x9a, 0x3, 0x9a, 0x7, 0x9a, 0xcc6, 0xa, 0x9a, 
       0xc, 0x9a, 0xe, 0x9a, 0xcc9, 0xb, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 
       0x9a, 0x5, 0x9a, 0xcce, 0xa, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 
       0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 
       0xcd8, 0xa, 0x9a, 0x5, 0x9a, 0xcda, 0xa, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 
       0x5, 0x9a, 0xcde, 0xa, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xce2, 
       0xa, 0x9a, 0x5, 0x9a, 0xce4, 0xa, 0x9a, 0x3, 0x9b, 0x3, 0x9b, 0x3, 
       0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x5, 0x9b, 0xced, 
       0xa, 0x9b, 0x5, 0x9b, 0xcef, 0xa, 0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x5, 
       0x9c, 0xcf3, 0xa, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 
       0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x7, 0x9e, 0xcfc, 0xa, 0x9e, 0xc, 
       0x9e, 0xe, 0x9e, 0xcff, 0xb, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x7, 0x9f, 0xd1e, 0xa, 0x9f, 0xc, 0x9f, 0xe, 
       0x9f, 0xd21, 0xb, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xd30, 0xa, 0x9f, 0x3, 
       0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x5, 0xa0, 0xd37, 
       0xa, 0xa0, 0x5, 0xa0, 0xd39, 0xa, 0xa0, 0x3, 0xa1, 0x3, 0xa1, 0x3, 
       0xa1, 0x7, 0xa1, 0xd3e, 0xa, 0xa1, 0xc, 0xa1, 0xe, 0xa1, 0xd41, 0xb, 
       0xa1, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x7, 0xa2, 0xd47, 
       0xa, 0xa2, 0xc, 0xa2, 0xe, 0xa2, 0xd4a, 0xb, 0xa2, 0x3, 0xa2, 0x3, 
       0xa2, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0xd51, 0xa, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 
       0xd58, 0xa, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 
       0xa4, 0x5, 0xa4, 0xd5f, 0xa, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 0xd62, 0xa, 
       0xa4, 0x3, 0xa4, 0x5, 0xa4, 0xd65, 0xa, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x5, 0xa5, 0xd6c, 0xa, 0xa5, 0x3, 
       0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x5, 0xa5, 0xd73, 
       0xa, 0xa5, 0x3, 0xa5, 0x5, 0xa5, 0xd76, 0xa, 0xa5, 0x5, 0xa5, 0xd78, 
       0xa, 0xa5, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 
       0x3, 0xa6, 0x5, 0xa6, 0xd80, 0xa, 0xa6, 0x5, 0xa6, 0xd82, 0xa, 0xa6, 
       0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x5, 0xa7, 0xd88, 0xa, 
       0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x7, 0xa8, 0xd8d, 0xa, 0xa8, 
       0xc, 0xa8, 0xe, 0xa8, 0xd90, 0xb, 0xa8, 0x3, 0xa9, 0x3, 0xa9, 0x3, 
       0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x5, 0xa9, 0xd97, 0xa, 0xa9, 0x3, 0xaa, 
       0x3, 0xaa, 0x7, 0xaa, 0xd9b, 0xa, 0xaa, 0xc, 0xaa, 0xe, 0xaa, 0xd9e, 
       0xb, 0xaa, 0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 0xda2, 0xa, 0xab, 0x3, 
       0xab, 0x3, 0xab, 0x5, 0xab, 0xda6, 0xa, 0xab, 0x3, 0xab, 0x3, 0xab, 
       0x5, 0xab, 0xdaa, 0xa, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x5, 
       0xab, 0xdaf, 0xa, 0xab, 0x5, 0xab, 0xdb1, 0xa, 0xab, 0x3, 0xab, 0x3, 
       0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 0xdb9, 
       0xa, 0xab, 0x5, 0xab, 0xdbb, 0xa, 0xab, 0x3, 0xab, 0x3, 0xab, 0x5, 
       0xab, 0xdbf, 0xa, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 
       0x3, 0xab, 0x5, 0xab, 0xdc6, 0xa, 0xab, 0x5, 0xab, 0xdc8, 0xa, 0xab, 
       0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 
       0xdcf, 0xa, 0xab, 0x5, 0xab, 0xdd1, 0xa, 0xab, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 
       0xdda, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 
       0xac, 0x3, 0xac, 0x5, 0xac, 0xde2, 0xa, 0xac, 0x3, 0xad, 0x3, 0xad, 
       0x3, 0xad, 0x7, 0xad, 0xde7, 0xa, 0xad, 0xc, 0xad, 0xe, 0xad, 0xdea, 
       0xb, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 0x5, 0xae, 0xdef, 0xa, 
       0xae, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 
       0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xb0, 0x5, 0xb0, 0xdfa, 0xa, 0xb0, 
       0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xdfe, 0xa, 0xb0, 0x5, 0xb0, 0xe00, 
       0xa, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xe03, 0xa, 0xb0, 0x3, 0xb0, 0x3, 
       0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 
       0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 
       0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 
       0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xe1b, 0xa, 0xb0, 0x3, 0xb1, 
       0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 
       0x3, 0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 
       0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x7, 0xb3, 0xe32, 0xa, 0xb3, 0xc, 0xb3, 0xe, 
       0xb3, 0xe35, 0xb, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xe39, 0xa, 
       0xb4, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 
       0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 
       0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x7, 0xb5, 0xe4b, 
       0xa, 0xb5, 0xc, 0xb5, 0xe, 0xb5, 0xe4e, 0xb, 0xb5, 0x3, 0xb5, 0x5, 
       0xb5, 0xe51, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xe55, 0xa, 
       0xb5, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb7, 0x3, 
       0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 
       0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x5, 0xb7, 0xe65, 0xa, 0xb7, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 
       0xe79, 0xa, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xeb3, 0xa, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xeb7, 0xa, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xee7, 0xa, 0xb8, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 
       0x3, 0xb8, 0x5, 0xb8, 0xef7, 0xa, 0xb8, 0x5, 0xb8, 0xef9, 0xa, 0xb8, 
       0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x5, 0xb9, 
       0xf00, 0xa, 0xb9, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 
       0xba, 0xf06, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 
       0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 
       0x3, 0xba, 0x5, 0xba, 0xf13, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 
       0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 
       0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 0xf22, 
       0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 
       0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 0xf2d, 0xa, 
       0xba, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x5, 0xbb, 0xf32, 0xa, 0xbb, 
       0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 
       0x3, 0xbb, 0x3, 0xbb, 0x5, 0xbb, 0xf3c, 0xa, 0xbb, 0x3, 0xbb, 0x3, 
       0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x5, 
       0xbb, 0xf45, 0xa, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 
       0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 
       0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbe, 0x3, 0xbe, 
       0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbf, 
       0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 
       0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc1, 0x5, 0xc1, 0xf67, 0xa, 
       0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc2, 0x5, 0xc2, 0xf6c, 0xa, 0xc2, 
       0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x5, 0xc3, 0xf72, 0xa, 
       0xc3, 0x3, 0xc4, 0x5, 0xc4, 0xf75, 0xa, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x5, 0xc4, 0xf7a, 0xa, 0xc4, 0x3, 0xc4, 0x7, 0xc4, 0xf7d, 
       0xa, 0xc4, 0xc, 0xc4, 0xe, 0xc4, 0xf80, 0xb, 0xc4, 0x3, 0xc4, 0x3, 
       0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xf88, 
       0xa, 0xc5, 0x3, 0xc5, 0x7, 0xc5, 0xf8b, 0xa, 0xc5, 0xc, 0xc5, 0xe, 
       0xc5, 0xf8e, 0xb, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc6, 0x5, 0xc6, 
       0xf93, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 
       0xc6, 0x7, 0xc6, 0xf9a, 0xa, 0xc6, 0xc, 0xc6, 0xe, 0xc6, 0xf9d, 0xb, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x7, 
       0xc6, 0xfa4, 0xa, 0xc6, 0xc, 0xc6, 0xe, 0xc6, 0xfa7, 0xb, 0xc6, 0x5, 
       0xc6, 0xfa9, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x7, 0xc6, 0xfb5, 0xa, 0xc6, 0xc, 0xc6, 0xe, 0xc6, 0xfb8, 0xb, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xfbd, 0xa, 0xc6, 0x3, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 
       0xc6, 0xfc5, 0xa, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xfc9, 0xa, 
       0xc7, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x7, 0xc8, 0xfcf, 
       0xa, 0xc8, 0xc, 0xc8, 0xe, 0xc8, 0xfd2, 0xb, 0xc8, 0x3, 0xc8, 0x3, 
       0xc8, 0x3, 0xc9, 0x3, 0xc9, 0x5, 0xc9, 0xfd8, 0xa, 0xc9, 0x3, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x7, 0xca, 0xfe3, 0xa, 0xca, 0xc, 0xca, 0xe, 
       0xca, 0xfe6, 0xb, 0xca, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x7, 0xcb, 
       0xfeb, 0xa, 0xcb, 0xc, 0xcb, 0xe, 0xcb, 0xfee, 0xb, 0xcb, 0x3, 0xcc, 
       0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 
       0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x5, 0xcc, 0xffa, 0xa, 0xcc, 0x3, 
       0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 0x1001, 
       0xa, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 
       0x1007, 0xa, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 0x100b, 0xa, 
       0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 
       0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 
       0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x5, 0xcd, 0x101c, 0xa, 0xcd, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x5, 0xce, 0x102b, 0xa, 0xce, 0x5, 0xce, 0x102d, 0xa, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0x1032, 0xa, 0xce, 
       0x3, 0xcf, 0x5, 0xcf, 0x1035, 0xa, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 
       0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x5, 0xd0, 0x103e, 
       0xa, 0xd0, 0x3, 0xd0, 0x5, 0xd0, 0x1041, 0xa, 0xd0, 0x3, 0xd0, 0x5, 
       0xd0, 0x1044, 0xa, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 
       0x3, 0xd1, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 
       0x3, 0xd2, 0x5, 0xd2, 0x1051, 0xa, 0xd2, 0x3, 0xd3, 0x3, 0xd3, 0x5, 
       0xd3, 0x1055, 0xa, 0xd3, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 
       0x3, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 0x105d, 0xa, 0xd4, 0x3, 0xd5, 0x3, 
       0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x5, 0xd5, 0x1063, 0xa, 0xd5, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x7, 0xd6, 0x1069, 0xa, 0xd6, 0xc, 
       0xd6, 0xe, 0xd6, 0x106c, 0xb, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x5, 0xd6, 0x1072, 0xa, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 
       0xd6, 0x3, 0xd6, 0x5, 0xd6, 0x1078, 0xa, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 
       0x1087, 0xa, 0xd6, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 
       0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x5, 0xd7, 0x1090, 0xa, 0xd7, 0x3, 0xd7, 
       0x3, 0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x5, 0xd8, 0x1096, 0xa, 0xd8, 0x3, 
       0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x5, 0xd9, 0x109c, 0xa, 0xd9, 
       0x3, 0xd9, 0x5, 0xd9, 0x109f, 0xa, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x5, 
       0xd9, 0x10a3, 0xa, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x7, 0xd9, 
       0x10a8, 0xa, 0xd9, 0xc, 0xd9, 0xe, 0xd9, 0x10ab, 0xb, 0xd9, 0x3, 
       0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0x10b2, 
       0xa, 0xda, 0x3, 0xda, 0x5, 0xda, 0x10b5, 0xa, 0xda, 0x3, 0xda, 0x3, 
       0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0x10bb, 0xa, 0xda, 0x3, 0xda, 
       0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0x10c1, 0xa, 0xda, 0x5, 
       0xda, 0x10c3, 0xa, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 
       0x5, 0xda, 0x10c9, 0xa, 0xda, 0x3, 0xda, 0x5, 0xda, 0x10cc, 0xa, 
       0xda, 0x5, 0xda, 0x10ce, 0xa, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 
       0x3, 0xda, 0x5, 0xda, 0x10d4, 0xa, 0xda, 0x5, 0xda, 0x10d6, 0xa, 
       0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 
       0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 
       0xdb, 0x5, 0xdb, 0x10e4, 0xa, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 
       0x3, 0xdb, 0x3, 0xdb, 0x5, 0xdb, 0x10eb, 0xa, 0xdb, 0x3, 0xdb, 0x3, 
       0xdb, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x5, 
       0xdc, 0x10f4, 0xa, 0xdc, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 
       0x3, 0xdd, 0x5, 0xdd, 0x10fb, 0xa, 0xdd, 0x3, 0xde, 0x3, 0xde, 0x3, 
       0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 
       0xde, 0x3, 0xde, 0x5, 0xde, 0x1107, 0xa, 0xde, 0x3, 0xde, 0x3, 0xde, 
       0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x5, 0xde, 0x110e, 0xa, 0xde, 0x3, 
       0xde, 0x3, 0xde, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x5, 0xdf, 0x1115, 
       0xa, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 
       0x5, 0xdf, 0x111c, 0xa, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 
       0xdf, 0x5, 0xdf, 0x1122, 0xa, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 
       0x3, 0xdf, 0x3, 0xdf, 0x5, 0xdf, 0x1129, 0xa, 0xdf, 0x3, 0xdf, 0x5, 
       0xdf, 0x112c, 0xa, 0xdf, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x5, 0xe0, 
       0x1131, 0xa, 0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x5, 0xe1, 0x1138, 0xa, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe2, 
       0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x5, 0xe2, 0x1140, 0xa, 0xe2, 0x3, 
       0xe2, 0x3, 0xe2, 0x5, 0xe2, 0x1144, 0xa, 0xe2, 0x3, 0xe2, 0x5, 0xe2, 
       0x1147, 0xa, 0xe2, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 
       0xe3, 0x3, 0xe3, 0x5, 0xe3, 0x114f, 0xa, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x5, 0xe3, 0x1153, 0xa, 0xe3, 0x3, 0xe3, 0x5, 0xe3, 0x1156, 0xa, 
       0xe3, 0x3, 0xe4, 0x3, 0xe4, 0x5, 0xe4, 0x115a, 0xa, 0xe4, 0x3, 0xe5, 
       0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0x115f, 0xa, 0xe5, 0x3, 0xe5, 0x3, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0x1165, 0xa, 0xe5, 0x3, 0xe5, 
       0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0x116b, 0xa, 0xe5, 0x3, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0x1171, 0xa, 0xe5, 
       0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0x1177, 0xa, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0x117d, 
       0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 
       0x1183, 0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 
       0xe5, 0x1189, 0xa, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0x118c, 0xa, 0xe5, 
       0x3, 0xe6, 0x3, 0xe6, 0x5, 0xe6, 0x1190, 0xa, 0xe6, 0x3, 0xe6, 0x3, 
       0xe6, 0x3, 0xe6, 0x5, 0xe6, 0x1195, 0xa, 0xe6, 0x7, 0xe6, 0x1197, 
       0xa, 0xe6, 0xc, 0xe6, 0xe, 0xe6, 0x119a, 0xb, 0xe6, 0x3, 0xe7, 0x3, 
       0xe7, 0x3, 0xe7, 0x7, 0xe7, 0x119f, 0xa, 0xe7, 0xc, 0xe7, 0xe, 0xe7, 
       0x11a2, 0xb, 0xe7, 0x3, 0xe8, 0x3, 0xe8, 0x5, 0xe8, 0x11a6, 0xa, 
       0xe8, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xea, 0x3, 0xea, 0x3, 0xeb, 0x5, 
       0xeb, 0x11ad, 0xa, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xec, 0x3, 0xec, 
       0x3, 0xec, 0x3, 0xec, 0x3, 0xec, 0x5, 0xec, 0x11b6, 0xa, 0xec, 0x5, 
       0xec, 0x11b8, 0xa, 0xec, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0x11da, 0xa, 
       0xed, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 
       0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x5, 0xee, 0x11e6, 
       0xa, 0xee, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 0x11eb, 0xa, 
       0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 
       0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 0x11f6, 0xa, 0xef, 
       0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 
       0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 0x1200, 0xa, 0xef, 0x5, 0xef, 0x1202, 
       0xa, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 
       0x1208, 0xa, 0xef, 0x5, 0xef, 0x120a, 0xa, 0xef, 0x3, 0xef, 0x3, 
       0xef, 0x3, 0xef, 0x5, 0xef, 0x120f, 0xa, 0xef, 0x5, 0xef, 0x1211, 
       0xa, 0xef, 0x3, 0xef, 0x5, 0xef, 0x1214, 0xa, 0xef, 0x3, 0xf0, 0x3, 
       0xf0, 0x5, 0xf0, 0x1218, 0xa, 0xf0, 0x3, 0xf1, 0x3, 0xf1, 0x5, 0xf1, 
       0x121c, 0xa, 0xf1, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x5, 
       0xf2, 0x1222, 0xa, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 
       0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x5, 0xf2, 0x122b, 0xa, 0xf2, 0x3, 
       0xf2, 0x5, 0xf2, 0x122e, 0xa, 0xf2, 0x5, 0xf2, 0x1230, 0xa, 0xf2, 
       0x3, 0xf3, 0x5, 0xf3, 0x1233, 0xa, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x3, 
       0xf3, 0x3, 0xf3, 0x5, 0xf3, 0x1239, 0xa, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 
       0x5, 0xf3, 0x123d, 0xa, 0xf3, 0x3, 0xf3, 0x5, 0xf3, 0x1240, 0xa, 
       0xf3, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 
       0xf4, 0x3, 0xf4, 0x5, 0xf4, 0x1249, 0xa, 0xf4, 0x3, 0xf5, 0x3, 0xf5, 
       0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x5, 0xf5, 
       0x1252, 0xa, 0xf5, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 
       0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x5, 
       0xf6, 0x125e, 0xa, 0xf6, 0x3, 0xf6, 0x5, 0xf6, 0x1261, 0xa, 0xf6, 
       0x3, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 0x1265, 0xa, 0xf7, 0x3, 0xf7, 0x3, 
       0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 0x126b, 0xa, 0xf7, 0x3, 0xf7, 
       0x5, 0xf7, 0x126e, 0xa, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 0x1272, 
       0xa, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 
       0x1278, 0xa, 0xf7, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x5, 0xf8, 0x127d, 
       0xa, 0xf8, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x5, 0xf9, 0x1282, 0xa, 
       0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x5, 0xf9, 0x1286, 0xa, 0xf9, 0x3, 0xf9, 
       0x3, 0xf9, 0x5, 0xf9, 0x128a, 0xa, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x5, 
       0xf9, 0x128e, 0xa, 0xf9, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfb, 0x3, 0xfb, 
       0x3, 0xfb, 0x5, 0xfb, 0x1295, 0xa, 0xfb, 0x3, 0xfc, 0x3, 0xfc, 0x3, 
       0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 
       0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 
       0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x5, 0xfd, 0x12a8, 0xa, 0xfd, 0x3, 0xfe, 
       0x3, 0xfe, 0x3, 0xff, 0x3, 0xff, 0x5, 0xff, 0x12ae, 0xa, 0xff, 0x3, 
       0xff, 0x2, 0x3, 0x106, 0x100, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 
       0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 
       0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 
       0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 
       0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 
       0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 
       0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 
       0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 
       0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 
       0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 
       0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 
       0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x100, 
       0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 0x10e, 0x110, 0x112, 0x114, 
       0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 0x122, 0x124, 0x126, 0x128, 
       0x12a, 0x12c, 0x12e, 0x130, 0x132, 0x134, 0x136, 0x138, 0x13a, 0x13c, 
       0x13e, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14a, 0x14c, 0x14e, 0x150, 
       0x152, 0x154, 0x156, 0x158, 0x15a, 0x15c, 0x15e, 0x160, 0x162, 0x164, 
       0x166, 0x168, 0x16a, 0x16c, 0x16e, 0x170, 0x172, 0x174, 0x176, 0x178, 
       0x17a, 0x17c, 0x17e, 0x180, 0x182, 0x184, 0x186, 0x188, 0x18a, 0x18c, 
       0x18e, 0x190, 0x192, 0x194, 0x196, 0x198, 0x19a, 0x19c, 0x19e, 0x1a0, 
       0x1a2, 0x1a4, 0x1a6, 0x1a8, 0x1aa, 0x1ac, 0x1ae, 0x1b0, 0x1b2, 0x1b4, 
       0x1b6, 0x1b8, 0x1ba, 0x1bc, 0x1be, 0x1c0, 0x1c2, 0x1c4, 0x1c6, 0x1c8, 
       0x1ca, 0x1cc, 0x1ce, 0x1d0, 0x1d2, 0x1d4, 0x1d6, 0x1d8, 0x1da, 0x1dc, 
       0x1de, 0x1e0, 0x1e2, 0x1e4, 0x1e6, 0x1e8, 0x1ea, 0x1ec, 0x1ee, 0x1f0, 
       0x1f2, 0x1f4, 0x1f6, 0x1f8, 0x1fa, 0x1fc, 0x2, 0x44, 0x3, 0x2, 0x33d, 
       0x33e, 0x4, 0x2, 0x33d, 0x33d, 0x342, 0x342, 0x4, 0x2, 0x1f0, 0x1f0, 
       0x311, 0x312, 0x4, 0x2, 0x33d, 0x33e, 0x342, 0x342, 0x4, 0x2, 0xc4, 
       0xc4, 0x2ed, 0x2ed, 0x5, 0x2, 0x33a, 0x33a, 0x33d, 0x33d, 0x342, 
       0x342, 0x5, 0x2, 0x140, 0x140, 0x28c, 0x28c, 0x31d, 0x31d, 0x5, 0x2, 
       0x59, 0x59, 0x140, 0x140, 0x28c, 0x28c, 0x4, 0x2, 0x20a, 0x20a, 0x2ee, 
       0x2ee, 0x4, 0x2, 0xc, 0xc, 0xfa, 0xfa, 0x4, 0x2, 0x33e, 0x33e, 0x342, 
       0x342, 0x4, 0x2, 0x62, 0x62, 0x97, 0x97, 0x6, 0x2, 0x61, 0x61, 0xa8, 
       0xa8, 0x143, 0x143, 0x17f, 0x17f, 0x4, 0x2, 0xef, 0xef, 0xf2, 0xf2, 
       0x4, 0x2, 0xe2, 0xe2, 0x100, 0x100, 0x3, 0x2, 0x110, 0x111, 0x4, 
       0x2, 0x295, 0x296, 0x2bb, 0x2bb, 0x5, 0x2, 0x207, 0x207, 0x2d9, 0x2d9, 
       0x32a, 0x32a, 0x5, 0x2, 0x169, 0x169, 0x1b1, 0x1b1, 0x1fb, 0x1fb, 
       0x4, 0x2, 0x1fb, 0x1fb, 0x204, 0x204, 0x4, 0x2, 0x228, 0x228, 0x252, 
       0x252, 0x4, 0x2, 0x271, 0x271, 0x2e1, 0x2e1, 0x4, 0x2, 0x185, 0x185, 
       0x256, 0x256, 0x3, 0x2, 0x295, 0x296, 0x3, 0x2, 0x173, 0x174, 0x6, 
       0x2, 0x1c4, 0x1c4, 0x298, 0x298, 0x2e6, 0x2e6, 0x342, 0x342, 0x4, 
       0x2, 0x1d4, 0x1d4, 0x1ff, 0x1ff, 0x4, 0x2, 0x11, 0x11, 0x40, 0x40, 
       0x4, 0x2, 0x23c, 0x23c, 0x2e7, 0x2e7, 0x4, 0x2, 0x222, 0x222, 0x2db, 
       0x2db, 0x6, 0x2, 0x200, 0x200, 0x215, 0x215, 0x248, 0x248, 0x2f9, 
       0x2f9, 0x5, 0x2, 0x293, 0x293, 0x2b8, 0x2b8, 0x2dc, 0x2dc, 0x4, 0x2, 
       0x197, 0x197, 0x2c1, 0x2c1, 0x3, 0x2, 0x35d, 0x35f, 0x5, 0x2, 0x352, 
       0x352, 0x360, 0x361, 0x363, 0x365, 0x3, 0x2, 0x360, 0x361, 0x5, 0x2, 
       0x7, 0x7, 0xe, 0xe, 0x155, 0x155, 0x4, 0x2, 0x7, 0x7, 0x67, 0x67, 
       0x3, 0x2, 0x344, 0x345, 0x4, 0x2, 0x2d4, 0x2d4, 0x2d7, 0x2d7, 0x4, 
       0x2, 0x21b, 0x21b, 0x27d, 0x27d, 0x4, 0x2, 0x4, 0x4, 0x335, 0x335, 
       0x4, 0x2, 0x1b1, 0x1b1, 0x29e, 0x29e, 0x4, 0x2, 0x12, 0x12, 0x63, 
       0x63, 0x4, 0x2, 0xfb, 0xfb, 0x22e, 0x22e, 0x5, 0x2, 0xd4, 0xd4, 0x1d2, 
       0x1d2, 0x22e, 0x22e, 0x5, 0x2, 0xd4, 0xd4, 0x22e, 0x22e, 0x257, 0x257, 
       0x4, 0x2, 0x220, 0x220, 0x2f1, 0x2f1, 0x4, 0x2, 0xec, 0xec, 0x33d, 
       0x33e, 0x5, 0x2, 0x92, 0x92, 0xb9, 0xb9, 0x12f, 0x12f, 0x6, 0x2, 
       0xd4, 0xd4, 0x22e, 0x22e, 0x257, 0x257, 0x2c2, 0x2c2, 0x4, 0x2, 0x33d, 
       0x33d, 0x33f, 0x33f, 0x5, 0x2, 0x1f3, 0x1f3, 0x2b3, 0x2b3, 0x2d5, 
       0x2d5, 0x8, 0x2, 0x1b9, 0x1b9, 0x25c, 0x25c, 0x26c, 0x26c, 0x2fd, 
       0x2fe, 0x305, 0x305, 0x328, 0x329, 0x3, 0x2, 0x1d7, 0x1d8, 0x4, 0x2, 
       0x21c, 0x21c, 0x24b, 0x24b, 0x4, 0x2, 0x249, 0x249, 0x24c, 0x24c, 
       0x4, 0x2, 0x2b2, 0x2b2, 0x2d7, 0x2d7, 0x5, 0x2, 0x92, 0x92, 0xef, 
       0xef, 0x2b8, 0x2b8, 0x4, 0x2, 0x3a, 0x3a, 0xe1, 0xe1, 0x3, 0x2, 0x11f, 
       0x120, 0x4, 0x2, 0x25c, 0x25c, 0x33e, 0x33e, 0x4, 0x2, 0x33e, 0x33e, 
       0x344, 0x344, 0x26, 0x2, 0x2a, 0x2a, 0x57, 0x57, 0x77, 0x77, 0x87, 
       0x88, 0x8c, 0x8c, 0xa6, 0xa6, 0xb4, 0xb4, 0xc8, 0xc9, 0xf0, 0xf0, 
       0xfe, 0xfe, 0x113, 0x113, 0x115, 0x115, 0x118, 0x118, 0x12a, 0x12b, 
       0x133, 0x133, 0x13b, 0x13b, 0x147, 0x147, 0x152, 0x152, 0x156, 0x156, 
       0x159, 0x159, 0x15e, 0x15e, 0x160, 0x160, 0x16c, 0x16c, 0x197, 0x1e1, 
       0x1e3, 0x1e7, 0x1e9, 0x200, 0x202, 0x237, 0x239, 0x240, 0x243, 0x296, 
       0x298, 0x2fb, 0x2fd, 0x302, 0x305, 0x322, 0x324, 0x32d, 0x32f, 0x331, 
       0x333, 0x333, 0x33f, 0x33f, 0x3, 0x2, 0x34a, 0x351, 0x7, 0x2, 0x225, 
       0x225, 0x243, 0x243, 0x268, 0x268, 0x30d, 0x30d, 0x35f, 0x35f, 0x2, 
       0x1599, 0x2, 0x201, 0x3, 0x2, 0x2, 0x2, 0x4, 0x217, 0x3, 0x2, 0x2, 
       0x2, 0x6, 0x21d, 0x3, 0x2, 0x2, 0x2, 0x8, 0x227, 0x3, 0x2, 0x2, 0x2, 
       0xa, 0x22e, 0x3, 0x2, 0x2, 0x2, 0xc, 0x243, 0x3, 0x2, 0x2, 0x2, 0xe, 
       0x251, 0x3, 0x2, 0x2, 0x2, 0x10, 0x253, 0x3, 0x2, 0x2, 0x2, 0x12, 
       0x25e, 0x3, 0x2, 0x2, 0x2, 0x14, 0x262, 0x3, 0x2, 0x2, 0x2, 0x16, 
       0x270, 0x3, 0x2, 0x2, 0x2, 0x18, 0x272, 0x3, 0x2, 0x2, 0x2, 0x1a, 
       0x279, 0x3, 0x2, 0x2, 0x2, 0x1c, 0x283, 0x3, 0x2, 0x2, 0x2, 0x1e, 
       0x28f, 0x3, 0x2, 0x2, 0x2, 0x20, 0x291, 0x3, 0x2, 0x2, 0x2, 0x22, 
       0x293, 0x3, 0x2, 0x2, 0x2, 0x24, 0x295, 0x3, 0x2, 0x2, 0x2, 0x26, 
       0x2af, 0x3, 0x2, 0x2, 0x2, 0x28, 0x2c0, 0x3, 0x2, 0x2, 0x2, 0x2a, 
       0x2cd, 0x3, 0x2, 0x2, 0x2, 0x2c, 0x2fc, 0x3, 0x2, 0x2, 0x2, 0x2e, 
       0x2fe, 0x3, 0x2, 0x2, 0x2, 0x30, 0x30e, 0x3, 0x2, 0x2, 0x2, 0x32, 
       0x310, 0x3, 0x2, 0x2, 0x2, 0x34, 0x31d, 0x3, 0x2, 0x2, 0x2, 0x36, 
       0x31f, 0x3, 0x2, 0x2, 0x2, 0x38, 0x322, 0x3, 0x2, 0x2, 0x2, 0x3a, 
       0x324, 0x3, 0x2, 0x2, 0x2, 0x3c, 0x326, 0x3, 0x2, 0x2, 0x2, 0x3e, 
       0x328, 0x3, 0x2, 0x2, 0x2, 0x40, 0x330, 0x3, 0x2, 0x2, 0x2, 0x42, 
       0x33e, 0x3, 0x2, 0x2, 0x2, 0x44, 0x366, 0x3, 0x2, 0x2, 0x2, 0x46, 
       0x36f, 0x3, 0x2, 0x2, 0x2, 0x48, 0x3a9, 0x3, 0x2, 0x2, 0x2, 0x4a, 
       0x3ab, 0x3, 0x2, 0x2, 0x2, 0x4c, 0x3bf, 0x3, 0x2, 0x2, 0x2, 0x4e, 
       0x3e9, 0x3, 0x2, 0x2, 0x2, 0x50, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x52, 
       0x407, 0x3, 0x2, 0x2, 0x2, 0x54, 0x450, 0x3, 0x2, 0x2, 0x2, 0x56, 
       0x46f, 0x3, 0x2, 0x2, 0x2, 0x58, 0x471, 0x3, 0x2, 0x2, 0x2, 0x5a, 
       0x47b, 0x3, 0x2, 0x2, 0x2, 0x5c, 0x47d, 0x3, 0x2, 0x2, 0x2, 0x5e, 
       0x492, 0x3, 0x2, 0x2, 0x2, 0x60, 0x4eb, 0x3, 0x2, 0x2, 0x2, 0x62, 
       0x4ed, 0x3, 0x2, 0x2, 0x2, 0x64, 0x4fa, 0x3, 0x2, 0x2, 0x2, 0x66, 
       0x532, 0x3, 0x2, 0x2, 0x2, 0x68, 0x535, 0x3, 0x2, 0x2, 0x2, 0x6a, 
       0x563, 0x3, 0x2, 0x2, 0x2, 0x6c, 0x566, 0x3, 0x2, 0x2, 0x2, 0x6e, 
       0x587, 0x3, 0x2, 0x2, 0x2, 0x70, 0x598, 0x3, 0x2, 0x2, 0x2, 0x72, 
       0x59b, 0x3, 0x2, 0x2, 0x2, 0x74, 0x5d6, 0x3, 0x2, 0x2, 0x2, 0x76, 
       0x5ee, 0x3, 0x2, 0x2, 0x2, 0x78, 0x5fe, 0x3, 0x2, 0x2, 0x2, 0x7a, 
       0x600, 0x3, 0x2, 0x2, 0x2, 0x7c, 0x631, 0x3, 0x2, 0x2, 0x2, 0x7e, 
       0x65a, 0x3, 0x2, 0x2, 0x2, 0x80, 0x68a, 0x3, 0x2, 0x2, 0x2, 0x82, 
       0x6a5, 0x3, 0x2, 0x2, 0x2, 0x84, 0x6bd, 0x3, 0x2, 0x2, 0x2, 0x86, 
       0x6dd, 0x3, 0x2, 0x2, 0x2, 0x88, 0x6fb, 0x3, 0x2, 0x2, 0x2, 0x8a, 
       0x712, 0x3, 0x2, 0x2, 0x2, 0x8c, 0x720, 0x3, 0x2, 0x2, 0x2, 0x8e, 
       0x722, 0x3, 0x2, 0x2, 0x2, 0x90, 0x742, 0x3, 0x2, 0x2, 0x2, 0x92, 
       0x758, 0x3, 0x2, 0x2, 0x2, 0x94, 0x776, 0x3, 0x2, 0x2, 0x2, 0x96, 
       0x778, 0x3, 0x2, 0x2, 0x2, 0x98, 0x7af, 0x3, 0x2, 0x2, 0x2, 0x9a, 
       0x7b1, 0x3, 0x2, 0x2, 0x2, 0x9c, 0x7bc, 0x3, 0x2, 0x2, 0x2, 0x9e, 
       0x7be, 0x3, 0x2, 0x2, 0x2, 0xa0, 0x7d9, 0x3, 0x2, 0x2, 0x2, 0xa2, 
       0x7e0, 0x3, 0x2, 0x2, 0x2, 0xa4, 0x7e6, 0x3, 0x2, 0x2, 0x2, 0xa6, 
       0x7f7, 0x3, 0x2, 0x2, 0x2, 0xa8, 0x808, 0x3, 0x2, 0x2, 0x2, 0xaa, 
       0x812, 0x3, 0x2, 0x2, 0x2, 0xac, 0x823, 0x3, 0x2, 0x2, 0x2, 0xae, 
       0x834, 0x3, 0x2, 0x2, 0x2, 0xb0, 0x83e, 0x3, 0x2, 0x2, 0x2, 0xb2, 
       0x840, 0x3, 0x2, 0x2, 0x2, 0xb4, 0x847, 0x3, 0x2, 0x2, 0x2, 0xb6, 
       0x883, 0x3, 0x2, 0x2, 0x2, 0xb8, 0x8a2, 0x3, 0x2, 0x2, 0x2, 0xba, 
       0x8a4, 0x3, 0x2, 0x2, 0x2, 0xbc, 0x8ac, 0x3, 0x2, 0x2, 0x2, 0xbe, 
       0x8b2, 0x3, 0x2, 0x2, 0x2, 0xc0, 0x8b9, 0x3, 0x2, 0x2, 0x2, 0xc2, 
       0x8bd, 0x3, 0x2, 0x2, 0x2, 0xc4, 0x8ea, 0x3, 0x2, 0x2, 0x2, 0xc6, 
       0x8ee, 0x3, 0x2, 0x2, 0x2, 0xc8, 0x8fb, 0x3, 0x2, 0x2, 0x2, 0xca, 
       0x924, 0x3, 0x2, 0x2, 0x2, 0xcc, 0x977, 0x3, 0x2, 0x2, 0x2, 0xce, 
       0x979, 0x3, 0x2, 0x2, 0x2, 0xd0, 0x97d, 0x3, 0x2, 0x2, 0x2, 0xd2, 
       0x982, 0x3, 0x2, 0x2, 0x2, 0xd4, 0x986, 0x3, 0x2, 0x2, 0x2, 0xd6, 
       0x98b, 0x3, 0x2, 0x2, 0x2, 0xd8, 0x990, 0x3, 0x2, 0x2, 0x2, 0xda, 
       0x99f, 0x3, 0x2, 0x2, 0x2, 0xdc, 0x9a4, 0x3, 0x2, 0x2, 0x2, 0xde, 
       0x9a8, 0x3, 0x2, 0x2, 0x2, 0xe0, 0x9b1, 0x3, 0x2, 0x2, 0x2, 0xe2, 
       0x9b6, 0x3, 0x2, 0x2, 0x2, 0xe4, 0x9be, 0x3, 0x2, 0x2, 0x2, 0xe6, 
       0x9c2, 0x3, 0x2, 0x2, 0x2, 0xe8, 0x9cf, 0x3, 0x2, 0x2, 0x2, 0xea, 
       0x9d1, 0x3, 0x2, 0x2, 0x2, 0xec, 0x9fe, 0x3, 0x2, 0x2, 0x2, 0xee, 
       0xa08, 0x3, 0x2, 0x2, 0x2, 0xf0, 0xa33, 0x3, 0x2, 0x2, 0x2, 0xf2, 
       0xa77, 0x3, 0x2, 0x2, 0x2, 0xf4, 0xa82, 0x3, 0x2, 0x2, 0x2, 0xf6, 
       0xa8d, 0x3, 0x2, 0x2, 0x2, 0xf8, 0xa99, 0x3, 0x2, 0x2, 0x2, 0xfa, 
       0xaa0, 0x3, 0x2, 0x2, 0x2, 0xfc, 0xac9, 0x3, 0x2, 0x2, 0x2, 0xfe, 
       0xad4, 0x3, 0x2, 0x2, 0x2, 0x100, 0xad6, 0x3, 0x2, 0x2, 0x2, 0x102, 
       0xb25, 0x3, 0x2, 0x2, 0x2, 0x104, 0xb29, 0x3, 0x2, 0x2, 0x2, 0x106, 
       0xb33, 0x3, 0x2, 0x2, 0x2, 0x108, 0xb4f, 0x3, 0x2, 0x2, 0x2, 0x10a, 
       0xb6a, 0x3, 0x2, 0x2, 0x2, 0x10c, 0xb70, 0x3, 0x2, 0x2, 0x2, 0x10e, 
       0xb7a, 0x3, 0x2, 0x2, 0x2, 0x110, 0xb84, 0x3, 0x2, 0x2, 0x2, 0x112, 
       0xb86, 0x3, 0x2, 0x2, 0x2, 0x114, 0xba2, 0x3, 0x2, 0x2, 0x2, 0x116, 
       0xba4, 0x3, 0x2, 0x2, 0x2, 0x118, 0xbc0, 0x3, 0x2, 0x2, 0x2, 0x11a, 
       0xbc2, 0x3, 0x2, 0x2, 0x2, 0x11c, 0xbca, 0x3, 0x2, 0x2, 0x2, 0x11e, 
       0xbd2, 0x3, 0x2, 0x2, 0x2, 0x120, 0xbdb, 0x3, 0x2, 0x2, 0x2, 0x122, 
       0xc16, 0x3, 0x2, 0x2, 0x2, 0x124, 0xc1d, 0x3, 0x2, 0x2, 0x2, 0x126, 
       0xc2b, 0x3, 0x2, 0x2, 0x2, 0x128, 0xc34, 0x3, 0x2, 0x2, 0x2, 0x12a, 
       0xc5b, 0x3, 0x2, 0x2, 0x2, 0x12c, 0xc6b, 0x3, 0x2, 0x2, 0x2, 0x12e, 
       0xc72, 0x3, 0x2, 0x2, 0x2, 0x130, 0xc74, 0x3, 0x2, 0x2, 0x2, 0x132, 
       0xce3, 0x3, 0x2, 0x2, 0x2, 0x134, 0xce5, 0x3, 0x2, 0x2, 0x2, 0x136, 
       0xcf0, 0x3, 0x2, 0x2, 0x2, 0x138, 0xcf4, 0x3, 0x2, 0x2, 0x2, 0x13a, 
       0xcf6, 0x3, 0x2, 0x2, 0x2, 0x13c, 0xd2f, 0x3, 0x2, 0x2, 0x2, 0x13e, 
       0xd31, 0x3, 0x2, 0x2, 0x2, 0x140, 0xd3a, 0x3, 0x2, 0x2, 0x2, 0x142, 
       0xd42, 0x3, 0x2, 0x2, 0x2, 0x144, 0xd50, 0x3, 0x2, 0x2, 0x2, 0x146, 
       0xd61, 0x3, 0x2, 0x2, 0x2, 0x148, 0xd77, 0x3, 0x2, 0x2, 0x2, 0x14a, 
       0xd81, 0x3, 0x2, 0x2, 0x2, 0x14c, 0xd87, 0x3, 0x2, 0x2, 0x2, 0x14e, 
       0xd89, 0x3, 0x2, 0x2, 0x2, 0x150, 0xd96, 0x3, 0x2, 0x2, 0x2, 0x152, 
       0xd98, 0x3, 0x2, 0x2, 0x2, 0x154, 0xdd0, 0x3, 0x2, 0x2, 0x2, 0x156, 
       0xdd2, 0x3, 0x2, 0x2, 0x2, 0x158, 0xde3, 0x3, 0x2, 0x2, 0x2, 0x15a, 
       0xdeb, 0x3, 0x2, 0x2, 0x2, 0x15c, 0xdf0, 0x3, 0x2, 0x2, 0x2, 0x15e, 
       0xe1a, 0x3, 0x2, 0x2, 0x2, 0x160, 0xe1c, 0x3, 0x2, 0x2, 0x2, 0x162, 
       0xe24, 0x3, 0x2, 0x2, 0x2, 0x164, 0xe2e, 0x3, 0x2, 0x2, 0x2, 0x166, 
       0xe36, 0x3, 0x2, 0x2, 0x2, 0x168, 0xe54, 0x3, 0x2, 0x2, 0x2, 0x16a, 
       0xe56, 0x3, 0x2, 0x2, 0x2, 0x16c, 0xe64, 0x3, 0x2, 0x2, 0x2, 0x16e, 
       0xef8, 0x3, 0x2, 0x2, 0x2, 0x170, 0xeff, 0x3, 0x2, 0x2, 0x2, 0x172, 
       0xf2c, 0x3, 0x2, 0x2, 0x2, 0x174, 0xf44, 0x3, 0x2, 0x2, 0x2, 0x176, 
       0xf46, 0x3, 0x2, 0x2, 0x2, 0x178, 0xf4d, 0x3, 0x2, 0x2, 0x2, 0x17a, 
       0xf54, 0x3, 0x2, 0x2, 0x2, 0x17c, 0xf5b, 0x3, 0x2, 0x2, 0x2, 0x17e, 
       0xf60, 0x3, 0x2, 0x2, 0x2, 0x180, 0xf66, 0x3, 0x2, 0x2, 0x2, 0x182, 
       0xf6b, 0x3, 0x2, 0x2, 0x2, 0x184, 0xf6f, 0x3, 0x2, 0x2, 0x2, 0x186, 
       0xf74, 0x3, 0x2, 0x2, 0x2, 0x188, 0xf83, 0x3, 0x2, 0x2, 0x2, 0x18a, 
       0xf92, 0x3, 0x2, 0x2, 0x2, 0x18c, 0xfc8, 0x3, 0x2, 0x2, 0x2, 0x18e, 
       0xfca, 0x3, 0x2, 0x2, 0x2, 0x190, 0xfd7, 0x3, 0x2, 0x2, 0x2, 0x192, 
       0xfd9, 0x3, 0x2, 0x2, 0x2, 0x194, 0xfe7, 0x3, 0x2, 0x2, 0x2, 0x196, 
       0xff9, 0x3, 0x2, 0x2, 0x2, 0x198, 0x101b, 0x3, 0x2, 0x2, 0x2, 0x19a, 
       0x1031, 0x3, 0x2, 0x2, 0x2, 0x19c, 0x1034, 0x3, 0x2, 0x2, 0x2, 0x19e, 
       0x1038, 0x3, 0x2, 0x2, 0x2, 0x1a0, 0x1047, 0x3, 0x2, 0x2, 0x2, 0x1a2, 
       0x1050, 0x3, 0x2, 0x2, 0x2, 0x1a4, 0x1054, 0x3, 0x2, 0x2, 0x2, 0x1a6, 
       0x105c, 0x3, 0x2, 0x2, 0x2, 0x1a8, 0x1062, 0x3, 0x2, 0x2, 0x2, 0x1aa, 
       0x1086, 0x3, 0x2, 0x2, 0x2, 0x1ac, 0x1088, 0x3, 0x2, 0x2, 0x2, 0x1ae, 
       0x1095, 0x3, 0x2, 0x2, 0x2, 0x1b0, 0x1097, 0x3, 0x2, 0x2, 0x2, 0x1b2, 
       0x10ac, 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x10ea, 0x3, 0x2, 0x2, 0x2, 0x1b6, 
       0x10f3, 0x3, 0x2, 0x2, 0x2, 0x1b8, 0x10fa, 0x3, 0x2, 0x2, 0x2, 0x1ba, 
       0x110d, 0x3, 0x2, 0x2, 0x2, 0x1bc, 0x112b, 0x3, 0x2, 0x2, 0x2, 0x1be, 
       0x1130, 0x3, 0x2, 0x2, 0x2, 0x1c0, 0x1137, 0x3, 0x2, 0x2, 0x2, 0x1c2, 
       0x1146, 0x3, 0x2, 0x2, 0x2, 0x1c4, 0x1155, 0x3, 0x2, 0x2, 0x2, 0x1c6, 
       0x1159, 0x3, 0x2, 0x2, 0x2, 0x1c8, 0x118b, 0x3, 0x2, 0x2, 0x2, 0x1ca, 
       0x118d, 0x3, 0x2, 0x2, 0x2, 0x1cc, 0x119b, 0x3, 0x2, 0x2, 0x2, 0x1ce, 
       0x11a5, 0x3, 0x2, 0x2, 0x2, 0x1d0, 0x11a7, 0x3, 0x2, 0x2, 0x2, 0x1d2, 
       0x11a9, 0x3, 0x2, 0x2, 0x2, 0x1d4, 0x11ac, 0x3, 0x2, 0x2, 0x2, 0x1d6, 
       0x11b7, 0x3, 0x2, 0x2, 0x2, 0x1d8, 0x11d9, 0x3, 0x2, 0x2, 0x2, 0x1da, 
       0x11db, 0x3, 0x2, 0x2, 0x2, 0x1dc, 0x11e7, 0x3, 0x2, 0x2, 0x2, 0x1de, 
       0x1217, 0x3, 0x2, 0x2, 0x2, 0x1e0, 0x121b, 0x3, 0x2, 0x2, 0x2, 0x1e2, 
       0x121d, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1232, 0x3, 0x2, 0x2, 0x2, 0x1e6, 
       0x1241, 0x3, 0x2, 0x2, 0x2, 0x1e8, 0x1251, 0x3, 0x2, 0x2, 0x2, 0x1ea, 
       0x1253, 0x3, 0x2, 0x2, 0x2, 0x1ec, 0x1277, 0x3, 0x2, 0x2, 0x2, 0x1ee, 
       0x127c, 0x3, 0x2, 0x2, 0x2, 0x1f0, 0x128d, 0x3, 0x2, 0x2, 0x2, 0x1f2, 
       0x128f, 0x3, 0x2, 0x2, 0x2, 0x1f4, 0x1294, 0x3, 0x2, 0x2, 0x2, 0x1f6, 
       0x1296, 0x3, 0x2, 0x2, 0x2, 0x1f8, 0x12a7, 0x3, 0x2, 0x2, 0x2, 0x1fa, 
       0x12a9, 0x3, 0x2, 0x2, 0x2, 0x1fc, 0x12ab, 0x3, 0x2, 0x2, 0x2, 0x1fe, 
       0x200, 0x5, 0x4, 0x3, 0x2, 0x1ff, 0x1fe, 0x3, 0x2, 0x2, 0x2, 0x200, 
       0x203, 0x3, 0x2, 0x2, 0x2, 0x201, 0x1ff, 0x3, 0x2, 0x2, 0x2, 0x201, 
       0x202, 0x3, 0x2, 0x2, 0x2, 0x202, 0x204, 0x3, 0x2, 0x2, 0x2, 0x203, 
       0x201, 0x3, 0x2, 0x2, 0x2, 0x204, 0x205, 0x7, 0x2, 0x2, 0x3, 0x205, 
       0x3, 0x3, 0x2, 0x2, 0x2, 0x206, 0x20a, 0x5, 0xc4, 0x63, 0x2, 0x207, 
       0x209, 0x5, 0xce, 0x68, 0x2, 0x208, 0x207, 0x3, 0x2, 0x2, 0x2, 0x209, 
       0x20c, 0x3, 0x2, 0x2, 0x2, 0x20a, 0x208, 0x3, 0x2, 0x2, 0x2, 0x20a, 
       0x20b, 0x3, 0x2, 0x2, 0x2, 0x20b, 0x218, 0x3, 0x2, 0x2, 0x2, 0x20c, 
       0x20a, 0x3, 0x2, 0x2, 0x2, 0x20d, 0x20f, 0x5, 0xc4, 0x63, 0x2, 0x20e, 
       0x20d, 0x3, 0x2, 0x2, 0x2, 0x20e, 0x20f, 0x3, 0x2, 0x2, 0x2, 0x20f, 
       0x210, 0x3, 0x2, 0x2, 0x2, 0x210, 0x214, 0x5, 0x6, 0x4, 0x2, 0x211, 
       0x213, 0x5, 0xce, 0x68, 0x2, 0x212, 0x211, 0x3, 0x2, 0x2, 0x2, 0x213, 
       0x216, 0x3, 0x2, 0x2, 0x2, 0x214, 0x212, 0x3, 0x2, 0x2, 0x2, 0x214, 
       0x215, 0x3, 0x2, 0x2, 0x2, 0x215, 0x218, 0x3, 0x2, 0x2, 0x2, 0x216, 
       0x214, 0x3, 0x2, 0x2, 0x2, 0x217, 0x206, 0x3, 0x2, 0x2, 0x2, 0x217, 
       0x20e, 0x3, 0x2, 0x2, 0x2, 0x218, 0x5, 0x3, 0x2, 0x2, 0x2, 0x219, 
       0x21b, 0x5, 0x8, 0x5, 0x2, 0x21a, 0x21c, 0x7, 0x35b, 0x2, 0x2, 0x21b, 
       0x21a, 0x3, 0x2, 0x2, 0x2, 0x21b, 0x21c, 0x3, 0x2, 0x2, 0x2, 0x21c, 
       0x21e, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x219, 0x3, 0x2, 0x2, 0x2, 0x21e, 
       0x21f, 0x3, 0x2, 0x2, 0x2, 0x21f, 0x21d, 0x3, 0x2, 0x2, 0x2, 0x21f, 
       0x220, 0x3, 0x2, 0x2, 0x2, 0x220, 0x7, 0x3, 0x2, 0x2, 0x2, 0x221, 
       0x228, 0x5, 0xa, 0x6, 0x2, 0x222, 0x228, 0x5, 0xc, 0x7, 0x2, 0x223, 
       0x228, 0x5, 0xe, 0x8, 0x2, 0x224, 0x228, 0x5, 0xd8, 0x6d, 0x2, 0x225, 
       0x228, 0x5, 0x2e, 0x18, 0x2, 0x226, 0x228, 0x5, 0x30, 0x19, 0x2, 
       0x227, 0x221, 0x3, 0x2, 0x2, 0x2, 0x227, 0x222, 0x3, 0x2, 0x2, 0x2, 
       0x227, 0x223, 0x3, 0x2, 0x2, 0x2, 0x227, 0x224, 0x3, 0x2, 0x2, 0x2, 
       0x227, 0x225, 0x3, 0x2, 0x2, 0x2, 0x227, 0x226, 0x3, 0x2, 0x2, 0x2, 
       0x228, 0x9, 0x3, 0x2, 0x2, 0x2, 0x229, 0x22f, 0x5, 0x5e, 0x30, 0x2, 
       0x22a, 0x22f, 0x5, 0x64, 0x33, 0x2, 0x22b, 0x22f, 0x5, 0x68, 0x35, 
       0x2, 0x22c, 0x22f, 0x5, 0x6e, 0x38, 0x2, 0x22d, 0x22f, 0x5, 0x72, 
       0x3a, 0x2, 0x22e, 0x229, 0x3, 0x2, 0x2, 0x2, 0x22e, 0x22a, 0x3, 0x2, 
       0x2, 0x2, 0x22e, 0x22b, 0x3, 0x2, 0x2, 0x2, 0x22e, 0x22c, 0x3, 0x2, 
       0x2, 0x2, 0x22e, 0x22d, 0x3, 0x2, 0x2, 0x2, 0x22f, 0xb, 0x3, 0x2, 
       0x2, 0x2, 0x230, 0x244, 0x5, 0x4a, 0x26, 0x2, 0x231, 0x244, 0x5, 
       0x96, 0x4c, 0x2, 0x232, 0x244, 0x5, 0x7c, 0x3f, 0x2, 0x233, 0x244, 
       0x5, 0x80, 0x41, 0x2, 0x234, 0x244, 0x5, 0x7e, 0x40, 0x2, 0x235, 
       0x244, 0x5, 0x4c, 0x27, 0x2, 0x236, 0x244, 0x5, 0x8e, 0x48, 0x2, 
       0x237, 0x244, 0x5, 0xac, 0x57, 0x2, 0x238, 0x244, 0x5, 0x92, 0x4a, 
       0x2, 0x239, 0x244, 0x5, 0x32, 0x1a, 0x2, 0x23a, 0x244, 0x5, 0xa6, 
       0x54, 0x2, 0x23b, 0x244, 0x5, 0x9e, 0x50, 0x2, 0x23c, 0x244, 0x5, 
       0xa4, 0x53, 0x2, 0x23d, 0x244, 0x5, 0x3e, 0x20, 0x2, 0x23e, 0x244, 
       0x5, 0xa8, 0x55, 0x2, 0x23f, 0x244, 0x5, 0xae, 0x58, 0x2, 0x240, 
       0x244, 0x5, 0xaa, 0x56, 0x2, 0x241, 0x244, 0x5, 0x40, 0x21, 0x2, 
       0x242, 0x244, 0x5, 0x42, 0x22, 0x2, 0x243, 0x230, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x231, 0x3, 0x2, 0x2, 0x2, 0x243, 0x232, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x233, 0x3, 0x2, 0x2, 0x2, 0x243, 0x234, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x235, 0x3, 0x2, 0x2, 0x2, 0x243, 0x236, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x237, 0x3, 0x2, 0x2, 0x2, 0x243, 0x238, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x239, 0x3, 0x2, 0x2, 0x2, 0x243, 0x23a, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x243, 0x23c, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x23d, 0x3, 0x2, 0x2, 0x2, 0x243, 0x23e, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x23f, 0x3, 0x2, 0x2, 0x2, 0x243, 0x240, 0x3, 0x2, 0x2, 
       0x2, 0x243, 0x241, 0x3, 0x2, 0x2, 0x2, 0x243, 0x242, 0x3, 0x2, 0x2, 
       0x2, 0x244, 0xd, 0x3, 0x2, 0x2, 0x2, 0x245, 0x252, 0x5, 0x10, 0x9, 
       0x2, 0x246, 0x252, 0x5, 0x12, 0xa, 0x2, 0x247, 0x252, 0x5, 0x14, 
       0xb, 0x2, 0x248, 0x252, 0x5, 0x16, 0xc, 0x2, 0x249, 0x252, 0x5, 0x1a, 
       0xe, 0x2, 0x24a, 0x252, 0x5, 0x18, 0xd, 0x2, 0x24b, 0x252, 0x5, 0x1c, 
       0xf, 0x2, 0x24c, 0x252, 0x5, 0x24, 0x13, 0x2, 0x24d, 0x252, 0x5, 
       0x26, 0x14, 0x2, 0x24e, 0x252, 0x5, 0x28, 0x15, 0x2, 0x24f, 0x252, 
       0x5, 0x2a, 0x16, 0x2, 0x250, 0x252, 0x5, 0x2c, 0x17, 0x2, 0x251, 
       0x245, 0x3, 0x2, 0x2, 0x2, 0x251, 0x246, 0x3, 0x2, 0x2, 0x2, 0x251, 
       0x247, 0x3, 0x2, 0x2, 0x2, 0x251, 0x248, 0x3, 0x2, 0x2, 0x2, 0x251, 
       0x249, 0x3, 0x2, 0x2, 0x2, 0x251, 0x24a, 0x3, 0x2, 0x2, 0x2, 0x251, 
       0x24b, 0x3, 0x2, 0x2, 0x2, 0x251, 0x24c, 0x3, 0x2, 0x2, 0x2, 0x251, 
       0x24d, 0x3, 0x2, 0x2, 0x2, 0x251, 0x24e, 0x3, 0x2, 0x2, 0x2, 0x251, 
       0x24f, 0x3, 0x2, 0x2, 0x2, 0x251, 0x250, 0x3, 0x2, 0x2, 0x2, 0x252, 
       0xf, 0x3, 0x2, 0x2, 0x2, 0x253, 0x255, 0x7, 0x1e, 0x2, 0x2, 0x254, 
       0x256, 0x7, 0x35b, 0x2, 0x2, 0x255, 0x254, 0x3, 0x2, 0x2, 0x2, 0x255, 
       0x256, 0x3, 0x2, 0x2, 0x2, 0x256, 0x258, 0x3, 0x2, 0x2, 0x2, 0x257, 
       0x259, 0x5, 0x6, 0x4, 0x2, 0x258, 0x257, 0x3, 0x2, 0x2, 0x2, 0x258, 
       0x259, 0x3, 0x2, 0x2, 0x2, 0x259, 0x25a, 0x3, 0x2, 0x2, 0x2, 0x25a, 
       0x25c, 0x7, 0x71, 0x2, 0x2, 0x25b, 0x25d, 0x7, 0x35b, 0x2, 0x2, 0x25c, 
       0x25b, 0x3, 0x2, 0x2, 0x2, 0x25c, 0x25d, 0x3, 0x2, 0x2, 0x2, 0x25d, 
       0x11, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x260, 0x7, 0x23, 0x2, 0x2, 0x25f, 
       0x261, 0x7, 0x35b, 0x2, 0x2, 0x260, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x260, 
       0x261, 0x3, 0x2, 0x2, 0x2, 0x261, 0x13, 0x3, 0x2, 0x2, 0x2, 0x262, 
       0x264, 0x7, 0x47, 0x2, 0x2, 0x263, 0x265, 0x7, 0x35b, 0x2, 0x2, 0x264, 
       0x263, 0x3, 0x2, 0x2, 0x2, 0x264, 0x265, 0x3, 0x2, 0x2, 0x2, 0x265, 
       0x15, 0x3, 0x2, 0x2, 0x2, 0x266, 0x267, 0x7, 0x95, 0x2, 0x2, 0x267, 
       0x269, 0x5, 0x1f4, 0xfb, 0x2, 0x268, 0x26a, 0x7, 0x35b, 0x2, 0x2, 
       0x269, 0x268, 0x3, 0x2, 0x2, 0x2, 0x269, 0x26a, 0x3, 0x2, 0x2, 0x2, 
       0x26a, 0x271, 0x3, 0x2, 0x2, 0x2, 0x26b, 0x26c, 0x5, 0x1f4, 0xfb, 
       0x2, 0x26c, 0x26e, 0x7, 0x35c, 0x2, 0x2, 0x26d, 0x26f, 0x7, 0x35b, 
       0x2, 0x2, 0x26e, 0x26d, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x26f, 0x3, 0x2, 
       0x2, 0x2, 0x26f, 0x271, 0x3, 0x2, 0x2, 0x2, 0x270, 0x266, 0x3, 0x2, 
       0x2, 0x2, 0x270, 0x26b, 0x3, 0x2, 0x2, 0x2, 0x271, 0x17, 0x3, 0x2, 
       0x2, 0x2, 0x272, 0x274, 0x7, 0x12a, 0x2, 0x2, 0x273, 0x275, 0x5, 
       0x106, 0x84, 0x2, 0x274, 0x273, 0x3, 0x2, 0x2, 0x2, 0x274, 0x275, 
       0x3, 0x2, 0x2, 0x2, 0x275, 0x277, 0x3, 0x2, 0x2, 0x2, 0x276, 0x278, 
       0x7, 0x35b, 0x2, 0x2, 0x277, 0x276, 0x3, 0x2, 0x2, 0x2, 0x277, 0x278, 
       0x3, 0x2, 0x2, 0x2, 0x278, 0x19, 0x3, 0x2, 0x2, 0x2, 0x279, 0x27a, 
       0x7, 0x9f, 0x2, 0x2, 0x27a, 0x27b, 0x5, 0x11c, 0x8f, 0x2, 0x27b, 
       0x27e, 0x5, 0x8, 0x5, 0x2, 0x27c, 0x27d, 0x7, 0x6f, 0x2, 0x2, 0x27d, 
       0x27f, 0x5, 0x8, 0x5, 0x2, 0x27e, 0x27c, 0x3, 0x2, 0x2, 0x2, 0x27e, 
       0x27f, 0x3, 0x2, 0x2, 0x2, 0x27f, 0x281, 0x3, 0x2, 0x2, 0x2, 0x280, 
       0x282, 0x7, 0x35b, 0x2, 0x2, 0x281, 0x280, 0x3, 0x2, 0x2, 0x2, 0x281, 
       0x282, 0x3, 0x2, 0x2, 0x2, 0x282, 0x1b, 0x3, 0x2, 0x2, 0x2, 0x283, 
       0x28a, 0x7, 0x30f, 0x2, 0x2, 0x284, 0x285, 0x5, 0x1e, 0x10, 0x2, 
       0x285, 0x286, 0x7, 0x35a, 0x2, 0x2, 0x286, 0x287, 0x5, 0x20, 0x11, 
       0x2, 0x287, 0x288, 0x7, 0x35a, 0x2, 0x2, 0x288, 0x289, 0x5, 0x22, 
       0x12, 0x2, 0x289, 0x28b, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x284, 0x3, 0x2, 
       0x2, 0x2, 0x28a, 0x28b, 0x3, 0x2, 0x2, 0x2, 0x28b, 0x28d, 0x3, 0x2, 
       0x2, 0x2, 0x28c, 0x28e, 0x7, 0x35b, 0x2, 0x2, 0x28d, 0x28c, 0x3, 
       0x2, 0x2, 0x2, 0x28d, 0x28e, 0x3, 0x2, 0x2, 0x2, 0x28e, 0x1d, 0x3, 
       0x2, 0x2, 0x2, 0x28f, 0x290, 0x9, 0x2, 0x2, 0x2, 0x290, 0x1f, 0x3, 
       0x2, 0x2, 0x2, 0x291, 0x292, 0x9, 0x3, 0x2, 0x2, 0x292, 0x21, 0x3, 
       0x2, 0x2, 0x2, 0x293, 0x294, 0x9, 0x2, 0x2, 0x2, 0x294, 0x23, 0x3, 
       0x2, 0x2, 0x2, 0x295, 0x296, 0x7, 0x1e, 0x2, 0x2, 0x296, 0x298, 0x7, 
       0x31a, 0x2, 0x2, 0x297, 0x299, 0x7, 0x35b, 0x2, 0x2, 0x298, 0x297, 
       0x3, 0x2, 0x2, 0x2, 0x298, 0x299, 0x3, 0x2, 0x2, 0x2, 0x299, 0x29b, 
       0x3, 0x2, 0x2, 0x2, 0x29a, 0x29c, 0x5, 0x6, 0x4, 0x2, 0x29b, 0x29a, 
       0x3, 0x2, 0x2, 0x2, 0x29b, 0x29c, 0x3, 0x2, 0x2, 0x2, 0x29c, 0x29d, 
       0x3, 0x2, 0x2, 0x2, 0x29d, 0x29e, 0x7, 0x71, 0x2, 0x2, 0x29e, 0x2a0, 
       0x7, 0x31a, 0x2, 0x2, 0x29f, 0x2a1, 0x7, 0x35b, 0x2, 0x2, 0x2a0, 
       0x29f, 0x3, 0x2, 0x2, 0x2, 0x2a0, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x2a1, 
       0x2a2, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x2a3, 0x7, 0x1e, 0x2, 0x2, 0x2a3, 
       0x2a5, 0x7, 0x1c8, 0x2, 0x2, 0x2a4, 0x2a6, 0x7, 0x35b, 0x2, 0x2, 
       0x2a5, 0x2a4, 0x3, 0x2, 0x2, 0x2, 0x2a5, 0x2a6, 0x3, 0x2, 0x2, 0x2, 
       0x2a6, 0x2a8, 0x3, 0x2, 0x2, 0x2, 0x2a7, 0x2a9, 0x5, 0x6, 0x4, 0x2, 
       0x2a8, 0x2a7, 0x3, 0x2, 0x2, 0x2, 0x2a8, 0x2a9, 0x3, 0x2, 0x2, 0x2, 
       0x2a9, 0x2aa, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x2ab, 0x7, 0x71, 0x2, 0x2, 
       0x2ab, 0x2ad, 0x7, 0x1c8, 0x2, 0x2, 0x2ac, 0x2ae, 0x7, 0x35b, 0x2, 
       0x2, 0x2ad, 0x2ac, 0x3, 0x2, 0x2, 0x2, 0x2ad, 0x2ae, 0x3, 0x2, 0x2, 
       0x2, 0x2ae, 0x25, 0x3, 0x2, 0x2, 0x2, 0x2af, 0x2b1, 0x7, 0x18c, 0x2, 
       0x2, 0x2b0, 0x2b2, 0x5, 0x6c, 0x37, 0x2, 0x2b1, 0x2b0, 0x3, 0x2, 
       0x2, 0x2, 0x2b1, 0x2b2, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0x2b4, 0x3, 0x2, 
       0x2, 0x2, 0x2b3, 0x2b5, 0x7, 0x35a, 0x2, 0x2, 0x2b4, 0x2b3, 0x3, 
       0x2, 0x2, 0x2, 0x2b4, 0x2b5, 0x3, 0x2, 0x2, 0x2, 0x2b5, 0x2b8, 0x3, 
       0x2, 0x2, 0x2, 0x2b6, 0x2b7, 0x9, 0x4, 0x2, 0x2, 0x2b7, 0x2b9, 0x5, 
       0x70, 0x39, 0x2, 0x2b8, 0x2b6, 0x3, 0x2, 0x2, 0x2, 0x2b8, 0x2b9, 
       0x3, 0x2, 0x2, 0x2, 0x2b9, 0x2bb, 0x3, 0x2, 0x2, 0x2, 0x2ba, 0x2bc, 
       0x5, 0x106, 0x84, 0x2, 0x2bb, 0x2ba, 0x3, 0x2, 0x2, 0x2, 0x2bb, 0x2bc, 
       0x3, 0x2, 0x2, 0x2, 0x2bc, 0x2be, 0x3, 0x2, 0x2, 0x2, 0x2bd, 0x2bf, 
       0x7, 0x35b, 0x2, 0x2, 0x2be, 0x2bd, 0x3, 0x2, 0x2, 0x2, 0x2be, 0x2bf, 
       0x3, 0x2, 0x2, 0x2, 0x2bf, 0x27, 0x3, 0x2, 0x2, 0x2, 0x2c0, 0x2c1, 
       0x7, 0x18f, 0x2, 0x2, 0x2c1, 0x2cb, 0x5, 0x11c, 0x8f, 0x2, 0x2c2, 
       0x2cc, 0x5, 0x8, 0x5, 0x2, 0x2c3, 0x2c5, 0x7, 0x23, 0x2, 0x2, 0x2c4, 
       0x2c6, 0x7, 0x35b, 0x2, 0x2, 0x2c5, 0x2c4, 0x3, 0x2, 0x2, 0x2, 0x2c5, 
       0x2c6, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x2cc, 0x3, 0x2, 0x2, 0x2, 0x2c7, 
       0x2c9, 0x7, 0x47, 0x2, 0x2, 0x2c8, 0x2ca, 0x7, 0x35b, 0x2, 0x2, 0x2c9, 
       0x2c8, 0x3, 0x2, 0x2, 0x2, 0x2c9, 0x2ca, 0x3, 0x2, 0x2, 0x2, 0x2ca, 
       0x2cc, 0x3, 0x2, 0x2, 0x2, 0x2cb, 0x2c2, 0x3, 0x2, 0x2, 0x2, 0x2cb, 
       0x2c3, 0x3, 0x2, 0x2, 0x2, 0x2cb, 0x2c7, 0x3, 0x2, 0x2, 0x2, 0x2cc, 
       0x29, 0x3, 0x2, 0x2, 0x2, 0x2cd, 0x2d0, 0x7, 0x10f, 0x2, 0x2, 0x2ce, 
       0x2d1, 0x5, 0x106, 0x84, 0x2, 0x2cf, 0x2d1, 0x7, 0x33a, 0x2, 0x2, 
       0x2d0, 0x2ce, 0x3, 0x2, 0x2, 0x2, 0x2d0, 0x2cf, 0x3, 0x2, 0x2, 0x2, 
       0x2d1, 0x2d6, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x2d3, 0x7, 0x35a, 0x2, 
       0x2, 0x2d3, 0x2d5, 0x7, 0x33d, 0x2, 0x2, 0x2d4, 0x2d2, 0x3, 0x2, 
       0x2, 0x2, 0x2d5, 0x2d8, 0x3, 0x2, 0x2, 0x2, 0x2d6, 0x2d4, 0x3, 0x2, 
       0x2, 0x2, 0x2d6, 0x2d7, 0x3, 0x2, 0x2, 0x2, 0x2d7, 0x2da, 0x3, 0x2, 
       0x2, 0x2, 0x2d8, 0x2d6, 0x3, 0x2, 0x2, 0x2, 0x2d9, 0x2db, 0x7, 0x35b, 
       0x2, 0x2, 0x2da, 0x2d9, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x2db, 0x3, 0x2, 
       0x2, 0x2, 0x2db, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x2dc, 0x2dd, 0x7, 0x116, 
       0x2, 0x2, 0x2dd, 0x2de, 0x7, 0x358, 0x2, 0x2, 0x2de, 0x2df, 0x9, 
       0x5, 0x2, 0x2, 0x2df, 0x2e0, 0x7, 0x35a, 0x2, 0x2, 0x2e0, 0x2e1, 
       0x5, 0x104, 0x83, 0x2, 0x2e1, 0x2e2, 0x7, 0x35a, 0x2, 0x2, 0x2e2, 
       0x2e7, 0x5, 0x104, 0x83, 0x2, 0x2e3, 0x2e4, 0x7, 0x35a, 0x2, 0x2, 
       0x2e4, 0x2e6, 0x5, 0x104, 0x83, 0x2, 0x2e5, 0x2e3, 0x3, 0x2, 0x2, 
       0x2, 0x2e6, 0x2e9, 0x3, 0x2, 0x2, 0x2, 0x2e7, 0x2e5, 0x3, 0x2, 0x2, 
       0x2, 0x2e7, 0x2e8, 0x3, 0x2, 0x2, 0x2, 0x2e8, 0x2ea, 0x3, 0x2, 0x2, 
       0x2, 0x2e9, 0x2e7, 0x3, 0x2, 0x2, 0x2, 0x2ea, 0x2ed, 0x7, 0x359, 
       0x2, 0x2, 0x2eb, 0x2ec, 0x7, 0x191, 0x2, 0x2, 0x2ec, 0x2ee, 0x9, 
       0x6, 0x2, 0x2, 0x2ed, 0x2eb, 0x3, 0x2, 0x2, 0x2, 0x2ed, 0x2ee, 0x3, 
       0x2, 0x2, 0x2, 0x2ee, 0x2f0, 0x3, 0x2, 0x2, 0x2, 0x2ef, 0x2f1, 0x7, 
       0x35b, 0x2, 0x2, 0x2f0, 0x2ef, 0x3, 0x2, 0x2, 0x2, 0x2f0, 0x2f1, 
       0x3, 0x2, 0x2, 0x2, 0x2f1, 0x2fd, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x2f3, 
       0x7, 0x116, 0x2, 0x2, 0x2f3, 0x2f4, 0x7, 0x33e, 0x2, 0x2, 0x2f4, 
       0x2f9, 0x9, 0x7, 0x2, 0x2, 0x2f5, 0x2f6, 0x7, 0x35a, 0x2, 0x2, 0x2f6, 
       0x2f8, 0x9, 0x5, 0x2, 0x2, 0x2f7, 0x2f5, 0x3, 0x2, 0x2, 0x2, 0x2f8, 
       0x2fb, 0x3, 0x2, 0x2, 0x2, 0x2f9, 0x2f7, 0x3, 0x2, 0x2, 0x2, 0x2f9, 
       0x2fa, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x2fd, 0x3, 0x2, 0x2, 0x2, 0x2fb, 
       0x2f9, 0x3, 0x2, 0x2, 0x2, 0x2fc, 0x2dc, 0x3, 0x2, 0x2, 0x2, 0x2fc, 
       0x2f2, 0x3, 0x2, 0x2, 0x2, 0x2fd, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x2fe, 
       0x2ff, 0x7, 0x35b, 0x2, 0x2, 0x2ff, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x300, 
       0x30f, 0x5, 0xb6, 0x5c, 0x2, 0x301, 0x30f, 0x5, 0xb8, 0x5d, 0x2, 
       0x302, 0x30f, 0x5, 0x5a, 0x2e, 0x2, 0x303, 0x30f, 0x5, 0x50, 0x29, 
       0x2, 0x304, 0x30f, 0x5, 0x54, 0x2b, 0x2, 0x305, 0x30f, 0x5, 0xc2, 
       0x62, 0x2, 0x306, 0x30f, 0x5, 0xba, 0x5e, 0x2, 0x307, 0x30f, 0x5, 
       0x5c, 0x2f, 0x2, 0x308, 0x30f, 0x5, 0xca, 0x66, 0x2, 0x309, 0x30f, 
       0x5, 0xcc, 0x67, 0x2, 0x30a, 0x30f, 0x5, 0xd0, 0x69, 0x2, 0x30b, 
       0x30f, 0x5, 0xd2, 0x6a, 0x2, 0x30c, 0x30f, 0x5, 0xd4, 0x6b, 0x2, 
       0x30d, 0x30f, 0x5, 0xd6, 0x6c, 0x2, 0x30e, 0x300, 0x3, 0x2, 0x2, 
       0x2, 0x30e, 0x301, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x302, 0x3, 0x2, 0x2, 
       0x2, 0x30e, 0x303, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x304, 0x3, 0x2, 0x2, 
       0x2, 0x30e, 0x305, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x306, 0x3, 0x2, 0x2, 
       0x2, 0x30e, 0x307, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x308, 0x3, 0x2, 0x2, 
       0x2, 0x30e, 0x309, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x30a, 0x3, 0x2, 0x2, 
       0x2, 0x30e, 0x30b, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x30c, 0x3, 0x2, 0x2, 
       0x2, 0x30e, 0x30d, 0x3, 0x2, 0x2, 0x2, 0x30f, 0x31, 0x3, 0x2, 0x2, 
       0x2, 0x310, 0x311, 0x7, 0x6c, 0x2, 0x2, 0x311, 0x314, 0x7, 0x1a2, 
       0x2, 0x2, 0x312, 0x313, 0x7, 0x9f, 0x2, 0x2, 0x313, 0x315, 0x7, 0x7c, 
       0x2, 0x2, 0x314, 0x312, 0x3, 0x2, 0x2, 0x2, 0x314, 0x315, 0x3, 0x2, 
       0x2, 0x2, 0x315, 0x319, 0x3, 0x2, 0x2, 0x2, 0x316, 0x317, 0x5, 0x1f4, 
       0xfb, 0x2, 0x317, 0x318, 0x7, 0x353, 0x2, 0x2, 0x318, 0x31a, 0x3, 
       0x2, 0x2, 0x2, 0x319, 0x316, 0x3, 0x2, 0x2, 0x2, 0x319, 0x31a, 0x3, 
       0x2, 0x2, 0x2, 0x31a, 0x31b, 0x3, 0x2, 0x2, 0x2, 0x31b, 0x31c, 0x5, 
       0x1f4, 0xfb, 0x2, 0x31c, 0x33, 0x3, 0x2, 0x2, 0x2, 0x31d, 0x31e, 
       0x7, 0x170, 0x2, 0x2, 0x31e, 0x35, 0x3, 0x2, 0x2, 0x2, 0x31f, 0x320, 
       0x7, 0x35c, 0x2, 0x2, 0x320, 0x321, 0x7, 0x35c, 0x2, 0x2, 0x321, 
       0x37, 0x3, 0x2, 0x2, 0x2, 0x322, 0x323, 0x9, 0x8, 0x2, 0x2, 0x323, 
       0x39, 0x3, 0x2, 0x2, 0x2, 0x324, 0x325, 0x9, 0x8, 0x2, 0x2, 0x325, 
       0x3b, 0x3, 0x2, 0x2, 0x2, 0x326, 0x327, 0x9, 0x9, 0x2, 0x2, 0x327, 
       0x3d, 0x3, 0x2, 0x2, 0x2, 0x328, 0x329, 0x7, 0x6c, 0x2, 0x2, 0x329, 
       0x32c, 0x7, 0x140, 0x2, 0x2, 0x32a, 0x32b, 0x7, 0x9f, 0x2, 0x2, 0x32b, 
       0x32d, 0x7, 0x7c, 0x2, 0x2, 0x32c, 0x32a, 0x3, 0x2, 0x2, 0x2, 0x32c, 
       0x32d, 0x3, 0x2, 0x2, 0x2, 0x32d, 0x32e, 0x3, 0x2, 0x2, 0x2, 0x32e, 
       0x32f, 0x5, 0x1f4, 0xfb, 0x2, 0x32f, 0x3f, 0x3, 0x2, 0x2, 0x2, 0x330, 
       0x331, 0x7, 0x254, 0x2, 0x2, 0x331, 0x332, 0x7, 0x169, 0x2, 0x2, 
       0x332, 0x333, 0x5, 0x1bc, 0xdf, 0x2, 0x333, 0x334, 0x7, 0xa1, 0x2, 
       0x2, 0x334, 0x335, 0x9, 0xa, 0x2, 0x2, 0x335, 0x339, 0x7, 0x274, 
       0x2, 0x2, 0x336, 0x337, 0x7, 0x32c, 0x2, 0x2, 0x337, 0x33a, 0x7, 
       0x33e, 0x2, 0x2, 0x338, 0x33a, 0x7, 0x287, 0x2, 0x2, 0x339, 0x336, 
       0x3, 0x2, 0x2, 0x2, 0x339, 0x338, 0x3, 0x2, 0x2, 0x2, 0x339, 0x33a, 
       0x3, 0x2, 0x2, 0x2, 0x33a, 0x33c, 0x3, 0x2, 0x2, 0x2, 0x33b, 0x33d, 
       0x7, 0x35b, 0x2, 0x2, 0x33c, 0x33b, 0x3, 0x2, 0x2, 0x2, 0x33c, 0x33d, 
       0x3, 0x2, 0x2, 0x2, 0x33d, 0x41, 0x3, 0x2, 0x2, 0x2, 0x33e, 0x33f, 
       0x7, 0x177, 0x2, 0x2, 0x33f, 0x340, 0x7, 0x169, 0x2, 0x2, 0x340, 
       0x354, 0x5, 0x1bc, 0xdf, 0x2, 0x341, 0x342, 0x7, 0x191, 0x2, 0x2, 
       0x342, 0x343, 0x7, 0x358, 0x2, 0x2, 0x343, 0x344, 0x7, 0x29c, 0x2, 
       0x2, 0x344, 0x34e, 0x7, 0x358, 0x2, 0x2, 0x345, 0x347, 0x7, 0x35a, 
       0x2, 0x2, 0x346, 0x345, 0x3, 0x2, 0x2, 0x2, 0x346, 0x347, 0x3, 0x2, 
       0x2, 0x2, 0x347, 0x34c, 0x3, 0x2, 0x2, 0x2, 0x348, 0x34d, 0x7, 0x33e, 
       0x2, 0x2, 0x349, 0x34a, 0x7, 0x33e, 0x2, 0x2, 0x34a, 0x34b, 0x7, 
       0x170, 0x2, 0x2, 0x34b, 0x34d, 0x7, 0x33e, 0x2, 0x2, 0x34c, 0x348, 
       0x3, 0x2, 0x2, 0x2, 0x34c, 0x349, 0x3, 0x2, 0x2, 0x2, 0x34d, 0x34f, 
       0x3, 0x2, 0x2, 0x2, 0x34e, 0x346, 0x3, 0x2, 0x2, 0x2, 0x34f, 0x350, 
       0x3, 0x2, 0x2, 0x2, 0x350, 0x34e, 0x3, 0x2, 0x2, 0x2, 0x350, 0x351, 
       0x3, 0x2, 0x2, 0x2, 0x351, 0x352, 0x3, 0x2, 0x2, 0x2, 0x352, 0x353, 
       0x7, 0x359, 0x2, 0x2, 0x353, 0x355, 0x7, 0x359, 0x2, 0x2, 0x354, 
       0x341, 0x3, 0x2, 0x2, 0x2, 0x354, 0x355, 0x3, 0x2, 0x2, 0x2, 0x355, 
       0x43, 0x3, 0x2, 0x2, 0x2, 0x356, 0x358, 0x7, 0x35a, 0x2, 0x2, 0x357, 
       0x356, 0x3, 0x2, 0x2, 0x2, 0x357, 0x358, 0x3, 0x2, 0x2, 0x2, 0x358, 
       0x35a, 0x3, 0x2, 0x2, 0x2, 0x359, 0x35b, 0x9, 0xb, 0x2, 0x2, 0x35a, 
       0x359, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x35b, 0x3, 0x2, 0x2, 0x2, 0x35b, 
       0x35d, 0x3, 0x2, 0x2, 0x2, 0x35c, 0x35e, 0x7, 0xe9, 0x2, 0x2, 0x35d, 
       0x35c, 0x3, 0x2, 0x2, 0x2, 0x35d, 0x35e, 0x3, 0x2, 0x2, 0x2, 0x35e, 
       0x364, 0x3, 0x2, 0x2, 0x2, 0x35f, 0x365, 0x5, 0x46, 0x24, 0x2, 0x360, 
       0x361, 0x7, 0x358, 0x2, 0x2, 0x361, 0x362, 0x5, 0x44, 0x23, 0x2, 
       0x362, 0x363, 0x7, 0x359, 0x2, 0x2, 0x363, 0x365, 0x3, 0x2, 0x2, 
       0x2, 0x364, 0x35f, 0x3, 0x2, 0x2, 0x2, 0x364, 0x360, 0x3, 0x2, 0x2, 
       0x2, 0x365, 0x367, 0x3, 0x2, 0x2, 0x2, 0x366, 0x357, 0x3, 0x2, 0x2, 
       0x2, 0x367, 0x368, 0x3, 0x2, 0x2, 0x2, 0x368, 0x366, 0x3, 0x2, 0x2, 
       0x2, 0x368, 0x369, 0x3, 0x2, 0x2, 0x2, 0x369, 0x45, 0x3, 0x2, 0x2, 
       0x2, 0x36a, 0x370, 0x5, 0x48, 0x25, 0x2, 0x36b, 0x36c, 0x7, 0x358, 
       0x2, 0x2, 0x36c, 0x36d, 0x5, 0x44, 0x23, 0x2, 0x36d, 0x36e, 0x7, 
       0x359, 0x2, 0x2, 0x36e, 0x370, 0x3, 0x2, 0x2, 0x2, 0x36f, 0x36a, 
       0x3, 0x2, 0x2, 0x2, 0x36f, 0x36b, 0x3, 0x2, 0x2, 0x2, 0x370, 0x47, 
       0x3, 0x2, 0x2, 0x2, 0x371, 0x38e, 0x5, 0x1f4, 0xfb, 0x2, 0x372, 0x37d, 
       0x5, 0x1f4, 0xfb, 0x2, 0x373, 0x374, 0x5, 0x1f4, 0xfb, 0x2, 0x374, 
       0x375, 0x7, 0x353, 0x2, 0x2, 0x375, 0x377, 0x3, 0x2, 0x2, 0x2, 0x376, 
       0x373, 0x3, 0x2, 0x2, 0x2, 0x376, 0x377, 0x3, 0x2, 0x2, 0x2, 0x377, 
       0x378, 0x3, 0x2, 0x2, 0x2, 0x378, 0x379, 0x5, 0x1f4, 0xfb, 0x2, 0x379, 
       0x37a, 0x7, 0x353, 0x2, 0x2, 0x37a, 0x37b, 0x5, 0x1f4, 0xfb, 0x2, 
       0x37b, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x37c, 0x372, 0x3, 0x2, 0x2, 0x2, 
       0x37c, 0x376, 0x3, 0x2, 0x2, 0x2, 0x37d, 0x389, 0x3, 0x2, 0x2, 0x2, 
       0x37e, 0x38a, 0x7, 0x346, 0x2, 0x2, 0x37f, 0x380, 0x7, 0x348, 0x2, 
       0x2, 0x380, 0x38a, 0x7, 0x347, 0x2, 0x2, 0x381, 0x382, 0x7, 0x349, 
       0x2, 0x2, 0x382, 0x38a, 0x7, 0x346, 0x2, 0x2, 0x383, 0x38a, 0x7, 
       0x347, 0x2, 0x2, 0x384, 0x385, 0x7, 0x347, 0x2, 0x2, 0x385, 0x38a, 
       0x7, 0x346, 0x2, 0x2, 0x386, 0x38a, 0x7, 0x348, 0x2, 0x2, 0x387, 
       0x388, 0x7, 0x348, 0x2, 0x2, 0x388, 0x38a, 0x7, 0x346, 0x2, 0x2, 
       0x389, 0x37e, 0x3, 0x2, 0x2, 0x2, 0x389, 0x37f, 0x3, 0x2, 0x2, 0x2, 
       0x389, 0x381, 0x3, 0x2, 0x2, 0x2, 0x389, 0x383, 0x3, 0x2, 0x2, 0x2, 
       0x389, 0x384, 0x3, 0x2, 0x2, 0x2, 0x389, 0x386, 0x3, 0x2, 0x2, 0x2, 
       0x389, 0x387, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x38b, 0x3, 0x2, 0x2, 0x2, 
       0x38b, 0x38c, 0x9, 0xc, 0x2, 0x2, 0x38c, 0x38e, 0x3, 0x2, 0x2, 0x2, 
       0x38d, 0x371, 0x3, 0x2, 0x2, 0x2, 0x38d, 0x37c, 0x3, 0x2, 0x2, 0x2, 
       0x38e, 0x3aa, 0x3, 0x2, 0x2, 0x2, 0x38f, 0x390, 0x5, 0x1f4, 0xfb, 
       0x2, 0x390, 0x391, 0x7, 0x353, 0x2, 0x2, 0x391, 0x393, 0x3, 0x2, 
       0x2, 0x2, 0x392, 0x38f, 0x3, 0x2, 0x2, 0x2, 0x392, 0x393, 0x3, 0x2, 
       0x2, 0x2, 0x393, 0x394, 0x3, 0x2, 0x2, 0x2, 0x394, 0x395, 0x5, 0x1f4, 
       0xfb, 0x2, 0x395, 0x396, 0x7, 0x353, 0x2, 0x2, 0x396, 0x397, 0x5, 
       0x1f4, 0xfb, 0x2, 0x397, 0x3a5, 0x7, 0x358, 0x2, 0x2, 0x398, 0x3a6, 
       0x5, 0x1f4, 0xfb, 0x2, 0x399, 0x39a, 0x5, 0x1f4, 0xfb, 0x2, 0x39a, 
       0x39b, 0x7, 0x353, 0x2, 0x2, 0x39b, 0x39d, 0x3, 0x2, 0x2, 0x2, 0x39c, 
       0x399, 0x3, 0x2, 0x2, 0x2, 0x39c, 0x39d, 0x3, 0x2, 0x2, 0x2, 0x39d, 
       0x39e, 0x3, 0x2, 0x2, 0x2, 0x39e, 0x39f, 0x5, 0x1f4, 0xfb, 0x2, 0x39f, 
       0x3a0, 0x7, 0x353, 0x2, 0x2, 0x3a0, 0x3a1, 0x5, 0x1f4, 0xfb, 0x2, 
       0x3a1, 0x3a2, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x3a3, 0x7, 0x35a, 0x2, 
       0x2, 0x3a3, 0x3a4, 0x9, 0xc, 0x2, 0x2, 0x3a4, 0x3a6, 0x3, 0x2, 0x2, 
       0x2, 0x3a5, 0x398, 0x3, 0x2, 0x2, 0x2, 0x3a5, 0x39c, 0x3, 0x2, 0x2, 
       0x2, 0x3a6, 0x3a7, 0x3, 0x2, 0x2, 0x2, 0x3a7, 0x3a8, 0x7, 0x359, 
       0x2, 0x2, 0x3a8, 0x3aa, 0x3, 0x2, 0x2, 0x2, 0x3a9, 0x38d, 0x3, 0x2, 
       0x2, 0x2, 0x3a9, 0x392, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x49, 0x3, 0x2, 
       0x2, 0x2, 0x3ab, 0x3ac, 0x7, 0xb, 0x2, 0x2, 0x3ac, 0x3ad, 0x7, 0x140, 
       0x2, 0x2, 0x3ad, 0x3ae, 0x5, 0x1f4, 0xfb, 0x2, 0x3ae, 0x3b8, 0x7, 
       0x175, 0x2, 0x2, 0x3af, 0x3b5, 0x7, 0x28c, 0x2, 0x2, 0x3b0, 0x3b5, 
       0x7, 0x31d, 0x2, 0x2, 0x3b1, 0x3b2, 0x7, 0x331, 0x2, 0x2, 0x3b2, 
       0x3b3, 0x7, 0x140, 0x2, 0x2, 0x3b3, 0x3b5, 0x7, 0x1ce, 0x2, 0x2, 
       0x3b4, 0x3af, 0x3, 0x2, 0x2, 0x2, 0x3b4, 0x3b0, 0x3, 0x2, 0x2, 0x2, 
       0x3b4, 0x3b1, 0x3, 0x2, 0x2, 0x2, 0x3b5, 0x3b6, 0x3, 0x2, 0x2, 0x2, 
       0x3b6, 0x3b7, 0x7, 0x35c, 0x2, 0x2, 0x3b7, 0x3b9, 0x7, 0x35c, 0x2, 
       0x2, 0x3b8, 0x3b4, 0x3, 0x2, 0x2, 0x2, 0x3b8, 0x3b9, 0x3, 0x2, 0x2, 
       0x2, 0x3b9, 0x3ba, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x3bd, 0x5, 0x1f4, 
       0xfb, 0x2, 0x3bb, 0x3bc, 0x7, 0x353, 0x2, 0x2, 0x3bc, 0x3be, 0x5, 
       0x1f4, 0xfb, 0x2, 0x3bd, 0x3bb, 0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3be, 
       0x3, 0x2, 0x2, 0x2, 0x3be, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x3bf, 0x3c0, 
       0x7, 0x4e, 0x2, 0x2, 0x3c0, 0x3c8, 0x7, 0x140, 0x2, 0x2, 0x3c1, 0x3c9, 
       0x5, 0x1f4, 0xfb, 0x2, 0x3c2, 0x3c3, 0x7, 0x16, 0x2, 0x2, 0x3c3, 
       0x3c9, 0x5, 0x1f4, 0xfb, 0x2, 0x3c4, 0x3c5, 0x5, 0x1f4, 0xfb, 0x2, 
       0x3c5, 0x3c6, 0x7, 0x16, 0x2, 0x2, 0x3c6, 0x3c7, 0x5, 0x1f4, 0xfb, 
       0x2, 0x3c7, 0x3c9, 0x3, 0x2, 0x2, 0x2, 0x3c8, 0x3c1, 0x3, 0x2, 0x2, 
       0x2, 0x3c8, 0x3c2, 0x3, 0x2, 0x2, 0x2, 0x3c8, 0x3c4, 0x3, 0x2, 0x2, 
       0x2, 0x3c9, 0x3e6, 0x3, 0x2, 0x2, 0x2, 0x3ca, 0x3e5, 0x5, 0x8e, 0x48, 
       0x2, 0x3cb, 0x3e5, 0x5, 0x92, 0x4a, 0x2, 0x3cc, 0x3cd, 0x9, 0xd, 
       0x2, 0x2, 0x3cd, 0x3ce, 0x9, 0xe, 0x2, 0x2, 0x3ce, 0x3d2, 0x7, 0xf2, 
       0x2, 0x2, 0x3cf, 0x3d0, 0x7, 0x140, 0x2, 0x2, 0x3d0, 0x3d1, 0x7, 
       0x35c, 0x2, 0x2, 0x3d1, 0x3d3, 0x7, 0x35c, 0x2, 0x2, 0x3d2, 0x3cf, 
       0x3, 0x2, 0x2, 0x2, 0x3d2, 0x3d3, 0x3, 0x2, 0x2, 0x2, 0x3d3, 0x3d4, 
       0x3, 0x2, 0x2, 0x2, 0x3d4, 0x3d5, 0x5, 0x1f4, 0xfb, 0x2, 0x3d5, 0x3d6, 
       0x7, 0x170, 0x2, 0x2, 0x3d6, 0x3d7, 0x5, 0x1f4, 0xfb, 0x2, 0x3d7, 
       0x3e5, 0x3, 0x2, 0x2, 0x2, 0x3d8, 0x3d9, 0x7, 0x12d, 0x2, 0x2, 0x3d9, 
       0x3da, 0x9, 0xe, 0x2, 0x2, 0x3da, 0x3de, 0x7, 0xf2, 0x2, 0x2, 0x3db, 
       0x3dc, 0x7, 0x140, 0x2, 0x2, 0x3dc, 0x3dd, 0x7, 0x35c, 0x2, 0x2, 
       0x3dd, 0x3df, 0x7, 0x35c, 0x2, 0x2, 0x3de, 0x3db, 0x3, 0x2, 0x2, 
       0x2, 0x3de, 0x3df, 0x3, 0x2, 0x2, 0x2, 0x3df, 0x3e0, 0x3, 0x2, 0x2, 
       0x2, 0x3e0, 0x3e1, 0x5, 0x1f4, 0xfb, 0x2, 0x3e1, 0x3e2, 0x7, 0x91, 
       0x2, 0x2, 0x3e2, 0x3e3, 0x5, 0x1f4, 0xfb, 0x2, 0x3e3, 0x3e5, 0x3, 
       0x2, 0x2, 0x2, 0x3e4, 0x3ca, 0x3, 0x2, 0x2, 0x2, 0x3e4, 0x3cb, 0x3, 
       0x2, 0x2, 0x2, 0x3e4, 0x3cc, 0x3, 0x2, 0x2, 0x2, 0x3e4, 0x3d8, 0x3, 
       0x2, 0x2, 0x2, 0x3e5, 0x3e8, 0x3, 0x2, 0x2, 0x2, 0x3e6, 0x3e4, 0x3, 
       0x2, 0x2, 0x2, 0x3e6, 0x3e7, 0x3, 0x2, 0x2, 0x2, 0x3e7, 0x4d, 0x3, 
       0x2, 0x2, 0x2, 0x3e8, 0x3e6, 0x3, 0x2, 0x2, 0x2, 0x3e9, 0x3ea, 0x7, 
       0x4e, 0x2, 0x2, 0x3ea, 0x3eb, 0x7, 0x331, 0x2, 0x2, 0x3eb, 0x3ec, 
       0x7, 0x140, 0x2, 0x2, 0x3ec, 0x3f0, 0x7, 0x1ce, 0x2, 0x2, 0x3ed, 
       0x3ee, 0x5, 0x1f4, 0xfb, 0x2, 0x3ee, 0x3ef, 0x7, 0x353, 0x2, 0x2, 
       0x3ef, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x3f0, 0x3ed, 0x3, 0x2, 0x2, 0x2, 
       0x3f0, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x3f1, 0x3f2, 0x3, 0x2, 0x2, 0x2, 
       0x3f2, 0x3f3, 0x5, 0x1f4, 0xfb, 0x2, 0x3f3, 0x3f7, 0x7, 0x11, 0x2, 
       0x2, 0x3f4, 0x3f8, 0x7, 0x342, 0x2, 0x2, 0x3f5, 0x3f8, 0x5, 0x1f4, 
       0xfb, 0x2, 0x3f6, 0x3f8, 0x7, 0x33d, 0x2, 0x2, 0x3f7, 0x3f4, 0x3, 
       0x2, 0x2, 0x2, 0x3f7, 0x3f5, 0x3, 0x2, 0x2, 0x2, 0x3f7, 0x3f6, 0x3, 
       0x2, 0x2, 0x2, 0x3f8, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x3f9, 0x3fa, 0x7, 
       0x4e, 0x2, 0x2, 0x3fa, 0x3fd, 0x7, 0x2af, 0x2, 0x2, 0x3fb, 0x3fe, 
       0x5, 0x1ba, 0xde, 0x2, 0x3fc, 0x3fe, 0x5, 0x1f4, 0xfb, 0x2, 0x3fd, 
       0x3fb, 0x3, 0x2, 0x2, 0x2, 0x3fd, 0x3fc, 0x3, 0x2, 0x2, 0x2, 0x3fe, 
       0x400, 0x3, 0x2, 0x2, 0x2, 0x3ff, 0x401, 0x5, 0x52, 0x2a, 0x2, 0x400, 
       0x3ff, 0x3, 0x2, 0x2, 0x2, 0x400, 0x401, 0x3, 0x2, 0x2, 0x2, 0x401, 
       0x405, 0x3, 0x2, 0x2, 0x2, 0x402, 0x403, 0x7, 0xf2, 0x2, 0x2, 0x403, 
       0x406, 0x5, 0x1f4, 0xfb, 0x2, 0x404, 0x406, 0x7, 0x5e, 0x2, 0x2, 
       0x405, 0x402, 0x3, 0x2, 0x2, 0x2, 0x405, 0x404, 0x3, 0x2, 0x2, 0x2, 
       0x405, 0x406, 0x3, 0x2, 0x2, 0x2, 0x406, 0x51, 0x3, 0x2, 0x2, 0x2, 
       0x407, 0x40e, 0x7, 0x191, 0x2, 0x2, 0x408, 0x409, 0x7, 0x2fb, 0x2, 
       0x2, 0x409, 0x40a, 0x7, 0x346, 0x2, 0x2, 0x40a, 0x40c, 0x9, 0xf, 
       0x2, 0x2, 0x40b, 0x40d, 0x7, 0x35a, 0x2, 0x2, 0x40c, 0x40b, 0x3, 
       0x2, 0x2, 0x2, 0x40c, 0x40d, 0x3, 0x2, 0x2, 0x2, 0x40d, 0x40f, 0x3, 
       0x2, 0x2, 0x2, 0x40e, 0x408, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x40f, 0x3, 
       0x2, 0x2, 0x2, 0x40f, 0x416, 0x3, 0x2, 0x2, 0x2, 0x410, 0x411, 0x7, 
       0x2d0, 0x2, 0x2, 0x411, 0x412, 0x7, 0x346, 0x2, 0x2, 0x412, 0x414, 
       0x9, 0xf, 0x2, 0x2, 0x413, 0x415, 0x7, 0x35a, 0x2, 0x2, 0x414, 0x413, 
       0x3, 0x2, 0x2, 0x2, 0x414, 0x415, 0x3, 0x2, 0x2, 0x2, 0x415, 0x417, 
       0x3, 0x2, 0x2, 0x2, 0x416, 0x410, 0x3, 0x2, 0x2, 0x2, 0x416, 0x417, 
       0x3, 0x2, 0x2, 0x2, 0x417, 0x445, 0x3, 0x2, 0x2, 0x2, 0x418, 0x419, 
       0x7, 0x19a, 0x2, 0x2, 0x419, 0x43f, 0x7, 0x358, 0x2, 0x2, 0x41a, 
       0x41b, 0x7, 0x2fb, 0x2, 0x2, 0x41b, 0x41c, 0x7, 0x346, 0x2, 0x2, 
       0x41c, 0x41e, 0x9, 0xf, 0x2, 0x2, 0x41d, 0x41f, 0x7, 0x35a, 0x2, 
       0x2, 0x41e, 0x41d, 0x3, 0x2, 0x2, 0x2, 0x41e, 0x41f, 0x3, 0x2, 0x2, 
       0x2, 0x41f, 0x421, 0x3, 0x2, 0x2, 0x2, 0x420, 0x41a, 0x3, 0x2, 0x2, 
       0x2, 0x420, 0x421, 0x3, 0x2, 0x2, 0x2, 0x421, 0x428, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x423, 0x7, 0x2aa, 0x2, 0x2, 0x423, 0x424, 0x7, 0x346, 
       0x2, 0x2, 0x424, 0x426, 0x5, 0x1c2, 0xe2, 0x2, 0x425, 0x427, 0x7, 
       0x35a, 0x2, 0x2, 0x426, 0x425, 0x3, 0x2, 0x2, 0x2, 0x426, 0x427, 
       0x3, 0x2, 0x2, 0x2, 0x427, 0x429, 0x3, 0x2, 0x2, 0x2, 0x428, 0x422, 
       0x3, 0x2, 0x2, 0x2, 0x428, 0x429, 0x3, 0x2, 0x2, 0x2, 0x429, 0x430, 
       0x3, 0x2, 0x2, 0x2, 0x42a, 0x42b, 0x7, 0x263, 0x2, 0x2, 0x42b, 0x42c, 
       0x7, 0x346, 0x2, 0x2, 0x42c, 0x42e, 0x7, 0x33e, 0x2, 0x2, 0x42d, 
       0x42f, 0x7, 0x35a, 0x2, 0x2, 0x42e, 0x42d, 0x3, 0x2, 0x2, 0x2, 0x42e, 
       0x42f, 0x3, 0x2, 0x2, 0x2, 0x42f, 0x431, 0x3, 0x2, 0x2, 0x2, 0x430, 
       0x42a, 0x3, 0x2, 0x2, 0x2, 0x430, 0x431, 0x3, 0x2, 0x2, 0x2, 0x431, 
       0x43c, 0x3, 0x2, 0x2, 0x2, 0x432, 0x433, 0x7, 0x7b, 0x2, 0x2, 0x433, 
       0x437, 0x7, 0x11, 0x2, 0x2, 0x434, 0x438, 0x7, 0x2e6, 0x2, 0x2, 0x435, 
       0x438, 0x7, 0x342, 0x2, 0x2, 0x436, 0x438, 0x7, 0x298, 0x2, 0x2, 
       0x437, 0x434, 0x3, 0x2, 0x2, 0x2, 0x437, 0x435, 0x3, 0x2, 0x2, 0x2, 
       0x437, 0x436, 0x3, 0x2, 0x2, 0x2, 0x438, 0x43a, 0x3, 0x2, 0x2, 0x2, 
       0x439, 0x43b, 0x7, 0x35a, 0x2, 0x2, 0x43a, 0x439, 0x3, 0x2, 0x2, 
       0x2, 0x43a, 0x43b, 0x3, 0x2, 0x2, 0x2, 0x43b, 0x43d, 0x3, 0x2, 0x2, 
       0x2, 0x43c, 0x432, 0x3, 0x2, 0x2, 0x2, 0x43c, 0x43d, 0x3, 0x2, 0x2, 
       0x2, 0x43d, 0x440, 0x3, 0x2, 0x2, 0x2, 0x43e, 0x440, 0x7, 0x6c, 0x2, 
       0x2, 0x43f, 0x420, 0x3, 0x2, 0x2, 0x2, 0x43f, 0x43e, 0x3, 0x2, 0x2, 
       0x2, 0x440, 0x441, 0x3, 0x2, 0x2, 0x2, 0x441, 0x443, 0x7, 0x359, 
       0x2, 0x2, 0x442, 0x444, 0x7, 0x35a, 0x2, 0x2, 0x443, 0x442, 0x3, 
       0x2, 0x2, 0x2, 0x443, 0x444, 0x3, 0x2, 0x2, 0x2, 0x444, 0x446, 0x3, 
       0x2, 0x2, 0x2, 0x445, 0x418, 0x3, 0x2, 0x2, 0x2, 0x445, 0x446, 0x3, 
       0x2, 0x2, 0x2, 0x446, 0x44e, 0x3, 0x2, 0x2, 0x2, 0x447, 0x448, 0x7, 
       0x29f, 0x2, 0x2, 0x448, 0x449, 0x7, 0x358, 0x2, 0x2, 0x449, 0x44a, 
       0x7, 0x2fb, 0x2, 0x2, 0x44a, 0x44b, 0x7, 0x346, 0x2, 0x2, 0x44b, 
       0x44c, 0x9, 0xf, 0x2, 0x2, 0x44c, 0x44d, 0x3, 0x2, 0x2, 0x2, 0x44d, 
       0x44f, 0x7, 0x359, 0x2, 0x2, 0x44e, 0x447, 0x3, 0x2, 0x2, 0x2, 0x44e, 
       0x44f, 0x3, 0x2, 0x2, 0x2, 0x44f, 0x53, 0x3, 0x2, 0x2, 0x2, 0x450, 
       0x451, 0x7, 0xb, 0x2, 0x2, 0x451, 0x454, 0x7, 0x2af, 0x2, 0x2, 0x452, 
       0x455, 0x5, 0x1ba, 0xde, 0x2, 0x453, 0x455, 0x5, 0x1f4, 0xfb, 0x2, 
       0x454, 0x452, 0x3, 0x2, 0x2, 0x2, 0x454, 0x453, 0x3, 0x2, 0x2, 0x2, 
       0x455, 0x458, 0x3, 0x2, 0x2, 0x2, 0x456, 0x459, 0x5, 0x52, 0x2a, 
       0x2, 0x457, 0x459, 0x5, 0x56, 0x2c, 0x2, 0x458, 0x456, 0x3, 0x2, 
       0x2, 0x2, 0x458, 0x457, 0x3, 0x2, 0x2, 0x2, 0x459, 0x55, 0x3, 0x2, 
       0x2, 0x2, 0x45a, 0x460, 0x7, 0x2bc, 0x2, 0x2, 0x45b, 0x45c, 0x7, 
       0x191, 0x2, 0x2, 0x45c, 0x45d, 0x7, 0x358, 0x2, 0x2, 0x45d, 0x45e, 
       0x5, 0x58, 0x2d, 0x2, 0x45e, 0x45f, 0x7, 0x359, 0x2, 0x2, 0x45f, 
       0x461, 0x3, 0x2, 0x2, 0x2, 0x460, 0x45b, 0x3, 0x2, 0x2, 0x2, 0x460, 
       0x461, 0x3, 0x2, 0x2, 0x2, 0x461, 0x470, 0x3, 0x2, 0x2, 0x2, 0x462, 
       0x467, 0x7, 0x2c5, 0x2, 0x2, 0x463, 0x464, 0x7, 0x191, 0x2, 0x2, 
       0x464, 0x465, 0x7, 0x251, 0x2, 0x2, 0x465, 0x466, 0x7, 0x346, 0x2, 
       0x2, 0x466, 0x468, 0x9, 0xf, 0x2, 0x2, 0x467, 0x463, 0x3, 0x2, 0x2, 
       0x2, 0x467, 0x468, 0x3, 0x2, 0x2, 0x2, 0x468, 0x470, 0x3, 0x2, 0x2, 
       0x2, 0x469, 0x46a, 0x7, 0x276, 0x2, 0x2, 0x46a, 0x46d, 0x7, 0x170, 
       0x2, 0x2, 0x46b, 0x46e, 0x5, 0x1f4, 0xfb, 0x2, 0x46c, 0x46e, 0x7, 
       0x5e, 0x2, 0x2, 0x46d, 0x46b, 0x3, 0x2, 0x2, 0x2, 0x46d, 0x46c, 0x3, 
       0x2, 0x2, 0x2, 0x46e, 0x470, 0x3, 0x2, 0x2, 0x2, 0x46f, 0x45a, 0x3, 
       0x2, 0x2, 0x2, 0x46f, 0x462, 0x3, 0x2, 0x2, 0x2, 0x46f, 0x469, 0x3, 
       0x2, 0x2, 0x2, 0x470, 0x57, 0x3, 0x2, 0x2, 0x2, 0x471, 0x472, 0x7, 
       0x265, 0x2, 0x2, 0x472, 0x473, 0x7, 0x346, 0x2, 0x2, 0x473, 0x474, 
       0x7, 0x33e, 0x2, 0x2, 0x474, 0x59, 0x3, 0x2, 0x2, 0x2, 0x475, 0x47c, 
       0x5, 0x1da, 0xee, 0x2, 0x476, 0x47c, 0x5, 0x1dc, 0xef, 0x2, 0x477, 
       0x47c, 0x5, 0x1e2, 0xf2, 0x2, 0x478, 0x47c, 0x5, 0x1e6, 0xf4, 0x2, 
       0x479, 0x47c, 0x5, 0x1ea, 0xf6, 0x2, 0x47a, 0x47c, 0x5, 0x1e4, 0xf3, 
       0x2, 0x47b, 0x475, 0x3, 0x2, 0x2, 0x2, 0x47b, 0x476, 0x3, 0x2, 0x2, 
       0x2, 0x47b, 0x477, 0x3, 0x2, 0x2, 0x2, 0x47b, 0x478, 0x3, 0x2, 0x2, 
       0x2, 0x47b, 0x479, 0x3, 0x2, 0x2, 0x2, 0x47b, 0x47a, 0x3, 0x2, 0x2, 
       0x2, 0x47c, 0x5b, 0x3, 0x2, 0x2, 0x2, 0x47d, 0x47e, 0x7, 0x4e, 0x2, 
       0x2, 0x47e, 0x47f, 0x7, 0x26b, 0x2, 0x2, 0x47f, 0x480, 0x7, 0x31d, 
       0x2, 0x2, 0x480, 0x483, 0x5, 0x1f4, 0xfb, 0x2, 0x481, 0x482, 0x7, 
       0x16, 0x2, 0x2, 0x482, 0x484, 0x5, 0x1f4, 0xfb, 0x2, 0x483, 0x481, 
       0x3, 0x2, 0x2, 0x2, 0x483, 0x484, 0x3, 0x2, 0x2, 0x2, 0x484, 0x485, 
       0x3, 0x2, 0x2, 0x2, 0x485, 0x486, 0x7, 0x326, 0x2, 0x2, 0x486, 0x48f, 
       0x7, 0x346, 0x2, 0x2, 0x487, 0x490, 0x7, 0xe2, 0x2, 0x2, 0x488, 0x490, 
       0x7, 0x203, 0x2, 0x2, 0x489, 0x490, 0x7, 0x32d, 0x2, 0x2, 0x48a, 
       0x48b, 0x7, 0x325, 0x2, 0x2, 0x48b, 0x48c, 0x7, 0x191, 0x2, 0x2, 
       0x48c, 0x48d, 0x7, 0x140, 0x2, 0x2, 0x48d, 0x48e, 0x7, 0x1ce, 0x2, 
       0x2, 0x48e, 0x490, 0x5, 0x1f4, 0xfb, 0x2, 0x48f, 0x487, 0x3, 0x2, 
       0x2, 0x2, 0x48f, 0x488, 0x3, 0x2, 0x2, 0x2, 0x48f, 0x489, 0x3, 0x2, 
       0x2, 0x2, 0x48f, 0x48a, 0x3, 0x2, 0x2, 0x2, 0x490, 0x5d, 0x3, 0x2, 
       0x2, 0x2, 0x491, 0x493, 0x5, 0x114, 0x8b, 0x2, 0x492, 0x491, 0x3, 
       0x2, 0x2, 0x2, 0x492, 0x493, 0x3, 0x2, 0x2, 0x2, 0x493, 0x494, 0x3, 
       0x2, 0x2, 0x2, 0x494, 0x49c, 0x7, 0xd4, 0x2, 0x2, 0x495, 0x496, 0x7, 
       0x171, 0x2, 0x2, 0x496, 0x497, 0x7, 0x358, 0x2, 0x2, 0x497, 0x498, 
       0x5, 0x106, 0x84, 0x2, 0x498, 0x49a, 0x7, 0x359, 0x2, 0x2, 0x499, 
       0x49b, 0x7, 0x103, 0x2, 0x2, 0x49a, 0x499, 0x3, 0x2, 0x2, 0x2, 0x49a, 
       0x49b, 0x3, 0x2, 0x2, 0x2, 0x49b, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x49c, 
       0x495, 0x3, 0x2, 0x2, 0x2, 0x49c, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x49d, 
       0x49f, 0x3, 0x2, 0x2, 0x2, 0x49e, 0x4a0, 0x7, 0xab, 0x2, 0x2, 0x49f, 
       0x49e, 0x3, 0x2, 0x2, 0x2, 0x49f, 0x4a0, 0x3, 0x2, 0x2, 0x2, 0x4a0, 
       0x4a1, 0x3, 0x2, 0x2, 0x2, 0x4a1, 0x4a3, 0x5, 0x1c6, 0xe4, 0x2, 0x4a2, 
       0x4a4, 0x5, 0x188, 0xc5, 0x2, 0x4a3, 0x4a2, 0x3, 0x2, 0x2, 0x2, 0x4a3, 
       0x4a4, 0x3, 0x2, 0x2, 0x2, 0x4a4, 0x4a6, 0x3, 0x2, 0x2, 0x2, 0x4a5, 
       0x4a7, 0x5, 0x182, 0xc2, 0x2, 0x4a6, 0x4a5, 0x3, 0x2, 0x2, 0x2, 0x4a6, 
       0x4a7, 0x3, 0x2, 0x2, 0x2, 0x4a7, 0x4a8, 0x3, 0x2, 0x2, 0x2, 0x4a8, 
       0x4a9, 0x7, 0x324, 0x2, 0x2, 0x4a9, 0x4aa, 0x5, 0x14e, 0xa8, 0x2, 
       0x4aa, 0x4ab, 0x7, 0xf2, 0x2, 0x2, 0x4ab, 0x4b6, 0x5, 0x11c, 0x8f, 
       0x2, 0x4ac, 0x4ad, 0x7, 0x18d, 0x2, 0x2, 0x4ad, 0x4b0, 0x7, 0xc7, 
       0x2, 0x2, 0x4ae, 0x4af, 0x7, 0xc, 0x2, 0x2, 0x4af, 0x4b1, 0x5, 0x11c, 
       0x8f, 0x2, 0x4b0, 0x4ae, 0x3, 0x2, 0x2, 0x2, 0x4b0, 0x4b1, 0x3, 0x2, 
       0x2, 0x2, 0x4b1, 0x4b2, 0x3, 0x2, 0x2, 0x2, 0x4b2, 0x4b3, 0x7, 0x16f, 
       0x2, 0x2, 0x4b3, 0x4b5, 0x5, 0x60, 0x31, 0x2, 0x4b4, 0x4ac, 0x3, 
       0x2, 0x2, 0x2, 0x4b5, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b4, 0x3, 
       0x2, 0x2, 0x2, 0x4b6, 0x4b7, 0x3, 0x2, 0x2, 0x2, 0x4b7, 0x4c6, 0x3, 
       0x2, 0x2, 0x2, 0x4b8, 0x4b6, 0x3, 0x2, 0x2, 0x2, 0x4b9, 0x4ba, 0x7, 
       0x18d, 0x2, 0x2, 0x4ba, 0x4bb, 0x7, 0xe9, 0x2, 0x2, 0x4bb, 0x4be, 
       0x7, 0xc7, 0x2, 0x2, 0x4bc, 0x4bd, 0x7, 0x28, 0x2, 0x2, 0x4bd, 0x4bf, 
       0x7, 0x16c, 0x2, 0x2, 0x4be, 0x4bc, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4bf, 
       0x3, 0x2, 0x2, 0x2, 0x4bf, 0x4c2, 0x3, 0x2, 0x2, 0x2, 0x4c0, 0x4c1, 
       0x7, 0xc, 0x2, 0x2, 0x4c1, 0x4c3, 0x5, 0x11c, 0x8f, 0x2, 0x4c2, 0x4c0, 
       0x3, 0x2, 0x2, 0x2, 0x4c2, 0x4c3, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4c4, 
       0x3, 0x2, 0x2, 0x2, 0x4c4, 0x4c5, 0x7, 0x16f, 0x2, 0x2, 0x4c5, 0x4c7, 
       0x5, 0x62, 0x32, 0x2, 0x4c6, 0x4b9, 0x3, 0x2, 0x2, 0x2, 0x4c6, 0x4c7, 
       0x3, 0x2, 0x2, 0x2, 0x4c7, 0x4d5, 0x3, 0x2, 0x2, 0x2, 0x4c8, 0x4c9, 
       0x7, 0x18d, 0x2, 0x2, 0x4c9, 0x4ca, 0x7, 0xe9, 0x2, 0x2, 0x4ca, 0x4cb, 
       0x7, 0xc7, 0x2, 0x2, 0x4cb, 0x4cc, 0x7, 0x28, 0x2, 0x2, 0x4cc, 0x4cf, 
       0x7, 0x156, 0x2, 0x2, 0x4cd, 0x4ce, 0x7, 0xc, 0x2, 0x2, 0x4ce, 0x4d0, 
       0x5, 0x11c, 0x8f, 0x2, 0x4cf, 0x4cd, 0x3, 0x2, 0x2, 0x2, 0x4cf, 0x4d0, 
       0x3, 0x2, 0x2, 0x2, 0x4d0, 0x4d1, 0x3, 0x2, 0x2, 0x2, 0x4d1, 0x4d2, 
       0x7, 0x16f, 0x2, 0x2, 0x4d2, 0x4d4, 0x5, 0x60, 0x31, 0x2, 0x4d3, 
       0x4c8, 0x3, 0x2, 0x2, 0x2, 0x4d4, 0x4d7, 0x3, 0x2, 0x2, 0x2, 0x4d5, 
       0x4d3, 0x3, 0x2, 0x2, 0x2, 0x4d5, 0x4d6, 0x3, 0x2, 0x2, 0x2, 0x4d6, 
       0x4d9, 0x3, 0x2, 0x2, 0x2, 0x4d7, 0x4d5, 0x3, 0x2, 0x2, 0x2, 0x4d8, 
       0x4da, 0x5, 0x74, 0x3b, 0x2, 0x4d9, 0x4d8, 0x3, 0x2, 0x2, 0x2, 0x4d9, 
       0x4da, 0x3, 0x2, 0x2, 0x2, 0x4da, 0x4dc, 0x3, 0x2, 0x2, 0x2, 0x4db, 
       0x4dd, 0x5, 0x13a, 0x9e, 0x2, 0x4dc, 0x4db, 0x3, 0x2, 0x2, 0x2, 0x4dc, 
       0x4dd, 0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4de, 0x3, 0x2, 0x2, 0x2, 0x4de, 
       0x4df, 0x7, 0x35b, 0x2, 0x2, 0x4df, 0x5f, 0x3, 0x2, 0x2, 0x2, 0x4e0, 
       0x4e1, 0x7, 0x17f, 0x2, 0x2, 0x4e1, 0x4e2, 0x7, 0x14e, 0x2, 0x2, 
       0x4e2, 0x4e7, 0x5, 0x118, 0x8d, 0x2, 0x4e3, 0x4e4, 0x7, 0x35a, 0x2, 
       0x2, 0x4e4, 0x4e6, 0x5, 0x118, 0x8d, 0x2, 0x4e5, 0x4e3, 0x3, 0x2, 
       0x2, 0x2, 0x4e6, 0x4e9, 0x3, 0x2, 0x2, 0x2, 0x4e7, 0x4e5, 0x3, 0x2, 
       0x2, 0x2, 0x4e7, 0x4e8, 0x3, 0x2, 0x2, 0x2, 0x4e8, 0x4ec, 0x3, 0x2, 
       0x2, 0x2, 0x4e9, 0x4e7, 0x3, 0x2, 0x2, 0x2, 0x4ea, 0x4ec, 0x7, 0x61, 
       0x2, 0x2, 0x4eb, 0x4e0, 0x3, 0x2, 0x2, 0x2, 0x4eb, 0x4ea, 0x3, 0x2, 
       0x2, 0x2, 0x4ec, 0x61, 0x3, 0x2, 0x2, 0x2, 0x4ed, 0x4f2, 0x7, 0xa8, 
       0x2, 0x2, 0x4ee, 0x4ef, 0x7, 0x358, 0x2, 0x2, 0x4ef, 0x4f0, 0x5, 
       0x1cc, 0xe7, 0x2, 0x4f0, 0x4f1, 0x7, 0x359, 0x2, 0x2, 0x4f1, 0x4f3, 
       0x3, 0x2, 0x2, 0x2, 0x4f2, 0x4ee, 0x3, 0x2, 0x2, 0x2, 0x4f2, 0x4f3, 
       0x3, 0x2, 0x2, 0x2, 0x4f3, 0x4f7, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f8, 
       0x5, 0x192, 0xca, 0x2, 0x4f5, 0x4f6, 0x7, 0x5e, 0x2, 0x2, 0x4f6, 
       0x4f8, 0x7, 0x187, 0x2, 0x2, 0x4f7, 0x4f4, 0x3, 0x2, 0x2, 0x2, 0x4f7, 
       0x4f5, 0x3, 0x2, 0x2, 0x2, 0x4f8, 0x63, 0x3, 0x2, 0x2, 0x2, 0x4f9, 
       0x4fb, 0x5, 0x114, 0x8b, 0x2, 0x4fa, 0x4f9, 0x3, 0x2, 0x2, 0x2, 0x4fa, 
       0x4fb, 0x3, 0x2, 0x2, 0x2, 0x4fb, 0x4fc, 0x3, 0x2, 0x2, 0x2, 0x4fc, 
       0x506, 0x7, 0x61, 0x2, 0x2, 0x4fd, 0x4fe, 0x7, 0x171, 0x2, 0x2, 0x4fe, 
       0x4ff, 0x7, 0x358, 0x2, 0x2, 0x4ff, 0x500, 0x5, 0x106, 0x84, 0x2, 
       0x500, 0x502, 0x7, 0x359, 0x2, 0x2, 0x501, 0x503, 0x7, 0x103, 0x2, 
       0x2, 0x502, 0x501, 0x3, 0x2, 0x2, 0x2, 0x502, 0x503, 0x3, 0x2, 0x2, 
       0x2, 0x503, 0x507, 0x3, 0x2, 0x2, 0x2, 0x504, 0x505, 0x7, 0x171, 
       0x2, 0x2, 0x505, 0x507, 0x7, 0x33e, 0x2, 0x2, 0x506, 0x4fd, 0x3, 
       0x2, 0x2, 0x2, 0x506, 0x504, 0x3, 0x2, 0x2, 0x2, 0x506, 0x507, 0x3, 
       0x2, 0x2, 0x2, 0x507, 0x509, 0x3, 0x2, 0x2, 0x2, 0x508, 0x50a, 0x7, 
       0x91, 0x2, 0x2, 0x509, 0x508, 0x3, 0x2, 0x2, 0x2, 0x509, 0x50a, 0x3, 
       0x2, 0x2, 0x2, 0x50a, 0x50b, 0x3, 0x2, 0x2, 0x2, 0x50b, 0x50d, 0x5, 
       0x66, 0x34, 0x2, 0x50c, 0x50e, 0x5, 0x188, 0xc5, 0x2, 0x50d, 0x50c, 
       0x3, 0x2, 0x2, 0x2, 0x50d, 0x50e, 0x3, 0x2, 0x2, 0x2, 0x50e, 0x510, 
       0x3, 0x2, 0x2, 0x2, 0x50f, 0x511, 0x5, 0x74, 0x3b, 0x2, 0x510, 0x50f, 
       0x3, 0x2, 0x2, 0x2, 0x510, 0x511, 0x3, 0x2, 0x2, 0x2, 0x511, 0x514, 
       0x3, 0x2, 0x2, 0x2, 0x512, 0x513, 0x7, 0x91, 0x2, 0x2, 0x513, 0x515, 
       0x5, 0x14e, 0xa8, 0x2, 0x514, 0x512, 0x3, 0x2, 0x2, 0x2, 0x514, 0x515, 
       0x3, 0x2, 0x2, 0x2, 0x515, 0x523, 0x3, 0x2, 0x2, 0x2, 0x516, 0x521, 
       0x7, 0x18e, 0x2, 0x2, 0x517, 0x522, 0x5, 0x11c, 0x8f, 0x2, 0x518, 
       0x519, 0x7, 0x50, 0x2, 0x2, 0x519, 0x51f, 0x7, 0xee, 0x2, 0x2, 0x51a, 
       0x51c, 0x7, 0x228, 0x2, 0x2, 0x51b, 0x51a, 0x3, 0x2, 0x2, 0x2, 0x51b, 
       0x51c, 0x3, 0x2, 0x2, 0x2, 0x51c, 0x51d, 0x3, 0x2, 0x2, 0x2, 0x51d, 
       0x520, 0x5, 0x1ce, 0xe8, 0x2, 0x51e, 0x520, 0x7, 0x33d, 0x2, 0x2, 
       0x51f, 0x51b, 0x3, 0x2, 0x2, 0x2, 0x51f, 0x51e, 0x3, 0x2, 0x2, 0x2, 
       0x520, 0x522, 0x3, 0x2, 0x2, 0x2, 0x521, 0x517, 0x3, 0x2, 0x2, 0x2, 
       0x521, 0x518, 0x3, 0x2, 0x2, 0x2, 0x522, 0x524, 0x3, 0x2, 0x2, 0x2, 
       0x523, 0x516, 0x3, 0x2, 0x2, 0x2, 0x523, 0x524, 0x3, 0x2, 0x2, 0x2, 
       0x524, 0x526, 0x3, 0x2, 0x2, 0x2, 0x525, 0x527, 0x5, 0x132, 0x9a, 
       0x2, 0x526, 0x525, 0x3, 0x2, 0x2, 0x2, 0x526, 0x527, 0x3, 0x2, 0x2, 
       0x2, 0x527, 0x529, 0x3, 0x2, 0x2, 0x2, 0x528, 0x52a, 0x5, 0x13a, 
       0x9e, 0x2, 0x529, 0x528, 0x3, 0x2, 0x2, 0x2, 0x529, 0x52a, 0x3, 0x2, 
       0x2, 0x2, 0x52a, 0x52c, 0x3, 0x2, 0x2, 0x2, 0x52b, 0x52d, 0x7, 0x35b, 
       0x2, 0x2, 0x52c, 0x52b, 0x3, 0x2, 0x2, 0x2, 0x52c, 0x52d, 0x3, 0x2, 
       0x2, 0x2, 0x52d, 0x65, 0x3, 0x2, 0x2, 0x2, 0x52e, 0x533, 0x5, 0x1c6, 
       0xe4, 0x2, 0x52f, 0x533, 0x5, 0x184, 0xc3, 0x2, 0x530, 0x533, 0x5, 
       0xb0, 0x59, 0x2, 0x531, 0x533, 0x7, 0x33d, 0x2, 0x2, 0x532, 0x52e, 
       0x3, 0x2, 0x2, 0x2, 0x532, 0x52f, 0x3, 0x2, 0x2, 0x2, 0x532, 0x530, 
       0x3, 0x2, 0x2, 0x2, 0x532, 0x531, 0x3, 0x2, 0x2, 0x2, 0x533, 0x67, 
       0x3, 0x2, 0x2, 0x2, 0x534, 0x536, 0x5, 0x114, 0x8b, 0x2, 0x535, 0x534, 
       0x3, 0x2, 0x2, 0x2, 0x535, 0x536, 0x3, 0x2, 0x2, 0x2, 0x536, 0x537, 
       0x3, 0x2, 0x2, 0x2, 0x537, 0x53f, 0x7, 0xa8, 0x2, 0x2, 0x538, 0x539, 
       0x7, 0x171, 0x2, 0x2, 0x539, 0x53a, 0x7, 0x358, 0x2, 0x2, 0x53a, 
       0x53b, 0x5, 0x106, 0x84, 0x2, 0x53b, 0x53d, 0x7, 0x359, 0x2, 0x2, 
       0x53c, 0x53e, 0x7, 0x103, 0x2, 0x2, 0x53d, 0x53c, 0x3, 0x2, 0x2, 
       0x2, 0x53d, 0x53e, 0x3, 0x2, 0x2, 0x2, 0x53e, 0x540, 0x3, 0x2, 0x2, 
       0x2, 0x53f, 0x538, 0x3, 0x2, 0x2, 0x2, 0x53f, 0x540, 0x3, 0x2, 0x2, 
       0x2, 0x540, 0x542, 0x3, 0x2, 0x2, 0x2, 0x541, 0x543, 0x7, 0xab, 0x2, 
       0x2, 0x542, 0x541, 0x3, 0x2, 0x2, 0x2, 0x542, 0x543, 0x3, 0x2, 0x2, 
       0x2, 0x543, 0x546, 0x3, 0x2, 0x2, 0x2, 0x544, 0x547, 0x5, 0x1c6, 
       0xe4, 0x2, 0x545, 0x547, 0x5, 0xb0, 0x59, 0x2, 0x546, 0x544, 0x3, 
       0x2, 0x2, 0x2, 0x546, 0x545, 0x3, 0x2, 0x2, 0x2, 0x547, 0x549, 0x3, 
       0x2, 0x2, 0x2, 0x548, 0x54a, 0x5, 0x188, 0xc5, 0x2, 0x549, 0x548, 
       0x3, 0x2, 0x2, 0x2, 0x549, 0x54a, 0x3, 0x2, 0x2, 0x2, 0x54a, 0x54f, 
       0x3, 0x2, 0x2, 0x2, 0x54b, 0x54c, 0x7, 0x358, 0x2, 0x2, 0x54c, 0x54d, 
       0x5, 0x1cc, 0xe7, 0x2, 0x54d, 0x54e, 0x7, 0x359, 0x2, 0x2, 0x54e, 
       0x550, 0x3, 0x2, 0x2, 0x2, 0x54f, 0x54b, 0x3, 0x2, 0x2, 0x2, 0x54f, 
       0x550, 0x3, 0x2, 0x2, 0x2, 0x550, 0x552, 0x3, 0x2, 0x2, 0x2, 0x551, 
       0x553, 0x5, 0x74, 0x3b, 0x2, 0x552, 0x551, 0x3, 0x2, 0x2, 0x2, 0x552, 
       0x553, 0x3, 0x2, 0x2, 0x2, 0x553, 0x554, 0x3, 0x2, 0x2, 0x2, 0x554, 
       0x556, 0x5, 0x6a, 0x36, 0x2, 0x555, 0x557, 0x5, 0x132, 0x9a, 0x2, 
       0x556, 0x555, 0x3, 0x2, 0x2, 0x2, 0x556, 0x557, 0x3, 0x2, 0x2, 0x2, 
       0x557, 0x559, 0x3, 0x2, 0x2, 0x2, 0x558, 0x55a, 0x5, 0x13a, 0x9e, 
       0x2, 0x559, 0x558, 0x3, 0x2, 0x2, 0x2, 0x559, 0x55a, 0x3, 0x2, 0x2, 
       0x2, 0x55a, 0x55c, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x55d, 0x7, 0x35b, 
       0x2, 0x2, 0x55c, 0x55b, 0x3, 0x2, 0x2, 0x2, 0x55c, 0x55d, 0x3, 0x2, 
       0x2, 0x2, 0x55d, 0x69, 0x3, 0x2, 0x2, 0x2, 0x55e, 0x564, 0x5, 0x192, 
       0xca, 0x2, 0x55f, 0x564, 0x5, 0x16c, 0xb7, 0x2, 0x560, 0x564, 0x5, 
       0xc2, 0x62, 0x2, 0x561, 0x562, 0x7, 0x5e, 0x2, 0x2, 0x562, 0x564, 
       0x7, 0x187, 0x2, 0x2, 0x563, 0x55e, 0x3, 0x2, 0x2, 0x2, 0x563, 0x55f, 
       0x3, 0x2, 0x2, 0x2, 0x563, 0x560, 0x3, 0x2, 0x2, 0x2, 0x563, 0x561, 
       0x3, 0x2, 0x2, 0x2, 0x564, 0x6b, 0x3, 0x2, 0x2, 0x2, 0x565, 0x567, 
       0x7, 0x358, 0x2, 0x2, 0x566, 0x565, 0x3, 0x2, 0x2, 0x2, 0x566, 0x567, 
       0x3, 0x2, 0x2, 0x2, 0x567, 0x568, 0x3, 0x2, 0x2, 0x2, 0x568, 0x56d, 
       0x7, 0x2bd, 0x2, 0x2, 0x569, 0x56e, 0x7, 0x7, 0x2, 0x2, 0x56a, 0x56e, 
       0x7, 0x67, 0x2, 0x2, 0x56b, 0x56e, 0x5, 0x12a, 0x96, 0x2, 0x56c, 
       0x56e, 0x7, 0x35d, 0x2, 0x2, 0x56d, 0x569, 0x3, 0x2, 0x2, 0x2, 0x56d, 
       0x56a, 0x3, 0x2, 0x2, 0x2, 0x56d, 0x56b, 0x3, 0x2, 0x2, 0x2, 0x56d, 
       0x56c, 0x3, 0x2, 0x2, 0x2, 0x56e, 0x577, 0x3, 0x2, 0x2, 0x2, 0x56f, 
       0x570, 0x7, 0x33d, 0x2, 0x2, 0x570, 0x571, 0x7, 0x346, 0x2, 0x2, 
       0x571, 0x573, 0x5, 0x106, 0x84, 0x2, 0x572, 0x574, 0x7, 0x35a, 0x2, 
       0x2, 0x573, 0x572, 0x3, 0x2, 0x2, 0x2, 0x573, 0x574, 0x3, 0x2, 0x2, 
       0x2, 0x574, 0x576, 0x3, 0x2, 0x2, 0x2, 0x575, 0x56f, 0x3, 0x2, 0x2, 
       0x2, 0x576, 0x579, 0x3, 0x2, 0x2, 0x2, 0x577, 0x575, 0x3, 0x2, 0x2, 
       0x2, 0x577, 0x578, 0x3, 0x2, 0x2, 0x2, 0x578, 0x57a, 0x3, 0x2, 0x2, 
       0x2, 0x579, 0x577, 0x3, 0x2, 0x2, 0x2, 0x57a, 0x57b, 0x7, 0x91, 0x2, 
       0x2, 0x57b, 0x581, 0x5, 0x1ba, 0xde, 0x2, 0x57c, 0x57d, 0x7, 0xab, 
       0x2, 0x2, 0x57d, 0x57e, 0x5, 0x1f4, 0xfb, 0x2, 0x57e, 0x57f, 0x7, 
       0x18e, 0x2, 0x2, 0x57f, 0x580, 0x5, 0x11c, 0x8f, 0x2, 0x580, 0x582, 
       0x3, 0x2, 0x2, 0x2, 0x581, 0x57c, 0x3, 0x2, 0x2, 0x2, 0x581, 0x582, 
       0x3, 0x2, 0x2, 0x2, 0x582, 0x584, 0x3, 0x2, 0x2, 0x2, 0x583, 0x585, 
       0x7, 0x359, 0x2, 0x2, 0x584, 0x583, 0x3, 0x2, 0x2, 0x2, 0x584, 0x585, 
       0x3, 0x2, 0x2, 0x2, 0x585, 0x6d, 0x3, 0x2, 0x2, 0x2, 0x586, 0x588, 
       0x5, 0x114, 0x8b, 0x2, 0x587, 0x586, 0x3, 0x2, 0x2, 0x2, 0x587, 0x588, 
       0x3, 0x2, 0x2, 0x2, 0x588, 0x589, 0x3, 0x2, 0x2, 0x2, 0x589, 0x58b, 
       0x5, 0x124, 0x93, 0x2, 0x58a, 0x58c, 0x5, 0x130, 0x99, 0x2, 0x58b, 
       0x58a, 0x3, 0x2, 0x2, 0x2, 0x58b, 0x58c, 0x3, 0x2, 0x2, 0x2, 0x58c, 
       0x58e, 0x3, 0x2, 0x2, 0x2, 0x58d, 0x58f, 0x5, 0x132, 0x9a, 0x2, 0x58e, 
       0x58d, 0x3, 0x2, 0x2, 0x2, 0x58e, 0x58f, 0x3, 0x2, 0x2, 0x2, 0x58f, 
       0x591, 0x3, 0x2, 0x2, 0x2, 0x590, 0x592, 0x5, 0x13a, 0x9e, 0x2, 0x591, 
       0x590, 0x3, 0x2, 0x2, 0x2, 0x591, 0x592, 0x3, 0x2, 0x2, 0x2, 0x592, 
       0x594, 0x3, 0x2, 0x2, 0x2, 0x593, 0x595, 0x7, 0x35b, 0x2, 0x2, 0x594, 
       0x593, 0x3, 0x2, 0x2, 0x2, 0x594, 0x595, 0x3, 0x2, 0x2, 0x2, 0x595, 
       0x6f, 0x3, 0x2, 0x2, 0x2, 0x596, 0x599, 0x7, 0x33d, 0x2, 0x2, 0x597, 
       0x599, 0x5, 0x1f0, 0xf9, 0x2, 0x598, 0x596, 0x3, 0x2, 0x2, 0x2, 0x598, 
       0x597, 0x3, 0x2, 0x2, 0x2, 0x599, 0x71, 0x3, 0x2, 0x2, 0x2, 0x59a, 
       0x59c, 0x5, 0x114, 0x8b, 0x2, 0x59b, 0x59a, 0x3, 0x2, 0x2, 0x2, 0x59b, 
       0x59c, 0x3, 0x2, 0x2, 0x2, 0x59c, 0x59d, 0x3, 0x2, 0x2, 0x2, 0x59d, 
       0x5a5, 0x7, 0x17f, 0x2, 0x2, 0x59e, 0x59f, 0x7, 0x171, 0x2, 0x2, 
       0x59f, 0x5a0, 0x7, 0x358, 0x2, 0x2, 0x5a0, 0x5a1, 0x5, 0x106, 0x84, 
       0x2, 0x5a1, 0x5a3, 0x7, 0x359, 0x2, 0x2, 0x5a2, 0x5a4, 0x7, 0x103, 
       0x2, 0x2, 0x5a3, 0x5a2, 0x3, 0x2, 0x2, 0x2, 0x5a3, 0x5a4, 0x3, 0x2, 
       0x2, 0x2, 0x5a4, 0x5a6, 0x3, 0x2, 0x2, 0x2, 0x5a5, 0x59e, 0x3, 0x2, 
       0x2, 0x2, 0x5a5, 0x5a6, 0x3, 0x2, 0x2, 0x2, 0x5a6, 0x5a9, 0x3, 0x2, 
       0x2, 0x2, 0x5a7, 0x5aa, 0x5, 0x1c6, 0xe4, 0x2, 0x5a8, 0x5aa, 0x5, 
       0xb0, 0x59, 0x2, 0x5a9, 0x5a7, 0x3, 0x2, 0x2, 0x2, 0x5a9, 0x5a8, 
       0x3, 0x2, 0x2, 0x2, 0x5aa, 0x5ac, 0x3, 0x2, 0x2, 0x2, 0x5ab, 0x5ad, 
       0x5, 0x186, 0xc4, 0x2, 0x5ac, 0x5ab, 0x3, 0x2, 0x2, 0x2, 0x5ac, 0x5ad, 
       0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5ae, 0x3, 0x2, 0x2, 0x2, 0x5ae, 0x5af, 
       0x7, 0x14e, 0x2, 0x2, 0x5af, 0x5b4, 0x5, 0x118, 0x8d, 0x2, 0x5b0, 
       0x5b1, 0x7, 0x35a, 0x2, 0x2, 0x5b1, 0x5b3, 0x5, 0x118, 0x8d, 0x2, 
       0x5b2, 0x5b0, 0x3, 0x2, 0x2, 0x2, 0x5b3, 0x5b6, 0x3, 0x2, 0x2, 0x2, 
       0x5b4, 0x5b2, 0x3, 0x2, 0x2, 0x2, 0x5b4, 0x5b5, 0x3, 0x2, 0x2, 0x2, 
       0x5b5, 0x5b8, 0x3, 0x2, 0x2, 0x2, 0x5b6, 0x5b4, 0x3, 0x2, 0x2, 0x2, 
       0x5b7, 0x5b9, 0x5, 0x74, 0x3b, 0x2, 0x5b8, 0x5b7, 0x3, 0x2, 0x2, 
       0x2, 0x5b8, 0x5b9, 0x3, 0x2, 0x2, 0x2, 0x5b9, 0x5bc, 0x3, 0x2, 0x2, 
       0x2, 0x5ba, 0x5bb, 0x7, 0x91, 0x2, 0x2, 0x5bb, 0x5bd, 0x5, 0x14e, 
       0xa8, 0x2, 0x5bc, 0x5ba, 0x3, 0x2, 0x2, 0x2, 0x5bc, 0x5bd, 0x3, 0x2, 
       0x2, 0x2, 0x5bd, 0x5cb, 0x3, 0x2, 0x2, 0x2, 0x5be, 0x5c9, 0x7, 0x18e, 
       0x2, 0x2, 0x5bf, 0x5ca, 0x5, 0x11a, 0x8e, 0x2, 0x5c0, 0x5c1, 0x7, 
       0x50, 0x2, 0x2, 0x5c1, 0x5c7, 0x7, 0xee, 0x2, 0x2, 0x5c2, 0x5c4, 
       0x7, 0x228, 0x2, 0x2, 0x5c3, 0x5c2, 0x3, 0x2, 0x2, 0x2, 0x5c3, 0x5c4, 
       0x3, 0x2, 0x2, 0x2, 0x5c4, 0x5c5, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5c8, 
       0x5, 0x1ce, 0xe8, 0x2, 0x5c6, 0x5c8, 0x7, 0x33d, 0x2, 0x2, 0x5c7, 
       0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5c7, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x5c8, 
       0x5ca, 0x3, 0x2, 0x2, 0x2, 0x5c9, 0x5bf, 0x3, 0x2, 0x2, 0x2, 0x5c9, 
       0x5c0, 0x3, 0x2, 0x2, 0x2, 0x5ca, 0x5cc, 0x3, 0x2, 0x2, 0x2, 0x5cb, 
       0x5be, 0x3, 0x2, 0x2, 0x2, 0x5cb, 0x5cc, 0x3, 0x2, 0x2, 0x2, 0x5cc, 
       0x5ce, 0x3, 0x2, 0x2, 0x2, 0x5cd, 0x5cf, 0x5, 0x132, 0x9a, 0x2, 0x5ce, 
       0x5cd, 0x3, 0x2, 0x2, 0x2, 0x5ce, 0x5cf, 0x3, 0x2, 0x2, 0x2, 0x5cf, 
       0x5d1, 0x3, 0x2, 0x2, 0x2, 0x5d0, 0x5d2, 0x5, 0x13a, 0x9e, 0x2, 0x5d1, 
       0x5d0, 0x3, 0x2, 0x2, 0x2, 0x5d1, 0x5d2, 0x3, 0x2, 0x2, 0x2, 0x5d2, 
       0x5d4, 0x3, 0x2, 0x2, 0x2, 0x5d3, 0x5d5, 0x7, 0x35b, 0x2, 0x2, 0x5d4, 
       0x5d3, 0x3, 0x2, 0x2, 0x2, 0x5d4, 0x5d5, 0x3, 0x2, 0x2, 0x2, 0x5d5, 
       0x73, 0x3, 0x2, 0x2, 0x2, 0x5d6, 0x5d7, 0x7, 0x296, 0x2, 0x2, 0x5d7, 
       0x5dc, 0x5, 0x76, 0x3c, 0x2, 0x5d8, 0x5d9, 0x7, 0x35a, 0x2, 0x2, 
       0x5d9, 0x5db, 0x5, 0x76, 0x3c, 0x2, 0x5da, 0x5d8, 0x3, 0x2, 0x2, 
       0x2, 0x5db, 0x5de, 0x3, 0x2, 0x2, 0x2, 0x5dc, 0x5da, 0x3, 0x2, 0x2, 
       0x2, 0x5dc, 0x5dd, 0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5ea, 0x3, 0x2, 0x2, 
       0x2, 0x5de, 0x5dc, 0x3, 0x2, 0x2, 0x2, 0x5df, 0x5e2, 0x7, 0xab, 0x2, 
       0x2, 0x5e0, 0x5e3, 0x7, 0x33d, 0x2, 0x2, 0x5e1, 0x5e3, 0x5, 0x1bc, 
       0xdf, 0x2, 0x5e2, 0x5e0, 0x3, 0x2, 0x2, 0x2, 0x5e2, 0x5e1, 0x3, 0x2, 
       0x2, 0x2, 0x5e3, 0x5e8, 0x3, 0x2, 0x2, 0x2, 0x5e4, 0x5e5, 0x7, 0x358, 
       0x2, 0x2, 0x5e5, 0x5e6, 0x5, 0x1cc, 0xe7, 0x2, 0x5e6, 0x5e7, 0x7, 
       0x359, 0x2, 0x2, 0x5e7, 0x5e9, 0x3, 0x2, 0x2, 0x2, 0x5e8, 0x5e4, 
       0x3, 0x2, 0x2, 0x2, 0x5e8, 0x5e9, 0x3, 0x2, 0x2, 0x2, 0x5e9, 0x5eb, 
       0x3, 0x2, 0x2, 0x2, 0x5ea, 0x5df, 0x3, 0x2, 0x2, 0x2, 0x5ea, 0x5eb, 
       0x3, 0x2, 0x2, 0x2, 0x5eb, 0x75, 0x3, 0x2, 0x2, 0x2, 0x5ec, 0x5ef, 
       0x5, 0x78, 0x3d, 0x2, 0x5ed, 0x5ef, 0x5, 0x106, 0x84, 0x2, 0x5ee, 
       0x5ec, 0x3, 0x2, 0x2, 0x2, 0x5ee, 0x5ed, 0x3, 0x2, 0x2, 0x2, 0x5ef, 
       0x5f1, 0x3, 0x2, 0x2, 0x2, 0x5f0, 0x5f2, 0x5, 0x180, 0xc1, 0x2, 0x5f1, 
       0x5f0, 0x3, 0x2, 0x2, 0x2, 0x5f1, 0x5f2, 0x3, 0x2, 0x2, 0x2, 0x5f2, 
       0x77, 0x3, 0x2, 0x2, 0x2, 0x5f3, 0x5f7, 0x7, 0x1f2, 0x2, 0x2, 0x5f4, 
       0x5f7, 0x7, 0x23d, 0x2, 0x2, 0x5f5, 0x5f7, 0x5, 0x1bc, 0xdf, 0x2, 
       0x5f6, 0x5f3, 0x3, 0x2, 0x2, 0x2, 0x5f6, 0x5f4, 0x3, 0x2, 0x2, 0x2, 
       0x5f6, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0x5f7, 0x5f8, 0x3, 0x2, 0x2, 0x2, 
       0x5f8, 0x5fb, 0x7, 0x353, 0x2, 0x2, 0x5f9, 0x5fc, 0x7, 0x35d, 0x2, 
       0x2, 0x5fa, 0x5fc, 0x5, 0x1f4, 0xfb, 0x2, 0x5fb, 0x5f9, 0x3, 0x2, 
       0x2, 0x2, 0x5fb, 0x5fa, 0x3, 0x2, 0x2, 0x2, 0x5fc, 0x5ff, 0x3, 0x2, 
       0x2, 0x2, 0x5fd, 0x5ff, 0x7, 0x336, 0x2, 0x2, 0x5fe, 0x5f6, 0x3, 
       0x2, 0x2, 0x2, 0x5fe, 0x5fd, 0x3, 0x2, 0x2, 0x2, 0x5ff, 0x79, 0x3, 
       0x2, 0x2, 0x2, 0x600, 0x601, 0x7, 0x4e, 0x2, 0x2, 0x601, 0x602, 0x7, 
       0x59, 0x2, 0x2, 0x602, 0x606, 0x5, 0x1f4, 0xfb, 0x2, 0x603, 0x604, 
       0x7, 0x43, 0x2, 0x2, 0x604, 0x605, 0x7, 0x346, 0x2, 0x2, 0x605, 0x607, 
       0x9, 0x10, 0x2, 0x2, 0x606, 0x603, 0x3, 0x2, 0x2, 0x2, 0x606, 0x607, 
       0x3, 0x2, 0x2, 0x2, 0x607, 0x614, 0x3, 0x2, 0x2, 0x2, 0x608, 0x60a, 
       0x7, 0xf2, 0x2, 0x2, 0x609, 0x60b, 0x7, 0x10e, 0x2, 0x2, 0x60a, 0x609, 
       0x3, 0x2, 0x2, 0x2, 0x60a, 0x60b, 0x3, 0x2, 0x2, 0x2, 0x60b, 0x60c, 
       0x3, 0x2, 0x2, 0x2, 0x60c, 0x611, 0x5, 0x1ae, 0xd8, 0x2, 0x60d, 0x60e, 
       0x7, 0x35a, 0x2, 0x2, 0x60e, 0x610, 0x5, 0x1ae, 0xd8, 0x2, 0x60f, 
       0x60d, 0x3, 0x2, 0x2, 0x2, 0x610, 0x613, 0x3, 0x2, 0x2, 0x2, 0x611, 
       0x60f, 0x3, 0x2, 0x2, 0x2, 0x611, 0x612, 0x3, 0x2, 0x2, 0x2, 0x612, 
       0x615, 0x3, 0x2, 0x2, 0x2, 0x613, 0x611, 0x3, 0x2, 0x2, 0x2, 0x614, 
       0x608, 0x3, 0x2, 0x2, 0x2, 0x614, 0x615, 0x3, 0x2, 0x2, 0x2, 0x615, 
       0x620, 0x3, 0x2, 0x2, 0x2, 0x616, 0x617, 0x7, 0xc4, 0x2, 0x2, 0x617, 
       0x618, 0x7, 0xf2, 0x2, 0x2, 0x618, 0x61d, 0x5, 0x1ae, 0xd8, 0x2, 
       0x619, 0x61a, 0x7, 0x35a, 0x2, 0x2, 0x61a, 0x61c, 0x5, 0x1ae, 0xd8, 
       0x2, 0x61b, 0x619, 0x3, 0x2, 0x2, 0x2, 0x61c, 0x61f, 0x3, 0x2, 0x2, 
       0x2, 0x61d, 0x61b, 0x3, 0x2, 0x2, 0x2, 0x61d, 0x61e, 0x3, 0x2, 0x2, 
       0x2, 0x61e, 0x621, 0x3, 0x2, 0x2, 0x2, 0x61f, 0x61d, 0x3, 0x2, 0x2, 
       0x2, 0x620, 0x616, 0x3, 0x2, 0x2, 0x2, 0x620, 0x621, 0x3, 0x2, 0x2, 
       0x2, 0x621, 0x624, 0x3, 0x2, 0x2, 0x2, 0x622, 0x623, 0x7, 0x3c, 0x2, 
       0x2, 0x623, 0x625, 0x5, 0x1f4, 0xfb, 0x2, 0x624, 0x622, 0x3, 0x2, 
       0x2, 0x2, 0x624, 0x625, 0x3, 0x2, 0x2, 0x2, 0x625, 0x62f, 0x3, 0x2, 
       0x2, 0x2, 0x626, 0x627, 0x7, 0x191, 0x2, 0x2, 0x627, 0x62c, 0x5, 
       0x1aa, 0xd6, 0x2, 0x628, 0x629, 0x7, 0x35a, 0x2, 0x2, 0x629, 0x62b, 
       0x5, 0x1aa, 0xd6, 0x2, 0x62a, 0x628, 0x3, 0x2, 0x2, 0x2, 0x62b, 0x62e, 
       0x3, 0x2, 0x2, 0x2, 0x62c, 0x62a, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x62d, 
       0x3, 0x2, 0x2, 0x2, 0x62d, 0x630, 0x3, 0x2, 0x2, 0x2, 0x62e, 0x62c, 
       0x3, 0x2, 0x2, 0x2, 0x62f, 0x626, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x630, 
       0x3, 0x2, 0x2, 0x2, 0x630, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x631, 0x633, 
       0x7, 0x4e, 0x2, 0x2, 0x632, 0x634, 0x7, 0x17b, 0x2, 0x2, 0x633, 0x632, 
       0x3, 0x2, 0x2, 0x2, 0x633, 0x634, 0x3, 0x2, 0x2, 0x2, 0x634, 0x636, 
       0x3, 0x2, 0x2, 0x2, 0x635, 0x637, 0x5, 0x1d2, 0xea, 0x2, 0x636, 0x635, 
       0x3, 0x2, 0x2, 0x2, 0x636, 0x637, 0x3, 0x2, 0x2, 0x2, 0x637, 0x638, 
       0x3, 0x2, 0x2, 0x2, 0x638, 0x639, 0x7, 0xa4, 0x2, 0x2, 0x639, 0x63a, 
       0x5, 0x1f4, 0xfb, 0x2, 0x63a, 0x63b, 0x7, 0xf2, 0x2, 0x2, 0x63b, 
       0x63c, 0x5, 0x166, 0xb4, 0x2, 0x63c, 0x63d, 0x7, 0x358, 0x2, 0x2, 
       0x63d, 0x63e, 0x5, 0x1ca, 0xe6, 0x2, 0x63e, 0x644, 0x7, 0x359, 0x2, 
       0x2, 0x63f, 0x640, 0x7, 0xa2, 0x2, 0x2, 0x640, 0x641, 0x7, 0x358, 
       0x2, 0x2, 0x641, 0x642, 0x5, 0x1cc, 0xe7, 0x2, 0x642, 0x643, 0x7, 
       0x359, 0x2, 0x2, 0x643, 0x645, 0x3, 0x2, 0x2, 0x2, 0x644, 0x63f, 
       0x3, 0x2, 0x2, 0x2, 0x644, 0x645, 0x3, 0x2, 0x2, 0x2, 0x645, 0x648, 
       0x3, 0x2, 0x2, 0x2, 0x646, 0x647, 0x7, 0x18e, 0x2, 0x2, 0x647, 0x649, 
       0x5, 0x11c, 0x8f, 0x2, 0x648, 0x646, 0x3, 0x2, 0x2, 0x2, 0x648, 0x649, 
       0x3, 0x2, 0x2, 0x2, 0x649, 0x64b, 0x3, 0x2, 0x2, 0x2, 0x64a, 0x64c, 
       0x5, 0xf6, 0x7c, 0x2, 0x64b, 0x64a, 0x3, 0x2, 0x2, 0x2, 0x64b, 0x64c, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x64f, 0x3, 0x2, 0x2, 0x2, 0x64d, 0x64e, 
       0x7, 0xf2, 0x2, 0x2, 0x64e, 0x650, 0x5, 0x1f4, 0xfb, 0x2, 0x64f, 
       0x64d, 0x3, 0x2, 0x2, 0x2, 0x64f, 0x650, 0x3, 0x2, 0x2, 0x2, 0x650, 
       0x652, 0x3, 0x2, 0x2, 0x2, 0x651, 0x653, 0x7, 0x35b, 0x2, 0x2, 0x652, 
       0x651, 0x3, 0x2, 0x2, 0x2, 0x652, 0x653, 0x3, 0x2, 0x2, 0x2, 0x653, 
       0x7d, 0x3, 0x2, 0x2, 0x2, 0x654, 0x657, 0x7, 0x4e, 0x2, 0x2, 0x655, 
       0x656, 0x7, 0xfa, 0x2, 0x2, 0x656, 0x658, 0x7, 0xb, 0x2, 0x2, 0x657, 
       0x655, 0x3, 0x2, 0x2, 0x2, 0x657, 0x658, 0x3, 0x2, 0x2, 0x2, 0x658, 
       0x65b, 0x3, 0x2, 0x2, 0x2, 0x659, 0x65b, 0x7, 0xb, 0x2, 0x2, 0x65a, 
       0x654, 0x3, 0x2, 0x2, 0x2, 0x65a, 0x659, 0x3, 0x2, 0x2, 0x2, 0x65b, 
       0x65c, 0x3, 0x2, 0x2, 0x2, 0x65c, 0x65d, 0x9, 0x11, 0x2, 0x2, 0x65d, 
       0x660, 0x5, 0x1c0, 0xe1, 0x2, 0x65e, 0x65f, 0x7, 0x35b, 0x2, 0x2, 
       0x65f, 0x661, 0x7, 0x33e, 0x2, 0x2, 0x660, 0x65e, 0x3, 0x2, 0x2, 
       0x2, 0x660, 0x661, 0x3, 0x2, 0x2, 0x2, 0x661, 0x670, 0x3, 0x2, 0x2, 
       0x2, 0x662, 0x664, 0x7, 0x358, 0x2, 0x2, 0x663, 0x662, 0x3, 0x2, 
       0x2, 0x2, 0x663, 0x664, 0x3, 0x2, 0x2, 0x2, 0x664, 0x665, 0x3, 0x2, 
       0x2, 0x2, 0x665, 0x66a, 0x5, 0x88, 0x45, 0x2, 0x666, 0x667, 0x7, 
       0x35a, 0x2, 0x2, 0x667, 0x669, 0x5, 0x88, 0x45, 0x2, 0x668, 0x666, 
       0x3, 0x2, 0x2, 0x2, 0x669, 0x66c, 0x3, 0x2, 0x2, 0x2, 0x66a, 0x668, 
       0x3, 0x2, 0x2, 0x2, 0x66a, 0x66b, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x66e, 
       0x3, 0x2, 0x2, 0x2, 0x66c, 0x66a, 0x3, 0x2, 0x2, 0x2, 0x66d, 0x66f, 
       0x7, 0x359, 0x2, 0x2, 0x66e, 0x66d, 0x3, 0x2, 0x2, 0x2, 0x66e, 0x66f, 
       0x3, 0x2, 0x2, 0x2, 0x66f, 0x671, 0x3, 0x2, 0x2, 0x2, 0x670, 0x663, 
       0x3, 0x2, 0x2, 0x2, 0x670, 0x671, 0x3, 0x2, 0x2, 0x2, 0x671, 0x67b, 
       0x3, 0x2, 0x2, 0x2, 0x672, 0x673, 0x7, 0x191, 0x2, 0x2, 0x673, 0x678, 
       0x5, 0x8a, 0x46, 0x2, 0x674, 0x675, 0x7, 0x35a, 0x2, 0x2, 0x675, 
       0x677, 0x5, 0x8a, 0x46, 0x2, 0x676, 0x674, 0x3, 0x2, 0x2, 0x2, 0x677, 
       0x67a, 0x3, 0x2, 0x2, 0x2, 0x678, 0x676, 0x3, 0x2, 0x2, 0x2, 0x678, 
       0x679, 0x3, 0x2, 0x2, 0x2, 0x679, 0x67c, 0x3, 0x2, 0x2, 0x2, 0x67a, 
       0x678, 0x3, 0x2, 0x2, 0x2, 0x67b, 0x672, 0x3, 0x2, 0x2, 0x2, 0x67b, 
       0x67c, 0x3, 0x2, 0x2, 0x2, 0x67c, 0x67f, 0x3, 0x2, 0x2, 0x2, 0x67d, 
       0x67e, 0x7, 0x8b, 0x2, 0x2, 0x67e, 0x680, 0x7, 0x122, 0x2, 0x2, 0x67f, 
       0x67d, 0x3, 0x2, 0x2, 0x2, 0x67f, 0x680, 0x3, 0x2, 0x2, 0x2, 0x680, 
       0x681, 0x3, 0x2, 0x2, 0x2, 0x681, 0x682, 0x7, 0x11, 0x2, 0x2, 0x682, 
       0x683, 0x5, 0x6, 0x4, 0x2, 0x683, 0x7f, 0x3, 0x2, 0x2, 0x2, 0x684, 
       0x687, 0x7, 0x4e, 0x2, 0x2, 0x685, 0x686, 0x7, 0xfa, 0x2, 0x2, 0x686, 
       0x688, 0x7, 0xb, 0x2, 0x2, 0x687, 0x685, 0x3, 0x2, 0x2, 0x2, 0x687, 
       0x688, 0x3, 0x2, 0x2, 0x2, 0x688, 0x68b, 0x3, 0x2, 0x2, 0x2, 0x689, 
       0x68b, 0x7, 0xb, 0x2, 0x2, 0x68a, 0x684, 0x3, 0x2, 0x2, 0x2, 0x68a, 
       0x689, 0x3, 0x2, 0x2, 0x2, 0x68b, 0x68c, 0x3, 0x2, 0x2, 0x2, 0x68c, 
       0x68d, 0x7, 0x93, 0x2, 0x2, 0x68d, 0x69b, 0x5, 0x1c0, 0xe1, 0x2, 
       0x68e, 0x68f, 0x7, 0x358, 0x2, 0x2, 0x68f, 0x694, 0x5, 0x88, 0x45, 
       0x2, 0x690, 0x691, 0x7, 0x35a, 0x2, 0x2, 0x691, 0x693, 0x5, 0x88, 
       0x45, 0x2, 0x692, 0x690, 0x3, 0x2, 0x2, 0x2, 0x693, 0x696, 0x3, 0x2, 
       0x2, 0x2, 0x694, 0x692, 0x3, 0x2, 0x2, 0x2, 0x694, 0x695, 0x3, 0x2, 
       0x2, 0x2, 0x695, 0x697, 0x3, 0x2, 0x2, 0x2, 0x696, 0x694, 0x3, 0x2, 
       0x2, 0x2, 0x697, 0x698, 0x7, 0x359, 0x2, 0x2, 0x698, 0x69c, 0x3, 
       0x2, 0x2, 0x2, 0x699, 0x69a, 0x7, 0x358, 0x2, 0x2, 0x69a, 0x69c, 
       0x7, 0x359, 0x2, 0x2, 0x69b, 0x68e, 0x3, 0x2, 0x2, 0x2, 0x69b, 0x699, 
       0x3, 0x2, 0x2, 0x2, 0x69c, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x69d, 0x6a1, 
       0x5, 0x82, 0x42, 0x2, 0x69e, 0x6a1, 0x5, 0x84, 0x43, 0x2, 0x69f, 
       0x6a1, 0x5, 0x86, 0x44, 0x2, 0x6a0, 0x69d, 0x3, 0x2, 0x2, 0x2, 0x6a0, 
       0x69e, 0x3, 0x2, 0x2, 0x2, 0x6a0, 0x69f, 0x3, 0x2, 0x2, 0x2, 0x6a1, 
       0x6a3, 0x3, 0x2, 0x2, 0x2, 0x6a2, 0x6a4, 0x7, 0x35b, 0x2, 0x2, 0x6a3, 
       0x6a2, 0x3, 0x2, 0x2, 0x2, 0x6a3, 0x6a4, 0x3, 0x2, 0x2, 0x2, 0x6a4, 
       0x81, 0x3, 0x2, 0x2, 0x2, 0x6a5, 0x6a6, 0x7, 0x12b, 0x2, 0x2, 0x6a6, 
       0x6b0, 0x7, 0x169, 0x2, 0x2, 0x6a7, 0x6a8, 0x7, 0x191, 0x2, 0x2, 
       0x6a8, 0x6ad, 0x5, 0x8c, 0x47, 0x2, 0x6a9, 0x6aa, 0x7, 0x35a, 0x2, 
       0x2, 0x6aa, 0x6ac, 0x5, 0x8c, 0x47, 0x2, 0x6ab, 0x6a9, 0x3, 0x2, 
       0x2, 0x2, 0x6ac, 0x6af, 0x3, 0x2, 0x2, 0x2, 0x6ad, 0x6ab, 0x3, 0x2, 
       0x2, 0x2, 0x6ad, 0x6ae, 0x3, 0x2, 0x2, 0x2, 0x6ae, 0x6b1, 0x3, 0x2, 
       0x2, 0x2, 0x6af, 0x6ad, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6a7, 0x3, 0x2, 
       0x2, 0x2, 0x6b0, 0x6b1, 0x3, 0x2, 0x2, 0x2, 0x6b1, 0x6b3, 0x3, 0x2, 
       0x2, 0x2, 0x6b2, 0x6b4, 0x7, 0x11, 0x2, 0x2, 0x6b3, 0x6b2, 0x3, 0x2, 
       0x2, 0x2, 0x6b3, 0x6b4, 0x3, 0x2, 0x2, 0x2, 0x6b4, 0x6b5, 0x3, 0x2, 
       0x2, 0x2, 0x6b5, 0x6bb, 0x7, 0x12a, 0x2, 0x2, 0x6b6, 0x6b7, 0x7, 
       0x358, 0x2, 0x2, 0x6b7, 0x6b8, 0x5, 0x6e, 0x38, 0x2, 0x6b8, 0x6b9, 
       0x7, 0x359, 0x2, 0x2, 0x6b9, 0x6bc, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6bc, 
       0x5, 0x6e, 0x38, 0x2, 0x6bb, 0x6b6, 0x3, 0x2, 0x2, 0x2, 0x6bb, 0x6ba, 
       0x3, 0x2, 0x2, 0x2, 0x6bc, 0x83, 0x3, 0x2, 0x2, 0x2, 0x6bd, 0x6be, 
       0x7, 0x12b, 0x2, 0x2, 0x6be, 0x6bf, 0x7, 0x33d, 0x2, 0x2, 0x6bf, 
       0x6c9, 0x5, 0xe0, 0x71, 0x2, 0x6c0, 0x6c1, 0x7, 0x191, 0x2, 0x2, 
       0x6c1, 0x6c6, 0x5, 0x8c, 0x47, 0x2, 0x6c2, 0x6c3, 0x7, 0x35a, 0x2, 
       0x2, 0x6c3, 0x6c5, 0x5, 0x8c, 0x47, 0x2, 0x6c4, 0x6c2, 0x3, 0x2, 
       0x2, 0x2, 0x6c5, 0x6c8, 0x3, 0x2, 0x2, 0x2, 0x6c6, 0x6c4, 0x3, 0x2, 
       0x2, 0x2, 0x6c6, 0x6c7, 0x3, 0x2, 0x2, 0x2, 0x6c7, 0x6ca, 0x3, 0x2, 
       0x2, 0x2, 0x6c8, 0x6c6, 0x3, 0x2, 0x2, 0x2, 0x6c9, 0x6c0, 0x3, 0x2, 
       0x2, 0x2, 0x6c9, 0x6ca, 0x3, 0x2, 0x2, 0x2, 0x6ca, 0x6cc, 0x3, 0x2, 
       0x2, 0x2, 0x6cb, 0x6cd, 0x7, 0x11, 0x2, 
  };
  static uint16_t serializedATNSegment1[] = {
    0x2, 0x6cc, 0x6cb, 0x3, 0x2, 0x2, 0x2, 0x6cc, 0x6cd, 0x3, 0x2, 0x2, 
       0x2, 0x6cd, 0x6ce, 0x3, 0x2, 0x2, 0x2, 0x6ce, 0x6d2, 0x7, 0x1e, 0x2, 
       0x2, 0x6cf, 0x6d1, 0x5, 0x8, 0x5, 0x2, 0x6d0, 0x6cf, 0x3, 0x2, 0x2, 
       0x2, 0x6d1, 0x6d4, 0x3, 0x2, 0x2, 0x2, 0x6d2, 0x6d0, 0x3, 0x2, 0x2, 
       0x2, 0x6d2, 0x6d3, 0x3, 0x2, 0x2, 0x2, 0x6d3, 0x6d5, 0x3, 0x2, 0x2, 
       0x2, 0x6d4, 0x6d2, 0x3, 0x2, 0x2, 0x2, 0x6d5, 0x6d7, 0x7, 0x12a, 
       0x2, 0x2, 0x6d6, 0x6d8, 0x7, 0x35b, 0x2, 0x2, 0x6d7, 0x6d6, 0x3, 
       0x2, 0x2, 0x2, 0x6d7, 0x6d8, 0x3, 0x2, 0x2, 0x2, 0x6d8, 0x6d9, 0x3, 
       0x2, 0x2, 0x2, 0x6d9, 0x6db, 0x7, 0x71, 0x2, 0x2, 0x6da, 0x6dc, 0x7, 
       0x35b, 0x2, 0x2, 0x6db, 0x6da, 0x3, 0x2, 0x2, 0x2, 0x6db, 0x6dc, 
       0x3, 0x2, 0x2, 0x2, 0x6dc, 0x85, 0x3, 0x2, 0x2, 0x2, 0x6dd, 0x6de, 
       0x7, 0x12b, 0x2, 0x2, 0x6de, 0x6e8, 0x5, 0x1ec, 0xf7, 0x2, 0x6df, 
       0x6e0, 0x7, 0x191, 0x2, 0x2, 0x6e0, 0x6e5, 0x5, 0x8c, 0x47, 0x2, 
       0x6e1, 0x6e2, 0x7, 0x35a, 0x2, 0x2, 0x6e2, 0x6e4, 0x5, 0x8c, 0x47, 
       0x2, 0x6e3, 0x6e1, 0x3, 0x2, 0x2, 0x2, 0x6e4, 0x6e7, 0x3, 0x2, 0x2, 
       0x2, 0x6e5, 0x6e3, 0x3, 0x2, 0x2, 0x2, 0x6e5, 0x6e6, 0x3, 0x2, 0x2, 
       0x2, 0x6e6, 0x6e9, 0x3, 0x2, 0x2, 0x2, 0x6e7, 0x6e5, 0x3, 0x2, 0x2, 
       0x2, 0x6e8, 0x6df, 0x3, 0x2, 0x2, 0x2, 0x6e8, 0x6e9, 0x3, 0x2, 0x2, 
       0x2, 0x6e9, 0x6eb, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6ec, 0x7, 0x11, 0x2, 
       0x2, 0x6eb, 0x6ea, 0x3, 0x2, 0x2, 0x2, 0x6eb, 0x6ec, 0x3, 0x2, 0x2, 
       0x2, 0x6ec, 0x6ed, 0x3, 0x2, 0x2, 0x2, 0x6ed, 0x6f1, 0x7, 0x1e, 0x2, 
       0x2, 0x6ee, 0x6f0, 0x5, 0x8, 0x5, 0x2, 0x6ef, 0x6ee, 0x3, 0x2, 0x2, 
       0x2, 0x6f0, 0x6f3, 0x3, 0x2, 0x2, 0x2, 0x6f1, 0x6ef, 0x3, 0x2, 0x2, 
       0x2, 0x6f1, 0x6f2, 0x3, 0x2, 0x2, 0x2, 0x6f2, 0x6f4, 0x3, 0x2, 0x2, 
       0x2, 0x6f3, 0x6f1, 0x3, 0x2, 0x2, 0x2, 0x6f4, 0x6f5, 0x7, 0x12a, 
       0x2, 0x2, 0x6f5, 0x6f7, 0x5, 0x106, 0x84, 0x2, 0x6f6, 0x6f8, 0x7, 
       0x35b, 0x2, 0x2, 0x6f7, 0x6f6, 0x3, 0x2, 0x2, 0x2, 0x6f7, 0x6f8, 
       0x3, 0x2, 0x2, 0x2, 0x6f8, 0x6f9, 0x3, 0x2, 0x2, 0x2, 0x6f9, 0x6fa, 
       0x7, 0x71, 0x2, 0x2, 0x6fa, 0x87, 0x3, 0x2, 0x2, 0x2, 0x6fb, 0x6ff, 
       0x7, 0x33d, 0x2, 0x2, 0x6fc, 0x6fd, 0x5, 0x1f4, 0xfb, 0x2, 0x6fd, 
       0x6fe, 0x7, 0x353, 0x2, 0x2, 0x6fe, 0x700, 0x3, 0x2, 0x2, 0x2, 0x6ff, 
       0x6fc, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x700, 0x3, 0x2, 0x2, 0x2, 0x700, 
       0x702, 0x3, 0x2, 0x2, 0x2, 0x701, 0x703, 0x7, 0x11, 0x2, 0x2, 0x702, 
       0x701, 0x3, 0x2, 0x2, 0x2, 0x702, 0x703, 0x3, 0x2, 0x2, 0x2, 0x703, 
       0x704, 0x3, 0x2, 0x2, 0x2, 0x704, 0x706, 0x5, 0x1ec, 0xf7, 0x2, 0x705, 
       0x707, 0x7, 0x188, 0x2, 0x2, 0x706, 0x705, 0x3, 0x2, 0x2, 0x2, 0x706, 
       0x707, 0x3, 0x2, 0x2, 0x2, 0x707, 0x70a, 0x3, 0x2, 0x2, 0x2, 0x708, 
       0x709, 0x7, 0x346, 0x2, 0x2, 0x709, 0x70b, 0x5, 0x1ee, 0xf8, 0x2, 
       0x70a, 0x708, 0x3, 0x2, 0x2, 0x2, 0x70a, 0x70b, 0x3, 0x2, 0x2, 0x2, 
       0x70b, 0x70d, 0x3, 0x2, 0x2, 0x2, 0x70c, 0x70e, 0x9, 0x12, 0x2, 0x2, 
       0x70d, 0x70c, 0x3, 0x2, 0x2, 0x2, 0x70d, 0x70e, 0x3, 0x2, 0x2, 0x2, 
       0x70e, 0x89, 0x3, 0x2, 0x2, 0x2, 0x70f, 0x713, 0x7, 0x207, 0x2, 0x2, 
       0x710, 0x713, 0x7, 0x2be, 0x2, 0x2, 0x711, 0x713, 0x5, 0xdc, 0x6f, 
       0x2, 0x712, 0x70f, 0x3, 0x2, 0x2, 0x2, 0x712, 0x710, 0x3, 0x2, 0x2, 
       0x2, 0x712, 0x711, 0x3, 0x2, 0x2, 0x2, 0x713, 0x8b, 0x3, 0x2, 0x2, 
       0x2, 0x714, 0x721, 0x7, 0x207, 0x2, 0x2, 0x715, 0x721, 0x7, 0x2d9, 
       0x2, 0x2, 0x716, 0x717, 0x7, 0x12b, 0x2, 0x2, 0x717, 0x718, 0x7, 
       0xec, 0x2, 0x2, 0x718, 0x719, 0x7, 0xf2, 0x2, 0x2, 0x719, 0x71a, 
       0x7, 0xec, 0x2, 0x2, 0x71a, 0x721, 0x7, 0x23b, 0x2, 0x2, 0x71b, 0x71c, 
       0x7, 0x2a, 0x2, 0x2, 0x71c, 0x71d, 0x7, 0xf2, 0x2, 0x2, 0x71d, 0x71e, 
       0x7, 0xec, 0x2, 0x2, 0x71e, 0x721, 0x7, 0x23b, 0x2, 0x2, 0x71f, 0x721, 
       0x5, 0xdc, 0x6f, 0x2, 0x720, 0x714, 0x3, 0x2, 0x2, 0x2, 0x720, 0x715, 
       0x3, 0x2, 0x2, 0x2, 0x720, 0x716, 0x3, 0x2, 0x2, 0x2, 0x720, 0x71b, 
       0x3, 0x2, 0x2, 0x2, 0x720, 0x71f, 0x3, 0x2, 0x2, 0x2, 0x721, 0x8d, 
       0x3, 0x2, 0x2, 0x2, 0x722, 0x723, 0x7, 0x4e, 0x2, 0x2, 0x723, 0x724, 
       0x7, 0x169, 0x2, 0x2, 0x724, 0x725, 0x5, 0x1bc, 0xdf, 0x2, 0x725, 
       0x726, 0x7, 0x358, 0x2, 0x2, 0x726, 0x728, 0x5, 0xe6, 0x74, 0x2, 
       0x727, 0x729, 0x7, 0x35a, 0x2, 0x2, 0x728, 0x727, 0x3, 0x2, 0x2, 
       0x2, 0x728, 0x729, 0x3, 0x2, 0x2, 0x2, 0x729, 0x72a, 0x3, 0x2, 0x2, 
       0x2, 0x72a, 0x72d, 0x7, 0x359, 0x2, 0x2, 0x72b, 0x72c, 0x7, 0x254, 
       0x2, 0x2, 0x72c, 0x72e, 0x5, 0x1f6, 0xfc, 0x2, 0x72d, 0x72b, 0x3, 
       0x2, 0x2, 0x2, 0x72d, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x72e, 0x732, 0x3, 
       0x2, 0x2, 0x2, 0x72f, 0x731, 0x5, 0x90, 0x49, 0x2, 0x730, 0x72f, 
       0x3, 0x2, 0x2, 0x2, 0x731, 0x734, 0x3, 0x2, 0x2, 0x2, 0x732, 0x730, 
       0x3, 0x2, 0x2, 0x2, 0x732, 0x733, 0x3, 0x2, 0x2, 0x2, 0x733, 0x738, 
       0x3, 0x2, 0x2, 0x2, 0x734, 0x732, 0x3, 0x2, 0x2, 0x2, 0x735, 0x736, 
       0x7, 0xf2, 0x2, 0x2, 0x736, 0x739, 0x5, 0x1f4, 0xfb, 0x2, 0x737, 
       0x739, 0x7, 0x5e, 0x2, 0x2, 0x738, 0x735, 0x3, 0x2, 0x2, 0x2, 0x738, 
       0x737, 0x3, 0x2, 0x2, 0x2, 0x738, 0x739, 0x3, 0x2, 0x2, 0x2, 0x739, 
       0x73d, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x73b, 0x7, 0x30e, 0x2, 0x2, 0x73b, 
       0x73e, 0x5, 0x1f4, 0xfb, 0x2, 0x73c, 0x73e, 0x7, 0x5e, 0x2, 0x2, 
       0x73d, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73d, 0x73c, 0x3, 0x2, 0x2, 0x2, 
       0x73d, 0x73e, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x740, 0x3, 0x2, 0x2, 0x2, 
       0x73f, 0x741, 0x7, 0x35b, 0x2, 0x2, 0x740, 0x73f, 0x3, 0x2, 0x2, 
       0x2, 0x740, 0x741, 0x3, 0x2, 0x2, 0x2, 0x741, 0x8f, 0x3, 0x2, 0x2, 
       0x2, 0x742, 0x756, 0x7, 0x191, 0x2, 0x2, 0x743, 0x744, 0x7, 0x358, 
       0x2, 0x2, 0x744, 0x749, 0x5, 0xf8, 0x7d, 0x2, 0x745, 0x746, 0x7, 
       0x35a, 0x2, 0x2, 0x746, 0x748, 0x5, 0xf8, 0x7d, 0x2, 0x747, 0x745, 
       0x3, 0x2, 0x2, 0x2, 0x748, 0x74b, 0x3, 0x2, 0x2, 0x2, 0x749, 0x747, 
       0x3, 0x2, 0x2, 0x2, 0x749, 0x74a, 0x3, 0x2, 0x2, 0x2, 0x74a, 0x74c, 
       0x3, 0x2, 0x2, 0x2, 0x74b, 0x749, 0x3, 0x2, 0x2, 0x2, 0x74c, 0x74d, 
       0x7, 0x359, 0x2, 0x2, 0x74d, 0x757, 0x3, 0x2, 0x2, 0x2, 0x74e, 0x753, 
       0x5, 0xf8, 0x7d, 0x2, 0x74f, 0x750, 0x7, 0x35a, 0x2, 0x2, 0x750, 
       0x752, 0x5, 0xf8, 0x7d, 0x2, 0x751, 0x74f, 0x3, 0x2, 0x2, 0x2, 0x752, 
       0x755, 0x3, 0x2, 0x2, 0x2, 0x753, 0x751, 0x3, 0x2, 0x2, 0x2, 0x753, 
       0x754, 0x3, 0x2, 0x2, 0x2, 0x754, 0x757, 0x3, 0x2, 0x2, 0x2, 0x755, 
       0x753, 0x3, 0x2, 0x2, 0x2, 0x756, 0x743, 0x3, 0x2, 0x2, 0x2, 0x756, 
       0x74e, 0x3, 0x2, 0x2, 0x2, 0x757, 0x91, 0x3, 0x2, 0x2, 0x2, 0x758, 
       0x759, 0x7, 0x4e, 0x2, 0x2, 0x759, 0x75a, 0x7, 0x18a, 0x2, 0x2, 0x75a, 
       0x75f, 0x5, 0x1be, 0xe0, 0x2, 0x75b, 0x75c, 0x7, 0x358, 0x2, 0x2, 
       0x75c, 0x75d, 0x5, 0x1cc, 0xe7, 0x2, 0x75d, 0x75e, 0x7, 0x359, 0x2, 
       0x2, 0x75e, 0x760, 0x3, 0x2, 0x2, 0x2, 0x75f, 0x75b, 0x3, 0x2, 0x2, 
       0x2, 0x75f, 0x760, 0x3, 0x2, 0x2, 0x2, 0x760, 0x76a, 0x3, 0x2, 0x2, 
       0x2, 0x761, 0x762, 0x7, 0x191, 0x2, 0x2, 0x762, 0x767, 0x5, 0x94, 
       0x4b, 0x2, 0x763, 0x764, 0x7, 0x35a, 0x2, 0x2, 0x764, 0x766, 0x5, 
       0x94, 0x4b, 0x2, 0x765, 0x763, 0x3, 0x2, 0x2, 0x2, 0x766, 0x769, 
       0x3, 0x2, 0x2, 0x2, 0x767, 0x765, 0x3, 0x2, 0x2, 0x2, 0x767, 0x768, 
       0x3, 0x2, 0x2, 0x2, 0x768, 0x76b, 0x3, 0x2, 0x2, 0x2, 0x769, 0x767, 
       0x3, 0x2, 0x2, 0x2, 0x76a, 0x761, 0x3, 0x2, 0x2, 0x2, 0x76a, 0x76b, 
       0x3, 0x2, 0x2, 0x2, 0x76b, 0x76c, 0x3, 0x2, 0x2, 0x2, 0x76c, 0x76d, 
       0x7, 0x11, 0x2, 0x2, 0x76d, 0x771, 0x5, 0x6e, 0x38, 0x2, 0x76e, 0x76f, 
       0x7, 0x191, 0x2, 0x2, 0x76f, 0x770, 0x7, 0x33, 0x2, 0x2, 0x770, 0x772, 
       0x7, 0xf9, 0x2, 0x2, 0x771, 0x76e, 0x3, 0x2, 0x2, 0x2, 0x771, 0x772, 
       0x3, 0x2, 0x2, 0x2, 0x772, 0x774, 0x3, 0x2, 0x2, 0x2, 0x773, 0x775, 
       0x7, 0x35b, 0x2, 0x2, 0x774, 0x773, 0x3, 0x2, 0x2, 0x2, 0x774, 0x775, 
       0x3, 0x2, 0x2, 0x2, 0x775, 0x93, 0x3, 0x2, 0x2, 0x2, 0x776, 0x777, 
       0x9, 0x13, 0x2, 0x2, 0x777, 0x95, 0x3, 0x2, 0x2, 0x2, 0x778, 0x779, 
       0x7, 0xb, 0x2, 0x2, 0x779, 0x77a, 0x7, 0x169, 0x2, 0x2, 0x77a, 0x7a6, 
       0x5, 0x1bc, 0xdf, 0x2, 0x77b, 0x77c, 0x7, 0x14e, 0x2, 0x2, 0x77c, 
       0x77d, 0x7, 0x358, 0x2, 0x2, 0x77d, 0x77e, 0x7, 0x255, 0x2, 0x2, 
       0x77e, 0x77f, 0x7, 0x346, 0x2, 0x2, 0x77f, 0x780, 0x9, 0x14, 0x2, 
       0x2, 0x780, 0x7a7, 0x7, 0x359, 0x2, 0x2, 0x781, 0x782, 0x7, 0x5, 
       0x2, 0x2, 0x782, 0x7a7, 0x5, 0xe8, 0x75, 0x2, 0x783, 0x784, 0x7, 
       0xb, 0x2, 0x2, 0x784, 0x785, 0x7, 0x3d, 0x2, 0x2, 0x785, 0x7a7, 0x5, 
       0xea, 0x76, 0x2, 0x786, 0x787, 0x7, 0x6c, 0x2, 0x2, 0x787, 0x788, 
       0x7, 0x3d, 0x2, 0x2, 0x788, 0x7a7, 0x5, 0x1f4, 0xfb, 0x2, 0x789, 
       0x78a, 0x7, 0x6c, 0x2, 0x2, 0x78a, 0x78b, 0x7, 0x42, 0x2, 0x2, 0x78b, 
       0x7a7, 0x5, 0x1f4, 0xfb, 0x2, 0x78c, 0x78d, 0x7, 0x191, 0x2, 0x2, 
       0x78d, 0x78e, 0x7, 0x33, 0x2, 0x2, 0x78e, 0x78f, 0x7, 0x5, 0x2, 0x2, 
       0x78f, 0x790, 0x7, 0x42, 0x2, 0x2, 0x790, 0x791, 0x5, 0x1f4, 0xfb, 
       0x2, 0x791, 0x792, 0x7, 0x8e, 0x2, 0x2, 0x792, 0x793, 0x7, 0xb4, 
       0x2, 0x2, 0x793, 0x794, 0x7, 0x358, 0x2, 0x2, 0x794, 0x795, 0x5, 
       0x1cc, 0xe7, 0x2, 0x795, 0x796, 0x7, 0x359, 0x2, 0x2, 0x796, 0x797, 
       0x7, 0x11d, 0x2, 0x2, 0x797, 0x798, 0x5, 0x1bc, 0xdf, 0x2, 0x798, 
       0x799, 0x7, 0x358, 0x2, 0x2, 0x799, 0x79a, 0x5, 0x1cc, 0xe7, 0x2, 
       0x79a, 0x79b, 0x7, 0x359, 0x2, 0x2, 0x79b, 0x7a7, 0x3, 0x2, 0x2, 
       0x2, 0x79c, 0x79d, 0x7, 0x33, 0x2, 0x2, 0x79d, 0x79e, 0x7, 0x42, 
       0x2, 0x2, 0x79e, 0x7a7, 0x5, 0x1f4, 0xfb, 0x2, 0x79f, 0x7a0, 0x9, 
       0x15, 0x2, 0x2, 0x7a0, 0x7a2, 0x7, 0x176, 0x2, 0x2, 0x7a1, 0x7a3, 
       0x5, 0x1f4, 0xfb, 0x2, 0x7a2, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x7a2, 0x7a3, 
       0x3, 0x2, 0x2, 0x2, 0x7a3, 0x7a7, 0x3, 0x2, 0x2, 0x2, 0x7a4, 0x7a5, 
       0x7, 0x2bc, 0x2, 0x2, 0x7a5, 0x7a7, 0x5, 0x90, 0x49, 0x2, 0x7a6, 
       0x77b, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x781, 0x3, 0x2, 0x2, 0x2, 0x7a6, 
       0x783, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x786, 0x3, 0x2, 0x2, 0x2, 0x7a6, 
       0x789, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x7a6, 
       0x79c, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x79f, 0x3, 0x2, 0x2, 0x2, 0x7a6, 
       0x7a4, 0x3, 0x2, 0x2, 0x2, 0x7a7, 0x7a9, 0x3, 0x2, 0x2, 0x2, 0x7a8, 
       0x7aa, 0x7, 0x35b, 0x2, 0x2, 0x7a9, 0x7a8, 0x3, 0x2, 0x2, 0x2, 0x7a9, 
       0x7aa, 0x3, 0x2, 0x2, 0x2, 0x7aa, 0x97, 0x3, 0x2, 0x2, 0x2, 0x7ab, 
       0x7ac, 0x7, 0x1df, 0x2, 0x2, 0x7ac, 0x7b0, 0x5, 0x1d0, 0xe9, 0x2, 
       0x7ad, 0x7ae, 0x7, 0x1e0, 0x2, 0x2, 0x7ae, 0x7b0, 0x9, 0x16, 0x2, 
       0x2, 0x7af, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x7af, 0x7ad, 0x3, 0x2, 0x2, 
       0x2, 0x7b0, 0x99, 0x3, 0x2, 0x2, 0x2, 0x7b1, 0x7b2, 0x7, 0x30c, 0x2, 
       0x2, 0x7b2, 0x7b3, 0x7, 0x346, 0x2, 0x2, 0x7b3, 0x7b4, 0x7, 0x33e, 
       0x2, 0x2, 0x7b4, 0x7b5, 0x9, 0x17, 0x2, 0x2, 0x7b5, 0x9b, 0x3, 0x2, 
       0x2, 0x2, 0x7b6, 0x7b7, 0x7, 0x130, 0x2, 0x2, 0x7b7, 0x7b8, 0x7, 
       0x1a1, 0x2, 0x2, 0x7b8, 0x7bd, 0x7, 0x33e, 0x2, 0x2, 0x7b9, 0x7ba, 
       0x7, 0x130, 0x2, 0x2, 0x7ba, 0x7bd, 0x7, 0x235, 0x2, 0x2, 0x7bb, 
       0x7bd, 0x7, 0x280, 0x2, 0x2, 0x7bc, 0x7b6, 0x3, 0x2, 0x2, 0x2, 0x7bc, 
       0x7b9, 0x3, 0x2, 0x2, 0x2, 0x7bc, 0x7bb, 0x3, 0x2, 0x2, 0x2, 0x7bd, 
       0x9d, 0x3, 0x2, 0x2, 0x2, 0x7be, 0x7bf, 0x7, 0x6c, 0x2, 0x2, 0x7bf, 
       0x7c2, 0x7, 0xa4, 0x2, 0x2, 0x7c0, 0x7c1, 0x7, 0x9f, 0x2, 0x2, 0x7c1, 
       0x7c3, 0x7, 0x7c, 0x2, 0x2, 0x7c2, 0x7c0, 0x3, 0x2, 0x2, 0x2, 0x7c2, 
       0x7c3, 0x3, 0x2, 0x2, 0x2, 0x7c3, 0x7d4, 0x3, 0x2, 0x2, 0x2, 0x7c4, 
       0x7c9, 0x5, 0xa0, 0x51, 0x2, 0x7c5, 0x7c6, 0x7, 0x35a, 0x2, 0x2, 
       0x7c6, 0x7c8, 0x5, 0xa0, 0x51, 0x2, 0x7c7, 0x7c5, 0x3, 0x2, 0x2, 
       0x2, 0x7c8, 0x7cb, 0x3, 0x2, 0x2, 0x2, 0x7c9, 0x7c7, 0x3, 0x2, 0x2, 
       0x2, 0x7c9, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7ca, 0x7d5, 0x3, 0x2, 0x2, 
       0x2, 0x7cb, 0x7c9, 0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7d1, 0x5, 0xa2, 0x52, 
       0x2, 0x7cd, 0x7ce, 0x7, 0x35a, 0x2, 0x2, 0x7ce, 0x7d0, 0x5, 0xa2, 
       0x52, 0x2, 0x7cf, 0x7cd, 0x3, 0x2, 0x2, 0x2, 0x7d0, 0x7d3, 0x3, 0x2, 
       0x2, 0x2, 0x7d1, 0x7cf, 0x3, 0x2, 0x2, 0x2, 0x7d1, 0x7d2, 0x3, 0x2, 
       0x2, 0x2, 0x7d2, 0x7d5, 0x3, 0x2, 0x2, 0x2, 0x7d3, 0x7d1, 0x3, 0x2, 
       0x2, 0x2, 0x7d4, 0x7c4, 0x3, 0x2, 0x2, 0x2, 0x7d4, 0x7cc, 0x3, 0x2, 
       0x2, 0x2, 0x7d5, 0x7d7, 0x3, 0x2, 0x2, 0x2, 0x7d6, 0x7d8, 0x7, 0x35b, 
       0x2, 0x2, 0x7d7, 0x7d6, 0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7d8, 0x3, 0x2, 
       0x2, 0x2, 0x7d8, 0x9f, 0x3, 0x2, 0x2, 0x2, 0x7d9, 0x7da, 0x5, 0x1f4, 
       0xfb, 0x2, 0x7da, 0x7db, 0x7, 0xf2, 0x2, 0x2, 0x7db, 0x7dc, 0x5, 
       0x1ba, 0xde, 0x2, 0x7dc, 0xa1, 0x3, 0x2, 0x2, 0x2, 0x7dd, 0x7de, 
       0x5, 0x1f4, 0xfb, 0x2, 0x7de, 0x7df, 0x7, 0x353, 0x2, 0x2, 0x7df, 
       0x7e1, 0x3, 0x2, 0x2, 0x2, 0x7e0, 0x7dd, 0x3, 0x2, 0x2, 0x2, 0x7e0, 
       0x7e1, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7e2, 
       0x7e3, 0x5, 0x1f4, 0xfb, 0x2, 0x7e3, 0x7e4, 0x7, 0x353, 0x2, 0x2, 
       0x7e4, 0x7e5, 0x5, 0x1f4, 0xfb, 0x2, 0x7e5, 0xa3, 0x3, 0x2, 0x2, 
       0x2, 0x7e6, 0x7e7, 0x7, 0x6c, 0x2, 0x2, 0x7e7, 0x7ea, 0x9, 0x11, 
       0x2, 0x2, 0x7e8, 0x7e9, 0x7, 0x9f, 0x2, 0x2, 0x7e9, 0x7eb, 0x7, 0x7c, 
       0x2, 0x2, 0x7ea, 0x7e8, 0x3, 0x2, 0x2, 0x2, 0x7ea, 0x7eb, 0x3, 0x2, 
       0x2, 0x2, 0x7eb, 0x7ec, 0x3, 0x2, 0x2, 0x2, 0x7ec, 0x7f1, 0x5, 0x1c0, 
       0xe1, 0x2, 0x7ed, 0x7ee, 0x7, 0x35a, 0x2, 0x2, 0x7ee, 0x7f0, 0x5, 
       0x1c0, 0xe1, 0x2, 0x7ef, 0x7ed, 0x3, 0x2, 0x2, 0x2, 0x7f0, 0x7f3, 
       0x3, 0x2, 0x2, 0x2, 0x7f1, 0x7ef, 0x3, 0x2, 0x2, 0x2, 0x7f1, 0x7f2, 
       0x3, 0x2, 0x2, 0x2, 0x7f2, 0x7f5, 0x3, 0x2, 0x2, 0x2, 0x7f3, 0x7f1, 
       0x3, 0x2, 0x2, 0x2, 0x7f4, 0x7f6, 0x7, 0x35b, 0x2, 0x2, 0x7f5, 0x7f4, 
       0x3, 0x2, 0x2, 0x2, 0x7f5, 0x7f6, 0x3, 0x2, 0x2, 0x2, 0x7f6, 0xa5, 
       0x3, 0x2, 0x2, 0x2, 0x7f7, 0x7f8, 0x7, 0x6c, 0x2, 0x2, 0x7f8, 0x7fb, 
       0x7, 0x93, 0x2, 0x2, 0x7f9, 0x7fa, 0x7, 0x9f, 0x2, 0x2, 0x7fa, 0x7fc, 
       0x7, 0x7c, 0x2, 0x2, 0x7fb, 0x7f9, 0x3, 0x2, 0x2, 0x2, 0x7fb, 0x7fc, 
       0x3, 0x2, 0x2, 0x2, 0x7fc, 0x7fd, 0x3, 0x2, 0x2, 0x2, 0x7fd, 0x802, 
       0x5, 0x1c0, 0xe1, 0x2, 0x7fe, 0x7ff, 0x7, 0x35a, 0x2, 0x2, 0x7ff, 
       0x801, 0x5, 0x1c0, 0xe1, 0x2, 0x800, 0x7fe, 0x3, 0x2, 0x2, 0x2, 0x801, 
       0x804, 0x3, 0x2, 0x2, 0x2, 0x802, 0x800, 0x3, 0x2, 0x2, 0x2, 0x802, 
       0x803, 0x3, 0x2, 0x2, 0x2, 0x803, 0x806, 0x3, 0x2, 0x2, 0x2, 0x804, 
       0x802, 0x3, 0x2, 0x2, 0x2, 0x805, 0x807, 0x7, 0x35b, 0x2, 0x2, 0x806, 
       0x805, 0x3, 0x2, 0x2, 0x2, 0x806, 0x807, 0x3, 0x2, 0x2, 0x2, 0x807, 
       0xa7, 0x3, 0x2, 0x2, 0x2, 0x808, 0x809, 0x7, 0x6c, 0x2, 0x2, 0x809, 
       0x80c, 0x7, 0x169, 0x2, 0x2, 0x80a, 0x80b, 0x7, 0x9f, 0x2, 0x2, 0x80b, 
       0x80d, 0x7, 0x7c, 0x2, 0x2, 0x80c, 0x80a, 0x3, 0x2, 0x2, 0x2, 0x80c, 
       0x80d, 0x3, 0x2, 0x2, 0x2, 0x80d, 0x80e, 0x3, 0x2, 0x2, 0x2, 0x80e, 
       0x810, 0x5, 0x1bc, 0xdf, 0x2, 0x80f, 0x811, 0x7, 0x35b, 0x2, 0x2, 
       0x810, 0x80f, 0x3, 0x2, 0x2, 0x2, 0x810, 0x811, 0x3, 0x2, 0x2, 0x2, 
       0x811, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x812, 0x813, 0x7, 0x6c, 0x2, 0x2, 
       0x813, 0x816, 0x7, 0x18a, 0x2, 0x2, 0x814, 0x815, 0x7, 0x9f, 0x2, 
       0x2, 0x815, 0x817, 0x7, 0x7c, 0x2, 0x2, 0x816, 0x814, 0x3, 0x2, 0x2, 
       0x2, 0x816, 0x817, 0x3, 0x2, 0x2, 0x2, 0x817, 0x818, 0x3, 0x2, 0x2, 
       0x2, 0x818, 0x81d, 0x5, 0x1be, 0xe0, 0x2, 0x819, 0x81a, 0x7, 0x35a, 
       0x2, 0x2, 0x81a, 0x81c, 0x5, 0x1be, 0xe0, 0x2, 0x81b, 0x819, 0x3, 
       0x2, 0x2, 0x2, 0x81c, 0x81f, 0x3, 0x2, 0x2, 0x2, 0x81d, 0x81b, 0x3, 
       0x2, 0x2, 0x2, 0x81d, 0x81e, 0x3, 0x2, 0x2, 0x2, 0x81e, 0x821, 0x3, 
       0x2, 0x2, 0x2, 0x81f, 0x81d, 0x3, 0x2, 0x2, 0x2, 0x820, 0x822, 0x7, 
       0x35b, 0x2, 0x2, 0x821, 0x820, 0x3, 0x2, 0x2, 0x2, 0x821, 0x822, 
       0x3, 0x2, 0x2, 0x2, 0x822, 0xab, 0x3, 0x2, 0x2, 0x2, 0x823, 0x824, 
       0x7, 0x4e, 0x2, 0x2, 0x824, 0x825, 0x7, 0x31d, 0x2, 0x2, 0x825, 0x82a, 
       0x5, 0x1be, 0xe0, 0x2, 0x826, 0x827, 0x7, 0x91, 0x2, 0x2, 0x827, 
       0x828, 0x5, 0x1ec, 0xf7, 0x2, 0x828, 0x829, 0x5, 0x1ee, 0xf8, 0x2, 
       0x829, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x826, 0x3, 0x2, 0x2, 0x2, 
       0x82a, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x82b, 0x832, 0x3, 0x2, 0x2, 0x2, 
       0x82c, 0x82d, 0x7, 0x11, 0x2, 0x2, 0x82d, 0x82e, 0x7, 0x169, 0x2, 
       0x2, 0x82e, 0x82f, 0x7, 0x358, 0x2, 0x2, 0x82f, 0x830, 0x5, 0xe6, 
       0x74, 0x2, 0x830, 0x831, 0x7, 0x359, 0x2, 0x2, 0x831, 0x833, 0x3, 
       0x2, 0x2, 0x2, 0x832, 0x82c, 0x3, 0x2, 0x2, 0x2, 0x832, 0x833, 0x3, 
       0x2, 0x2, 0x2, 0x833, 0xad, 0x3, 0x2, 0x2, 0x2, 0x834, 0x835, 0x7, 
       0x6c, 0x2, 0x2, 0x835, 0x838, 0x7, 0x31d, 0x2, 0x2, 0x836, 0x837, 
       0x7, 0x9f, 0x2, 0x2, 0x837, 0x839, 0x7, 0x7c, 0x2, 0x2, 0x838, 0x836, 
       0x3, 0x2, 0x2, 0x2, 0x838, 0x839, 0x3, 0x2, 0x2, 0x2, 0x839, 0x83a, 
       0x3, 0x2, 0x2, 0x2, 0x83a, 0x83b, 0x5, 0x1be, 0xe0, 0x2, 0x83b, 0xaf, 
       0x3, 0x2, 0x2, 0x2, 0x83c, 0x83f, 0x5, 0xb2, 0x5a, 0x2, 0x83d, 0x83f, 
       0x5, 0xb4, 0x5b, 0x2, 0x83e, 0x83c, 0x3, 0x2, 0x2, 0x2, 0x83e, 0x83d, 
       0x3, 0x2, 0x2, 0x2, 0x83f, 0xb1, 0x3, 0x2, 0x2, 0x2, 0x840, 0x841, 
       0x7, 0xf6, 0x2, 0x2, 0x841, 0x842, 0x7, 0x358, 0x2, 0x2, 0x842, 0x843, 
       0x5, 0x1f4, 0xfb, 0x2, 0x843, 0x844, 0x7, 0x35a, 0x2, 0x2, 0x844, 
       0x845, 0x7, 0x342, 0x2, 0x2, 0x845, 0x846, 0x7, 0x359, 0x2, 0x2, 
       0x846, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x847, 0x848, 0x7, 0xf5, 0x2, 0x2, 
       0x848, 0x849, 0x7, 0x358, 0x2, 0x2, 0x849, 0x84a, 0x7, 0x342, 0x2, 
       0x2, 0x84a, 0x84b, 0x7, 0x35a, 0x2, 0x2, 0x84b, 0x84c, 0x7, 0x342, 
       0x2, 0x2, 0x84c, 0x84d, 0x7, 0x359, 0x2, 0x2, 0x84d, 0x84f, 0x7, 
       0x353, 0x2, 0x2, 0x84e, 0x850, 0x5, 0x1f4, 0xfb, 0x2, 0x84f, 0x84e, 
       0x3, 0x2, 0x2, 0x2, 0x84f, 0x850, 0x3, 0x2, 0x2, 0x2, 0x850, 0x851, 
       0x3, 0x2, 0x2, 0x2, 0x851, 0x853, 0x7, 0x353, 0x2, 0x2, 0x852, 0x854, 
       0x5, 0x1f4, 0xfb, 0x2, 0x853, 0x852, 0x3, 0x2, 0x2, 0x2, 0x853, 0x854, 
       0x3, 0x2, 0x2, 0x2, 0x854, 0x855, 0x3, 0x2, 0x2, 0x2, 0x855, 0x856, 
       0x7, 0x353, 0x2, 0x2, 0x856, 0x857, 0x5, 0x1f4, 0xfb, 0x2, 0x857, 
       0xb5, 0x3, 0x2, 0x2, 0x2, 0x858, 0x859, 0x7, 0x5d, 0x2, 0x2, 0x859, 
       0x85b, 0x7, 0x33d, 0x2, 0x2, 0x85a, 0x85c, 0x7, 0x11, 0x2, 0x2, 0x85b, 
       0x85a, 0x3, 0x2, 0x2, 0x2, 0x85b, 0x85c, 0x3, 0x2, 0x2, 0x2, 0x85c, 
       0x85d, 0x3, 0x2, 0x2, 0x2, 0x85d, 0x85f, 0x5, 0xe0, 0x71, 0x2, 0x85e, 
       0x860, 0x7, 0x35b, 0x2, 0x2, 0x85f, 0x85e, 0x3, 0x2, 0x2, 0x2, 0x85f, 
       0x860, 0x3, 0x2, 0x2, 0x2, 0x860, 0x884, 0x3, 0x2, 0x2, 0x2, 0x861, 
       0x862, 0x7, 0x5d, 0x2, 0x2, 0x862, 0x867, 0x5, 0xde, 0x70, 0x2, 0x863, 
       0x864, 0x7, 0x35a, 0x2, 0x2, 0x864, 0x866, 0x5, 0xde, 0x70, 0x2, 
       0x865, 0x863, 0x3, 0x2, 0x2, 0x2, 0x866, 0x869, 0x3, 0x2, 0x2, 0x2, 
       0x867, 0x865, 0x3, 0x2, 0x2, 0x2, 0x867, 0x868, 0x3, 0x2, 0x2, 0x2, 
       0x868, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x869, 0x867, 0x3, 0x2, 0x2, 0x2, 
       0x86a, 0x86c, 0x7, 0x35b, 0x2, 0x2, 0x86b, 0x86a, 0x3, 0x2, 0x2, 
       0x2, 0x86b, 0x86c, 0x3, 0x2, 0x2, 0x2, 0x86c, 0x884, 0x3, 0x2, 0x2, 
       0x2, 0x86d, 0x86e, 0x7, 0x5d, 0x2, 0x2, 0x86e, 0x870, 0x7, 0x33d, 
       0x2, 0x2, 0x86f, 0x871, 0x7, 0x11, 0x2, 0x2, 0x870, 0x86f, 0x3, 0x2, 
       0x2, 0x2, 0x870, 0x871, 0x3, 0x2, 0x2, 0x2, 0x871, 0x872, 0x3, 0x2, 
       0x2, 0x2, 0x872, 0x874, 0x5, 0xe2, 0x72, 0x2, 0x873, 0x875, 0x7, 
       0x35b, 0x2, 0x2, 0x874, 0x873, 0x3, 0x2, 0x2, 0x2, 0x874, 0x875, 
       0x3, 0x2, 0x2, 0x2, 0x875, 0x884, 0x3, 0x2, 0x2, 0x2, 0x876, 0x877, 
       0x7, 0x191, 0x2, 0x2, 0x877, 0x878, 0x7, 0x333, 0x2, 0x2, 0x878, 
       0x879, 0x7, 0x358, 0x2, 0x2, 0x879, 0x87b, 0x7, 0x342, 0x2, 0x2, 
       0x87a, 0x87c, 0x7, 0x35a, 0x2, 0x2, 0x87b, 0x87a, 0x3, 0x2, 0x2, 
       0x2, 0x87b, 0x87c, 0x3, 0x2, 0x2, 0x2, 0x87c, 0x87d, 0x3, 0x2, 0x2, 
       0x2, 0x87d, 0x87e, 0x7, 0x11, 0x2, 0x2, 0x87e, 0x87f, 0x5, 0x1f4, 
       0xfb, 0x2, 0x87f, 0x881, 0x7, 0x359, 0x2, 0x2, 0x880, 0x882, 0x7, 
       0x35b, 0x2, 0x2, 0x881, 0x880, 0x3, 0x2, 0x2, 0x2, 0x881, 0x882, 
       0x3, 0x2, 0x2, 0x2, 0x882, 0x884, 0x3, 0x2, 0x2, 0x2, 0x883, 0x858, 
       0x3, 0x2, 0x2, 0x2, 0x883, 0x861, 0x3, 0x2, 0x2, 0x2, 0x883, 0x86d, 
       0x3, 0x2, 0x2, 0x2, 0x883, 0x876, 0x3, 0x2, 0x2, 0x2, 0x884, 0xb7, 
       0x3, 0x2, 0x2, 0x2, 0x885, 0x887, 0x7, 0x38, 0x2, 0x2, 0x886, 0x888, 
       0x7, 0x228, 0x2, 0x2, 0x887, 0x886, 0x3, 0x2, 0x2, 0x2, 0x887, 0x888, 
       0x3, 0x2, 0x2, 0x2, 0x888, 0x889, 0x3, 0x2, 0x2, 0x2, 0x889, 0x88b, 
       0x5, 0x1ce, 0xe8, 0x2, 0x88a, 0x88c, 0x7, 0x35b, 0x2, 0x2, 0x88b, 
       0x88a, 0x3, 0x2, 0x2, 0x2, 0x88b, 0x88c, 0x3, 0x2, 0x2, 0x2, 0x88c, 
       0x8a3, 0x3, 0x2, 0x2, 0x2, 0x88d, 0x88f, 0x7, 0x5c, 0x2, 0x2, 0x88e, 
       0x890, 0x7, 0x228, 0x2, 0x2, 0x88f, 0x88e, 0x3, 0x2, 0x2, 0x2, 0x88f, 
       0x890, 0x3, 0x2, 0x2, 0x2, 0x890, 0x892, 0x3, 0x2, 0x2, 0x2, 0x891, 
       0x893, 0x7, 0x55, 0x2, 0x2, 0x892, 0x891, 0x3, 0x2, 0x2, 0x2, 0x892, 
       0x893, 0x3, 0x2, 0x2, 0x2, 0x893, 0x894, 0x3, 0x2, 0x2, 0x2, 0x894, 
       0x896, 0x5, 0x1ce, 0xe8, 0x2, 0x895, 0x897, 0x7, 0x35b, 0x2, 0x2, 
       0x896, 0x895, 0x3, 0x2, 0x2, 0x2, 0x896, 0x897, 0x3, 0x2, 0x2, 0x2, 
       0x897, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x898, 0x8a3, 0x5, 0xfa, 0x7e, 
       0x2, 0x899, 0x8a3, 0x5, 0x100, 0x81, 0x2, 0x89a, 0x89c, 0x7, 0xf4, 
       0x2, 0x2, 0x89b, 0x89d, 0x7, 0x228, 0x2, 0x2, 0x89c, 0x89b, 0x3, 
       0x2, 0x2, 0x2, 0x89c, 0x89d, 0x3, 0x2, 0x2, 0x2, 0x89d, 0x89e, 0x3, 
       0x2, 0x2, 0x2, 0x89e, 0x8a0, 0x5, 0x1ce, 0xe8, 0x2, 0x89f, 0x8a1, 
       0x7, 0x35b, 0x2, 0x2, 0x8a0, 0x89f, 0x3, 0x2, 0x2, 0x2, 0x8a0, 0x8a1, 
       0x3, 0x2, 0x2, 0x2, 0x8a1, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x8a2, 0x885, 
       0x3, 0x2, 0x2, 0x2, 0x8a2, 0x88d, 0x3, 0x2, 0x2, 0x2, 0x8a2, 0x898, 
       0x3, 0x2, 0x2, 0x2, 0x8a2, 0x899, 0x3, 0x2, 0x2, 0x2, 0x8a2, 0x89a, 
       0x3, 0x2, 0x2, 0x2, 0x8a3, 0xb9, 0x3, 0x2, 0x2, 0x2, 0x8a4, 0x8a8, 
       0x7, 0xb7, 0x2, 0x2, 0x8a5, 0x8a9, 0x5, 0xbc, 0x5f, 0x2, 0x8a6, 0x8a9, 
       0x5, 0xbe, 0x60, 0x2, 0x8a7, 0x8a9, 0x5, 0xc0, 0x61, 0x2, 0x8a8, 
       0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a8, 0x8a6, 0x3, 0x2, 0x2, 0x2, 0x8a8, 
       0x8a7, 0x3, 0x2, 0x2, 0x2, 0x8a9, 0xbb, 0x3, 0x2, 0x2, 0x2, 0x8aa, 
       0x8ad, 0x9, 0xc, 0x2, 0x2, 0x8ab, 0x8ad, 0x7, 0x323, 0x2, 0x2, 0x8ac, 
       0x8aa, 0x3, 0x2, 0x2, 0x2, 0x8ac, 0x8ab, 0x3, 0x2, 0x2, 0x2, 0x8ad, 
       0x8b0, 0x3, 0x2, 0x2, 0x2, 0x8ae, 0x8af, 0x7, 0x191, 0x2, 0x2, 0x8af, 
       0x8b1, 0x7, 0x2fc, 0x2, 0x2, 0x8b0, 0x8ae, 0x3, 0x2, 0x2, 0x2, 0x8b0, 
       0x8b1, 0x3, 0x2, 0x2, 0x2, 0x8b1, 0xbd, 0x3, 0x2, 0x2, 0x2, 0x8b2, 
       0x8b3, 0x7, 0x2ae, 0x2, 0x2, 0x8b3, 0x8b4, 0x7, 0xea, 0x2, 0x2, 0x8b4, 
       0x8b7, 0x7, 0x303, 0x2, 0x2, 0x8b5, 0x8b8, 0x7, 0x7, 0x2, 0x2, 0x8b6, 
       0x8b8, 0x7, 0x33e, 0x2, 0x2, 0x8b7, 0x8b5, 0x3, 0x2, 0x2, 0x2, 0x8b7, 
       0x8b6, 0x3, 0x2, 0x2, 0x2, 0x8b8, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x8b9, 
       0x8ba, 0x7, 0x15f, 0x2, 0x2, 0x8ba, 0x8bb, 0x7, 0x241, 0x2, 0x2, 
       0x8bb, 0x8bc, 0x7, 0x33e, 0x2, 0x2, 0x8bc, 0xc1, 0x3, 0x2, 0x2, 0x2, 
       0x8bd, 0x8be, 0x7, 0x7b, 0x2, 0x2, 0x8be, 0x8bf, 0x5, 0xc4, 0x63, 
       0x2, 0x8bf, 0xc3, 0x3, 0x2, 0x2, 0x2, 0x8c0, 0x8c1, 0x7, 0x33d, 0x2, 
       0x2, 0x8c1, 0x8c3, 0x7, 0x346, 0x2, 0x2, 0x8c2, 0x8c0, 0x3, 0x2, 
       0x2, 0x2, 0x8c2, 0x8c3, 0x3, 0x2, 0x2, 0x2, 0x8c3, 0x8c6, 0x3, 0x2, 
       0x2, 0x2, 0x8c4, 0x8c7, 0x5, 0x1c4, 0xe3, 0x2, 0x8c5, 0x8c7, 0x5, 
       0x106, 0x84, 0x2, 0x8c6, 0x8c4, 0x3, 0x2, 0x2, 0x2, 0x8c6, 0x8c5, 
       0x3, 0x2, 0x2, 0x2, 0x8c7, 0x8d0, 0x3, 0x2, 0x2, 0x2, 0x8c8, 0x8cd, 
       0x5, 0xc6, 0x64, 0x2, 0x8c9, 0x8ca, 0x7, 0x35a, 0x2, 0x2, 0x8ca, 
       0x8cc, 0x5, 0xc6, 0x64, 0x2, 0x8cb, 0x8c9, 0x3, 0x2, 0x2, 0x2, 0x8cc, 
       0x8cf, 0x3, 0x2, 0x2, 0x2, 0x8cd, 0x8cb, 0x3, 0x2, 0x2, 0x2, 0x8cd, 
       0x8ce, 0x3, 0x2, 0x2, 0x2, 0x8ce, 0x8d1, 0x3, 0x2, 0x2, 0x2, 0x8cf, 
       0x8cd, 0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8c8, 0x3, 0x2, 0x2, 0x2, 0x8d0, 
       0x8d1, 0x3, 0x2, 0x2, 0x2, 0x8d1, 0x8d3, 0x3, 0x2, 0x2, 0x2, 0x8d2, 
       0x8d4, 0x7, 0x35b, 0x2, 0x2, 0x8d3, 0x8d2, 0x3, 0x2, 0x2, 0x2, 0x8d3, 
       0x8d4, 0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8d5, 
       0x8d6, 0x7, 0x358, 0x2, 0x2, 0x8d6, 0x8db, 0x5, 0xc8, 0x65, 0x2, 
       0x8d7, 0x8d8, 0x7, 0x360, 0x2, 0x2, 0x8d8, 0x8da, 0x5, 0xc8, 0x65, 
       0x2, 0x8d9, 0x8d7, 0x3, 0x2, 0x2, 0x2, 0x8da, 0x8dd, 0x3, 0x2, 0x2, 
       0x2, 0x8db, 0x8d9, 0x3, 0x2, 0x2, 0x2, 0x8db, 0x8dc, 0x3, 0x2, 0x2, 
       0x2, 0x8dc, 0x8de, 0x3, 0x2, 0x2, 0x2, 0x8dd, 0x8db, 0x3, 0x2, 0x2, 
       0x2, 0x8de, 0x8e5, 0x7, 0x359, 0x2, 0x2, 0x8df, 0x8e1, 0x7, 0x11, 
       0x2, 0x2, 0x8e0, 0x8df, 0x3, 0x2, 0x2, 0x2, 0x8e0, 0x8e1, 0x3, 0x2, 
       0x2, 0x2, 0x8e1, 0x8e2, 0x3, 0x2, 0x2, 0x2, 0x8e2, 0x8e3, 0x9, 0x18, 
       0x2, 0x2, 0x8e3, 0x8e4, 0x7, 0x346, 0x2, 0x2, 0x8e4, 0x8e6, 0x7, 
       0x342, 0x2, 0x2, 0x8e5, 0x8e0, 0x3, 0x2, 0x2, 0x2, 0x8e5, 0x8e6, 
       0x3, 0x2, 0x2, 0x2, 0x8e6, 0x8e8, 0x3, 0x2, 0x2, 0x2, 0x8e7, 0x8e9, 
       0x7, 0x35b, 0x2, 0x2, 0x8e8, 0x8e7, 0x3, 0x2, 0x2, 0x2, 0x8e8, 0x8e9, 
       0x3, 0x2, 0x2, 0x2, 0x8e9, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8ea, 0x8c2, 
       0x3, 0x2, 0x2, 0x2, 0x8ea, 0x8d5, 0x3, 0x2, 0x2, 0x2, 0x8eb, 0xc5, 
       0x3, 0x2, 0x2, 0x2, 0x8ec, 0x8ed, 0x7, 0x33d, 0x2, 0x2, 0x8ed, 0x8ef, 
       0x7, 0x346, 0x2, 0x2, 0x8ee, 0x8ec, 0x3, 0x2, 0x2, 0x2, 0x8ee, 0x8ef, 
       0x3, 0x2, 0x2, 0x2, 0x8ef, 0x8f9, 0x3, 0x2, 0x2, 0x2, 0x8f0, 0x8f3, 
       0x5, 0x104, 0x83, 0x2, 0x8f1, 0x8f3, 0x5, 0x1f4, 0xfb, 0x2, 0x8f2, 
       0x8f0, 0x3, 0x2, 0x2, 0x2, 0x8f2, 0x8f1, 0x3, 0x2, 0x2, 0x2, 0x8f3, 
       0x8f5, 0x3, 0x2, 0x2, 0x2, 0x8f4, 0x8f6, 0x9, 0x19, 0x2, 0x2, 0x8f5, 
       0x8f4, 0x3, 0x2, 0x2, 0x2, 0x8f5, 0x8f6, 0x3, 0x2, 0x2, 0x2, 0x8f6, 
       0x8fa, 0x3, 0x2, 0x2, 0x2, 0x8f7, 0x8fa, 0x7, 0x5e, 0x2, 0x2, 0x8f8, 
       0x8fa, 0x7, 0xec, 0x2, 0x2, 0x8f9, 0x8f2, 0x3, 0x2, 0x2, 0x2, 0x8f9, 
       0x8f7, 0x3, 0x2, 0x2, 0x2, 0x8f9, 0x8f8, 0x3, 0x2, 0x2, 0x2, 0x8fa, 
       0xc7, 0x3, 0x2, 0x2, 0x2, 0x8fb, 0x8fc, 0x9, 0x3, 0x2, 0x2, 0x8fc, 
       0xc9, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8fe, 0x7, 0x14e, 0x2, 0x2, 0x8fe, 
       0x901, 0x7, 0x33d, 0x2, 0x2, 0x8ff, 0x900, 0x7, 0x353, 0x2, 0x2, 
       0x900, 0x902, 0x5, 0x1f4, 0xfb, 0x2, 0x901, 0x8ff, 0x3, 0x2, 0x2, 
       0x2, 0x901, 0x902, 0x3, 0x2, 0x2, 0x2, 0x902, 0x903, 0x3, 0x2, 0x2, 
       0x2, 0x903, 0x904, 0x7, 0x346, 0x2, 0x2, 0x904, 0x906, 0x5, 0x106, 
       0x84, 0x2, 0x905, 0x907, 0x7, 0x35b, 0x2, 0x2, 0x906, 0x905, 0x3, 
       0x2, 0x2, 0x2, 0x906, 0x907, 0x3, 0x2, 0x2, 0x2, 0x907, 0x925, 0x3, 
       0x2, 0x2, 0x2, 0x908, 0x909, 0x7, 0x14e, 0x2, 0x2, 0x909, 0x90a, 
       0x7, 0x33d, 0x2, 0x2, 0x90a, 0x90b, 0x5, 0x1fa, 0xfe, 0x2, 0x90b, 
       0x90d, 0x5, 0x106, 0x84, 0x2, 0x90c, 0x90e, 0x7, 0x35b, 0x2, 0x2, 
       0x90d, 0x90c, 0x3, 0x2, 0x2, 0x2, 0x90d, 0x90e, 0x3, 0x2, 0x2, 0x2, 
       0x90e, 0x925, 0x3, 0x2, 0x2, 0x2, 0x90f, 0x910, 0x7, 0x14e, 0x2, 
       0x2, 0x910, 0x911, 0x7, 0x33d, 0x2, 0x2, 0x911, 0x912, 0x7, 0x346, 
       0x2, 0x2, 0x912, 0x913, 0x7, 0x55, 0x2, 0x2, 0x913, 0x91e, 0x5, 0xfc, 
       0x7f, 0x2, 0x914, 0x91c, 0x7, 0x8b, 0x2, 0x2, 0x915, 0x916, 0x7, 
       0x119, 0x2, 0x2, 0x916, 0x91d, 0x7, 0x291, 0x2, 0x2, 0x917, 0x91a, 
       0x7, 0x17f, 0x2, 0x2, 0x918, 0x919, 0x7, 0xee, 0x2, 0x2, 0x919, 0x91b, 
       0x5, 0x1cc, 0xe7, 0x2, 0x91a, 0x918, 0x3, 0x2, 0x2, 0x2, 0x91a, 0x91b, 
       0x3, 0x2, 0x2, 0x2, 0x91b, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x915, 
       0x3, 0x2, 0x2, 0x2, 0x91c, 0x917, 0x3, 0x2, 0x2, 0x2, 0x91d, 0x91f, 
       0x3, 0x2, 0x2, 0x2, 0x91e, 0x914, 0x3, 0x2, 0x2, 0x2, 0x91e, 0x91f, 
       0x3, 0x2, 0x2, 0x2, 0x91f, 0x921, 0x3, 0x2, 0x2, 0x2, 0x920, 0x922, 
       0x7, 0x35b, 0x2, 0x2, 0x921, 0x920, 0x3, 0x2, 0x2, 0x2, 0x921, 0x922, 
       0x3, 0x2, 0x2, 0x2, 0x922, 0x925, 0x3, 0x2, 0x2, 0x2, 0x923, 0x925, 
       0x5, 0x102, 0x82, 0x2, 0x924, 0x8fd, 0x3, 0x2, 0x2, 0x2, 0x924, 0x908, 
       0x3, 0x2, 0x2, 0x2, 0x924, 0x90f, 0x3, 0x2, 0x2, 0x2, 0x924, 0x923, 
       0x3, 0x2, 0x2, 0x2, 0x925, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x926, 0x927, 
       0x7, 0x1e, 0x2, 0x2, 0x927, 0x928, 0x7, 0x68, 0x2, 0x2, 0x928, 0x92b, 
       0x9, 0x1a, 0x2, 0x2, 0x929, 0x92c, 0x5, 0x1f4, 0xfb, 0x2, 0x92a, 
       0x92c, 0x7, 0x33d, 0x2, 0x2, 0x92b, 0x929, 0x3, 0x2, 0x2, 0x2, 0x92b, 
       0x92a, 0x3, 0x2, 0x2, 0x2, 0x92b, 0x92c, 0x3, 0x2, 0x2, 0x2, 0x92c, 
       0x92e, 0x3, 0x2, 0x2, 0x2, 0x92d, 0x92f, 0x7, 0x35b, 0x2, 0x2, 0x92e, 
       0x92d, 0x3, 0x2, 0x2, 0x2, 0x92e, 0x92f, 0x3, 0x2, 0x2, 0x2, 0x92f, 
       0x978, 0x3, 0x2, 0x2, 0x2, 0x930, 0x931, 0x7, 0x1e, 0x2, 0x2, 0x931, 
       0x93b, 0x9, 0x1a, 0x2, 0x2, 0x932, 0x935, 0x5, 0x1f4, 0xfb, 0x2, 
       0x933, 0x935, 0x7, 0x33d, 0x2, 0x2, 0x934, 0x932, 0x3, 0x2, 0x2, 
       0x2, 0x934, 0x933, 0x3, 0x2, 0x2, 0x2, 0x935, 0x939, 0x3, 0x2, 0x2, 
       0x2, 0x936, 0x937, 0x7, 0x191, 0x2, 0x2, 0x937, 0x938, 0x7, 0x25a, 
       0x2, 0x2, 0x938, 0x93a, 0x7, 0x342, 0x2, 0x2, 0x939, 0x936, 0x3, 
       0x2, 0x2, 0x2, 0x939, 0x93a, 0x3, 0x2, 0x2, 0x2, 0x93a, 0x93c, 0x3, 
       0x2, 0x2, 0x2, 0x93b, 0x934, 0x3, 0x2, 0x2, 0x2, 0x93b, 0x93c, 0x3, 
       0x2, 0x2, 0x2, 0x93c, 0x93e, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x93f, 0x7, 
       0x35b, 0x2, 0x2, 0x93e, 0x93d, 0x3, 0x2, 0x2, 0x2, 0x93e, 0x93f, 
       0x3, 0x2, 0x2, 0x2, 0x93f, 0x978, 0x3, 0x2, 0x2, 0x2, 0x940, 0x941, 
       0x7, 0x3f, 0x2, 0x2, 0x941, 0x94e, 0x9, 0x1a, 0x2, 0x2, 0x942, 0x945, 
       0x5, 0x1f4, 0xfb, 0x2, 0x943, 0x945, 0x7, 0x33d, 0x2, 0x2, 0x944, 
       0x942, 0x3, 0x2, 0x2, 0x2, 0x944, 0x943, 0x3, 0x2, 0x2, 0x2, 0x945, 
       0x94c, 0x3, 0x2, 0x2, 0x2, 0x946, 0x947, 0x7, 0x191, 0x2, 0x2, 0x947, 
       0x948, 0x7, 0x358, 0x2, 0x2, 0x948, 0x949, 0x7, 0x1f1, 0x2, 0x2, 
       0x949, 0x94a, 0x7, 0x346, 0x2, 0x2, 0x94a, 0x94b, 0x9, 0xf, 0x2, 
       0x2, 0x94b, 0x94d, 0x7, 0x359, 0x2, 0x2, 0x94c, 0x946, 0x3, 0x2, 
       0x2, 0x2, 0x94c, 0x94d, 0x3, 0x2, 0x2, 0x2, 0x94d, 0x94f, 0x3, 0x2, 
       0x2, 0x2, 0x94e, 0x944, 0x3, 0x2, 0x2, 0x2, 0x94e, 0x94f, 0x3, 0x2, 
       0x2, 0x2, 0x94f, 0x951, 0x3, 0x2, 0x2, 0x2, 0x950, 0x952, 0x7, 0x35b, 
       0x2, 0x2, 0x951, 0x950, 0x3, 0x2, 0x2, 0x2, 0x951, 0x952, 0x3, 0x2, 
       0x2, 0x2, 0x952, 0x978, 0x3, 0x2, 0x2, 0x2, 0x953, 0x955, 0x7, 0x3f, 
       0x2, 0x2, 0x954, 0x956, 0x7, 0x32f, 0x2, 0x2, 0x955, 0x954, 0x3, 
       0x2, 0x2, 0x2, 0x955, 0x956, 0x3, 0x2, 0x2, 0x2, 0x956, 0x958, 0x3, 
       0x2, 0x2, 0x2, 0x957, 0x959, 0x7, 0x35b, 0x2, 0x2, 0x958, 0x957, 
       0x3, 0x2, 0x2, 0x2, 0x958, 0x959, 0x3, 0x2, 0x2, 0x2, 0x959, 0x978, 
       0x3, 0x2, 0x2, 0x2, 0x95a, 0x95b, 0x7, 0x3f, 0x2, 0x2, 0x95b, 0x978, 
       0x5, 0x1f4, 0xfb, 0x2, 0x95c, 0x95d, 0x7, 0x130, 0x2, 0x2, 0x95d, 
       0x978, 0x5, 0x1f4, 0xfb, 0x2, 0x95e, 0x95f, 0x7, 0x130, 0x2, 0x2, 
       0x95f, 0x962, 0x9, 0x1a, 0x2, 0x2, 0x960, 0x963, 0x5, 0x1f4, 0xfb, 
       0x2, 0x961, 0x963, 0x7, 0x33d, 0x2, 0x2, 0x962, 0x960, 0x3, 0x2, 
       0x2, 0x2, 0x962, 0x961, 0x3, 0x2, 0x2, 0x2, 0x962, 0x963, 0x3, 0x2, 
       0x2, 0x2, 0x963, 0x965, 0x3, 0x2, 0x2, 0x2, 0x964, 0x966, 0x7, 0x35b, 
       0x2, 0x2, 0x965, 0x964, 0x3, 0x2, 0x2, 0x2, 0x965, 0x966, 0x3, 0x2, 
       0x2, 0x2, 0x966, 0x978, 0x3, 0x2, 0x2, 0x2, 0x967, 0x969, 0x7, 0x130, 
       0x2, 0x2, 0x968, 0x96a, 0x7, 0x32f, 0x2, 0x2, 0x969, 0x968, 0x3, 
       0x2, 0x2, 0x2, 0x969, 0x96a, 0x3, 0x2, 0x2, 0x2, 0x96a, 0x96c, 0x3, 
       0x2, 0x2, 0x2, 0x96b, 0x96d, 0x7, 0x35b, 0x2, 0x2, 0x96c, 0x96b, 
       0x3, 0x2, 0x2, 0x2, 0x96c, 0x96d, 0x3, 0x2, 0x2, 0x2, 0x96d, 0x978, 
       0x3, 0x2, 0x2, 0x2, 0x96e, 0x96f, 0x7, 0x13e, 0x2, 0x2, 0x96f, 0x972, 
       0x9, 0x1a, 0x2, 0x2, 0x970, 0x973, 0x5, 0x1f4, 0xfb, 0x2, 0x971, 
       0x973, 0x7, 0x33d, 0x2, 0x2, 0x972, 0x970, 0x3, 0x2, 0x2, 0x2, 0x972, 
       0x971, 0x3, 0x2, 0x2, 0x2, 0x972, 0x973, 0x3, 0x2, 0x2, 0x2, 0x973, 
       0x975, 0x3, 0x2, 0x2, 0x2, 0x974, 0x976, 0x7, 0x35b, 0x2, 0x2, 0x975, 
       0x974, 0x3, 0x2, 0x2, 0x2, 0x975, 0x976, 0x3, 0x2, 0x2, 0x2, 0x976, 
       0x978, 0x3, 0x2, 0x2, 0x2, 0x977, 0x926, 0x3, 0x2, 0x2, 0x2, 0x977, 
       0x930, 0x3, 0x2, 0x2, 0x2, 0x977, 0x940, 0x3, 0x2, 0x2, 0x2, 0x977, 
       0x953, 0x3, 0x2, 0x2, 0x2, 0x977, 0x95a, 0x3, 0x2, 0x2, 0x2, 0x977, 
       0x95c, 0x3, 0x2, 0x2, 0x2, 0x977, 0x95e, 0x3, 0x2, 0x2, 0x2, 0x977, 
       0x967, 0x3, 0x2, 0x2, 0x2, 0x977, 0x96e, 0x3, 0x2, 0x2, 0x2, 0x978, 
       0xcd, 0x3, 0x2, 0x2, 0x2, 0x979, 0x97b, 0x7, 0x229, 0x2, 0x2, 0x97a, 
       0x97c, 0x7, 0x33e, 0x2, 0x2, 0x97b, 0x97a, 0x3, 0x2, 0x2, 0x2, 0x97b, 
       0x97c, 0x3, 0x2, 0x2, 0x2, 0x97c, 0xcf, 0x3, 0x2, 0x2, 0x2, 0x97d, 
       0x97e, 0x7, 0x183, 0x2, 0x2, 0x97e, 0x980, 0x5, 0x1f4, 0xfb, 0x2, 
       0x97f, 0x981, 0x7, 0x35b, 0x2, 0x2, 0x980, 0x97f, 0x3, 0x2, 0x2, 
       0x2, 0x980, 0x981, 0x3, 0x2, 0x2, 0x2, 0x981, 0xd1, 0x3, 0x2, 0x2, 
       0x2, 0x982, 0x984, 0x7, 0x14f, 0x2, 0x2, 0x983, 0x985, 0x7, 0x342, 
       0x2, 0x2, 0x984, 0x983, 0x3, 0x2, 0x2, 0x2, 0x984, 0x985, 0x3, 0x2, 
       0x2, 0x2, 0x985, 0xd3, 0x3, 0x2, 0x2, 0x2, 0x986, 0x989, 0x7, 0x11c, 
       0x2, 0x2, 0x987, 0x988, 0x7, 0x191, 0x2, 0x2, 0x988, 0x98a, 0x7, 
       0x297, 0x2, 0x2, 0x989, 0x987, 0x3, 0x2, 0x2, 0x2, 0x989, 0x98a, 
       0x3, 0x2, 0x2, 0x2, 0x98a, 0xd5, 0x3, 0x2, 0x2, 0x2, 0x98b, 0x98e, 
       0x7, 0x151, 0x2, 0x2, 0x98c, 0x98d, 0x7, 0x191, 0x2, 0x2, 0x98d, 
       0x98f, 0x7, 0x287, 0x2, 0x2, 0x98e, 0x98c, 0x3, 0x2, 0x2, 0x2, 0x98e, 
       0x98f, 0x3, 0x2, 0x2, 0x2, 0x98f, 0xd7, 0x3, 0x2, 0x2, 0x2, 0x990, 
       0x991, 0x7, 0x5b, 0x2, 0x2, 0x991, 0x996, 0x5, 0x1f6, 0xfc, 0x2, 
       0x992, 0x993, 0x7, 0x358, 0x2, 0x2, 0x993, 0x994, 0x5, 0x194, 0xcb, 
       0x2, 0x994, 0x995, 0x7, 0x359, 0x2, 0x2, 0x995, 0x997, 0x3, 0x2, 
       0x2, 0x2, 0x996, 0x992, 0x3, 0x2, 0x2, 0x2, 0x996, 0x997, 0x3, 0x2, 
       0x2, 0x2, 0x997, 0x99a, 0x3, 0x2, 0x2, 0x2, 0x998, 0x999, 0x7, 0x191, 
       0x2, 0x2, 0x999, 0x99b, 0x5, 0xda, 0x6e, 0x2, 0x99a, 0x998, 0x3, 
       0x2, 0x2, 0x2, 0x99a, 0x99b, 0x3, 0x2, 0x2, 0x2, 0x99b, 0x99d, 0x3, 
       0x2, 0x2, 0x2, 0x99c, 0x99e, 0x7, 0x35b, 0x2, 0x2, 0x99d, 0x99c, 
       0x3, 0x2, 0x2, 0x2, 0x99d, 0x99e, 0x3, 0x2, 0x2, 0x2, 0x99e, 0xd9, 
       0x3, 0x2, 0x2, 0x2, 0x99f, 0x9a2, 0x5, 0x1f6, 0xfc, 0x2, 0x9a0, 0x9a1, 
       0x7, 0x35a, 0x2, 0x2, 0x9a1, 0x9a3, 0x5, 0x1f6, 0xfc, 0x2, 0x9a2, 
       0x9a0, 0x3, 0x2, 0x2, 0x2, 0x9a2, 0x9a3, 0x3, 0x2, 0x2, 0x2, 0x9a3, 
       0xdb, 0x3, 0x2, 0x2, 0x2, 0x9a4, 0x9a5, 0x7, 0x7b, 0x2, 0x2, 0x9a5, 
       0x9a6, 0x7, 0x11, 0x2, 0x2, 0x9a6, 0x9a7, 0x9, 0x1b, 0x2, 0x2, 0x9a7, 
       0xdd, 0x3, 0x2, 0x2, 0x2, 0x9a8, 0x9aa, 0x7, 0x33d, 0x2, 0x2, 0x9a9, 
       0x9ab, 0x7, 0x11, 0x2, 0x2, 0x9aa, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0x9aa, 
       0x9ab, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9ac, 0x3, 0x2, 0x2, 0x2, 0x9ac, 
       0x9af, 0x5, 0x1ec, 0xf7, 0x2, 0x9ad, 0x9ae, 0x7, 0x346, 0x2, 0x2, 
       0x9ae, 0x9b0, 0x5, 0x106, 0x84, 0x2, 0x9af, 0x9ad, 0x3, 0x2, 0x2, 
       0x2, 0x9af, 0x9b0, 0x3, 0x2, 0x2, 0x2, 0x9b0, 0xdf, 0x3, 0x2, 0x2, 
       0x2, 0x9b1, 0x9b2, 0x7, 0x169, 0x2, 0x2, 0x9b2, 0x9b3, 0x7, 0x358, 
       0x2, 0x2, 0x9b3, 0x9b4, 0x5, 0xe6, 0x74, 0x2, 0x9b4, 0x9b5, 0x7, 
       0x359, 0x2, 0x2, 0x9b5, 0xe1, 0x3, 0x2, 0x2, 0x2, 0x9b6, 0x9b7, 0x7, 
       0x331, 0x2, 0x2, 0x9b7, 0x9b9, 0x7, 0x358, 0x2, 0x2, 0x9b8, 0x9ba, 
       0x9, 0x1c, 0x2, 0x2, 0x9b9, 0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9b9, 0x9ba, 
       0x3, 0x2, 0x2, 0x2, 0x9ba, 0x9bb, 0x3, 0x2, 0x2, 0x2, 0x9bb, 0x9bc, 
       0x5, 0xe4, 0x73, 0x2, 0x9bc, 0x9bd, 0x7, 0x359, 0x2, 0x2, 0x9bd, 
       0xe3, 0x3, 0x2, 0x2, 0x2, 0x9be, 0x9bf, 0x7, 0x33f, 0x2, 0x2, 0x9bf, 
       0x9c0, 0x7, 0x353, 0x2, 0x2, 0x9c0, 0x9c1, 0x7, 0x33f, 0x2, 0x2, 
       0x9c1, 0xe5, 0x3, 0x2, 0x2, 0x2, 0x9c2, 0x9c9, 0x5, 0xe8, 0x75, 0x2, 
       0x9c3, 0x9c5, 0x7, 0x35a, 0x2, 0x2, 0x9c4, 0x9c3, 0x3, 0x2, 0x2, 
       0x2, 0x9c4, 0x9c5, 0x3, 0x2, 0x2, 0x2, 0x9c5, 0x9c6, 0x3, 0x2, 0x2, 
       0x2, 0x9c6, 0x9c8, 0x5, 0xe8, 0x75, 0x2, 0x9c7, 0x9c4, 0x3, 0x2, 
       0x2, 0x2, 0x9c8, 0x9cb, 0x3, 0x2, 0x2, 0x2, 0x9c9, 0x9c7, 0x3, 0x2, 
       0x2, 0x2, 0x9c9, 0x9ca, 0x3, 0x2, 0x2, 0x2, 0x9ca, 0xe7, 0x3, 0x2, 
       0x2, 0x2, 0x9cb, 0x9c9, 0x3, 0x2, 0x2, 0x2, 0x9cc, 0x9d0, 0x5, 0xea, 
       0x76, 0x2, 0x9cd, 0x9d0, 0x5, 0xec, 0x77, 0x2, 0x9ce, 0x9d0, 0x5, 
       0xf0, 0x79, 0x2, 0x9cf, 0x9cc, 0x3, 0x2, 0x2, 0x2, 0x9cf, 0x9cd, 
       0x3, 0x2, 0x2, 0x2, 0x9cf, 0x9ce, 0x3, 0x2, 0x2, 0x2, 0x9d0, 0xe9, 
       0x3, 0x2, 0x2, 0x2, 0x9d1, 0x9d5, 0x5, 0x1f4, 0xfb, 0x2, 0x9d2, 0x9d6, 
       0x5, 0x1ec, 0xf7, 0x2, 0x9d3, 0x9d4, 0x7, 0x11, 0x2, 0x2, 0x9d4, 
       0x9d6, 0x5, 0x106, 0x84, 0x2, 0x9d5, 0x9d2, 0x3, 0x2, 0x2, 0x2, 0x9d5, 
       0x9d3, 0x3, 0x2, 0x2, 0x2, 0x9d6, 0x9d9, 0x3, 0x2, 0x2, 0x2, 0x9d7, 
       0x9d8, 0x7, 0x3c, 0x2, 0x2, 0x9d8, 0x9da, 0x5, 0x1f4, 0xfb, 0x2, 
       0x9d9, 0x9d7, 0x3, 0x2, 0x2, 0x2, 0x9d9, 0x9da, 0x3, 0x2, 0x2, 0x2, 
       0x9da, 0x9dc, 0x3, 0x2, 0x2, 0x2, 0x9db, 0x9dd, 0x5, 0x1d4, 0xeb, 
       0x2, 0x9dc, 0x9db, 0x3, 0x2, 0x2, 0x2, 0x9dc, 0x9dd, 0x3, 0x2, 0x2, 
       0x2, 0x9dd, 0x9f3, 0x3, 0x2, 0x2, 0x2, 0x9de, 0x9df, 0x7, 0x42, 0x2, 
       0x2, 0x9df, 0x9e1, 0x5, 0x1f4, 0xfb, 0x2, 0x9e0, 0x9de, 0x3, 0x2, 
       0x2, 0x2, 0x9e0, 0x9e1, 0x3, 0x2, 0x2, 0x2, 0x9e1, 0x9e2, 0x3, 0x2, 
       0x2, 0x2, 0x9e2, 0x9e4, 0x5, 0x1d6, 0xec, 0x2, 0x9e3, 0x9e5, 0x5, 
       0x1d6, 0xec, 0x2, 0x9e4, 0x9e3, 0x3, 0x2, 0x2, 0x2, 0x9e4, 0x9e5, 
       0x3, 0x2, 0x2, 0x2, 0x9e5, 0x9f4, 0x3, 0x2, 0x2, 0x2, 0x9e6, 0x9ec, 
       0x7, 0x9c, 0x2, 0x2, 0x9e7, 0x9e8, 0x7, 0x358, 0x2, 0x2, 0x9e8, 0x9e9, 
       0x7, 0x33e, 0x2, 0x2, 0x9e9, 0x9ea, 0x7, 0x35a, 0x2, 0x2, 0x9ea, 
       0x9eb, 0x7, 0x33e, 0x2, 0x2, 0x9eb, 0x9ed, 0x7, 0x359, 0x2, 0x2, 
       0x9ec, 0x9e7, 0x3, 0x2, 0x2, 0x2, 0x9ec, 0x9ed, 0x3, 0x2, 0x2, 0x2, 
       0x9ed, 0x9f1, 0x3, 0x2, 0x2, 0x2, 0x9ee, 0x9ef, 0x7, 0xe9, 0x2, 0x2, 
       0x9ef, 0x9f0, 0x7, 0x8b, 0x2, 0x2, 0x9f0, 0x9f2, 0x7, 0x122, 0x2, 
       0x2, 0x9f1, 0x9ee, 0x3, 0x2, 0x2, 0x2, 0x9f1, 0x9f2, 0x3, 0x2, 0x2, 
       0x2, 0x9f2, 0x9f4, 0x3, 0x2, 0x2, 0x2, 0x9f3, 0x9e0, 0x3, 0x2, 0x2, 
       0x2, 0x9f3, 0x9e6, 0x3, 0x2, 0x2, 0x2, 0x9f3, 0x9f4, 0x3, 0x2, 0x2, 
       0x2, 0x9f4, 0x9f6, 0x3, 0x2, 0x2, 0x2, 0x9f5, 0x9f7, 0x7, 0x134, 
       0x2, 0x2, 0x9f6, 0x9f5, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9f7, 0x3, 0x2, 
       0x2, 0x2, 0x9f7, 0x9fb, 0x3, 0x2, 0x2, 0x2, 0x9f8, 0x9fa, 0x5, 0xee, 
       0x78, 0x2, 0x9f9, 0x9f8, 0x3, 0x2, 0x2, 0x2, 0x9fa, 0x9fd, 0x3, 0x2, 
       0x2, 0x2, 0x9fb, 0x9f9, 0x3, 0x2, 0x2, 0x2, 0x9fb, 0x9fc, 0x3, 0x2, 
       0x2, 0x2, 0x9fc, 0xeb, 0x3, 0x2, 0x2, 0x2, 0x9fd, 0x9fb, 0x3, 0x2, 
       0x2, 0x2, 0x9fe, 0x9ff, 0x5, 0x1f4, 0xfb, 0x2, 0x9ff, 0xa00, 0x9, 
       0x1d, 0x2, 0x2, 0xa00, 0xa04, 0x5, 0x106, 0x84, 0x2, 0xa01, 0xa05, 
       0x7, 0x25b, 0x2, 0x2, 0xa02, 0xa03, 0x7, 0xe9, 0x2, 0x2, 0xa03, 0xa05, 
       0x7, 0x25b, 0x2, 0x2, 0xa04, 0xa01, 0x3, 0x2, 0x2, 0x2, 0xa04, 0xa02, 
       0x3, 0x2, 0x2, 0x2, 0xa04, 0xa05, 0x3, 0x2, 0x2, 0x2, 0xa05, 0xed, 
       0x3, 0x2, 0x2, 0x2, 0xa06, 0xa07, 0x7, 0x42, 0x2, 0x2, 0xa07, 0xa09, 
       0x5, 0x1f4, 0xfb, 0x2, 0xa08, 0xa06, 0x3, 0x2, 0x2, 0x2, 0xa08, 0xa09, 
       0x3, 0x2, 0x2, 0x2, 0xa09, 0xa2f, 0x3, 0x2, 0x2, 0x2, 0xa0a, 0xa0b, 
       0x7, 0x10e, 0x2, 0x2, 0xa0b, 0xa0e, 0x7, 0xb4, 0x2, 0x2, 0xa0c, 0xa0e, 
       0x7, 0x17b, 0x2, 0x2, 0xa0d, 0xa0a, 0x3, 0x2, 0x2, 0x2, 0xa0d, 0xa0c, 
       0x3, 0x2, 0x2, 0x2, 0xa0e, 0xa10, 0x3, 0x2, 0x2, 0x2, 0xa0f, 0xa11, 
       0x5, 0x1d2, 0xea, 0x2, 0xa10, 0xa0f, 0x3, 0x2, 0x2, 0x2, 0xa10, 0xa11, 
       0x3, 0x2, 0x2, 0x2, 0xa11, 0xa13, 0x3, 0x2, 0x2, 0x2, 0xa12, 0xa14, 
       0x5, 0xf6, 0x7c, 0x2, 0xa13, 0xa12, 0x3, 0x2, 0x2, 0x2, 0xa13, 0xa14, 
       0x3, 0x2, 0x2, 0x2, 0xa14, 0xa30, 0x3, 0x2, 0x2, 0x2, 0xa15, 0xa19, 
       0x7, 0x33, 0x2, 0x2, 0xa16, 0xa17, 0x7, 0xe9, 0x2, 0x2, 0xa17, 0xa18, 
       0x7, 0x8b, 0x2, 0x2, 0xa18, 0xa1a, 0x7, 0x122, 0x2, 0x2, 0xa19, 0xa16, 
       0x3, 0x2, 0x2, 0x2, 0xa19, 0xa1a, 0x3, 0x2, 0x2, 0x2, 0xa1a, 0xa1b, 
       0x3, 0x2, 0x2, 0x2, 0xa1b, 0xa1c, 0x7, 0x358, 0x2, 0x2, 0xa1c, 0xa1d, 
       0x5, 0x11c, 0x8f, 0x2, 0xa1d, 0xa1e, 0x7, 0x359, 0x2, 0x2, 0xa1e, 
       0xa30, 0x3, 0x2, 0x2, 0x2, 0xa1f, 0xa20, 0x7, 0x8e, 0x2, 0x2, 0xa20, 
       0xa22, 0x7, 0xb4, 0x2, 0x2, 0xa21, 0xa1f, 0x3, 0x2, 0x2, 0x2, 0xa21, 
       0xa22, 0x3, 0x2, 0x2, 0x2, 0xa22, 0xa23, 0x3, 0x2, 0x2, 0x2, 0xa23, 
       0xa24, 0x7, 0x11d, 0x2, 0x2, 0xa24, 0xa25, 0x5, 0x1bc, 0xdf, 0x2, 
       0xa25, 0xa26, 0x7, 0x358, 0x2, 0x2, 0xa26, 0xa27, 0x5, 0x1cc, 0xe7, 
       0x2, 0xa27, 0xa29, 0x7, 0x359, 0x2, 0x2, 0xa28, 0xa2a, 0x5, 0xf2, 
       0x7a, 0x2, 0xa29, 0xa28, 0x3, 0x2, 0x2, 0x2, 0xa29, 0xa2a, 0x3, 0x2, 
       0x2, 0x2, 0xa2a, 0xa2c, 0x3, 0x2, 0x2, 0x2, 0xa2b, 0xa2d, 0x5, 0xf4, 
       0x7b, 0x2, 0xa2c, 0xa2b, 0x3, 0x2, 0x2, 0x2, 0xa2c, 0xa2d, 0x3, 0x2, 
       0x2, 0x2, 0xa2d, 0xa30, 0x3, 0x2, 0x2, 0x2, 0xa2e, 0xa30, 0x5, 0x1d4, 
       0xeb, 0x2, 0xa2f, 0xa0d, 0x3, 0x2, 0x2, 0x2, 0xa2f, 0xa15, 0x3, 0x2, 
       0x2, 0x2, 0xa2f, 0xa21, 0x3, 0x2, 0x2, 0x2, 0xa2f, 0xa2e, 0x3, 0x2, 
       0x2, 0x2, 0xa30, 0xef, 0x3, 0x2, 0x2, 0x2, 0xa31, 0xa32, 0x7, 0x42, 
       0x2, 0x2, 0xa32, 0xa34, 0x5, 0x1f4, 0xfb, 0x2, 0xa33, 0xa31, 0x3, 
       0x2, 0x2, 0x2, 0xa33, 0xa34, 0x3, 0x2, 0x2, 0x2, 0xa34, 0xa75, 0x3, 
       0x2, 0x2, 0x2, 0xa35, 0xa36, 0x7, 0x10e, 0x2, 0x2, 0xa36, 0xa39, 
       0x7, 0xb4, 0x2, 0x2, 0xa37, 0xa39, 0x7, 0x17b, 0x2, 0x2, 0xa38, 0xa35, 
       0x3, 0x2, 0x2, 0x2, 0xa38, 0xa37, 0x3, 0x2, 0x2, 0x2, 0xa39, 0xa3b, 
       0x3, 0x2, 0x2, 0x2, 0xa3a, 0xa3c, 0x5, 0x1d2, 0xea, 0x2, 0xa3b, 0xa3a, 
       0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa3c, 0x3, 0x2, 0x2, 0x2, 0xa3c, 0xa3d, 
       0x3, 0x2, 0x2, 0x2, 0xa3d, 0xa3e, 0x7, 0x358, 0x2, 0x2, 0xa3e, 0xa3f, 
       0x5, 0x1ca, 0xe6, 0x2, 0xa3f, 0xa41, 0x7, 0x359, 0x2, 0x2, 0xa40, 
       0xa42, 0x5, 0xf6, 0x7c, 0x2, 0xa41, 0xa40, 0x3, 0x2, 0x2, 0x2, 0xa41, 
       0xa42, 0x3, 0x2, 0x2, 0x2, 0xa42, 0xa45, 0x3, 0x2, 0x2, 0x2, 0xa43, 
       0xa44, 0x7, 0xf2, 0x2, 0x2, 0xa44, 0xa46, 0x5, 0x1f4, 0xfb, 0x2, 
       0xa45, 0xa43, 0x3, 0x2, 0x2, 0x2, 0xa45, 0xa46, 0x3, 0x2, 0x2, 0x2, 
       0xa46, 0xa76, 0x3, 0x2, 0x2, 0x2, 0xa47, 0xa4b, 0x7, 0x33, 0x2, 0x2, 
       0xa48, 0xa49, 0x7, 0xe9, 0x2, 0x2, 0xa49, 0xa4a, 0x7, 0x8b, 0x2, 
       0x2, 0xa4a, 0xa4c, 0x7, 0x122, 0x2, 0x2, 0xa4b, 0xa48, 0x3, 0x2, 
       0x2, 0x2, 0xa4b, 0xa4c, 0x3, 0x2, 0x2, 0x2, 0xa4c, 0xa4d, 0x3, 0x2, 
       0x2, 0x2, 0xa4d, 0xa4e, 0x7, 0x358, 0x2, 0x2, 0xa4e, 0xa4f, 0x5, 
       0x11c, 0x8f, 0x2, 0xa4f, 0xa50, 0x7, 0x359, 0x2, 0x2, 0xa50, 0xa76, 
       0x3, 0x2, 0x2, 0x2, 0xa51, 0xa53, 0x7, 0x5e, 0x2, 0x2, 0xa52, 0xa54, 
       0x7, 0x358, 0x2, 0x2, 0xa53, 0xa52, 0x3, 0x2, 0x2, 0x2, 0xa53, 0xa54, 
       0x3, 0x2, 0x2, 0x2, 0xa54, 0xa59, 0x3, 0x2, 0x2, 0x2, 0xa55, 0xa5a, 
       0x7, 0x342, 0x2, 0x2, 0xa56, 0xa5a, 0x7, 0x360, 0x2, 0x2, 0xa57, 
       0xa5a, 0x5, 0x16e, 0xb8, 0x2, 0xa58, 0xa5a, 0x7, 0x33e, 0x2, 0x2, 
       0xa59, 0xa55, 0x3, 0x2, 0x2, 0x2, 0xa59, 0xa56, 0x3, 0x2, 0x2, 0x2, 
       0xa59, 0xa57, 0x3, 0x2, 0x2, 0x2, 0xa59, 0xa58, 0x3, 0x2, 0x2, 0x2, 
       0xa5a, 0xa5b, 0x3, 0x2, 0x2, 0x2, 0xa5b, 0xa59, 0x3, 0x2, 0x2, 0x2, 
       0xa5b, 0xa5c, 0x3, 0x2, 0x2, 0x2, 0xa5c, 0xa5e, 0x3, 0x2, 0x2, 0x2, 
       0xa5d, 0xa5f, 0x7, 0x359, 0x2, 0x2, 0xa5e, 0xa5d, 0x3, 0x2, 0x2, 
       0x2, 0xa5e, 0xa5f, 0x3, 0x2, 0x2, 0x2, 0xa5f, 0xa60, 0x3, 0x2, 0x2, 
       0x2, 0xa60, 0xa61, 0x7, 0x8b, 0x2, 0x2, 0xa61, 0xa76, 0x5, 0x1f4, 
       0xfb, 0x2, 0xa62, 0xa63, 0x7, 0x8e, 0x2, 0x2, 0xa63, 0xa64, 0x7, 
       0xb4, 0x2, 0x2, 0xa64, 0xa65, 0x7, 0x358, 0x2, 0x2, 0xa65, 0xa66, 
       0x5, 0x1cc, 0xe7, 0x2, 0xa66, 0xa67, 0x7, 0x359, 0x2, 0x2, 0xa67, 
       0xa68, 0x7, 0x11d, 0x2, 0x2, 0xa68, 0xa6d, 0x5, 0x1bc, 0xdf, 0x2, 
       0xa69, 0xa6a, 0x7, 0x358, 0x2, 0x2, 0xa6a, 0xa6b, 0x5, 0x1cc, 0xe7, 
       0x2, 0xa6b, 0xa6c, 0x7, 0x359, 0x2, 0x2, 0xa6c, 0xa6e, 0x3, 0x2, 
       0x2, 0x2, 0xa6d, 0xa69, 0x3, 0x2, 0x2, 0x2, 0xa6d, 0xa6e, 0x3, 0x2, 
       0x2, 0x2, 0xa6e, 0xa70, 0x3, 0x2, 0x2, 0x2, 0xa6f, 0xa71, 0x5, 0xf2, 
       0x7a, 0x2, 0xa70, 0xa6f, 0x3, 0x2, 0x2, 0x2, 0xa70, 0xa71, 0x3, 0x2, 
       0x2, 0x2, 0xa71, 0xa73, 0x3, 0x2, 0x2, 0x2, 0xa72, 0xa74, 0x5, 0xf4, 
       0x7b, 0x2, 0xa73, 0xa72, 0x3, 0x2, 0x2, 0x2, 0xa73, 0xa74, 0x3, 0x2, 
       0x2, 0x2, 0xa74, 0xa76, 0x3, 0x2, 0x2, 0x2, 0xa75, 0xa38, 0x3, 0x2, 
       0x2, 0x2, 0xa75, 0xa47, 0x3, 0x2, 0x2, 0x2, 0xa75, 0xa51, 0x3, 0x2, 
       0x2, 0x2, 0xa75, 0xa62, 0x3, 0x2, 0x2, 0x2, 0xa76, 0xf1, 0x3, 0x2, 
       0x2, 0x2, 0xa77, 0xa78, 0x7, 0xf2, 0x2, 0x2, 0xa78, 0xa80, 0x7, 0x61, 
       0x2, 0x2, 0xa79, 0xa7a, 0x7, 0x27e, 0x2, 0x2, 0xa7a, 0xa81, 0x7, 
       0x199, 0x2, 0x2, 0xa7b, 0xa81, 0x7, 0x2b, 0x2, 0x2, 0xa7c, 0xa7d, 
       0x7, 0x14e, 0x2, 0x2, 0xa7d, 0xa81, 0x7, 0xec, 0x2, 0x2, 0xa7e, 0xa7f, 
       0x7, 0x14e, 0x2, 0x2, 0xa7f, 0xa81, 0x7, 0x5e, 0x2, 0x2, 0xa80, 0xa79, 
       0x3, 0x2, 0x2, 0x2, 0xa80, 0xa7b, 0x3, 0x2, 0x2, 0x2, 0xa80, 0xa7c, 
       0x3, 0x2, 0x2, 0x2, 0xa80, 0xa7e, 0x3, 0x2, 0x2, 0x2, 0xa81, 0xf3, 
       0x3, 0x2, 0x2, 0x2, 0xa82, 0xa83, 0x7, 0xf2, 0x2, 0x2, 0xa83, 0xa8b, 
       0x7, 0x17f, 0x2, 0x2, 0xa84, 0xa85, 0x7, 0x27e, 0x2, 0x2, 0xa85, 
       0xa8c, 0x7, 0x199, 0x2, 0x2, 0xa86, 0xa8c, 0x7, 0x2b, 0x2, 0x2, 0xa87, 
       0xa88, 0x7, 0x14e, 0x2, 0x2, 0xa88, 0xa8c, 0x7, 0xec, 0x2, 0x2, 0xa89, 
       0xa8a, 0x7, 0x14e, 0x2, 0x2, 0xa8a, 0xa8c, 0x7, 0x5e, 0x2, 0x2, 0xa8b, 
       0xa84, 0x3, 0x2, 0x2, 0x2, 0xa8b, 0xa86, 0x3, 0x2, 0x2, 0x2, 0xa8b, 
       0xa87, 0x3, 0x2, 0x2, 0x2, 0xa8b, 0xa89, 0x3, 0x2, 0x2, 0x2, 0xa8c, 
       0xf5, 0x3, 0x2, 0x2, 0x2, 0xa8d, 0xa8e, 0x7, 0x191, 0x2, 0x2, 0xa8e, 
       0xa8f, 0x7, 0x358, 0x2, 0x2, 0xa8f, 0xa94, 0x5, 0xf8, 0x7d, 0x2, 
       0xa90, 0xa91, 0x7, 0x35a, 0x2, 0x2, 0xa91, 0xa93, 0x5, 0xf8, 0x7d, 
       0x2, 0xa92, 0xa90, 0x3, 0x2, 0x2, 0x2, 0xa93, 0xa96, 0x3, 0x2, 0x2, 
       0x2, 0xa94, 0xa92, 0x3, 0x2, 0x2, 0x2, 0xa94, 0xa95, 0x3, 0x2, 0x2, 
       0x2, 0xa95, 0xa97, 0x3, 0x2, 0x2, 0x2, 0xa96, 0xa94, 0x3, 0x2, 0x2, 
       0x2, 0xa97, 0xa98, 0x7, 0x359, 0x2, 0x2, 0xa98, 0xf7, 0x3, 0x2, 0x2, 
       0x2, 0xa99, 0xa9a, 0x5, 0x1f6, 0xfc, 0x2, 0xa9a, 0xa9e, 0x7, 0x346, 
       0x2, 0x2, 0xa9b, 0xa9f, 0x5, 0x1f6, 0xfc, 0x2, 0xa9c, 0xa9f, 0x5, 
       0x1d0, 0xe9, 0x2, 0xa9d, 0xa9f, 0x7, 0x33e, 0x2, 0x2, 0xa9e, 0xa9b, 
       0x3, 0x2, 0x2, 0x2, 0xa9e, 0xa9c, 0x3, 0x2, 0x2, 0x2, 0xa9e, 0xa9d, 
       0x3, 0x2, 0x2, 0x2, 0xa9f, 0xf9, 0x3, 0x2, 0x2, 0x2, 0xaa0, 0xaa1, 
       0x7, 0x5d, 0x2, 0x2, 0xaa1, 0xac1, 0x5, 0x1ce, 0xe8, 0x2, 0xaa2, 
       0xaac, 0x7, 0x55, 0x2, 0x2, 0xaa3, 0xaaa, 0x5, 0xfc, 0x7f, 0x2, 0xaa4, 
       0xaa5, 0x7, 0x8b, 0x2, 0x2, 0xaa5, 0xaa8, 0x7, 0x17f, 0x2, 0x2, 0xaa6, 
       0xaa7, 0x7, 0xee, 0x2, 0x2, 0xaa7, 0xaa9, 0x5, 0x1cc, 0xe7, 0x2, 
       0xaa8, 0xaa6, 0x3, 0x2, 0x2, 0x2, 0xaa8, 0xaa9, 0x3, 0x2, 0x2, 0x2, 
       0xaa9, 0xaab, 0x3, 0x2, 0x2, 0x2, 0xaaa, 0xaa4, 0x3, 0x2, 0x2, 0x2, 
       0xaaa, 0xaab, 0x3, 0x2, 0x2, 0x2, 0xaab, 0xaad, 0x3, 0x2, 0x2, 0x2, 
       0xaac, 0xaa3, 0x3, 0x2, 0x2, 0x2, 0xaac, 0xaad, 0x3, 0x2, 0x2, 0x2, 
       0xaad, 0xac2, 0x3, 0x2, 0x2, 0x2, 0xaae, 0xab0, 0x9, 0x1e, 0x2, 0x2, 
       0xaaf, 0xaae, 0x3, 0x2, 0x2, 0x2, 0xaaf, 0xab0, 0x3, 0x2, 0x2, 0x2, 
       0xab0, 0xab2, 0x3, 0x2, 0x2, 0x2, 0xab1, 0xab3, 0x7, 0x2db, 0x2, 
       0x2, 0xab2, 0xab1, 0x3, 0x2, 0x2, 0x2, 0xab2, 0xab3, 0x3, 0x2, 0x2, 
       0x2, 0xab3, 0xab4, 0x3, 0x2, 0x2, 0x2, 0xab4, 0xab5, 0x7, 0x55, 0x2, 
       0x2, 0xab5, 0xab6, 0x7, 0x8b, 0x2, 0x2, 0xab6, 0xabf, 0x5, 0x6e, 
       0x38, 0x2, 0xab7, 0xabd, 0x7, 0x8b, 0x2, 0x2, 0xab8, 0xab9, 0x7, 
       0x119, 0x2, 0x2, 0xab9, 0xabe, 0x7, 0x291, 0x2, 0x2, 0xaba, 0xabe, 
       0x7, 0x17f, 0x2, 0x2, 0xabb, 0xabc, 0x7, 0xee, 0x2, 0x2, 0xabc, 0xabe, 
       0x5, 0x1cc, 0xe7, 0x2, 0xabd, 0xab8, 0x3, 0x2, 0x2, 0x2, 0xabd, 0xaba, 
       0x3, 0x2, 0x2, 0x2, 0xabd, 0xabb, 0x3, 0x2, 0x2, 0x2, 0xabe, 0xac0, 
       0x3, 0x2, 0x2, 0x2, 0xabf, 0xab7, 0x3, 0x2, 0x2, 0x2, 0xabf, 0xac0, 
       0x3, 0x2, 0x2, 0x2, 0xac0, 0xac2, 0x3, 0x2, 0x2, 0x2, 0xac1, 0xaa2, 
       0x3, 0x2, 0x2, 0x2, 0xac1, 0xaaf, 0x3, 0x2, 0x2, 0x2, 0xac2, 0xac4, 
       0x3, 0x2, 0x2, 0x2, 0xac3, 0xac5, 0x7, 0x35b, 0x2, 0x2, 0xac4, 0xac3, 
       0x3, 0x2, 0x2, 0x2, 0xac4, 0xac5, 0x3, 0x2, 0x2, 0x2, 0xac5, 0xfb, 
       0x3, 0x2, 0x2, 0x2, 0xac6, 0xac8, 0x5, 0xfe, 0x80, 0x2, 0xac7, 0xac6, 
       0x3, 0x2, 0x2, 0x2, 0xac8, 0xacb, 0x3, 0x2, 0x2, 0x2, 0xac9, 0xac7, 
       0x3, 0x2, 0x2, 0x2, 0xac9, 0xaca, 0x3, 0x2, 0x2, 0x2, 0xaca, 0xacc, 
       0x3, 0x2, 0x2, 0x2, 0xacb, 0xac9, 0x3, 0x2, 0x2, 0x2, 0xacc, 0xacd, 
       0x7, 0x8b, 0x2, 0x2, 0xacd, 0xace, 0x5, 0x6e, 0x38, 0x2, 0xace, 0xfd, 
       0x3, 0x2, 0x2, 0x2, 0xacf, 0xad5, 0x9, 0x16, 0x2, 0x2, 0xad0, 0xad5, 
       0x9, 0x1f, 0x2, 0x2, 0xad1, 0xad5, 0x9, 0x20, 0x2, 0x2, 0xad2, 0xad5, 
       0x9, 0x21, 0x2, 0x2, 0xad3, 0xad5, 0x7, 0x31e, 0x2, 0x2, 0xad4, 0xacf, 
       0x3, 0x2, 0x2, 0x2, 0xad4, 0xad0, 0x3, 0x2, 0x2, 0x2, 0xad4, 0xad1, 
       0x3, 0x2, 0x2, 0x2, 0xad4, 0xad2, 0x3, 0x2, 0x2, 0x2, 0xad4, 0xad3, 
       0x3, 0x2, 0x2, 0x2, 0xad5, 0xff, 0x3, 0x2, 0x2, 0x2, 0xad6, 0xae0, 
       0x7, 0x85, 0x2, 0x2, 0xad7, 0xade, 0x7, 0x27d, 0x2, 0x2, 0xad8, 0xade, 
       0x7, 0x2a4, 0x2, 0x2, 0xad9, 0xade, 0x7, 0x21b, 0x2, 0x2, 0xada, 
       0xade, 0x7, 0x24a, 0x2, 0x2, 0xadb, 0xadc, 0x9, 0x22, 0x2, 0x2, 0xadc, 
       0xade, 0x5, 0x106, 0x84, 0x2, 0xadd, 0xad7, 0x3, 0x2, 0x2, 0x2, 0xadd, 
       0xad8, 0x3, 0x2, 0x2, 0x2, 0xadd, 0xad9, 0x3, 0x2, 0x2, 0x2, 0xadd, 
       0xada, 0x3, 0x2, 0x2, 0x2, 0xadd, 0xadb, 0x3, 0x2, 0x2, 0x2, 0xadd, 
       0xade, 0x3, 0x2, 0x2, 0x2, 0xade, 0xadf, 0x3, 0x2, 0x2, 0x2, 0xadf, 
       0xae1, 0x7, 0x91, 0x2, 0x2, 0xae0, 0xadd, 0x3, 0x2, 0x2, 0x2, 0xae0, 
       0xae1, 0x3, 0x2, 0x2, 0x2, 0xae1, 0xae3, 0x3, 0x2, 0x2, 0x2, 0xae2, 
       0xae4, 0x7, 0x228, 0x2, 0x2, 0xae3, 0xae2, 0x3, 0x2, 0x2, 0x2, 0xae3, 
       0xae4, 0x3, 0x2, 0x2, 0x2, 0xae4, 0xae5, 0x3, 0x2, 0x2, 0x2, 0xae5, 
       0xaef, 0x5, 0x1ce, 0xe8, 0x2, 0xae6, 0xae7, 0x7, 0xab, 0x2, 0x2, 
       0xae7, 0xaec, 0x7, 0x33d, 0x2, 0x2, 0xae8, 0xae9, 0x7, 0x35a, 0x2, 
       0x2, 0xae9, 0xaeb, 0x7, 0x33d, 0x2, 0x2, 0xaea, 0xae8, 0x3, 0x2, 
       0x2, 0x2, 0xaeb, 0xaee, 0x3, 0x2, 0x2, 0x2, 0xaec, 0xaea, 0x3, 0x2, 
       0x2, 0x2, 0xaec, 0xaed, 0x3, 0x2, 0x2, 0x2, 0xaed, 0xaf0, 0x3, 0x2, 
       0x2, 0x2, 0xaee, 0xaec, 0x3, 0x2, 0x2, 0x2, 0xaef, 0xae6, 0x3, 0x2, 
       0x2, 0x2, 0xaef, 0xaf0, 0x3, 0x2, 0x2, 0x2, 0xaf0, 0xaf2, 0x3, 0x2, 
       0x2, 0x2, 0xaf1, 0xaf3, 0x7, 0x35b, 0x2, 0x2, 0xaf2, 0xaf1, 0x3, 
       0x2, 0x2, 0x2, 0xaf2, 0xaf3, 0x3, 0x2, 0x2, 0x2, 0xaf3, 0x101, 0x3, 
       0x2, 0x2, 0x2, 0xaf4, 0xaf5, 0x7, 0x14e, 0x2, 0x2, 0xaf5, 0xaf9, 
       0x5, 0x1f4, 0xfb, 0x2, 0xaf6, 0xafa, 0x5, 0x1f4, 0xfb, 0x2, 0xaf7, 
       0xafa, 0x5, 0x104, 0x83, 0x2, 0xaf8, 0xafa, 0x5, 0x1d0, 0xe9, 0x2, 
       0xaf9, 0xaf6, 0x3, 0x2, 0x2, 0x2, 0xaf9, 0xaf7, 0x3, 0x2, 0x2, 0x2, 
       0xaf9, 0xaf8, 0x3, 0x2, 0x2, 0x2, 0xafa, 0xafc, 0x3, 0x2, 0x2, 0x2, 
       0xafb, 0xafd, 0x7, 0x35b, 0x2, 0x2, 0xafc, 0xafb, 0x3, 0x2, 0x2, 
       0x2, 0xafc, 0xafd, 0x3, 0x2, 0x2, 0x2, 0xafd, 0xb26, 0x3, 0x2, 0x2, 
       0x2, 0xafe, 0xaff, 0x7, 0x14e, 0x2, 0x2, 0xaff, 0xb00, 0x7, 0x174, 
       0x2, 0x2, 0xb00, 0xb01, 0x7, 0x240, 0x2, 0x2, 0xb01, 0xb0b, 0x7, 
       0x24d, 0x2, 0x2, 0xb02, 0xb03, 0x7, 0x119, 0x2, 0x2, 0xb03, 0xb0c, 
       0x7, 0x320, 0x2, 0x2, 0xb04, 0xb05, 0x7, 0x119, 0x2, 0x2, 0xb05, 
       0xb0c, 0x7, 0x1d0, 0x2, 0x2, 0xb06, 0xb07, 0x7, 0x2c6, 0x2, 0x2, 
       0xb07, 0xb0c, 0x7, 0x119, 0x2, 0x2, 0xb08, 0xb0c, 0x7, 0x2f5, 0x2, 
       0x2, 0xb09, 0xb0c, 0x7, 0x2eb, 0x2, 0x2, 0xb0a, 0xb0c, 0x7, 0x33e, 
       0x2, 0x2, 0xb0b, 0xb02, 0x3, 0x2, 0x2, 0x2, 0xb0b, 0xb04, 0x3, 0x2, 
       0x2, 0x2, 0xb0b, 0xb06, 0x3, 0x2, 0x2, 0x2, 0xb0b, 0xb08, 0x3, 0x2, 
       0x2, 0x2, 0xb0b, 0xb09, 0x3, 0x2, 0x2, 0x2, 0xb0b, 0xb0a, 0x3, 0x2, 
       0x2, 0x2, 0xb0c, 0xb0e, 0x3, 0x2, 0x2, 0x2, 0xb0d, 0xb0f, 0x7, 0x35b, 
       0x2, 0x2, 0xb0e, 0xb0d, 0x3, 0x2, 0x2, 0x2, 0xb0e, 0xb0f, 0x3, 0x2, 
       0x2, 0x2, 0xb0f, 0xb26, 0x3, 0x2, 0x2, 0x2, 0xb10, 0xb11, 0x7, 0x14e, 
       0x2, 0x2, 0xb11, 0xb12, 0x7, 0x9e, 0x2, 0x2, 0xb12, 0xb13, 0x5, 0x1bc, 
       0xdf, 0x2, 0xb13, 0xb15, 0x5, 0x1d0, 0xe9, 0x2, 0xb14, 0xb16, 0x7, 
       0x35b, 0x2, 0x2, 0xb15, 0xb14, 0x3, 0x2, 0x2, 0x2, 0xb15, 0xb16, 
       0x3, 0x2, 0x2, 0x2, 0xb16, 0xb26, 0x3, 0x2, 0x2, 0x2, 0xb17, 0xb18, 
       0x7, 0x14e, 0x2, 0x2, 0xb18, 0xb19, 0x7, 0x1a8, 0x2, 0x2, 0xb19, 
       0xb26, 0x5, 0x1d0, 0xe9, 0x2, 0xb1a, 0xb1b, 0x7, 0x14e, 0x2, 0x2, 
       0xb1b, 0xb1c, 0x7, 0x2b1, 0x2, 0x2, 0xb1c, 0xb26, 0x5, 0x1d0, 0xe9, 
       0x2, 0xb1d, 0xb1e, 0x7, 0x14e, 0x2, 0x2, 0xb1e, 0xb1f, 0x7, 0x1a9, 
       0x2, 0x2, 0xb1f, 0xb26, 0x5, 0x1d0, 0xe9, 0x2, 0xb20, 0xb21, 0x7, 
       0x14e, 0x2, 0x2, 0xb21, 0xb22, 0x7, 0x1aa, 0x2, 0x2, 0xb22, 0xb26, 
       0x5, 0x1d0, 0xe9, 0x2, 0xb23, 0xb24, 0x7, 0x14e, 0x2, 0x2, 0xb24, 
       0xb26, 0x5, 0x178, 0xbd, 0x2, 0xb25, 0xaf4, 0x3, 0x2, 0x2, 0x2, 0xb25, 
       0xafe, 0x3, 0x2, 0x2, 0x2, 0xb25, 0xb10, 0x3, 0x2, 0x2, 0x2, 0xb25, 
       0xb17, 0x3, 0x2, 0x2, 0x2, 0xb25, 0xb1a, 0x3, 0x2, 0x2, 0x2, 0xb25, 
       0xb1d, 0x3, 0x2, 0x2, 0x2, 0xb25, 0xb20, 0x3, 0x2, 0x2, 0x2, 0xb25, 
       0xb23, 0x3, 0x2, 0x2, 0x2, 0xb26, 0x103, 0x3, 0x2, 0x2, 0x2, 0xb27, 
       0xb2a, 0x5, 0x1f0, 0xf9, 0x2, 0xb28, 0xb2a, 0x7, 0x33d, 0x2, 0x2, 
       0xb29, 0xb27, 0x3, 0x2, 0x2, 0x2, 0xb29, 0xb28, 0x3, 0x2, 0x2, 0x2, 
       0xb2a, 0x105, 0x3, 0x2, 0x2, 0x2, 0xb2b, 0xb2c, 0x8, 0x84, 0x1, 0x2, 
       0xb2c, 0xb34, 0x5, 0x108, 0x85, 0x2, 0xb2d, 0xb34, 0x5, 0x16e, 0xb8, 
       0x2, 0xb2e, 0xb34, 0x5, 0x10a, 0x86, 0x2, 0xb2f, 0xb34, 0x5, 0x1c8, 
       0xe5, 0x2, 0xb30, 0xb34, 0x5, 0x10e, 0x88, 0x2, 0xb31, 0xb34, 0x5, 
       0x10c, 0x87, 0x2, 0xb32, 0xb34, 0x5, 0x19e, 0xd0, 0x2, 0xb33, 0xb2b, 
       0x3, 0x2, 0x2, 0x2, 0xb33, 0xb2d, 0x3, 0x2, 0x2, 0x2, 0xb33, 0xb2e, 
       0x3, 0x2, 0x2, 0x2, 0xb33, 0xb2f, 0x3, 0x2, 0x2, 0x2, 0xb33, 0xb30, 
       0x3, 0x2, 0x2, 0x2, 0xb33, 0xb31, 0x3, 0x2, 0x2, 0x2, 0xb33, 0xb32, 
       0x3, 0x2, 0x2, 0x2, 0xb34, 0xb48, 0x3, 0x2, 0x2, 0x2, 0xb35, 0xb36, 
       0xc, 0x7, 0x2, 0x2, 0xb36, 0xb37, 0x9, 0x23, 0x2, 0x2, 0xb37, 0xb47, 
       0x5, 0x106, 0x84, 0x8, 0xb38, 0xb39, 0xc, 0x6, 0x2, 0x2, 0xb39, 0xb3a, 
       0x9, 0x24, 0x2, 0x2, 0xb3a, 0xb47, 0x5, 0x106, 0x84, 0x7, 0xb3b, 
       0xb3c, 0xc, 0x5, 0x2, 0x2, 0xb3c, 0xb3d, 0x5, 0x1f8, 0xfd, 0x2, 0xb3d, 
       0xb3e, 0x5, 0x106, 0x84, 0x6, 0xb3e, 0xb47, 0x3, 0x2, 0x2, 0x2, 0xb3f, 
       0xb40, 0xc, 0x4, 0x2, 0x2, 0xb40, 0xb41, 0x5, 0x1fa, 0xfe, 0x2, 0xb41, 
       0xb42, 0x5, 0x106, 0x84, 0x5, 0xb42, 0xb47, 0x3, 0x2, 0x2, 0x2, 0xb43, 
       0xb44, 0xc, 0xc, 0x2, 0x2, 0xb44, 0xb45, 0x7, 0x3c, 0x2, 0x2, 0xb45, 
       0xb47, 0x5, 0x1f4, 0xfb, 0x2, 0xb46, 0xb35, 0x3, 0x2, 0x2, 0x2, 0xb46, 
       0xb38, 0x3, 0x2, 0x2, 0x2, 0xb46, 0xb3b, 0x3, 0x2, 0x2, 0x2, 0xb46, 
       0xb3f, 0x3, 0x2, 0x2, 0x2, 0xb46, 0xb43, 0x3, 0x2, 0x2, 0x2, 0xb47, 
       0xb4a, 0x3, 0x2, 0x2, 0x2, 0xb48, 0xb46, 0x3, 0x2, 0x2, 0x2, 0xb48, 
       0xb49, 0x3, 0x2, 0x2, 0x2, 0xb49, 0x107, 0x3, 0x2, 0x2, 0x2, 0xb4a, 
       0xb48, 0x3, 0x2, 0x2, 0x2, 0xb4b, 0xb50, 0x7, 0x5e, 0x2, 0x2, 0xb4c, 
       0xb50, 0x7, 0xec, 0x2, 0x2, 0xb4d, 0xb50, 0x7, 0x33d, 0x2, 0x2, 0xb4e, 
       0xb50, 0x5, 0x1f0, 0xf9, 0x2, 0xb4f, 0xb4b, 0x3, 0x2, 0x2, 0x2, 0xb4f, 
       0xb4c, 0x3, 0x2, 0x2, 0x2, 0xb4f, 0xb4d, 0x3, 0x2, 0x2, 0x2, 0xb4f, 
       0xb4e, 0x3, 0x2, 0x2, 0x2, 0xb50, 0x109, 0x3, 0x2, 0x2, 0x2, 0xb51, 
       0xb52, 0x7, 0x2c, 0x2, 0x2, 0xb52, 0xb54, 0x5, 0x106, 0x84, 0x2, 
       0xb53, 0xb55, 0x5, 0x17c, 0xbf, 0x2, 0xb54, 0xb53, 0x3, 0x2, 0x2, 
       0x2, 0xb55, 0xb56, 0x3, 0x2, 0x2, 0x2, 0xb56, 0xb54, 0x3, 0x2, 0x2, 
       0x2, 0xb56, 0xb57, 0x3, 0x2, 0x2, 0x2, 0xb57, 0xb5a, 0x3, 0x2, 0x2, 
       0x2, 0xb58, 0xb59, 0x7, 0x6f, 0x2, 0x2, 0xb59, 0xb5b, 0x5, 0x106, 
       0x84, 0x2, 0xb5a, 0xb58, 0x3, 0x2, 0x2, 0x2, 0xb5a, 0xb5b, 0x3, 0x2, 
       0x2, 0x2, 0xb5b, 0xb5c, 0x3, 0x2, 0x2, 0x2, 0xb5c, 0xb5d, 0x7, 0x71, 
       0x2, 0x2, 0xb5d, 0xb6b, 0x3, 0x2, 0x2, 0x2, 0xb5e, 0xb60, 0x7, 0x2c, 
       0x2, 0x2, 0xb5f, 0xb61, 0x5, 0x17e, 0xc0, 0x2, 0xb60, 0xb5f, 0x3, 
       0x2, 0x2, 0x2, 0xb61, 0xb62, 0x3, 0x2, 0x2, 0x2, 0xb62, 0xb60, 0x3, 
       0x2, 0x2, 0x2, 0xb62, 0xb63, 0x3, 0x2, 0x2, 0x2, 0xb63, 0xb66, 0x3, 
       0x2, 0x2, 0x2, 0xb64, 0xb65, 0x7, 0x6f, 0x2, 0x2, 0xb65, 0xb67, 0x5, 
       0x106, 0x84, 0x2, 0xb66, 0xb64, 0x3, 0x2, 0x2, 0x2, 0xb66, 0xb67, 
       0x3, 0x2, 0x2, 0x2, 0xb67, 0xb68, 0x3, 0x2, 0x2, 0x2, 0xb68, 0xb69, 
       0x7, 0x71, 0x2, 0x2, 0xb69, 0xb6b, 0x3, 0x2, 0x2, 0x2, 0xb6a, 0xb51, 
       0x3, 0x2, 0x2, 0x2, 0xb6a, 0xb5e, 0x3, 0x2, 0x2, 0x2, 0xb6b, 0x10b, 
       0x3, 0x2, 0x2, 0x2, 0xb6c, 0xb6d, 0x7, 0x362, 0x2, 0x2, 0xb6d, 0xb71, 
       0x5, 0x106, 0x84, 0x2, 0xb6e, 0xb6f, 0x9, 0x25, 0x2, 0x2, 0xb6f, 
       0xb71, 0x5, 0x106, 0x84, 0x2, 0xb70, 0xb6c, 0x3, 0x2, 0x2, 0x2, 0xb70, 
       0xb6e, 0x3, 0x2, 0x2, 0x2, 0xb71, 0x10d, 0x3, 0x2, 0x2, 0x2, 0xb72, 
       0xb73, 0x7, 0x358, 0x2, 0x2, 0xb73, 0xb74, 0x5, 0x106, 0x84, 0x2, 
       0xb74, 0xb75, 0x7, 0x359, 0x2, 0x2, 0xb75, 0xb7b, 0x3, 0x2, 0x2, 
       0x2, 0xb76, 0xb77, 0x7, 0x358, 0x2, 0x2, 0xb77, 0xb78, 0x5, 0x112, 
       0x8a, 0x2, 0xb78, 0xb79, 0x7, 0x359, 0x2, 0x2, 0xb79, 0xb7b, 0x3, 
       0x2, 0x2, 0x2, 0xb7a, 0xb72, 0x3, 0x2, 0x2, 0x2, 0xb7a, 0xb76, 0x3, 
       0x2, 0x2, 0x2, 0xb7b, 0x10f, 0x3, 0x2, 0x2, 0x2, 0xb7c, 0xb85, 0x7, 
       0xec, 0x2, 0x2, 0xb7d, 0xb85, 0x5, 0x1f0, 0xf9, 0x2, 0xb7e, 0xb85, 
       0x5, 0x16e, 0xb8, 0x2, 0xb7f, 0xb85, 0x7, 0x33d, 0x2, 0x2, 0xb80, 
       0xb81, 0x7, 0x358, 0x2, 0x2, 0xb81, 0xb82, 0x5, 0x110, 0x89, 0x2, 
       0xb82, 0xb83, 0x7, 0x359, 0x2, 0x2, 0xb83, 0xb85, 0x3, 0x2, 0x2, 
       0x2, 0xb84, 0xb7c, 0x3, 0x2, 0x2, 0x2, 0xb84, 0xb7d, 0x3, 0x2, 0x2, 
       0x2, 0xb84, 0xb7e, 0x3, 0x2, 0x2, 0x2, 0xb84, 0xb7f, 0x3, 0x2, 0x2, 
       0x2, 0xb84, 0xb80, 0x3, 0x2, 0x2, 0x2, 0xb85, 0x111, 0x3, 0x2, 0x2, 
       0x2, 0xb86, 0xb87, 0x5, 0x6e, 0x38, 0x2, 0xb87, 0x113, 0x3, 0x2, 
       0x2, 0x2, 0xb88, 0xb8b, 0x7, 0x191, 0x2, 0x2, 0xb89, 0xb8a, 0x7, 
       0x333, 0x2, 0x2, 0xb8a, 0xb8c, 0x7, 0x35a, 0x2, 0x2, 0xb8b, 0xb89, 
       0x3, 0x2, 0x2, 0x2, 0xb8b, 0xb8c, 0x3, 0x2, 0x2, 0x2, 0xb8c, 0xb8d, 
       0x3, 0x2, 0x2, 0x2, 0xb8d, 0xb92, 0x5, 0x116, 0x8c, 0x2, 0xb8e, 0xb8f, 
       0x7, 0x35a, 0x2, 0x2, 0xb8f, 0xb91, 0x5, 0x116, 0x8c, 0x2, 0xb90, 
       0xb8e, 0x3, 0x2, 0x2, 0x2, 0xb91, 0xb94, 0x3, 0x2, 0x2, 0x2, 0xb92, 
       0xb90, 0x3, 0x2, 0x2, 0x2, 0xb92, 0xb93, 0x3, 0x2, 0x2, 0x2, 0xb93, 
       0xba3, 0x3, 0x2, 0x2, 0x2, 0xb94, 0xb92, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb96, 0x7, 0x191, 0x2, 0x2, 0xb96, 0xb9b, 0x7, 0x22, 0x2, 0x2, 0xb97, 
       0xb98, 0x7, 0x358, 0x2, 0x2, 0xb98, 0xb99, 0x5, 0x164, 0xb3, 0x2, 
       0xb99, 0xb9a, 0x7, 0x359, 0x2, 0x2, 0xb9a, 0xb9c, 0x3, 0x2, 0x2, 
       0x2, 0xb9b, 0xb97, 0x3, 0x2, 0x2, 0x2, 0xb9b, 0xb9c, 0x3, 0x2, 0x2, 
       0x2, 0xb9c, 0xb9d, 0x3, 0x2, 0x2, 0x2, 0xb9d, 0xb9e, 0x7, 0x11, 0x2, 
       0x2, 0xb9e, 0xb9f, 0x7, 0x358, 0x2, 0x2, 0xb9f, 0xba0, 0x5, 0x6e, 
       0x38, 0x2, 0xba0, 0xba1, 0x7, 0x359, 0x2, 0x2, 0xba1, 0xba3, 0x3, 
       0x2, 0x2, 0x2, 0xba2, 0xb88, 0x3, 0x2, 0x2, 0x2, 0xba2, 0xb95, 0x3, 
       0x2, 0x2, 0x2, 0xba3, 0x115, 0x3, 0x2, 0x2, 0x2, 0xba4, 0xba9, 0x5, 
       0x1f4, 0xfb, 0x2, 0xba5, 0xba6, 0x7, 0x358, 0x2, 0x2, 0xba6, 0xba7, 
       0x5, 0x1cc, 0xe7, 0x2, 0xba7, 0xba8, 0x7, 0x359, 0x2, 0x2, 0xba8, 
       0xbaa, 0x3, 0x2, 0x2, 0x2, 0xba9, 0xba5, 0x3, 0x2, 0x2, 0x2, 0xba9, 
       0xbaa, 0x3, 0x2, 0x2, 0x2, 0xbaa, 0xbab, 0x3, 0x2, 0x2, 0x2, 0xbab, 
       0xbac, 0x7, 0x11, 0x2, 0x2, 0xbac, 0xbad, 0x7, 0x358, 0x2, 0x2, 0xbad, 
       0xbae, 0x5, 0x6e, 0x38, 0x2, 0xbae, 0xbaf, 0x7, 0x359, 0x2, 0x2, 
       0xbaf, 0x117, 0x3, 0x2, 0x2, 0x2, 0xbb0, 0xbb3, 0x5, 0x1c8, 0xe5, 
       0x2, 0xbb1, 0xbb3, 0x7, 0x33d, 0x2, 0x2, 0xbb2, 0xbb0, 0x3, 0x2, 
       0x2, 0x2, 0xbb2, 0xbb1, 0x3, 0x2, 0x2, 0x2, 0xbb3, 0xbb6, 0x3, 0x2, 
       0x2, 0x2, 0xbb4, 0xbb7, 0x7, 0x346, 0x2, 0x2, 0xbb5, 0xbb7, 0x5, 
       0x1fa, 0xfe, 0x2, 0xbb6, 0xbb4, 0x3, 0x2, 0x2, 0x2, 0xbb6, 0xbb5, 
       0x3, 0x2, 0x2, 0x2, 0xbb7, 0xbb8, 0x3, 0x2, 0x2, 0x2, 0xbb8, 0xbc1, 
       0x5, 0x106, 0x84, 0x2, 0xbb9, 0xbba, 0x5, 0x1f4, 0xfb, 0x2, 0xbba, 
       0xbbb, 0x7, 0x353, 0x2, 0x2, 0xbbb, 0xbbc, 0x5, 0x1f4, 0xfb, 0x2, 
       0xbbc, 0xbbd, 0x7, 0x358, 0x2, 0x2, 0xbbd, 0xbbe, 0x5, 0x194, 0xcb, 
       0x2, 0xbbe, 0xbbf, 0x7, 0x359, 0x2, 0x2, 0xbbf, 0xbc1, 0x3, 0x2, 
       0x2, 0x2, 0xbc0, 0xbb2, 0x3, 0x2, 0x2, 0x2, 0xbc0, 0xbb9, 0x3, 0x2, 
       0x2, 0x2, 0xbc1, 0x119, 0x3, 0x2, 0x2, 0x2, 0xbc2, 0xbc7, 0x5, 0x11c, 
       0x8f, 0x2, 0xbc3, 0xbc4, 0x7, 0x35a, 0x2, 0x2, 0xbc4, 0xbc6, 0x5, 
       0x11c, 0x8f, 0x2, 0xbc5, 0xbc3, 0x3, 0x2, 0x2, 0x2, 0xbc6, 0xbc9, 
       0x3, 0x2, 0x2, 0x2, 0xbc7, 0xbc5, 0x3, 0x2, 0x2, 0x2, 0xbc7, 0xbc8, 
       0x3, 0x2, 0x2, 0x2, 0xbc8, 0x11b, 0x3, 0x2, 0x2, 0x2, 0xbc9, 0xbc7, 
       0x3, 0x2, 0x2, 0x2, 0xbca, 0xbcf, 0x5, 0x11e, 0x90, 0x2, 0xbcb, 0xbcc, 
       0x7, 0xfa, 0x2, 0x2, 0xbcc, 0xbce, 0x5, 0x11e, 0x90, 0x2, 0xbcd, 
       0xbcb, 0x3, 0x2, 0x2, 0x2, 0xbce, 0xbd1, 0x3, 0x2, 0x2, 0x2, 0xbcf, 
       0xbcd, 0x3, 0x2, 0x2, 0x2, 0xbcf, 0xbd0, 0x3, 0x2, 0x2, 0x2, 0xbd0, 
       0x11d, 0x3, 0x2, 0x2, 0x2, 0xbd1, 0xbcf, 0x3, 0x2, 0x2, 0x2, 0xbd2, 
       0xbd7, 0x5, 0x120, 0x91, 0x2, 0xbd3, 0xbd4, 0x7, 0xc, 0x2, 0x2, 0xbd4, 
       0xbd6, 0x5, 0x120, 0x91, 0x2, 0xbd5, 0xbd3, 0x3, 0x2, 0x2, 0x2, 0xbd6, 
       0xbd9, 0x3, 0x2, 0x2, 0x2, 0xbd7, 0xbd5, 0x3, 0x2, 0x2, 0x2, 0xbd7, 
       0xbd8, 0x3, 0x2, 0x2, 0x2, 0xbd8, 0x11f, 0x3, 0x2, 0x2, 0x2, 0xbd9, 
       0xbd7, 0x3, 0x2, 0x2, 0x2, 0xbda, 0xbdc, 0x7, 0xe9, 0x2, 0x2, 0xbdb, 
       0xbda, 0x3, 0x2, 0x2, 0x2, 0xbdb, 0xbdc, 0x3, 0x2, 0x2, 0x2, 0xbdc, 
       0xbdd, 0x3, 0x2, 0x2, 0x2, 0xbdd, 0xbde, 0x5, 0x122, 0x92, 0x2, 0xbde, 
       0x121, 0x3, 0x2, 0x2, 0x2, 0xbdf, 0xbe0, 0x7, 0x7c, 0x2, 0x2, 0xbe0, 
       0xbe1, 0x7, 0x358, 0x2, 0x2, 0xbe1, 0xbe2, 0x5, 0x112, 0x8a, 0x2, 
       0xbe2, 0xbe3, 0x7, 0x359, 0x2, 0x2, 0xbe3, 0xc17, 0x3, 0x2, 0x2, 
       0x2, 0xbe4, 0xbe5, 0x5, 0x106, 0x84, 0x2, 0xbe5, 0xbe6, 0x5, 0x1f8, 
       0xfd, 0x2, 0xbe6, 0xbe7, 0x5, 0x106, 0x84, 0x2, 0xbe7, 0xc17, 0x3, 
       0x2, 0x2, 0x2, 0xbe8, 0xbe9, 0x5, 0x106, 0x84, 0x2, 0xbe9, 0xbea, 
       0x5, 0x1f8, 0xfd, 0x2, 0xbea, 0xbeb, 0x9, 0x26, 0x2, 0x2, 0xbeb, 
       0xbec, 0x7, 0x358, 0x2, 0x2, 0xbec, 0xbed, 0x5, 0x112, 0x8a, 0x2, 
       0xbed, 0xbee, 0x7, 0x359, 0x2, 0x2, 0xbee, 0xc17, 0x3, 0x2, 0x2, 
       0x2, 0xbef, 0xbf1, 0x5, 0x106, 0x84, 0x2, 0xbf0, 0xbf2, 0x7, 0xe9, 
       0x2, 0x2, 0xbf1, 0xbf0, 0x3, 0x2, 0x2, 0x2, 0xbf1, 0xbf2, 0x3, 0x2, 
       0x2, 0x2, 0xbf2, 0xbf3, 0x3, 0x2, 0x2, 0x2, 0xbf3, 0xbf4, 0x7, 0x1f, 
       0x2, 0x2, 0xbf4, 0xbf5, 0x5, 0x106, 0x84, 0x2, 0xbf5, 0xbf6, 0x7, 
       0xc, 0x2, 0x2, 0xbf6, 0xbf7, 0x5, 0x106, 0x84, 0x2, 0xbf7, 0xc17, 
       0x3, 0x2, 0x2, 0x2, 0xbf8, 0xbfa, 0x5, 0x106, 0x84, 0x2, 0xbf9, 0xbfb, 
       0x7, 0xe9, 0x2, 0x2, 0xbfa, 0xbf9, 0x3, 0x2, 0x2, 0x2, 0xbfa, 0xbfb, 
       0x3, 0x2, 0x2, 0x2, 0xbfb, 0xbfc, 0x3, 0x2, 0x2, 0x2, 0xbfc, 0xbfd, 
       0x7, 0xa1, 0x2, 0x2, 0xbfd, 0xc00, 0x7, 0x358, 0x2, 0x2, 0xbfe, 0xc01, 
       0x5, 0x112, 0x8a, 0x2, 0xbff, 0xc01, 0x5, 0x194, 0xcb, 0x2, 0xc00, 
       0xbfe, 0x3, 0x2, 0x2, 0x2, 0xc00, 0xbff, 0x3, 0x2, 0x2, 0x2, 0xc01, 
       0xc02, 0x3, 0x2, 0x2, 0x2, 0xc02, 0xc03, 0x7, 0x359, 0x2, 0x2, 0xc03, 
       0xc17, 0x3, 0x2, 0x2, 0x2, 0xc04, 0xc06, 0x5, 0x106, 0x84, 0x2, 0xc05, 
       0xc07, 0x7, 0xe9, 0x2, 0x2, 0xc06, 0xc05, 0x3, 0x2, 0x2, 0x2, 0xc06, 
       0xc07, 0x3, 0x2, 0x2, 0x2, 0xc07, 0xc08, 0x3, 0x2, 0x2, 0x2, 0xc08, 
       0xc09, 0x7, 0xbd, 0x2, 0x2, 0xc09, 0xc0c, 0x5, 0x106, 0x84, 0x2, 
       0xc0a, 0xc0b, 0x7, 0x74, 0x2, 0x2, 0xc0b, 0xc0d, 0x5, 0x106, 0x84, 
       0x2, 0xc0c, 0xc0a, 0x3, 0x2, 0x2, 0x2, 0xc0c, 0xc0d, 0x3, 0x2, 0x2, 
       0x2, 0xc0d, 0xc17, 0x3, 0x2, 0x2, 0x2, 0xc0e, 0xc0f, 0x5, 0x106, 
       0x84, 0x2, 0xc0f, 0xc10, 0x7, 0xae, 0x2, 0x2, 0xc10, 0xc11, 0x5, 
       0x1d4, 0xeb, 0x2, 0xc11, 0xc17, 0x3, 0x2, 0x2, 0x2, 0xc12, 0xc13, 
       0x7, 0x358, 0x2, 0x2, 0xc13, 0xc14, 0x5, 0x11c, 0x8f, 0x2, 0xc14, 
       0xc15, 0x7, 0x359, 0x2, 0x2, 0xc15, 0xc17, 0x3, 0x2, 0x2, 0x2, 0xc16, 
       0xbdf, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xbe4, 0x3, 0x2, 0x2, 0x2, 0xc16, 
       0xbe8, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xbef, 0x3, 0x2, 0x2, 0x2, 0xc16, 
       0xbf8, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xc04, 0x3, 0x2, 0x2, 0x2, 0xc16, 
       0xc0e, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xc12, 0x3, 0x2, 0x2, 0x2, 0xc17, 
       0x123, 0x3, 0x2, 0x2, 0x2, 0xc18, 0xc1e, 0x5, 0x128, 0x95, 0x2, 0xc19, 
       0xc1a, 0x7, 0x358, 0x2, 0x2, 0xc1a, 0xc1b, 0x5, 0x124, 0x93, 0x2, 
       0xc1b, 0xc1c, 0x7, 0x359, 0x2, 0x2, 0xc1c, 0xc1e, 0x3, 0x2, 0x2, 
       0x2, 0xc1d, 0xc18, 0x3, 0x2, 0x2, 0x2, 0xc1d, 0xc19, 0x3, 0x2, 0x2, 
       0x2, 0xc1e, 0xc22, 0x3, 0x2, 0x2, 0x2, 0xc1f, 0xc21, 0x5, 0x126, 
       0x94, 0x2, 0xc20, 0xc1f, 0x3, 0x2, 0x2, 0x2, 0xc21, 0xc24, 0x3, 0x2, 
       0x2, 0x2, 0xc22, 0xc20, 0x3, 0x2, 0x2, 0x2, 0xc22, 0xc23, 0x3, 0x2, 
       0x2, 0x2, 0xc23, 0x125, 0x3, 0x2, 0x2, 0x2, 0xc24, 0xc22, 0x3, 0x2, 
       0x2, 0x2, 0xc25, 0xc27, 0x7, 0x17a, 0x2, 0x2, 0xc26, 0xc28, 0x7, 
       0x7, 0x2, 0x2, 0xc27, 0xc26, 0x3, 0x2, 0x2, 0x2, 0xc27, 0xc28, 0x3, 
       0x2, 0x2, 0x2, 0xc28, 0xc2c, 0x3, 0x2, 0x2, 0x2, 0xc29, 0xc2c, 0x7, 
       0x79, 0x2, 0x2, 0xc2a, 0xc2c, 0x7, 0xaa, 0x2, 0x2, 0xc2b, 0xc25, 
       0x3, 0x2, 0x2, 0x2, 0xc2b, 0xc29, 0x3, 0x2, 0x2, 0x2, 0xc2b, 0xc2a, 
       0x3, 0x2, 0x2, 0x2, 0xc2c, 0xc32, 0x3, 0x2, 0x2, 0x2, 0xc2d, 0xc33, 
       0x5, 0x128, 0x95, 0x2, 0xc2e, 0xc2f, 0x7, 0x358, 0x2, 0x2, 0xc2f, 
       0xc30, 0x5, 0x124, 0x93, 0x2, 0xc30, 0xc31, 0x7, 0x359, 0x2, 0x2, 
       0xc31, 0xc33, 0x3, 0x2, 0x2, 0x2, 0xc32, 0xc2d, 0x3, 0x2, 0x2, 0x2, 
       0xc32, 0xc2e, 0x3, 0x2, 0x2, 0x2, 0xc33, 0x127, 0x3, 0x2, 0x2, 0x2, 
       0xc34, 0xc36, 0x7, 0x143, 0x2, 0x2, 0xc35, 0xc37, 0x9, 0x27, 0x2, 
       0x2, 0xc36, 0xc35, 0x3, 0x2, 0x2, 0x2, 0xc36, 0xc37, 0x3, 0x2, 0x2, 
       0x2, 0xc37, 0xc39, 0x3, 0x2, 0x2, 0x2, 0xc38, 0xc3a, 0x5, 0x12a, 
       0x96, 0x2, 0xc39, 0xc38, 0x3, 0x2, 0x2, 0x2, 0xc39, 0xc3a, 0x3, 0x2, 
       0x2, 0x2, 0xc3a, 0xc3b, 0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc3e, 0x5, 0x140, 
       0xa1, 0x2, 0xc3c, 0xc3d, 0x7, 0xab, 0x2, 0x2, 0xc3d, 0xc3f, 0x5, 
       0x1bc, 0xdf, 0x2, 0xc3e, 0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc3e, 0xc3f, 
       0x3, 0x2, 0x2, 0x2, 0xc3f, 0xc42, 0x3, 0x2, 0x2, 0x2, 0xc40, 0xc41, 
       0x7, 0x91, 0x2, 0x2, 0xc41, 0xc43, 0x5, 0x14e, 0xa8, 0x2, 0xc42, 
       0xc40, 0x3, 0x2, 0x2, 0x2, 0xc42, 0xc43, 0x3, 0x2, 0x2, 0x2, 0xc43, 
       0xc46, 0x3, 0x2, 0x2, 0x2, 0xc44, 0xc45, 0x7, 0x18e, 0x2, 0x2, 0xc45, 
       0xc47, 0x5, 0x11c, 0x8f, 0x2, 0xc46, 0xc44, 0x3, 0x2, 0x2, 0x2, 0xc46, 
       0xc47, 0x3, 0x2, 0x2, 0x2, 0xc47, 0xc55, 0x3, 0x2, 0x2, 0x2, 0xc48, 
       0xc49, 0x7, 0x98, 0x2, 0x2, 0xc49, 0xc4b, 0x7, 0x28, 0x2, 0x2, 0xc4a, 
       0xc4c, 0x7, 0x7, 0x2, 0x2, 0xc4b, 0xc4a, 0x3, 0x2, 0x2, 0x2, 0xc4b, 
       0xc4c, 0x3, 0x2, 0x2, 0x2, 0xc4c, 0xc4d, 0x3, 0x2, 0x2, 0x2, 0xc4d, 
       0xc52, 0x5, 0x138, 0x9d, 0x2, 0xc4e, 0xc4f, 0x7, 0x35a, 0x2, 0x2, 
       0xc4f, 0xc51, 0x5, 0x138, 0x9d, 0x2, 0xc50, 0xc4e, 0x3, 0x2, 0x2, 
       0x2, 0xc51, 0xc54, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc50, 0x3, 0x2, 0x2, 
       0x2, 0xc52, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc53, 0xc56, 0x3, 0x2, 0x2, 
       0x2, 0xc54, 0xc52, 0x3, 0x2, 0x2, 0x2, 0xc55, 0xc48, 0x3, 0x2, 0x2, 
       0x2, 0xc55, 0xc56, 0x3, 0x2, 0x2, 0x2, 0xc56, 0xc59, 0x3, 0x2, 0x2, 
       0x2, 0xc57, 0xc58, 0x7, 0x99, 0x2, 0x2, 0xc58, 0xc5a, 0x5, 0x11c, 
       0x8f, 0x2, 0xc59, 0xc57, 0x3, 0x2, 0x2, 0x2, 0xc59, 0xc5a, 0x3, 0x2, 
       0x2, 0x2, 0xc5a, 0x129, 0x3, 0x2, 0x2, 0x2, 0xc5b, 0xc5e, 0x7, 0x171, 
       0x2, 0x2, 0xc5c, 0xc5f, 0x5, 0x12c, 0x97, 0x2, 0xc5d, 0xc5f, 0x5, 
       0x12e, 0x98, 0x2, 0xc5e, 0xc5c, 0x3, 0x2, 0x2, 0x2, 0xc5e, 0xc5d, 
       0x3, 0x2, 0x2, 0x2, 0xc5f, 0xc62, 0x3, 0x2, 0x2, 0x2, 0xc60, 0xc61, 
       0x7, 0x191, 0x2, 0x2, 0xc61, 0xc63, 0x7, 0x310, 0x2, 0x2, 0xc62, 
       0xc60, 0x3, 0x2, 0x2, 0x2, 0xc62, 0xc63, 0x3, 0x2, 0x2, 0x2, 0xc63, 
       0x12b, 0x3, 0x2, 0x2, 0x2, 0xc64, 0xc65, 0x9, 0x28, 0x2, 0x2, 0xc65, 
       0xc6c, 0x7, 0x103, 0x2, 0x2, 0xc66, 0xc67, 0x7, 0x358, 0x2, 0x2, 
       0xc67, 0xc68, 0x5, 0x106, 0x84, 0x2, 0xc68, 0xc69, 0x7, 0x359, 0x2, 
       0x2, 0xc69, 0xc6a, 0x7, 0x103, 0x2, 0x2, 0xc6a, 0xc6c, 0x3, 0x2, 
       0x2, 0x2, 0xc6b, 0xc64, 0x3, 0x2, 0x2, 0x2, 0xc6b, 0xc66, 0x3, 0x2, 
       0x2, 0x2, 0xc6c, 0x12d, 0x3, 0x2, 0x2, 0x2, 0xc6d, 0xc73, 0x7, 0x33e, 
       0x2, 0x2, 0xc6e, 0xc6f, 0x7, 0x358, 0x2, 0x2, 0xc6f, 0xc70, 0x5, 
       0x106, 0x84, 0x2, 0xc70, 0xc71, 0x7, 0x359, 0x2, 0x2, 0xc71, 0xc73, 
       0x3, 0x2, 0x2, 0x2, 0xc72, 0xc6d, 0x3, 0x2, 0x2, 0x2, 0xc72, 0xc6e, 
       0x3, 0x2, 0x2, 0x2, 0xc73, 0x12f, 0x3, 0x2, 0x2, 0x2, 0xc74, 0xc75, 
       0x7, 0xfb, 0x2, 0x2, 0xc75, 0xc76, 0x7, 0x28, 0x2, 0x2, 0xc76, 0xc7b, 
       0x5, 0x136, 0x9c, 0x2, 0xc77, 0xc78, 0x7, 0x35a, 0x2, 0x2, 0xc78, 
       0xc7a, 0x5, 0x136, 0x9c, 0x2, 0xc79, 0xc77, 0x3, 0x2, 0x2, 0x2, 0xc7a, 
       0xc7d, 0x3, 0x2, 0x2, 0x2, 0xc7b, 0xc79, 0x3, 0x2, 0x2, 0x2, 0xc7b, 
       0xc7c, 0x3, 0x2, 0x2, 0x2, 0xc7c, 0xc89, 0x3, 0x2, 0x2, 0x2, 0xc7d, 
       0xc7b, 0x3, 0x2, 0x2, 0x2, 0xc7e, 0xc7f, 0x7, 0x28e, 0x2, 0x2, 0xc7f, 
       0xc80, 0x5, 0x106, 0x84, 0x2, 0xc80, 0xc87, 0x9, 0x29, 0x2, 0x2, 
       0xc81, 0xc82, 0x7, 0x85, 0x2, 0x2, 0xc82, 0xc83, 0x9, 0x2a, 0x2, 
       0x2, 0xc83, 0xc84, 0x5, 0x106, 0x84, 0x2, 0xc84, 0xc85, 0x9, 0x29, 
       0x2, 0x2, 0xc85, 0xc86, 0x7, 0x291, 0x2, 0x2, 0xc86, 0xc88, 0x3, 
       0x2, 0x2, 0x2, 0xc87, 0xc81, 0x3, 0x2, 0x2, 0x2, 0xc87, 0xc88, 0x3, 
       0x2, 0x2, 0x2, 0xc88, 0xc8a, 0x3, 0x2, 0x2, 0x2, 0xc89, 0xc7e, 0x3, 
       0x2, 0x2, 0x2, 0xc89, 0xc8a, 0x3, 0x2, 0x2, 0x2, 0xc8a, 0x131, 0x3, 
       0x2, 0x2, 0x2, 0xc8b, 0xc8c, 0x7, 0x8b, 0x2, 0x2, 0xc8c, 0xce4, 0x7, 
       0x24, 0x2, 0x2, 0xc8d, 0xc8e, 0x7, 0x8b, 0x2, 0x2, 0xc8e, 0xc96, 
       0x7, 0x331, 0x2, 0x2, 0xc8f, 0xc93, 0x7, 0x118, 0x2, 0x2, 0xc90, 
       0xc91, 0x7, 0x358, 0x2, 0x2, 0xc91, 0xc92, 0x7, 0x342, 0x2, 0x2, 
       0xc92, 0xc94, 0x7, 0x359, 0x2, 0x2, 0xc93, 0xc90, 0x3, 0x2, 0x2, 
       0x2, 0xc93, 0xc94, 0x3, 0x2, 0x2, 0x2, 0xc94, 0xc97, 0x3, 0x2, 0x2, 
       0x2, 0xc95, 0xc97, 0x7, 0x1b1, 0x2, 0x2, 0xc96, 0xc8f, 0x3, 0x2, 
       0x2, 0x2, 0xc96, 0xc95, 0x3, 0x2, 0x2, 0x2, 0xc97, 0xc9b, 0x3, 0x2, 
       0x2, 0x2, 0xc98, 0xc9a, 0x5, 0x134, 0x9b, 0x2, 0xc99, 0xc98, 0x3, 
       0x2, 0x2, 0x2, 0xc9a, 0xc9d, 0x3, 0x2, 0x2, 0x2, 0xc9b, 0xc99, 0x3, 
       0x2, 0x2, 0x2, 0xc9b, 0xc9c, 0x3, 0x2, 0x2, 0x2, 0xc9c, 0xca8, 0x3, 
       0x2, 0x2, 0x2, 0xc9d, 0xc9b, 0x3, 0x2, 0x2, 0x2, 0xc9e, 0xca6, 0x7, 
       0x35a, 0x2, 0x2, 0xc9f, 0xca7, 0x7, 0x332, 0x2, 0x2, 0xca0, 0xca4, 
       0x7, 0x334, 0x2, 0x2, 0xca1, 0xca2, 0x7, 0x358, 0x2, 0x2, 0xca2, 
       0xca3, 0x7, 0x342, 0x2, 0x2, 0xca3, 0xca5, 0x7, 0x359, 0x2, 0x2, 
       0xca4, 0xca1, 0x3, 0x2, 0x2, 0x2, 0xca4, 0xca5, 0x3, 0x2, 0x2, 0x2, 
       0xca5, 0xca7, 0x3, 0x2, 0x2, 0x2, 0xca6, 0xc9f, 0x3, 0x2, 0x2, 0x2, 
       0xca6, 0xca0, 0x3, 0x2, 0x2, 0x2, 0xca7, 0xca9, 0x3, 0x2, 0x2, 0x2, 
       0xca8, 0xc9e, 0x3, 0x2, 0x2, 0x2, 0xca8, 0xca9, 0x3, 0x2, 0x2, 0x2, 
       0xca9, 0xcad, 0x3, 0x2, 0x2, 0x2, 0xcaa, 0xcab, 0x7, 0x35a, 0x2, 
       0x2, 0xcab, 0xcac, 0x7, 0x201, 0x2, 0x2, 0xcac, 0xcae, 0x9, 0x2b, 
       0x2, 0x2, 0xcad, 0xcaa, 0x3, 0x2, 0x2, 0x2, 0xcad, 0xcae, 0x3, 0x2, 
       0x2, 0x2, 0xcae, 0xce4, 0x3, 0x2, 0x2, 0x2, 0xcaf, 0xcb0, 0x7, 0x8b, 
       0x2, 0x2, 0xcb0, 0xcb1, 0x7, 0x331, 0x2, 0x2, 0xcb1, 0xcb5, 0x7, 
       0x20f, 0x2, 0x2, 0xcb2, 0xcb4, 0x5, 0x134, 0x9b, 0x2, 0xcb3, 0xcb2, 
       0x3, 0x2, 0x2, 0x2, 0xcb4, 0xcb7, 0x3, 0x2, 0x2, 0x2, 0xcb5, 0xcb3, 
       0x3, 0x2, 0x2, 0x2, 0xcb5, 0xcb6, 0x3, 0x2, 0x2, 0x2, 0xcb6, 0xcba, 
       0x3, 0x2, 0x2, 0x2, 0xcb7, 0xcb5, 0x3, 0x2, 0x2, 0x2, 0xcb8, 0xcb9, 
       0x7, 0x35a, 0x2, 0x2, 0xcb9, 0xcbb, 0x7, 0x332, 0x2, 0x2, 0xcba, 
       0xcb8, 0x3, 0x2, 0x2, 0x2, 0xcba, 0xcbb, 0x3, 0x2, 0x2, 0x2, 0xcbb, 
       0xce4, 0x3, 0x2, 0x2, 0x2, 0xcbc, 0xcbd, 0x7, 0x8b, 0x2, 0x2, 0xcbd, 
       0xcbe, 0x7, 0x331, 0x2, 0x2, 0xcbe, 0xcc2, 0x7, 0x29e, 0x2, 0x2, 
       0xcbf, 0xcc0, 0x7, 0x358, 0x2, 0x2, 0xcc0, 0xcc1, 0x7, 0x342, 0x2, 
       0x2, 0xcc1, 0xcc3, 0x7, 0x359, 0x2, 0x2, 0xcc2, 0xcbf, 0x3, 0x2, 
       0x2, 0x2, 0xcc2, 0xcc3, 0x3, 0x2, 0x2, 0x2, 0xcc3, 0xcc7, 0x3, 0x2, 
       0x2, 0x2, 0xcc4, 0xcc6, 0x5, 0x134, 0x9b, 0x2, 0xcc5, 0xcc4, 0x3, 
       0x2, 0x2, 0x2, 0xcc6, 0xcc9, 0x3, 0x2, 0x2, 0x2, 0xcc7, 0xcc5, 0x3, 
       0x2, 0x2, 0x2, 0xcc7, 0xcc8, 0x3, 0x2, 0x2, 0x2, 0xcc8, 0xccd, 0x3, 
       0x2, 0x2, 0x2, 0xcc9, 0xcc7, 0x3, 0x2, 0x2, 0x2, 0xcca, 0xccb, 0x7, 
       0x35a, 0x2, 0x2, 0xccb, 0xccc, 0x7, 0x201, 0x2, 0x2, 0xccc, 0xcce, 
       0x9, 0x2b, 0x2, 0x2, 0xccd, 0xcca, 0x3, 0x2, 0x2, 0x2, 0xccd, 0xcce, 
       0x3, 0x2, 0x2, 0x2, 0xcce, 0xce4, 0x3, 0x2, 0x2, 0x2, 0xccf, 0xcd0, 
       0x7, 0x8b, 0x2, 0x2, 0xcd0, 0xcd1, 0x7, 0x242, 0x2, 0x2, 0xcd1, 0xcd9, 
       0x9, 0x2c, 0x2, 0x2, 0xcd2, 0xcd3, 0x7, 0x35a, 0x2, 0x2, 0xcd3, 0xcd7, 
       0x7, 0x2d2, 0x2, 0x2, 0xcd4, 0xcd5, 0x7, 0x358, 0x2, 0x2, 0xcd5, 
       0xcd6, 0x7, 0x342, 0x2, 0x2, 0xcd6, 0xcd8, 0x7, 0x359, 0x2, 0x2, 
       0xcd7, 0xcd4, 0x3, 0x2, 0x2, 0x2, 0xcd7, 0xcd8, 0x3, 0x2, 0x2, 0x2, 
       0xcd8, 0xcda, 0x3, 0x2, 0x2, 0x2, 0xcd9, 0xcd2, 0x3, 0x2, 0x2, 0x2, 
       0xcd9, 0xcda, 0x3, 0x2, 0x2, 0x2, 0xcda, 0xcdd, 0x3, 0x2, 0x2, 0x2, 
       0xcdb, 0xcdc, 0x7, 0x35a, 0x2, 0x2, 0xcdc, 0xcde, 0x7, 0x238, 0x2, 
       0x2, 0xcdd, 0xcdb, 0x3, 0x2, 0x2, 0x2, 0xcdd, 0xcde, 0x3, 0x2, 0x2, 
       0x2, 0xcde, 0xce1, 0x3, 0x2, 0x2, 0x2, 0xcdf, 0xce0, 0x7, 0x35a, 
       0x2, 0x2, 0xce0, 0xce2, 0x7, 0x32e, 0x2, 0x2, 0xce1, 0xcdf, 0x3, 
       0x2, 0x2, 0x2, 0xce1, 0xce2, 0x3, 0x2, 0x2, 0x2, 0xce2, 0xce4, 0x3, 
       0x2, 0x2, 0x2, 0xce3, 0xc8b, 0x3, 0x2, 0x2, 0x2, 0xce3, 0xc8d, 0x3, 
       0x2, 0x2, 0x2, 0xce3, 0xcaf, 0x3, 0x2, 0x2, 0x2, 0xce3, 0xcbc, 0x3, 
       0x2, 0x2, 0x2, 0xce3, 0xccf, 0x3, 0x2, 0x2, 0x2, 0xce4, 0x133, 0x3, 
       0x2, 0x2, 0x2, 0xce5, 0xcee, 0x7, 0x35a, 0x2, 0x2, 0xce6, 0xcef, 
       0x7, 0x1bd, 0x2, 0x2, 0xce7, 0xcef, 0x7, 0x31d, 0x2, 0x2, 0xce8, 
       0xcec, 0x7, 0x2d2, 0x2, 0x2, 0xce9, 0xcea, 0x7, 0x358, 0x2, 0x2, 
       0xcea, 0xceb, 0x7, 0x342, 0x2, 0x2, 0xceb, 0xced, 0x7, 0x359, 0x2, 
       0x2, 0xcec, 0xce9, 0x3, 0x2, 0x2, 0x2, 0xcec, 0xced, 0x3, 0x2, 0x2, 
       0x2, 0xced, 0xcef, 0x3, 0x2, 0x2, 0x2, 0xcee, 0xce6, 0x3, 0x2, 0x2, 
       0x2, 0xcee, 0xce7, 0x3, 0x2, 0x2, 0x2, 0xcee, 0xce8, 0x3, 0x2, 0x2, 
       0x2, 0xcef, 0x135, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcf2, 0x5, 0x106, 
       0x84, 0x2, 0xcf1, 0xcf3, 0x9, 0x2d, 0x2, 0x2, 0xcf2, 0xcf1, 0x3, 
       0x2, 0x2, 0x2, 0xcf2, 0xcf3, 0x3, 0x2, 0x2, 0x2, 0xcf3, 0x137, 0x3, 
       0x2, 0x2, 0x2, 0xcf4, 0xcf5, 0x5, 0x106, 0x84, 0x2, 0xcf5, 0x139, 
       0x3, 0x2, 0x2, 0x2, 0xcf6, 0xcf7, 0x7, 0xf9, 0x2, 0x2, 0xcf7, 0xcf8, 
       0x7, 0x358, 0x2, 0x2, 0xcf8, 0xcfd, 0x5, 0x13c, 0x9f, 0x2, 0xcf9, 
       0xcfa, 0x7, 0x35a, 0x2, 0x2, 0xcfa, 0xcfc, 0x5, 0x13c, 0x9f, 0x2, 
       0xcfb, 0xcf9, 0x3, 0x2, 0x2, 0x2, 0xcfc, 0xcff, 0x3, 0x2, 0x2, 0x2, 
       0xcfd, 0xcfb, 0x3, 0x2, 0x2, 0x2, 0xcfd, 0xcfe, 0x3, 0x2, 0x2, 0x2, 
       0xcfe, 0xd00, 0x3, 0x2, 0x2, 0x2, 0xcff, 0xcfd, 0x3, 0x2, 0x2, 0x2, 
       0xd00, 0xd01, 0x7, 0x359, 0x2, 0x2, 0xd01, 0x13b, 0x3, 0x2, 0x2, 
       0x2, 0xd02, 0xd03, 0x7, 0x214, 0x2, 0x2, 0xd03, 0xd30, 0x7, 0x33e, 
       0x2, 0x2, 0xd04, 0xd05, 0x9, 0x2e, 0x2, 0x2, 0xd05, 0xd30, 0x7, 0x98, 
       0x2, 0x2, 0xd06, 0xd07, 0x9, 0x2f, 0x2, 0x2, 0xd07, 0xd30, 0x7, 0x17a, 
       0x2, 0x2, 0xd08, 0xd09, 0x9, 0x30, 0x2, 0x2, 0xd09, 0xd30, 0x7, 0xb2, 
       0x2, 0x2, 0xd0a, 0xd0b, 0x7, 0x20d, 0x2, 0x2, 0xd0b, 0xd30, 0x7, 
       0x32b, 0x2, 0x2, 0xd0c, 0xd0d, 0x7, 0x21e, 0x2, 0x2, 0xd0d, 0xd30, 
       0x7, 0xfb, 0x2, 0x2, 0xd0e, 0xd30, 0x7, 0x234, 0x2, 0x2, 0xd0f, 0xd10, 
       0x7, 0x244, 0x2, 0x2, 0xd10, 0xd30, 0x7, 0x109, 0x2, 0x2, 0xd11, 
       0xd12, 0x7, 0x245, 0x2, 0x2, 0xd12, 0xd30, 0x7, 0x109, 0x2, 0x2, 
       0xd13, 0xd14, 0x7, 0x265, 0x2, 0x2, 0xd14, 0xd30, 0x7, 0x33e, 0x2, 
       0x2, 0xd15, 0xd16, 0x7, 0x266, 0x2, 0x2, 0xd16, 0xd30, 0x7, 0x33e, 
       0x2, 0x2, 0xd17, 0xd18, 0x7, 0x294, 0x2, 0x2, 0xd18, 0xd19, 0x7, 
       0x8b, 0x2, 0x2, 0xd19, 0xd1a, 0x7, 0x358, 0x2, 0x2, 0xd1a, 0xd1f, 
       0x5, 0x13e, 0xa0, 0x2, 0xd1b, 0xd1c, 0x7, 0x35a, 0x2, 0x2, 0xd1c, 
       0xd1e, 0x5, 0x13e, 0xa0, 0x2, 0xd1d, 0xd1b, 0x3, 0x2, 0x2, 0x2, 0xd1e, 
       0xd21, 0x3, 0x2, 0x2, 0x2, 0xd1f, 0xd1d, 0x3, 0x2, 0x2, 0x2, 0xd1f, 
       0xd20, 0x3, 0x2, 0x2, 0x2, 0xd20, 0xd22, 0x3, 0x2, 0x2, 0x2, 0xd21, 
       0xd1f, 0x3, 0x2, 0x2, 0x2, 0xd22, 0xd23, 0x7, 0x359, 0x2, 0x2, 0xd23, 
       0xd30, 0x3, 0x2, 0x2, 0x2, 0xd24, 0xd25, 0x7, 0x294, 0x2, 0x2, 0xd25, 
       0xd26, 0x7, 0x8b, 0x2, 0x2, 0xd26, 0xd30, 0x7, 0x321, 0x2, 0x2, 0xd27, 
       0xd28, 0x7, 0x29a, 0x2, 0x2, 0xd28, 0xd30, 0x9, 0x31, 0x2, 0x2, 0xd29, 
       0xd30, 0x7, 0x2be, 0x2, 0x2, 0xd2a, 0xd2b, 0x7, 0x2d1, 0x2, 0x2, 
       0xd2b, 0xd30, 0x7, 0x109, 0x2, 0x2, 0xd2c, 0xd2d, 0x7, 0x183, 0x2, 
       0x2, 0xd2d, 0xd2e, 0x7, 0x109, 0x2, 0x2, 0xd2e, 0xd30, 0x7, 0x342, 
       0x2, 0x2, 0xd2f, 0xd02, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd04, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd06, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd08, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd0a, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd0c, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd0e, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd0f, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd11, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd13, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd15, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd17, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd24, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd27, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd29, 0x3, 0x2, 0x2, 0x2, 0xd2f, 0xd2a, 0x3, 0x2, 
       0x2, 0x2, 0xd2f, 0xd2c, 0x3, 0x2, 0x2, 0x2, 0xd30, 0x13d, 0x3, 0x2, 
       0x2, 0x2, 0xd31, 0xd38, 0x7, 0x33d, 0x2, 0x2, 0xd32, 0xd39, 0x7, 
       0x321, 0x2, 0x2, 0xd33, 0xd36, 0x7, 0x346, 0x2, 0x2, 0xd34, 0xd37, 
       0x5, 0x1f0, 0xf9, 0x2, 0xd35, 0xd37, 0x7, 0xec, 0x2, 0x2, 0xd36, 
       0xd34, 0x3, 0x2, 0x2, 0x2, 0xd36, 0xd35, 0x3, 0x2, 0x2, 0x2, 0xd37, 
       0xd39, 0x3, 0x2, 0x2, 0x2, 0xd38, 0xd32, 0x3, 0x2, 0x2, 0x2, 0xd38, 
       0xd33, 0x3, 0x2, 0x2, 0x2, 0xd39, 0x13f, 0x3, 0x2, 0x2, 0x2, 0xd3a, 
       0xd3f, 0x5, 0x14c, 0xa7, 0x2, 0xd3b, 0xd3c, 0x7, 0x35a, 0x2, 0x2, 
       0xd3c, 0xd3e, 0x5, 0x14c, 0xa7, 0x2, 0xd3d, 0xd3b, 0x3, 0x2, 0x2, 
       0x2, 0xd3e, 0xd41, 0x3, 0x2, 0x2, 0x2, 0xd3f, 0xd3d, 0x3, 0x2, 0x2, 
       0x2, 0xd3f, 0xd40, 0x3, 0x2, 0x2, 0x2, 0xd40, 0x141, 0x3, 0x2, 0x2, 
       0x2, 0xd41, 0xd3f, 0x3, 0x2, 0x2, 0x2, 0xd42, 0xd43, 0x7, 0x358, 
       0x2, 0x2, 0xd43, 0xd48, 0x5, 0xc8, 0x65, 0x2, 0xd44, 0xd45, 0x7, 
       0x35a, 0x2, 0x2, 0xd45, 0xd47, 0x5, 0xc8, 0x65, 0x2, 0xd46, 0xd44, 
       0x3, 0x2, 0x2, 0x2, 0xd47, 0xd4a, 0x3, 0x2, 0x2, 0x2, 0xd48, 0xd46, 
       0x3, 0x2, 0x2, 0x2, 0xd48, 0xd49, 0x3, 0x2, 0x2, 0x2, 0xd49, 0xd4b, 
       0x3, 0x2, 0x2, 0x2, 0xd4a, 0xd48, 0x3, 0x2, 0x2, 0x2, 0xd4b, 0xd4c, 
       0x7, 0x359, 0x2, 0x2, 0xd4c, 0x143, 0x3, 0x2, 0x2, 0x2, 0xd4d, 0xd4e, 
       0x5, 0x1bc, 0xdf, 0x2, 0xd4e, 0xd4f, 0x7, 0x353, 0x2, 0x2, 0xd4f, 
       0xd51, 0x3, 0x2, 0x2, 0x2, 0xd50, 0xd4d, 0x3, 0x2, 0x2, 0x2, 0xd50, 
       0xd51, 0x3, 0x2, 0x2, 0x2, 0xd51, 0xd52, 0x3, 0x2, 0x2, 0x2, 0xd52, 
       0xd53, 0x7, 0x35d, 0x2, 0x2, 0xd53, 0x145, 0x3, 0x2, 0x2, 0x2, 0xd54, 
       0xd55, 0x5, 0x1bc, 0xdf, 0x2, 0xd55, 0xd56, 0x7, 0x353, 0x2, 0x2, 
       0xd56, 0xd58, 0x3, 0x2, 0x2, 0x2, 0xd57, 0xd54, 0x3, 0x2, 0x2, 0x2, 
       0xd57, 0xd58, 0x3, 0x2, 0x2, 0x2, 0xd58, 0xd5e, 0x3, 0x2, 0x2, 0x2, 
       0xd59, 0xd5f, 0x5, 0x1f4, 0xfb, 0x2, 0xd5a, 0xd5b, 0x7, 0x357, 0x2, 
       0x2, 0xd5b, 0xd5f, 0x7, 0x9c, 0x2, 0x2, 0xd5c, 0xd5d, 0x7, 0x357, 
       0x2, 0x2, 0xd5d, 0xd5f, 0x7, 0x2d6, 0x2, 0x2, 0xd5e, 0xd59, 0x3, 
       0x2, 0x2, 0x2, 0xd5e, 0xd5a, 0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd5c, 0x3, 
       0x2, 0x2, 0x2, 0xd5f, 0xd62, 0x3, 0x2, 0x2, 0x2, 0xd60, 0xd62, 0x7, 
       0xec, 0x2, 0x2, 0xd61, 0xd57, 0x3, 0x2, 0x2, 0x2, 0xd61, 0xd60, 0x3, 
       0x2, 0x2, 0x2, 0xd62, 0xd64, 0x3, 0x2, 0x2, 0x2, 0xd63, 0xd65, 0x5, 
       0x180, 0xc1, 0x2, 0xd64, 0xd63, 0x3, 0x2, 0x2, 0x2, 0xd64, 0xd65, 
       0x3, 0x2, 0x2, 0x2, 0xd65, 0x147, 0x3, 0x2, 0x2, 0x2, 0xd66, 0xd67, 
       0x5, 0x1f4, 0xfb, 0x2, 0xd67, 0xd68, 0x7, 0x353, 0x2, 0x2, 0xd68, 
       0xd69, 0x5, 0x1f4, 0xfb, 0x2, 0xd69, 0xd6b, 0x5, 0x142, 0xa2, 0x2, 
       0xd6a, 0xd6c, 0x5, 0x180, 0xc1, 0x2, 0xd6b, 0xd6a, 0x3, 0x2, 0x2, 
       0x2, 0xd6b, 0xd6c, 0x3, 0x2, 0x2, 0x2, 0xd6c, 0xd78, 0x3, 0x2, 0x2, 
       0x2, 0xd6d, 0xd6e, 0x5, 0x1f4, 0xfb, 0x2, 0xd6e, 0xd6f, 0x7, 0x35c, 
       0x2, 0x2, 0xd6f, 0xd70, 0x7, 0x35c, 0x2, 0x2, 0xd70, 0xd72, 0x5, 
       0x1f4, 0xfb, 0x2, 0xd71, 0xd73, 0x5, 0x142, 0xa2, 0x2, 0xd72, 0xd71, 
       0x3, 0x2, 0x2, 0x2, 0xd72, 0xd73, 0x3, 0x2, 0x2, 0x2, 0xd73, 0xd75, 
       0x3, 0x2, 0x2, 0x2, 0xd74, 0xd76, 0x5, 0x180, 0xc1, 0x2, 0xd75, 0xd74, 
       0x3, 0x2, 0x2, 0x2, 0xd75, 0xd76, 0x3, 0x2, 0x2, 0x2, 0xd76, 0xd78, 
       0x3, 0x2, 0x2, 0x2, 0xd77, 0xd66, 0x3, 0x2, 0x2, 0x2, 0xd77, 0xd6d, 
       0x3, 0x2, 0x2, 0x2, 0xd78, 0x149, 0x3, 0x2, 0x2, 0x2, 0xd79, 0xd7a, 
       0x5, 0x190, 0xc9, 0x2, 0xd7a, 0xd7b, 0x7, 0x346, 0x2, 0x2, 0xd7b, 
       0xd7c, 0x5, 0x106, 0x84, 0x2, 0xd7c, 0xd82, 0x3, 0x2, 0x2, 0x2, 0xd7d, 
       0xd7f, 0x5, 0x106, 0x84, 0x2, 0xd7e, 0xd80, 0x5, 0x180, 0xc1, 0x2, 
       0xd7f, 0xd7e, 0x3, 0x2, 0x2, 0x2, 0xd7f, 0xd80, 0x3, 0x2, 0x2, 0x2, 
       0xd80, 0xd82, 0x3, 0x2, 0x2, 0x2, 0xd81, 0xd79, 0x3, 0x2, 0x2, 0x2, 
       0xd81, 0xd7d, 0x3, 0x2, 0x2, 0x2, 0xd82, 0x14b, 0x3, 0x2, 0x2, 0x2, 
       0xd83, 0xd88, 0x5, 0x144, 0xa3, 0x2, 0xd84, 0xd88, 0x5, 0x146, 0xa4, 
       0x2, 0xd85, 0xd88, 0x5, 0x148, 0xa5, 0x2, 0xd86, 0xd88, 0x5, 0x14a, 
       0xa6, 0x2, 0xd87, 0xd83, 0x3, 0x2, 0x2, 0x2, 0xd87, 0xd84, 0x3, 0x2, 
       0x2, 0x2, 0xd87, 0xd85, 0x3, 0x2, 0x2, 0x2, 0xd87, 0xd86, 0x3, 0x2, 
       0x2, 0x2, 0xd88, 0x14d, 0x3, 0x2, 0x2, 0x2, 0xd89, 0xd8e, 0x5, 0x150, 
       0xa9, 0x2, 0xd8a, 0xd8b, 0x7, 0x35a, 0x2, 0x2, 0xd8b, 0xd8d, 0x5, 
       0x150, 0xa9, 0x2, 0xd8c, 0xd8a, 0x3, 0x2, 0x2, 0x2, 0xd8d, 0xd90, 
       0x3, 0x2, 0x2, 0x2, 0xd8e, 0xd8c, 0x3, 0x2, 0x2, 0x2, 0xd8e, 0xd8f, 
       0x3, 0x2, 0x2, 0x2, 0xd8f, 0x14f, 0x3, 0x2, 0x2, 0x2, 0xd90, 0xd8e, 
       0x3, 0x2, 0x2, 0x2, 0xd91, 0xd97, 0x5, 0x152, 0xaa, 0x2, 0xd92, 0xd93, 
       0x7, 0x358, 0x2, 0x2, 0xd93, 0xd94, 0x5, 0x152, 0xaa, 0x2, 0xd94, 
       0xd95, 0x7, 0x359, 0x2, 0x2, 0xd95, 0xd97, 0x3, 0x2, 0x2, 0x2, 0xd96, 
       0xd91, 0x3, 0x2, 0x2, 0x2, 0xd96, 0xd92, 0x3, 0x2, 0x2, 0x2, 0xd97, 
       0x151, 0x3, 0x2, 0x2, 0x2, 0xd98, 0xd9c, 0x5, 0x154, 0xab, 0x2, 0xd99, 
       0xd9b, 0x5, 0x15e, 0xb0, 0x2, 0xd9a, 0xd99, 0x3, 0x2, 0x2, 0x2, 0xd9b, 
       0xd9e, 0x3, 0x2, 0x2, 0x2, 0xd9c, 0xd9a, 0x3, 0x2, 0x2, 0x2, 0xd9c, 
       0xd9d, 0x3, 0x2, 0x2, 0x2, 0xd9d, 0x153, 0x3, 0x2, 0x2, 0x2, 0xd9e, 
       0xd9c, 0x3, 0x2, 0x2, 0x2, 0xd9f, 0xda1, 0x5, 0x166, 0xb4, 0x2, 0xda0, 
       0xda2, 0x5, 0x182, 0xc2, 0x2, 0xda1, 0xda0, 0x3, 0x2, 0x2, 0x2, 0xda1, 
       0xda2, 0x3, 0x2, 0x2, 0x2, 0xda2, 0xdd1, 0x3, 0x2, 0x2, 0x2, 0xda3, 
       0xda5, 0x5, 0x1ba, 0xde, 0x2, 0xda4, 0xda6, 0x5, 0x182, 0xc2, 0x2, 
       0xda5, 0xda4, 0x3, 0x2, 0x2, 0x2, 0xda5, 0xda6, 0x3, 0x2, 0x2, 0x2, 
       0xda6, 0xdd1, 0x3, 0x2, 0x2, 0x2, 0xda7, 0xda9, 0x5, 0x168, 0xb5, 
       0x2, 0xda8, 0xdaa, 0x5, 0x182, 0xc2, 0x2, 0xda9, 0xda8, 0x3, 0x2, 
       0x2, 0x2, 0xda9, 0xdaa, 0x3, 0x2, 0x2, 0x2, 0xdaa, 0xdd1, 0x3, 0x2, 
       0x2, 0x2, 0xdab, 0xdb0, 0x5, 0x16c, 0xb7, 0x2, 0xdac, 0xdae, 0x5, 
       0x182, 0xc2, 0x2, 0xdad, 0xdaf, 0x5, 0x18e, 0xc8, 0x2, 0xdae, 0xdad, 
       0x3, 0x2, 0x2, 0x2, 0xdae, 0xdaf, 0x3, 0x2, 0x2, 0x2, 0xdaf, 0xdb1, 
       0x3, 0x2, 0x2, 0x2, 0xdb0, 0xdac, 0x3, 0x2, 0x2, 0x2, 0xdb0, 0xdb1, 
       0x3, 0x2, 0x2, 0x2, 0xdb1, 0xdd1, 0x3, 0x2, 0x2, 0x2, 0xdb2, 0xdb3, 
       0x5, 0x15c, 0xaf, 0x2, 0xdb3, 0xdb4, 0x5, 0x182, 0xc2, 0x2, 0xdb4, 
       0xdd1, 0x3, 0x2, 0x2, 0x2, 0xdb5, 0xdba, 0x5, 0x16e, 0xb8, 0x2, 0xdb6, 
       0xdb8, 0x5, 0x182, 0xc2, 0x2, 0xdb7, 0xdb9, 0x5, 0x18e, 0xc8, 0x2, 
       0xdb8, 0xdb7, 0x3, 0x2, 0x2, 0x2, 0xdb8, 0xdb9, 0x3, 0x2, 0x2, 0x2, 
       0xdb9, 0xdbb, 0x3, 0x2, 0x2, 0x2, 0xdba, 0xdb6, 0x3, 0x2, 0x2, 0x2, 
       0xdba, 0xdbb, 0x3, 0x2, 0x2, 0x2, 0xdbb, 0xdd1, 0x3, 0x2, 0x2, 0x2, 
       0xdbc, 0xdbe, 0x7, 0x33d, 0x2, 0x2, 0xdbd, 0xdbf, 0x5, 0x182, 0xc2, 
       0x2, 0xdbe, 0xdbd, 0x3, 0x2, 0x2, 0x2, 0xdbe, 0xdbf, 0x3, 0x2, 0x2, 
       0x2, 0xdbf, 0xdd1, 0x3, 0x2, 0x2, 0x2, 0xdc0, 0xdc1, 0x7, 0x33d, 
       0x2, 0x2, 0xdc1, 0xdc2, 0x7, 0x353, 0x2, 0x2, 0xdc2, 0xdc7, 0x5, 
       0x16e, 0xb8, 0x2, 0xdc3, 0xdc5, 0x5, 0x182, 0xc2, 0x2, 0xdc4, 0xdc6, 
       0x5, 0x18e, 0xc8, 0x2, 0xdc5, 0xdc4, 0x3, 0x2, 0x2, 0x2, 0xdc5, 0xdc6, 
       0x3, 0x2, 0x2, 0x2, 0xdc6, 0xdc8, 0x3, 0x2, 0x2, 0x2, 0xdc7, 0xdc3, 
       0x3, 0x2, 0x2, 0x2, 0xdc7, 0xdc8, 0x3, 0x2, 0x2, 0x2, 0xdc8, 0xdd1, 
       0x3, 0x2, 0x2, 0x2, 0xdc9, 0xdd1, 0x5, 0x156, 0xac, 0x2, 0xdca, 0xdcb, 
       0x7, 0x35c, 0x2, 0x2, 0xdcb, 0xdcc, 0x7, 0x35c, 0x2, 0x2, 0xdcc, 
       0xdce, 0x5, 0x16e, 0xb8, 0x2, 0xdcd, 0xdcf, 0x5, 0x182, 0xc2, 0x2, 
       0xdce, 0xdcd, 0x3, 0x2, 0x2, 0x2, 0xdce, 0xdcf, 0x3, 0x2, 0x2, 0x2, 
       0xdcf, 0xdd1, 0x3, 0x2, 0x2, 0x2, 0xdd0, 0xd9f, 0x3, 0x2, 0x2, 0x2, 
       0xdd0, 0xda3, 0x3, 0x2, 0x2, 0x2, 0xdd0, 0xda7, 0x3, 0x2, 0x2, 0x2, 
       0xdd0, 0xdab, 0x3, 0x2, 0x2, 0x2, 0xdd0, 0xdb2, 0x3, 0x2, 0x2, 0x2, 
       0xdd0, 0xdb5, 0x3, 0x2, 0x2, 0x2, 0xdd0, 0xdbc, 0x3, 0x2, 0x2, 0x2, 
       0xdd0, 0xdc0, 0x3, 0x2, 0x2, 0x2, 0xdd0, 0xdc9, 0x3, 0x2, 0x2, 0x2, 
       0xdd0, 0xdca, 0x3, 0x2, 0x2, 0x2, 0xdd1, 0x155, 0x3, 0x2, 0x2, 0x2, 
       0xdd2, 0xdd3, 0x7, 0xf8, 0x2, 0x2, 0xdd3, 0xdd4, 0x7, 0x358, 0x2, 
       0x2, 0xdd4, 0xdd5, 0x5, 0x106, 0x84, 0x2, 0xdd5, 0xdd6, 0x7, 0x35a, 
       0x2, 0x2, 0xdd6, 0xdd9, 0x5, 0x106, 0x84, 0x2, 0xdd7, 0xdd8, 0x7, 
       0x35a, 0x2, 0x2, 0xdd8, 0xdda, 0x5, 0x106, 0x84, 0x2, 0xdd9, 0xdd7, 
       0x3, 0x2, 0x2, 0x2, 0xdd9, 0xdda, 0x3, 0x2, 0x2, 0x2, 0xdda, 0xddb, 
       0x3, 0x2, 0x2, 0x2, 0xddb, 0xde1, 0x7, 0x359, 0x2, 0x2, 0xddc, 0xddd, 
       0x7, 0x191, 0x2, 0x2, 0xddd, 0xdde, 0x7, 0x358, 0x2, 0x2, 0xdde, 
       0xddf, 0x5, 0x158, 0xad, 0x2, 0xddf, 0xde0, 0x7, 0x359, 0x2, 0x2, 
       0xde0, 0xde2, 0x3, 0x2, 0x2, 0x2, 0xde1, 0xddc, 0x3, 0x2, 0x2, 0x2, 
       0xde1, 0xde2, 0x3, 0x2, 0x2, 0x2, 0xde2, 0x157, 0x3, 0x2, 0x2, 0x2, 
       0xde3, 0xde8, 0x5, 0x15a, 0xae, 0x2, 0xde4, 0xde5, 0x7, 0x35a, 0x2, 
       0x2, 0xde5, 0xde7, 0x5, 0x15a, 0xae, 0x2, 0xde6, 0xde4, 0x3, 0x2, 
       0x2, 0x2, 0xde7, 0xdea, 0x3, 0x2, 0x2, 0x2, 0xde8, 0xde6, 0x3, 0x2, 
       0x2, 0x2, 0xde8, 0xde9, 0x3, 0x2, 0x2, 0x2, 0xde9, 0x159, 0x3, 0x2, 
       0x2, 0x2, 0xdea, 0xde8, 0x3, 0x2, 0x2, 0x2, 0xdeb, 0xdec, 0x7, 0x33f, 
       0x2, 0x2, 0xdec, 0xdee, 0x5, 0x1ec, 0xf7, 0x2, 0xded, 0xdef, 0x7, 
       0x342, 0x2, 0x2, 0xdee, 0xded, 0x3, 0x2, 0x2, 0x2, 0xdee, 0xdef, 
       0x3, 0x2, 0x2, 0x2, 0xdef, 0x15b, 0x3, 0x2, 0x2, 0x2, 0xdf0, 0xdf1, 
       0x7, 0x2f, 0x2, 0x2, 0xdf1, 0xdf2, 0x7, 0x358, 0x2, 0x2, 0xdf2, 0xdf3, 
       0x7, 0x30, 0x2, 0x2, 0xdf3, 0xdf4, 0x5, 0x1bc, 0xdf, 0x2, 0xdf4, 
       0xdf5, 0x7, 0x35a, 0x2, 0x2, 0xdf5, 0xdf6, 0x9, 0x32, 0x2, 0x2, 0xdf6, 
       0xdf7, 0x7, 0x359, 0x2, 0x2, 0xdf7, 0x15d, 0x3, 0x2, 0x2, 0x2, 0xdf8, 
       0xdfa, 0x7, 0xa7, 0x2, 0x2, 0xdf9, 0xdf8, 0x3, 0x2, 0x2, 0x2, 0xdf9, 
       0xdfa, 0x3, 0x2, 0x2, 0x2, 0xdfa, 0xe00, 0x3, 0x2, 0x2, 0x2, 0xdfb, 
       0xdfd, 0x9, 0x33, 0x2, 0x2, 0xdfc, 0xdfe, 0x7, 0xfc, 0x2, 0x2, 0xdfd, 
       0xdfc, 0x3, 0x2, 0x2, 0x2, 0xdfd, 0xdfe, 0x3, 0x2, 0x2, 0x2, 0xdfe, 
       0xe00, 0x3, 0x2, 0x2, 0x2, 0xdff, 0xdf9, 0x3, 0x2, 0x2, 0x2, 0xdff, 
       0xdfb, 0x3, 0x2, 0x2, 0x2, 0xe00, 0xe02, 0x3, 0x2, 0x2, 0x2, 0xe01, 
       0xe03, 0x9, 0x34, 0x2, 0x2, 0xe02, 0xe01, 0x3, 0x2, 0x2, 0x2, 0xe02, 
       0xe03, 0x3, 0x2, 0x2, 0x2, 0xe03, 0xe04, 0x3, 0x2, 0x2, 0x2, 0xe04, 
       0xe05, 0x7, 0xb2, 0x2, 0x2, 0xe05, 0xe06, 0x5, 0x150, 0xa9, 0x2, 
       0xe06, 0xe07, 0x7, 0xf2, 0x2, 0x2, 0xe07, 0xe08, 0x5, 0x11c, 0x8f, 
       0x2, 0xe08, 0xe1b, 0x3, 0x2, 0x2, 0x2, 0xe09, 0xe0a, 0x7, 0x4f, 0x2, 
       0x2, 0xe0a, 0xe0b, 0x7, 0xb2, 0x2, 0x2, 0xe0b, 0xe1b, 0x5, 0x150, 
       0xa9, 0x2, 0xe0c, 0xe0d, 0x7, 0x4f, 0x2, 0x2, 0xe0d, 0xe0e, 0x7, 
       0x1ac, 0x2, 0x2, 0xe0e, 0xe1b, 0x5, 0x150, 0xa9, 0x2, 0xe0f, 0xe10, 
       0x7, 0xfc, 0x2, 0x2, 0xe10, 0xe11, 0x7, 0x1ac, 0x2, 0x2, 0xe11, 0xe1b, 
       0x5, 0x150, 0xa9, 0x2, 0xe12, 0xe13, 0x7, 0x108, 0x2, 0x2, 0xe13, 
       0xe14, 0x5, 0x160, 0xb1, 0x2, 0xe14, 0xe15, 0x5, 0x182, 0xc2, 0x2, 
       0xe15, 0xe1b, 0x3, 0x2, 0x2, 0x2, 0xe16, 0xe17, 0x7, 0x17d, 0x2, 
       0x2, 0xe17, 0xe18, 0x5, 0x162, 0xb2, 0x2, 0xe18, 0xe19, 0x5, 0x182, 
       0xc2, 0x2, 0xe19, 0xe1b, 0x3, 0x2, 0x2, 0x2, 0xe1a, 0xdff, 0x3, 0x2, 
       0x2, 0x2, 0xe1a, 0xe09, 0x3, 0x2, 0x2, 0x2, 0xe1a, 0xe0c, 0x3, 0x2, 
       0x2, 0x2, 0xe1a, 0xe0f, 0x3, 0x2, 0x2, 0x2, 0xe1a, 0xe12, 0x3, 0x2, 
       0x2, 0x2, 0xe1a, 0xe16, 0x3, 0x2, 0x2, 0x2, 0xe1b, 0x15f, 0x3, 0x2, 
       0x2, 0x2, 0xe1c, 0xe1d, 0x7, 0x358, 0x2, 0x2, 0xe1d, 0xe1e, 0x5, 
       0x198, 0xcd, 0x2, 0xe1e, 0xe1f, 0x7, 0x8b, 0x2, 0x2, 0xe1f, 0xe20, 
       0x5, 0x1c8, 0xe5, 0x2, 0xe20, 0xe21, 0x7, 0xa1, 0x2, 0x2, 0xe21, 
       0xe22, 0x5, 0x18e, 0xc8, 0x2, 0xe22, 0xe23, 0x7, 0x359, 0x2, 0x2, 
       0xe23, 0x161, 0x3, 0x2, 0x2, 0x2, 0xe24, 0xe25, 0x7, 0x358, 0x2, 
       0x2, 0xe25, 0xe26, 0x5, 0x106, 0x84, 0x2, 0xe26, 0xe27, 0x7, 0x8b, 
       0x2, 0x2, 0xe27, 0xe28, 0x5, 0x1c8, 0xe5, 0x2, 0xe28, 0xe29, 0x7, 
       0xa1, 0x2, 0x2, 0xe29, 0xe2a, 0x7, 0x358, 0x2, 0x2, 0xe2a, 0xe2b, 
       0x5, 0x164, 0xb3, 0x2, 0xe2b, 0xe2c, 0x7, 0x359, 0x2, 0x2, 0xe2c, 
       0xe2d, 0x7, 0x359, 0x2, 0x2, 0xe2d, 0x163, 0x3, 0x2, 0x2, 0x2, 0xe2e, 
       0xe33, 0x5, 0x1c8, 0xe5, 0x2, 0xe2f, 0xe30, 0x7, 0x35a, 0x2, 0x2, 
       0xe30, 0xe32, 0x5, 0x1c8, 0xe5, 0x2, 0xe31, 0xe2f, 0x3, 0x2, 0x2, 
       0x2, 0xe32, 0xe35, 0x3, 0x2, 0x2, 0x2, 0xe33, 0xe31, 0x3, 0x2, 0x2, 
       0x2, 0xe33, 0xe34, 0x3, 0x2, 0x2, 0x2, 0xe34, 0x165, 0x3, 0x2, 0x2, 
       0x2, 0xe35, 0xe33, 0x3, 0x2, 0x2, 0x2, 0xe36, 0xe38, 0x5, 0x1bc, 
       0xdf, 0x2, 0xe37, 0xe39, 0x5, 0x186, 0xc4, 0x2, 0xe38, 0xe37, 0x3, 
       0x2, 0x2, 0x2, 0xe38, 0xe39, 0x3, 0x2, 0x2, 0x2, 0xe39, 0x167, 0x3, 
       0x2, 0x2, 0x2, 0xe3a, 0xe3b, 0x7, 0xf7, 0x2, 0x2, 0xe3b, 0xe3c, 0x7, 
       0x358, 0x2, 0x2, 0xe3c, 0xe3d, 0x7, 0x342, 0x2, 0x2, 0xe3d, 0xe3e, 
       0x7, 0x35a, 0x2, 0x2, 0xe3e, 0xe3f, 0x7, 0x342, 0x2, 0x2, 0xe3f, 
       0xe40, 0x7, 0x35a, 0x2, 0x2, 0xe40, 0xe41, 0x7, 0x342, 0x2, 0x2, 
       0xe41, 0xe55, 0x7, 0x359, 0x2, 0x2, 0xe42, 0xe43, 0x7, 0xf7, 0x2, 
       0x2, 0xe43, 0xe44, 0x7, 0x358, 0x2, 0x2, 0xe44, 0xe45, 0x7, 0x27, 
       0x2, 0x2, 0xe45, 0xe46, 0x7, 0x342, 0x2, 0x2, 0xe46, 0xe50, 0x7, 
       0x35a, 0x2, 0x2, 0xe47, 0xe4c, 0x5, 0x16a, 0xb6, 0x2, 0xe48, 0xe49, 
       0x7, 0x35a, 0x2, 0x2, 0xe49, 0xe4b, 0x5, 0x16a, 0xb6, 0x2, 0xe4a, 
       0xe48, 0x3, 0x2, 0x2, 0x2, 0xe4b, 0xe4e, 0x3, 0x2, 0x2, 0x2, 0xe4c, 
       0xe4a, 0x3, 0x2, 0x2, 0x2, 0xe4c, 0xe4d, 0x3, 0x2, 0x2, 0x2, 0xe4d, 
       0xe51, 0x3, 0x2, 0x2, 0x2, 0xe4e, 0xe4c, 0x3, 0x2, 0x2, 0x2, 0xe4f, 
       0xe51, 0x5, 0x1f4, 0xfb, 0x2, 0xe50, 0xe47, 0x3, 0x2, 0x2, 0x2, 0xe50, 
       0xe4f, 0x3, 0x2, 0x2, 0x2, 0xe51, 0xe52, 0x3, 0x2, 0x2, 0x2, 0xe52, 
       0xe53, 0x7, 0x359, 0x2, 0x2, 0xe53, 0xe55, 0x3, 0x2, 0x2, 0x2, 0xe54, 
       0xe3a, 0x3, 0x2, 0x2, 0x2, 0xe54, 0xe42, 0x3, 0x2, 0x2, 0x2, 0xe55, 
       0x169, 0x3, 0x2, 0x2, 0x2, 0xe56, 0xe57, 0x5, 0x1f4, 0xfb, 0x2, 0xe57, 
       0xe58, 0x7, 0x346, 0x2, 0x2, 0xe58, 0xe59, 0x9, 0xc, 0x2, 0x2, 0xe59, 
       0x16b, 0x3, 0x2, 0x2, 0x2, 0xe5a, 0xe65, 0x5, 0x112, 0x8a, 0x2, 0xe5b, 
       0xe5c, 0x7, 0x358, 0x2, 0x2, 0xe5c, 0xe5d, 0x5, 0x112, 0x8a, 0x2, 
       0xe5d, 0xe5e, 0x7, 0x359, 0x2, 0x2, 0xe5e, 0xe65, 0x3, 0x2, 0x2, 
       0x2, 0xe5f, 0xe65, 0x5, 0x192, 0xca, 0x2, 0xe60, 0xe61, 0x7, 0x358, 
       0x2, 0x2, 0xe61, 0xe62, 0x5, 0x192, 0xca, 0x2, 0xe62, 0xe63, 0x7, 
       0x359, 0x2, 0x2, 0xe63, 0xe65, 0x3, 0x2, 0x2, 0x2, 0xe64, 0xe5a, 
       0x3, 0x2, 0x2, 0x2, 0xe64, 0xe5b, 0x3, 0x2, 0x2, 0x2, 0xe64, 0xe5f, 
       0x3, 0x2, 0x2, 0x2, 0xe64, 0xe60, 0x3, 0x2, 0x2, 0x2, 0xe65, 0x16d, 
       0x3, 0x2, 0x2, 0x2, 0xe66, 0xe67, 0x7, 0x1be, 0x2, 0x2, 0xe67, 0xe68, 
       0x7, 0x358, 0x2, 0x2, 0xe68, 0xe69, 0x7, 0x35d, 0x2, 0x2, 0xe69, 
       0xef9, 0x7, 0x359, 0x2, 0x2, 0xe6a, 0xe6b, 0x7, 0x1c6, 0x2, 0x2, 
       0xe6b, 0xe6c, 0x7, 0x358, 0x2, 0x2, 0xe6c, 0xe6d, 0x5, 0x106, 0x84, 
       0x2, 0xe6d, 0xe6e, 0x7, 0x11, 0x2, 0x2, 0xe6e, 0xe6f, 0x5, 0x1ec, 
       0xf7, 0x2, 0xe6f, 0xe70, 0x7, 0x359, 0x2, 0x2, 0xe70, 0xef9, 0x3, 
       0x2, 0x2, 0x2, 0xe71, 0xe72, 0x7, 0x4c, 0x2, 0x2, 0xe72, 0xe73, 0x7, 
       0x358, 0x2, 0x2, 0xe73, 0xe74, 0x5, 0x1ec, 0xf7, 0x2, 0xe74, 0xe75, 
       0x7, 0x35a, 0x2, 0x2, 0xe75, 0xe78, 0x5, 0x106, 0x84, 0x2, 0xe76, 
       0xe77, 0x7, 0x35a, 0x2, 0x2, 0xe77, 0xe79, 0x5, 0x106, 0x84, 0x2, 
       0xe78, 0xe76, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe79, 0x3, 0x2, 0x2, 0x2, 
       0xe79, 0xe7a, 0x3, 0x2, 0x2, 0x2, 0xe7a, 0xe7b, 0x7, 0x359, 0x2, 
       0x2, 0xe7b, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xe7c, 0xe7d, 0x7, 0x1cb, 
       0x2, 0x2, 0xe7d, 0xe7e, 0x7, 0x358, 0x2, 0x2, 0xe7e, 0xe7f, 0x7, 
       0x35d, 0x2, 0x2, 0xe7f, 0xef9, 0x7, 0x359, 0x2, 0x2, 0xe80, 0xe81, 
       0x7, 0x3b, 0x2, 0x2, 0xe81, 0xe82, 0x7, 0x358, 0x2, 0x2, 0xe82, 0xe83, 
       0x5, 0x194, 0xcb, 0x2, 0xe83, 0xe84, 0x7, 0x359, 0x2, 0x2, 0xe84, 
       0xef9, 0x3, 0x2, 0x2, 0x2, 0xe85, 0xef9, 0x7, 0x53, 0x2, 0x2, 0xe86, 
       0xef9, 0x7, 0x54, 0x2, 0x2, 0xe87, 0xe88, 0x7, 0x1e4, 0x2, 0x2, 0xe88, 
       0xe89, 0x7, 0x358, 0x2, 0x2, 0xe89, 0xe8a, 0x7, 0x33f, 0x2, 0x2, 
       0xe8a, 0xe8b, 0x7, 0x35a, 0x2, 0x2, 0xe8b, 0xe8c, 0x5, 0x106, 0x84, 
       0x2, 0xe8c, 0xe8d, 0x7, 0x35a, 0x2, 0x2, 0xe8d, 0xe8e, 0x5, 0x106, 
       0x84, 0x2, 0xe8e, 0xe8f, 0x7, 0x359, 0x2, 0x2, 0xe8f, 0xef9, 0x3, 
       0x2, 0x2, 0x2, 0xe90, 0xe91, 0x7, 0x1e5, 0x2, 0x2, 0xe91, 0xe92, 
       0x7, 0x358, 0x2, 0x2, 0xe92, 0xe93, 0x7, 0x33f, 0x2, 0x2, 0xe93, 
       0xe94, 0x7, 0x35a, 0x2, 0x2, 0xe94, 0xe95, 0x5, 0x106, 0x84, 0x2, 
       0xe95, 0xe96, 0x7, 0x35a, 0x2, 0x2, 0xe96, 0xe97, 0x5, 0x106, 0x84, 
       0x2, 0xe97, 0xe98, 0x7, 0x359, 0x2, 0x2, 0xe98, 0xef9, 0x3, 0x2, 
       0x2, 0x2, 0xe99, 0xe9a, 0x7, 0x1e6, 0x2, 0x2, 0xe9a, 0xe9b, 0x7, 
       0x358, 0x2, 0x2, 0xe9b, 0xe9c, 0x7, 0x33f, 0x2, 0x2, 0xe9c, 0xe9d, 
       0x7, 0x35a, 0x2, 0x2, 0xe9d, 0xe9e, 0x5, 0x106, 0x84, 0x2, 0xe9e, 
       0xe9f, 0x7, 0x359, 0x2, 0x2, 0xe9f, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xea0, 
       0xea1, 0x7, 0x1e7, 0x2, 0x2, 0xea1, 0xea2, 0x7, 0x358, 0x2, 0x2, 
       0xea2, 0xea3, 0x7, 0x33f, 0x2, 0x2, 0xea3, 0xea4, 0x7, 0x35a, 0x2, 
       0x2, 0xea4, 0xea5, 0x5, 0x106, 0x84, 0x2, 0xea5, 0xea6, 0x7, 0x359, 
       0x2, 0x2, 0xea6, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xea7, 0xea8, 0x7, 0x226, 
       0x2, 0x2, 0xea8, 0xea9, 0x7, 0x358, 0x2, 0x2, 0xea9, 0xef9, 0x7, 
       0x359, 0x2, 0x2, 0xeaa, 0xeab, 0x7, 0x227, 0x2, 0x2, 0xeab, 0xeac, 
       0x7, 0x358, 0x2, 0x2, 0xeac, 0xef9, 0x7, 0x359, 0x2, 0x2, 0xead, 
       0xeae, 0x7, 0x9c, 0x2, 0x2, 0xeae, 0xeaf, 0x7, 0x358, 0x2, 0x2, 0xeaf, 
       0xeb2, 0x5, 0x1ec, 0xf7, 0x2, 0xeb0, 0xeb1, 0x7, 0x35a, 0x2, 0x2, 
       0xeb1, 0xeb3, 0x7, 0x33e, 0x2, 0x2, 0xeb2, 0xeb0, 0x3, 0x2, 0x2, 
       0x2, 0xeb2, 0xeb3, 0x3, 0x2, 0x2, 0x2, 0xeb3, 0xeb6, 0x3, 0x2, 0x2, 
       0x2, 0xeb4, 0xeb5, 0x7, 0x35a, 0x2, 0x2, 0xeb5, 0xeb7, 0x7, 0x33e, 
       0x2, 0x2, 0xeb6, 0xeb4, 0x3, 0x2, 0x2, 0x2, 0xeb6, 0xeb7, 0x3, 0x2, 
       0x2, 0x2, 0xeb7, 0xeb8, 0x3, 0x2, 0x2, 0x2, 0xeb8, 0xeb9, 0x7, 0x359, 
       0x2, 0x2, 0xeb9, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xeba, 0xef9, 0x7, 0x26d, 
       0x2, 0x2, 0xebb, 0xebc, 0x7, 0xed, 0x2, 0x2, 0xebc, 0xebd, 0x7, 0x358, 
       0x2, 0x2, 0xebd, 0xebe, 0x5, 0x106, 0x84, 0x2, 0xebe, 0xebf, 0x7, 
       0x35a, 0x2, 0x2, 0xebf, 0xec0, 0x5, 0x106, 0x84, 0x2, 0xec0, 0xec1, 
       0x7, 0x359, 0x2, 0x2, 0xec1, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xec2, 0xec3, 
       0x7, 0x301, 0x2, 0x2, 0xec3, 0xec4, 0x7, 0x358, 0x2, 0x2, 0xec4, 
       0xec5, 0x5, 0x106, 0x84, 0x2, 0xec5, 0xec6, 0x7, 0x35a, 0x2, 0x2, 
       0xec6, 0xec7, 0x7, 0x33e, 0x2, 0x2, 0xec7, 0xec8, 0x7, 0x35a, 0x2, 
       0x2, 0xec8, 0xec9, 0x7, 0x33e, 0x2, 0x2, 0xec9, 0xeca, 0x7, 0x35a, 
       0x2, 0x2, 0xeca, 0xecb, 0x5, 0x106, 0x84, 0x2, 0xecb, 0xecc, 0x7, 
       0x359, 0x2, 0x2, 0xecc, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xecd, 0xef9, 
       0x7, 0x14c, 0x2, 0x2, 0xece, 0xef9, 0x7, 0x168, 0x2, 0x2, 0xecf, 
       0xed0, 0x7, 0xb0, 0x2, 0x2, 0xed0, 0xed1, 0x7, 0x358, 0x2, 0x2, 0xed1, 
       0xed2, 0x5, 0x106, 0x84, 0x2, 0xed2, 0xed3, 0x7, 0x35a, 0x2, 0x2, 
       0xed3, 0xed4, 0x5, 0x106, 0x84, 0x2, 0xed4, 0xed5, 0x7, 0x359, 0x2, 
       0x2, 0xed5, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xed6, 0xef9, 0x5, 0x170, 
       0xb9, 0x2, 0xed7, 0xed8, 0x7, 0xa0, 0x2, 0x2, 0xed8, 0xed9, 0x7, 
       0x358, 0x2, 0x2, 0xed9, 0xeda, 0x5, 0x11c, 0x8f, 0x2, 0xeda, 0xedb, 
       0x7, 0x35a, 0x2, 0x2, 0xedb, 0xedc, 0x5, 0x106, 0x84, 0x2, 0xedc, 
       0xedd, 0x7, 0x35a, 0x2, 0x2, 0xedd, 0xede, 0x5, 0x106, 0x84, 0x2, 
       0xede, 0xedf, 0x7, 0x359, 0x2, 0x2, 0xedf, 0xef9, 0x3, 0x2, 0x2, 
       0x2, 0xee0, 0xef9, 0x5, 0x196, 0xcc, 0x2, 0xee1, 0xef9, 0x5, 0x198, 
       0xcd, 0x2, 0xee2, 0xef9, 0x5, 0x19a, 0xce, 0x2, 0xee3, 0xee4, 0x5, 
       0x1d8, 0xed, 0x2, 0xee4, 0xee6, 0x7, 0x358, 0x2, 0x2, 0xee5, 0xee7, 
       0x5, 0x194, 0xcb, 0x2, 0xee6, 0xee5, 0x3, 0x2, 0x2, 0x2, 0xee6, 0xee7, 
       0x3, 0x2, 0x2, 0x2, 0xee7, 0xee8, 0x3, 0x2, 0x2, 0x2, 0xee8, 0xee9, 
       0x7, 0x359, 0x2, 0x2, 0xee9, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xeea, 0xeeb, 
       0x7, 0x300, 0x2, 0x2, 0xeeb, 0xeec, 0x7, 0x358, 0x2, 0x2, 0xeec, 
       0xeed, 0x5, 0x106, 0x84, 0x2, 0xeed, 0xeee, 0x7, 0x35a, 0x2, 0x2, 
       0xeee, 0xeef, 0x5, 0x106, 0x84, 0x2, 0xeef, 0xef6, 0x7, 0x359, 0x2, 
       0x2, 0xef0, 0xef1, 0x7, 0x192, 0x2, 0x2, 0xef1, 0xef2, 0x7, 0x98, 
       0x2, 0x2, 0xef2, 0xef3, 0x7, 0x358, 0x2, 0x2, 0xef3, 0xef4, 0x5, 
       0x130, 0x99, 0x2, 0xef4, 0xef5, 0x7, 0x359, 0x2, 0x2, 0xef5, 0xef7, 
       0x3, 0x2, 0x2, 0x2, 0xef6, 0xef0, 0x3, 0x2, 0x2, 0x2, 0xef6, 0xef7, 
       0x3, 0x2, 0x2, 0x2, 0xef7, 0xef9, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xe66, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xe6a, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xe71, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xe7c, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xe80, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xe85, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xe86, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xe87, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xe90, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xe99, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xea0, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xea7, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xeaa, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xead, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xeba, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xebb, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xec2, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xecd, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xece, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xecf, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xed6, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xed7, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xee0, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xee1, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xee2, 
       0x3, 0x2, 0x2, 0x2, 0xef8, 0xee3, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xeea, 
       0x3, 0x2, 0x2, 0x2, 0xef9, 0x16f, 0x3, 0x2, 0x2, 0x2, 0xefa, 0xf00, 
       0x5, 0x172, 0xba, 0x2, 0xefb, 0xf00, 0x5, 0x174, 0xbb, 0x2, 0xefc, 
       0xf00, 0x5, 0x176, 0xbc, 0x2, 0xefd, 0xf00, 0x5, 0x178, 0xbd, 0x2, 
       0xefe, 0xf00, 0x5, 0x17a, 0xbe, 0x2, 0xeff, 0xefa, 0x3, 0x2, 0x2, 
       0x2, 0xeff, 0xefb, 0x3, 0x2, 0x2, 0x2, 0xeff, 0xefc, 0x3, 0x2, 0x2, 
       0x2, 0xeff, 0xefd, 0x3, 0x2, 0x2, 0x2, 0xeff, 0xefe, 0x3, 0x2, 0x2, 
       0x2, 0xf00, 0x171, 0x3, 0x2, 0x2, 0x2, 0xf01, 0xf06, 0x7, 0x33d, 
       0x2, 0x2, 0xf02, 0xf06, 0x7, 0x33f, 0x2, 0x2, 0xf03, 0xf06, 0x7, 
       0x77, 0x2, 0x2, 0xf04, 0xf06, 0x5, 0x174, 0xbb, 0x2, 0xf05, 0xf01, 
       0x3, 0x2, 0x2, 0x2, 0xf05, 0xf02, 0x3, 0x2, 0x2, 0x2, 0xf05, 0xf03, 
       0x3, 0x2, 0x2, 0x2, 0xf05, 0xf04, 0x3, 0x2, 0x2, 0x2, 0xf06, 0xf07, 
       0x3, 0x2, 0x2, 0x2, 0xf07, 0xf08, 0x7, 0x353, 0x2, 0x2, 0xf08, 0xf09, 
       0x7, 0x327, 0x2, 0x2, 0xf09, 0xf0a, 0x7, 0x358, 0x2, 0x2, 0xf0a, 
       0xf0b, 0x7, 0x342, 0x2, 0x2, 0xf0b, 0xf0c, 0x7, 0x35a, 0x2, 0x2, 
       0xf0c, 0xf0d, 0x7, 0x342, 0x2, 0x2, 0xf0d, 0xf2d, 0x7, 0x359, 0x2, 
       0x2, 0xf0e, 0xf13, 0x7, 0x33d, 0x2, 0x2, 0xf0f, 0xf13, 0x7, 0x33f, 
       0x2, 0x2, 0xf10, 0xf13, 0x7, 0x77, 0x2, 0x2, 0xf11, 0xf13, 0x5, 0x174, 
       0xbb, 0x2, 0xf12, 0xf0e, 0x3, 0x2, 0x2, 0x2, 0xf12, 0xf0f, 0x3, 0x2, 
       0x2, 0x2, 0xf12, 0xf10, 0x3, 0x2, 0x2, 0x2, 0xf12, 0xf11, 0x3, 0x2, 
       0x2, 0x2, 0xf13, 0xf14, 0x3, 0x2, 0x2, 0x2, 0xf14, 0xf15, 0x7, 0x353, 
       0x2, 0x2, 0xf15, 0xf16, 0x7, 0x2d4, 0x2, 0x2, 0xf16, 0xf17, 0x7, 
       0x353, 0x2, 0x2, 0xf17, 0xf18, 0x7, 0x327, 0x2, 0x2, 0xf18, 0xf19, 
       0x7, 0x358, 0x2, 0x2, 0xf19, 0xf1a, 0x7, 0x342, 0x2, 0x2, 0xf1a, 
       0xf1b, 0x7, 0x35a, 0x2, 0x2, 0xf1b, 0xf1c, 0x7, 0x342, 0x2, 0x2, 
       0xf1c, 0xf2d, 0x7, 0x359, 0x2, 0x2, 0xf1d, 0xf22, 0x7, 0x33d, 0x2, 
       0x2, 0xf1e, 0xf22, 0x7, 0x33f, 0x2, 0x2, 0xf1f, 0xf22, 0x7, 0x77, 
       0x2, 0x2, 0xf20, 0xf22, 0x5, 0x174, 0xbb, 0x2, 0xf21, 0xf1d, 0x3, 
       0x2, 0x2, 0x2, 0xf21, 0xf1e, 0x3, 0x2, 0x2, 0x2, 0xf21, 0xf1f, 0x3, 
       0x2, 0x2, 0x2, 0xf21, 0xf20, 0x3, 0x2, 0x2, 0x2, 0xf22, 0xf23, 0x3, 
       0x2, 0x2, 0x2, 0xf23, 0xf24, 0x7, 0x353, 0x2, 0x2, 0xf24, 0xf25, 
       0x7, 0xff, 0x2, 0x2, 0xf25, 0xf26, 0x7, 0x353, 0x2, 0x2, 0xf26, 0xf27, 
       0x7, 0x327, 0x2, 0x2, 0xf27, 0xf28, 0x7, 0x358, 0x2, 0x2, 0xf28, 
       0xf29, 0x7, 0x342, 0x2, 0x2, 0xf29, 0xf2a, 0x7, 0x35a, 0x2, 0x2, 
       0xf2a, 0xf2b, 0x7, 0x342, 0x2, 0x2, 0xf2b, 0xf2d, 0x7, 0x359, 0x2, 
       0x2, 0xf2c, 0xf05, 0x3, 0x2, 0x2, 0x2, 0xf2c, 0xf12, 0x3, 0x2, 0x2, 
       0x2, 0xf2c, 0xf21, 0x3, 0x2, 0x2, 0x2, 0xf2d, 0x173, 0x3, 0x2, 0x2, 
       0x2, 0xf2e, 0xf32, 0x7, 0x33d, 0x2, 0x2, 0xf2f, 0xf32, 0x7, 0x33f, 
       0x2, 0x2, 0xf30, 0xf32, 0x5, 0x1ba, 0xde, 0x2, 0xf31, 0xf2e, 0x3, 
       0x2, 0x2, 0x2, 0xf31, 0xf2f, 0x3, 0x2, 0x2, 0x2, 0xf31, 0xf30, 0x3, 
       0x2, 0x2, 0x2, 0xf32, 0xf33, 0x3, 0x2, 0x2, 0x2, 0xf33, 0xf34, 0x7, 
       0x353, 0x2, 0x2, 0xf34, 0xf35, 0x7, 0x2ae, 0x2, 0x2, 0xf35, 0xf36, 
       0x7, 0x358, 0x2, 0x2, 0xf36, 0xf37, 0x7, 0x342, 0x2, 0x2, 0xf37, 
       0xf45, 0x7, 0x359, 0x2, 0x2, 0xf38, 0xf3c, 0x7, 0x33d, 0x2, 0x2, 
       0xf39, 0xf3c, 0x7, 0x33f, 0x2, 0x2, 0xf3a, 0xf3c, 0x5, 0x1ba, 0xde, 
       0x2, 0xf3b, 0xf38, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf39, 0x3, 0x2, 0x2, 
       0x2, 0xf3b, 0xf3a, 0x3, 0x2, 0x2, 0x2, 0xf3c, 0xf3d, 0x3, 0x2, 0x2, 
       0x2, 0xf3d, 0xf3e, 0x7, 0x353, 0x2, 0x2, 0xf3e, 0xf3f, 0x7, 0x2d4, 
       0x2, 0x2, 0xf3f, 0xf40, 0x7, 0x353, 0x2, 0x2, 0xf40, 0xf41, 0x7, 
       0x2ae, 0x2, 0x2, 0xf41, 0xf42, 0x7, 0x358, 0x2, 0x2, 0xf42, 0xf43, 
       0x7, 0x342, 0x2, 0x2, 0xf43, 0xf45, 0x7, 0x359, 0x2, 0x2, 0xf44, 
       0xf31, 0x3, 0x2, 0x2, 0x2, 0xf44, 0xf3b, 0x3, 0x2, 0x2, 0x2, 0xf45, 
       0x175, 0x3, 0x2, 0x2, 0x2, 0xf46, 0xf47, 0x9, 0x35, 0x2, 0x2, 0xf47, 
       0xf48, 0x7, 0x353, 0x2, 0x2, 0xf48, 0xf49, 0x7, 0x20c, 0x2, 0x2, 
       0xf49, 0xf4a, 0x7, 0x358, 0x2, 0x2, 0xf4a, 0xf4b, 0x7, 0x342, 0x2, 
       0x2, 0xf4b, 0xf4c, 0x7, 0x359, 0x2, 0x2, 0xf4c, 0x177, 0x3, 0x2, 
       0x2, 0x2, 0xf4d, 0xf4e, 0x9, 0x35, 0x2, 0x2, 0xf4e, 0xf4f, 0x7, 0x353, 
       0x2, 0x2, 0xf4f, 0xf50, 0x7, 0x275, 0x2, 0x2, 0xf50, 0xf51, 0x7, 
       0x358, 0x2, 0x2, 0xf51, 0xf52, 0x7, 0x342, 0x2, 0x2, 0xf52, 0xf53, 
       0x7, 0x359, 0x2, 0x2, 0xf53, 0x179, 0x3, 0x2, 0x2, 0x2, 0xf54, 0xf55, 
       0x9, 0x35, 0x2, 0x2, 0xf55, 0xf56, 0x7, 0x353, 0x2, 0x2, 0xf56, 0xf57, 
       0x7, 0x282, 0x2, 0x2, 0xf57, 0xf58, 0x7, 0x358, 0x2, 0x2, 0xf58, 
       0xf59, 0x7, 0x342, 0x2, 0x2, 0xf59, 0xf5a, 0x7, 0x359, 0x2, 0x2, 
       0xf5a, 0x17b, 0x3, 0x2, 0x2, 0x2, 0xf5b, 0xf5c, 0x7, 0x18d, 0x2, 
       0x2, 0xf5c, 0xf5d, 0x5, 0x106, 0x84, 0x2, 0xf5d, 0xf5e, 0x7, 0x16f, 
       0x2, 0x2, 0xf5e, 0xf5f, 0x5, 0x106, 0x84, 0x2, 0xf5f, 0x17d, 0x3, 
       0x2, 0x2, 0x2, 0xf60, 0xf61, 0x7, 0x18d, 0x2, 0x2, 0xf61, 0xf62, 
       0x5, 0x11c, 0x8f, 0x2, 0xf62, 0xf63, 0x7, 0x16f, 0x2, 0x2, 0xf63, 
       0xf64, 0x5, 0x106, 0x84, 0x2, 0xf64, 0x17f, 0x3, 0x2, 0x2, 0x2, 0xf65, 
       0xf67, 0x7, 0x11, 0x2, 0x2, 0xf66, 0xf65, 0x3, 0x2, 0x2, 0x2, 0xf66, 
       0xf67, 0x3, 0x2, 0x2, 0x2, 0xf67, 0xf68, 0x3, 0x2, 0x2, 0x2, 0xf68, 
       0xf69, 0x5, 0x190, 0xc9, 0x2, 0xf69, 0x181, 0x3, 0x2, 0x2, 0x2, 0xf6a, 
       0xf6c, 0x7, 0x11, 0x2, 0x2, 0xf6b, 0xf6a, 0x3, 0x2, 0x2, 0x2, 0xf6b, 
       0xf6c, 0x3, 0x2, 0x2, 0x2, 0xf6c, 0xf6d, 0x3, 0x2, 0x2, 0x2, 0xf6d, 
       0xf6e, 0x5, 0x184, 0xc3, 0x2, 0xf6e, 0x183, 0x3, 0x2, 0x2, 0x2, 0xf6f, 
       0xf71, 0x5, 0x1f4, 0xfb, 0x2, 0xf70, 0xf72, 0x5, 0x186, 0xc4, 0x2, 
       0xf71, 0xf70, 0x3, 0x2, 0x2, 0x2, 0xf71, 0xf72, 0x3, 0x2, 0x2, 0x2, 
       0xf72, 0x185, 0x3, 0x2, 0x2, 0x2, 0xf73, 0xf75, 0x7, 0x191, 0x2, 
       0x2, 0xf74, 0xf73, 0x3, 0x2, 0x2, 0x2, 0xf74, 0xf75, 0x3, 0x2, 0x2, 
       0x2, 0xf75, 0xf76, 0x3, 0x2, 0x2, 0x2, 0xf76, 0xf77, 0x7, 0x358, 
       0x2, 0x2, 0xf77, 0xf7e, 0x5, 0x18a, 0xc6, 0x2, 0xf78, 0xf7a, 0x7, 
       0x35a, 0x2, 0x2, 0xf79, 0xf78, 0x3, 0x2, 0x2, 0x2, 0xf79, 0xf7a, 
       0x3, 0x2, 0x2, 0x2, 0xf7a, 0xf7b, 0x3, 0x2, 0x2, 0x2, 0xf7b, 0xf7d, 
       0x5, 0x18a, 0xc6, 0x2, 0xf7c, 0xf79, 0x3, 0x2, 0x2, 0x2, 0xf7d, 0xf80, 
       0x3, 0x2, 0x2, 0x2, 0xf7e, 0xf7c, 0x3, 0x2, 0x2, 0x2, 0xf7e, 0xf7f, 
       0x3, 0x2, 0x2, 0x2, 0xf7f, 0xf81, 0x3, 0x2, 0x2, 0x2, 0xf80, 0xf7e, 
       0x3, 0x2, 0x2, 0x2, 0xf81, 0xf82, 0x7, 0x359, 0x2, 0x2, 0xf82, 0x187, 
       0x3, 0x2, 0x2, 0x2, 0xf83, 0xf84, 0x7, 0x191, 0x2, 0x2, 0xf84, 0xf85, 
       0x7, 0x358, 0x2, 0x2, 0xf85, 0xf8c, 0x5, 0x18a, 0xc6, 0x2, 0xf86, 
       0xf88, 0x7, 0x35a, 0x2, 0x2, 0xf87, 0xf86, 0x3, 0x2, 0x2, 0x2, 0xf87, 
       0xf88, 0x3, 0x2, 0x2, 0x2, 0xf88, 0xf89, 0x3, 0x2, 0x2, 0x2, 0xf89, 
       0xf8b, 0x5, 0x18a, 0xc6, 0x2, 0xf8a, 0xf87, 0x3, 0x2, 0x2, 0x2, 0xf8b, 
       0xf8e, 0x3, 0x2, 0x2, 0x2, 0xf8c, 0xf8a, 0x3, 0x2, 0x2, 0x2, 0xf8c, 
       0xf8d, 0x3, 0x2, 0x2, 0x2, 0xf8d, 0xf8f, 0x3, 0x2, 0x2, 0x2, 0xf8e, 
       0xf8c, 0x3, 0x2, 0x2, 0x2, 0xf8f, 0xf90, 0x7, 0x359, 0x2, 0x2, 0xf90, 
       0x189, 0x3, 0x2, 0x2, 0x2, 0xf91, 0xf93, 0x7, 0x283, 0x2, 0x2, 0xf92, 
       0xf91, 0x3, 0x2, 0x2, 0x2, 0xf92, 0xf93, 0x3, 0x2, 0x2, 0x2, 0xf93, 
       0xfc4, 0x3, 0x2, 0x2, 0x2, 0xf94, 0xfa8, 0x7, 0xa4, 0x2, 0x2, 0xf95, 
       0xf96, 0x7, 0x358, 0x2, 0x2, 0xf96, 0xf9b, 0x5, 0x18c, 0xc7, 0x2, 
       0xf97, 0xf98, 0x7, 0x35a, 0x2, 0x2, 0xf98, 0xf9a, 0x5, 0x18c, 0xc7, 
       0x2, 0xf99, 0xf97, 0x3, 0x2, 0x2, 0x2, 0xf9a, 0xf9d, 0x3, 0x2, 0x2, 
       0x2, 0xf9b, 0xf99, 0x3, 0x2, 0x2, 0x2, 0xf9b, 0xf9c, 0x3, 0x2, 0x2, 
       0x2, 0xf9c, 0xf9e, 0x3, 0x2, 0x2, 0x2, 0xf9d, 0xf9b, 0x3, 0x2, 0x2, 
       0x2, 0xf9e, 0xf9f, 0x7, 0x359, 0x2, 0x2, 0xf9f, 0xfa9, 0x3, 0x2, 
       0x2, 0x2, 0xfa0, 0xfa5, 0x5, 0x18c, 0xc7, 0x2, 0xfa1, 0xfa2, 0x7, 
       0x35a, 0x2, 0x2, 0xfa2, 0xfa4, 0x5, 0x18c, 0xc7, 0x2, 0xfa3, 0xfa1, 
       0x3, 0x2, 0x2, 0x2, 0xfa4, 0xfa7, 0x3, 0x2, 0x2, 0x2, 0xfa5, 0xfa3, 
       0x3, 0x2, 0x2, 0x2, 0xfa5, 0xfa6, 0x3, 0x2, 0x2, 0x2, 0xfa6, 0xfa9, 
       0x3, 0x2, 0x2, 0x2, 0xfa7, 0xfa5, 0x3, 0x2, 0x2, 0x2, 0xfa8, 0xf95, 
       0x3, 0x2, 0x2, 0x2, 0xfa8, 0xfa0, 0x3, 0x2, 0x2, 0x2, 0xfa9, 0xfc5, 
       0x3, 0x2, 0x2, 0x2, 0xfaa, 0xfab, 0x7, 0xa4, 0x2, 0x2, 0xfab, 0xfac, 
       0x7, 0x346, 0x2, 0x2, 0xfac, 0xfc5, 0x5, 0x18c, 0xc7, 0x2, 0xfad, 
       0xfbc, 0x7, 0x8c, 0x2, 0x2, 0xfae, 0xfaf, 0x7, 0x358, 0x2, 0x2, 0xfaf, 
       0xfb0, 0x5, 0x18c, 0xc7, 0x2, 0xfb0, 0xfb1, 0x7, 0x358, 0x2, 0x2, 
       0xfb1, 0xfb6, 0x7, 0x33f, 0x2, 0x2, 0xfb2, 0xfb3, 0x7, 0x35a, 0x2, 
       0x2, 0xfb3, 0xfb5, 0x7, 0x33f, 0x2, 0x2, 0xfb4, 0xfb2, 0x3, 0x2, 
       0x2, 0x2, 0xfb5, 0xfb8, 0x3, 0x2, 0x2, 0x2, 0xfb6, 0xfb4, 0x3, 0x2, 
       0x2, 0x2, 0xfb6, 0xfb7, 0x3, 0x2, 0x2, 0x2, 0xfb7, 0xfb9, 0x3, 0x2, 
       0x2, 0x2, 0xfb8, 0xfb6, 0x3, 0x2, 0x2, 0x2, 0xfb9, 0xfba, 0x7, 0x359, 
       0x2, 0x2, 0xfba, 0xfbb, 0x7, 0x359, 0x2, 0x2, 0xfbb, 0xfbd, 0x3, 
       0x2, 0x2, 0x2, 0xfbc, 0xfae, 0x3, 0x2, 0x2, 0x2, 0xfbc, 0xfbd, 0x3, 
       0x2, 0x2, 0x2, 0xfbd, 0xfc5, 0x3, 0x2, 0x2, 0x2, 0xfbe, 0xfc5, 0x7, 
       0x2eb, 0x2, 0x2, 0xfbf, 0xfc5, 0x7, 0x2f5, 0x2, 0x2, 0xfc0, 0xfc1, 
       0x7, 0x2f6, 0x2, 0x2, 0xfc1, 0xfc2, 0x7, 0x346, 0x2, 0x2, 0xfc2, 
       0xfc5, 0x7, 0x33e, 0x2, 0x2, 0xfc3, 0xfc5, 0x7, 0x33f, 0x2, 0x2, 
       0xfc4, 0xf94, 0x3, 0x2, 0x2, 0x2, 0xfc4, 0xfaa, 0x3, 0x2, 0x2, 0x2, 
       0xfc4, 0xfad, 0x3, 0x2, 0x2, 0x2, 0xfc4, 0xfbe, 0x3, 0x2, 0x2, 0x2, 
       0xfc4, 0xfbf, 0x3, 0x2, 0x2, 0x2, 0xfc4, 0xfc0, 0x3, 0x2, 0x2, 0x2, 
       0xfc4, 0xfc3, 0x3, 0x2, 0x2, 0x2, 0xfc5, 0x18b, 0x3, 0x2, 0x2, 0x2, 
       0xfc6, 0xfc9, 0x5, 0x1f4, 0xfb, 0x2, 0xfc7, 0xfc9, 0x7, 0x33e, 0x2, 
       0x2, 0xfc8, 0xfc6, 0x3, 0x2, 0x2, 0x2, 0xfc8, 0xfc7, 0x3, 0x2, 0x2, 
       0x2, 0xfc9, 0x18d, 0x3, 0x2, 0x2, 0x2, 0xfca, 0xfcb, 0x7, 0x358, 
       0x2, 0x2, 0xfcb, 0xfd0, 0x5, 0x190, 0xc9, 0x2, 0xfcc, 0xfcd, 0x7, 
       0x35a, 0x2, 0x2, 0xfcd, 0xfcf, 0x5, 0x190, 0xc9, 0x2, 0xfce, 0xfcc, 
       0x3, 0x2, 0x2, 0x2, 0xfcf, 0xfd2, 0x3, 0x2, 0x2, 0x2, 0xfd0, 0xfce, 
       0x3, 0x2, 0x2, 0x2, 0xfd0, 0xfd1, 0x3, 0x2, 0x2, 0x2, 0xfd1, 0xfd3, 
       0x3, 0x2, 0x2, 0x2, 0xfd2, 0xfd0, 0x3, 0x2, 0x2, 0x2, 0xfd3, 0xfd4, 
       0x7, 0x359, 0x2, 0x2, 0xfd4, 0x18f, 0x3, 0x2, 0x2, 0x2, 0xfd5, 0xfd8, 
       0x5, 0x1f4, 0xfb, 0x2, 0xfd6, 0xfd8, 0x7, 0x342, 0x2, 0x2, 0xfd7, 
       0xfd5, 0x3, 0x2, 0x2, 0x2, 0xfd7, 0xfd6, 0x3, 0x2, 0x2, 0x2, 0xfd8, 
       0x191, 0x3, 0x2, 0x2, 0x2, 0xfd9, 0xfda, 0x7, 0x187, 0x2, 0x2, 0xfda, 
       0xfdb, 0x7, 0x358, 0x2, 0x2, 0xfdb, 0xfdc, 0x5, 0x194, 0xcb, 0x2, 
       0xfdc, 0xfe4, 0x7, 0x359, 0x2, 0x2, 0xfdd, 0xfde, 0x7, 0x35a, 0x2, 
       0x2, 0xfde, 0xfdf, 0x7, 0x358, 0x2, 0x2, 0xfdf, 0xfe0, 0x5, 0x194, 
       0xcb, 0x2, 0xfe0, 0xfe1, 0x7, 0x359, 0x2, 0x2, 0xfe1, 0xfe3, 0x3, 
       0x2, 0x2, 0x2, 0xfe2, 0xfdd, 0x3, 0x2, 0x2, 0x2, 0xfe3, 0xfe6, 0x3, 
       0x2, 0x2, 0x2, 0xfe4, 0xfe2, 0x3, 0x2, 0x2, 0x2, 0xfe4, 0xfe5, 0x3, 
       0x2, 0x2, 0x2, 0xfe5, 0x193, 0x3, 0x2, 0x2, 0x2, 0xfe6, 0xfe4, 0x3, 
       0x2, 0x2, 0x2, 0xfe7, 0xfec, 0x5, 0x106, 0x84, 0x2, 0xfe8, 0xfe9, 
       0x7, 0x35a, 0x2, 0x2, 0xfe9, 0xfeb, 0x5, 0x106, 0x84, 0x2, 0xfea, 
       0xfe8, 0x3, 0x2, 0x2, 0x2, 0xfeb, 0xfee, 0x3, 0x2, 0x2, 0x2, 0xfec, 
       0xfea, 0x3, 0x2, 0x2, 0x2, 0xfec, 0xfed, 0x3, 0x2, 0x2, 0x2, 0xfed, 
       0x195, 0x3, 0x2, 0x2, 0x2, 0xfee, 0xfec, 0x3, 0x2, 0x2, 0x2, 0xfef, 
       0xff0, 0x9, 0x36, 0x2, 0x2, 0xff0, 0xff1, 0x7, 0x358, 0x2, 0x2, 0xff1, 
       0xff2, 0x7, 0x359, 0x2, 0x2, 0xff2, 0xffa, 0x5, 0x19e, 0xd0, 0x2, 
       0xff3, 0xff4, 0x7, 0x288, 0x2, 0x2, 0xff4, 0xff5, 0x7, 0x358, 0x2, 
       0x2, 0xff5, 0xff6, 0x5, 0x106, 0x84, 0x2, 0xff6, 0xff7, 0x7, 0x359, 
       0x2, 0x2, 0xff7, 0xff8, 0x5, 0x19e, 0xd0, 0x2, 0xff8, 0xffa, 0x3, 
       0x2, 0x2, 0x2, 0xff9, 0xfef, 0x3, 0x2, 0x2, 0x2, 0xff9, 0xff3, 0x3, 
       0x2, 0x2, 0x2, 0xffa, 0x197, 0x3, 0x2, 0x2, 0x2, 0xffb, 0xffc, 0x9, 
       0x37, 0x2, 0x2, 0xffc, 0xffd, 0x7, 0x358, 0x2, 0x2, 0xffd, 0xffe, 
       0x5, 0x19c, 0xcf, 0x2, 0xffe, 0x1000, 0x7, 0x359, 0x2, 0x2, 0xfff, 
       0x1001, 0x5, 0x19e, 0xd0, 0x2, 0x1000, 0xfff, 0x3, 0x2, 0x2, 0x2, 
       0x1000, 0x1001, 0x3, 0x2, 0x2, 0x2, 0x1001, 0x101c, 0x3, 0x2, 0x2, 
       0x2, 0x1002, 0x1003, 0x9, 0x38, 0x2, 0x2, 0x1003, 0x1006, 0x7, 0x358, 
       0x2, 0x2, 0x1004, 0x1007, 0x7, 0x35d, 0x2, 0x2, 0x1005, 0x1007, 0x5, 
       0x19c, 0xcf, 0x2, 0x1006, 0x1004, 0x3, 0x2, 0x2, 0x2, 0x1006, 0x1005, 
       0x3, 0x2, 0x2, 0x2, 0x1007, 0x1008, 0x3, 0x2, 0x2, 0x2, 0x1008, 0x100a, 
       0x7, 0x359, 0x2, 0x2, 0x1009, 0x100b, 0x5, 0x19e, 0xd0, 0x2, 0x100a, 
       0x1009, 0x3, 0x2, 0x2, 0x2, 0x100a, 0x100b, 0x3, 0x2, 0x2, 0x2, 0x100b, 
       0x101c, 0x3, 0x2, 0x2, 0x2, 0x100c, 0x100d, 0x7, 0x1cc, 0x2, 0x2, 
       0x100d, 0x100e, 0x7, 0x358, 0x2, 0x2, 0x100e, 0x100f, 0x5, 0x19c, 
       0xcf, 0x2, 0x100f, 0x1010, 0x7, 0x359, 0x2, 0x2, 0x1010, 0x101c, 
       0x3, 0x2, 0x2, 0x2, 0x1011, 0x1012, 0x7, 0x22b, 0x2, 0x2, 0x1012, 
       0x1013, 0x7, 0x358, 0x2, 0x2, 0x1013, 0x1014, 0x5, 0x106, 0x84, 0x2, 
       0x1014, 0x1015, 0x7, 0x359, 0x2, 0x2, 0x1015, 0x101c, 0x3, 0x2, 0x2, 
       0x2, 0x1016, 0x1017, 0x7, 0x22c, 0x2, 0x2, 0x1017, 0x1018, 0x7, 0x358, 
       0x2, 0x2, 0x1018, 0x1019, 0x5, 0x194, 0xcb, 0x2, 0x1019, 0x101a, 
       0x7, 0x359, 0x2, 0x2, 0x101a, 0x101c, 0x3, 0x2, 0x2, 0x2, 0x101b, 
       0xffb, 0x3, 0x2, 0x2, 0x2, 0x101b, 0x1002, 0x3, 0x2, 0x2, 0x2, 0x101b, 
       0x100c, 0x3, 0x2, 0x2, 0x2, 0x101b, 0x1011, 0x3, 0x2, 0x2, 0x2, 0x101b, 
       0x1016, 0x3, 0x2, 0x2, 0x2, 0x101c, 0x199, 0x3, 0x2, 0x2, 0x2, 0x101d, 
       0x101e, 0x9, 0x39, 0x2, 0x2, 0x101e, 0x101f, 0x7, 0x358, 0x2, 0x2, 
       0x101f, 0x1020, 0x5, 0x106, 0x84, 0x2, 0x1020, 0x1021, 0x7, 0x359, 
       0x2, 0x2, 0x1021, 0x1022, 0x5, 0x19e, 0xd0, 0x2, 0x1022, 0x1032, 
       0x3, 0x2, 0x2, 0x2, 0x1023, 0x1024, 0x9, 0x3a, 0x2, 0x2, 0x1024, 
       0x1025, 0x7, 0x358, 0x2, 0x2, 0x1025, 0x102c, 0x5, 0x106, 0x84, 0x2, 
       0x1026, 0x1027, 0x7, 0x35a, 0x2, 0x2, 0x1027, 0x102a, 0x5, 0x106, 
       0x84, 0x2, 0x1028, 0x1029, 0x7, 0x35a, 0x2, 0x2, 0x1029, 0x102b, 
       0x5, 0x106, 0x84, 0x2, 0x102a, 0x1028, 0x3, 0x2, 0x2, 0x2, 0x102a, 
       0x102b, 0x3, 0x2, 0x2, 0x2, 0x102b, 0x102d, 0x3, 0x2, 0x2, 0x2, 0x102c, 
       0x1026, 0x3, 0x2, 0x2, 0x2, 0x102c, 0x102d, 0x3, 0x2, 0x2, 0x2, 0x102d, 
       0x102e, 0x3, 0x2, 0x2, 0x2, 0x102e, 0x102f, 0x7, 0x359, 0x2, 0x2, 
       0x102f, 0x1030, 0x5, 0x19e, 0xd0, 0x2, 0x1030, 0x1032, 0x3, 0x2, 
       0x2, 0x2, 0x1031, 0x101d, 0x3, 0x2, 0x2, 0x2, 0x1031, 0x1023, 0x3, 
       0x2, 0x2, 0x2, 0x1032, 0x19b, 0x3, 0x2, 0x2, 0x2, 0x1033, 0x1035, 
       0x9, 0x27, 0x2, 0x2, 0x1034, 0x1033, 0x3, 0x2, 0x2, 0x2, 0x1034, 
       0x1035, 0x3, 0x2, 0x2, 0x2, 0x1035, 0x1036, 0x3, 0x2, 0x2, 0x2, 0x1036, 
       0x1037, 0x5, 0x106, 0x84, 0x2, 0x1037, 0x19d, 0x3, 0x2, 0x2, 0x2, 
       0x1038, 0x1039, 0x7, 0xfd, 0x2, 0x2, 0x1039, 0x103d, 0x7, 0x358, 
       0x2, 0x2, 0x103a, 0x103b, 0x7, 0x29b, 0x2, 0x2, 0x103b, 0x103c, 0x7, 
       0x28, 0x2, 0x2, 0x103c, 0x103e, 0x5, 0x194, 0xcb, 0x2, 0x103d, 0x103a, 
       0x3, 0x2, 0x2, 0x2, 0x103d, 0x103e, 0x3, 0x2, 0x2, 0x2, 0x103e, 0x1040, 
       0x3, 0x2, 0x2, 0x2, 0x103f, 0x1041, 0x5, 0x130, 0x99, 0x2, 0x1040, 
       0x103f, 0x3, 0x2, 0x2, 0x2, 0x1040, 0x1041, 0x3, 0x2, 0x2, 0x2, 0x1041, 
       0x1043, 0x3, 0x2, 0x2, 0x2, 0x1042, 0x1044, 0x5, 0x1a0, 0xd1, 0x2, 
       0x1043, 0x1042, 0x3, 0x2, 0x2, 0x2, 0x1043, 0x1044, 0x3, 0x2, 0x2, 
       0x2, 0x1044, 0x1045, 0x3, 0x2, 0x2, 0x2, 0x1045, 0x1046, 0x7, 0x359, 
       0x2, 0x2, 0x1046, 0x19f, 0x3, 0x2, 0x2, 0x2, 0x1047, 0x1048, 0x9, 
       0x3b, 0x2, 0x2, 0x1048, 0x1049, 0x5, 0x1a2, 0xd2, 0x2, 0x1049, 0x1a1, 
       0x3, 0x2, 0x2, 0x2, 0x104a, 0x1051, 0x5, 0x1a6, 0xd4, 0x2, 0x104b, 
       0x104c, 0x7, 0x1f, 0x2, 0x2, 0x104c, 0x104d, 0x5, 0x1a4, 0xd3, 0x2, 
       0x104d, 0x104e, 0x7, 0xc, 0x2, 0x2, 0x104e, 0x104f, 0x5, 0x1a4, 0xd3, 
       0x2, 0x104f, 0x1051, 0x3, 0x2, 0x2, 0x2, 0x1050, 0x104a, 0x3, 0x2, 
       0x2, 0x2, 0x1050, 0x104b, 0x3, 0x2, 0x2, 0x2, 0x1051, 0x1a3, 0x3, 
       0x2, 0x2, 0x2, 0x1052, 0x1055, 0x5, 0x1a6, 0xd4, 0x2, 0x1053, 0x1055, 
       0x5, 0x1a8, 0xd5, 0x2, 0x1054, 0x1052, 0x3, 0x2, 0x2, 0x2, 0x1054, 
       0x1053, 0x3, 0x2, 0x2, 0x2, 0x1055, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0x1056, 
       0x1057, 0x7, 0x31f, 0x2, 0x2, 0x1057, 0x105d, 0x7, 0x2a2, 0x2, 0x2, 
       0x1058, 0x1059, 0x7, 0x33e, 0x2, 0x2, 0x1059, 0x105d, 0x7, 0x2a2, 
       0x2, 0x2, 0x105a, 0x105b, 0x7, 0x50, 0x2, 0x2, 0x105b, 0x105d, 0x7, 
       0x2d4, 0x2, 0x2, 0x105c, 0x1056, 0x3, 0x2, 0x2, 0x2, 0x105c, 0x1058, 
       0x3, 0x2, 0x2, 0x2, 0x105c, 0x105a, 0x3, 0x2, 0x2, 0x2, 0x105d, 0x1a7, 
       0x3, 0x2, 0x2, 0x2, 0x105e, 0x105f, 0x7, 0x31f, 0x2, 0x2, 0x105f, 
       0x1063, 0x7, 0x21d, 0x2, 0x2, 0x1060, 0x1061, 0x7, 0x33e, 0x2, 0x2, 
       0x1061, 0x1063, 0x7, 0x21d, 0x2, 0x2, 0x1062, 0x105e, 0x3, 0x2, 0x2, 
       0x2, 0x1062, 0x1060, 0x3, 0x2, 0x2, 0x2, 0x1063, 0x1a9, 0x3, 0x2, 
       0x2, 0x2, 0x1064, 0x1065, 0x7, 0x219, 0x2, 0x2, 0x1065, 0x106a, 0x5, 
       0x1ac, 0xd7, 0x2, 0x1066, 0x1067, 0x7, 0x35a, 0x2, 0x2, 0x1067, 0x1069, 
       0x5, 0x1ac, 0xd7, 0x2, 0x1068, 0x1066, 0x3, 0x2, 0x2, 0x2, 0x1069, 
       0x106c, 0x3, 0x2, 0x2, 0x2, 0x106a, 0x1068, 0x3, 0x2, 0x2, 0x2, 0x106a, 
       0x106b, 0x3, 0x2, 0x2, 0x2, 0x106b, 0x1087, 0x3, 0x2, 0x2, 0x2, 0x106c, 
       0x106a, 0x3, 0x2, 0x2, 0x2, 0x106d, 0x106e, 0x7, 0x1ef, 0x2, 0x2, 
       0x106e, 0x1071, 0x7, 0x346, 0x2, 0x2, 0x106f, 0x1072, 0x5, 0x1f4, 
       0xfb, 0x2, 0x1070, 0x1072, 0x7, 0x342, 0x2, 0x2, 0x1071, 0x106f, 
       0x3, 0x2, 0x2, 0x2, 0x1071, 0x1070, 0x3, 0x2, 0x2, 0x2, 0x1072, 0x1087, 
       0x3, 0x2, 0x2, 0x2, 0x1073, 0x1074, 0x7, 0x1ee, 0x2, 0x2, 0x1074, 
       0x1077, 0x7, 0x346, 0x2, 0x2, 0x1075, 0x1078, 0x5, 0x1f4, 0xfb, 0x2, 
       0x1076, 0x1078, 0x7, 0x342, 0x2, 0x2, 0x1077, 0x1075, 0x3, 0x2, 0x2, 
       0x2, 0x1077, 0x1076, 0x3, 0x2, 0x2, 0x2, 0x1078, 0x1087, 0x3, 0x2, 
       0x2, 0x2, 0x1079, 0x107a, 0x7, 0x279, 0x2, 0x2, 0x107a, 0x107b, 0x7, 
       0x346, 0x2, 0x2, 0x107b, 0x1087, 0x9, 0xf, 0x2, 0x2, 0x107c, 0x107d, 
       0x7, 0x316, 0x2, 0x2, 0x107d, 0x107e, 0x7, 0x346, 0x2, 0x2, 0x107e, 
       0x1087, 0x9, 0xf, 0x2, 0x2, 0x107f, 0x1080, 0x7, 0x31c, 0x2, 0x2, 
       0x1080, 0x1081, 0x7, 0x346, 0x2, 0x2, 0x1081, 0x1087, 0x7, 0x33e, 
       0x2, 0x2, 0x1082, 0x1083, 0x7, 0x1ea, 0x2, 0x2, 0x1083, 0x1087, 0x9, 
       0xf, 0x2, 0x2, 0x1084, 0x1085, 0x7, 0x319, 0x2, 0x2, 0x1085, 0x1087, 
       0x9, 0xf, 0x2, 0x2, 0x1086, 0x1064, 0x3, 0x2, 0x2, 0x2, 0x1086, 0x106d, 
       0x3, 0x2, 0x2, 0x2, 0x1086, 0x1073, 0x3, 0x2, 0x2, 0x2, 0x1086, 0x1079, 
       0x3, 0x2, 0x2, 0x2, 0x1086, 0x107c, 0x3, 0x2, 0x2, 0x2, 0x1086, 0x107f, 
       0x3, 0x2, 0x2, 0x2, 0x1086, 0x1082, 0x3, 0x2, 0x2, 0x2, 0x1086, 0x1084, 
       0x3, 0x2, 0x2, 0x2, 0x1087, 0x1ab, 0x3, 0x2, 0x2, 0x2, 0x1088, 0x108f, 
       0x7, 0x358, 0x2, 0x2, 0x1089, 0x108a, 0x7, 0x284, 0x2, 0x2, 0x108a, 
       0x108b, 0x7, 0x346, 0x2, 0x2, 0x108b, 0x1090, 0x9, 0x3c, 0x2, 0x2, 
       0x108c, 0x108d, 0x7, 0x1fa, 0x2, 0x2, 0x108d, 0x108e, 0x7, 0x346, 
       0x2, 0x2, 0x108e, 0x1090, 0x7, 0x342, 0x2, 0x2, 0x108f, 0x1089, 0x3, 
       0x2, 0x2, 0x2, 0x108f, 0x108c, 0x3, 0x2, 0x2, 0x2, 0x1090, 0x1091, 
       0x3, 0x2, 0x2, 0x2, 0x1091, 0x1092, 0x7, 0x359, 0x2, 0x2, 0x1092, 
       0x1ad, 0x3, 0x2, 0x2, 0x2, 0x1093, 0x1096, 0x5, 0x1b0, 0xd9, 0x2, 
       0x1094, 0x1096, 0x5, 0x1b2, 0xda, 0x2, 0x1095, 0x1093, 0x3, 0x2, 
       0x2, 0x2, 0x1095, 0x1094, 0x3, 0x2, 0x2, 0x2, 0x1096, 0x1af, 0x3, 
       0x2, 0x2, 0x2, 0x1097, 0x1098, 0x7, 0x216, 0x2, 0x2, 0x1098, 0x109b, 
       0x5, 0x1f4, 0xfb, 0x2, 0x1099, 0x109a, 0x7, 0x44, 0x2, 0x2, 0x109a, 
       0x109c, 0x7, 0x219, 0x2, 0x2, 0x109b, 0x1099, 0x3, 0x2, 0x2, 0x2, 
       0x109b, 0x109c, 0x3, 0x2, 0x2, 0x2, 0x109c, 0x109e, 0x3, 0x2, 0x2, 
       0x2, 0x109d, 0x109f, 0x7, 0x5e, 0x2, 0x2, 0x109e, 0x109d, 0x3, 0x2, 
       0x2, 0x2, 0x109e, 0x109f, 0x3, 0x2, 0x2, 0x2, 0x109f, 0x10a2, 0x3, 
       0x2, 0x2, 0x2, 0x10a0, 0x10a1, 0x7, 0x44, 0x2, 0x2, 0x10a1, 0x10a3, 
       0x7, 0x26a, 0x2, 0x2, 0x10a2, 0x10a0, 0x3, 0x2, 0x2, 0x2, 0x10a2, 
       0x10a3, 0x3, 0x2, 0x2, 0x2, 0x10a3, 0x10a4, 0x3, 0x2, 0x2, 0x2, 0x10a4, 
       0x10a9, 0x5, 0x1b2, 0xda, 0x2, 0x10a5, 0x10a6, 0x7, 0x35a, 0x2, 0x2, 
       0x10a6, 0x10a8, 0x5, 0x1b2, 0xda, 0x2, 0x10a7, 0x10a5, 0x3, 0x2, 
       0x2, 0x2, 0x10a8, 0x10ab, 0x3, 0x2, 0x2, 0x2, 0x10a9, 0x10a7, 0x3, 
       0x2, 0x2, 0x2, 0x10a9, 0x10aa, 0x3, 0x2, 0x2, 0x2, 0x10aa, 0x1b1, 
       0x3, 0x2, 0x2, 0x2, 0x10ab, 0x10a9, 0x3, 0x2, 0x2, 0x2, 0x10ac, 0x10ad, 
       0x7, 0x358, 0x2, 0x2, 0x10ad, 0x10ae, 0x7, 0x278, 0x2, 0x2, 0x10ae, 
       0x10b1, 0x7, 0x346, 0x2, 0x2, 0x10af, 0x10b2, 0x5, 0x1f4, 0xfb, 0x2, 
       0x10b0, 0x10b2, 0x7, 0x342, 0x2, 0x2, 0x10b1, 0x10af, 0x3, 0x2, 0x2, 
       0x2, 0x10b1, 0x10b0, 0x3, 0x2, 0x2, 0x2, 0x10b2, 0x10b4, 0x3, 0x2, 
       0x2, 0x2, 0x10b3, 0x10b5, 0x7, 0x35a, 0x2, 0x2, 0x10b4, 0x10b3, 0x3, 
       0x2, 0x2, 0x2, 0x10b4, 0x10b5, 0x3, 0x2, 0x2, 0x2, 0x10b5, 0x10b6, 
       0x3, 0x2, 0x2, 0x2, 0x10b6, 0x10b7, 0x7, 0x87, 0x2, 0x2, 0x10b7, 
       0x10b8, 0x7, 0x346, 0x2, 0x2, 0x10b8, 0x10ba, 0x7, 0x342, 0x2, 0x2, 
       0x10b9, 0x10bb, 0x7, 0x35a, 0x2, 0x2, 0x10ba, 0x10b9, 0x3, 0x2, 0x2, 
       0x2, 0x10ba, 0x10bb, 0x3, 0x2, 0x2, 0x2, 0x10bb, 0x10c2, 0x3, 0x2, 
       0x2, 0x2, 0x10bc, 0x10bd, 0x7, 0x2f3, 0x2, 0x2, 0x10bd, 0x10be, 0x7, 
       0x346, 0x2, 0x2, 0x10be, 0x10c0, 0x5, 0x1fc, 0xff, 0x2, 0x10bf, 0x10c1, 
       0x7, 0x35a, 0x2, 0x2, 0x10c0, 0x10bf, 0x3, 0x2, 0x2, 0x2, 0x10c0, 
       0x10c1, 0x3, 0x2, 0x2, 0x2, 0x10c1, 0x10c3, 0x3, 0x2, 0x2, 0x2, 0x10c2, 
       0x10bc, 0x3, 0x2, 0x2, 0x2, 0x10c2, 0x10c3, 0x3, 0x2, 0x2, 0x2, 0x10c3, 
       0x10cd, 0x3, 0x2, 0x2, 0x2, 0x10c4, 0x10c5, 0x7, 0x267, 0x2, 0x2, 
       0x10c5, 0x10c8, 0x7, 0x346, 0x2, 0x2, 0x10c6, 0x10c9, 0x5, 0x1fc, 
       0xff, 0x2, 0x10c7, 0x10c9, 0x7, 0x322, 0x2, 0x2, 0x10c8, 0x10c6, 
       0x3, 0x2, 0x2, 0x2, 0x10c8, 0x10c7, 0x3, 0x2, 0x2, 0x2, 0x10c9, 0x10cb, 
       0x3, 0x2, 0x2, 0x2, 0x10ca, 0x10cc, 0x7, 0x35a, 0x2, 0x2, 0x10cb, 
       0x10ca, 0x3, 0x2, 0x2, 0x2, 0x10cb, 0x10cc, 0x3, 0x2, 0x2, 0x2, 0x10cc, 
       0x10ce, 0x3, 0x2, 0x2, 0x2, 0x10cd, 0x10c4, 0x3, 0x2, 0x2, 0x2, 0x10cd, 
       0x10ce, 0x3, 0x2, 0x2, 0x2, 0x10ce, 0x10d5, 0x3, 0x2, 0x2, 0x2, 0x10cf, 
       0x10d0, 0x7, 0x217, 0x2, 0x2, 0x10d0, 0x10d1, 0x7, 0x346, 0x2, 0x2, 
       0x10d1, 0x10d3, 0x5, 0x1fc, 0xff, 0x2, 0x10d2, 0x10d4, 0x7, 0x35a, 
       0x2, 0x2, 0x10d3, 0x10d2, 0x3, 0x2, 0x2, 0x2, 0x10d3, 0x10d4, 0x3, 
       0x2, 0x2, 0x2, 0x10d4, 0x10d6, 0x3, 0x2, 0x2, 0x2, 0x10d5, 0x10cf, 
       0x3, 0x2, 0x2, 0x2, 0x10d5, 0x10d6, 0x3, 0x2, 0x2, 0x2, 0x10d6, 0x10d7, 
       0x3, 0x2, 0x2, 0x2, 0x10d7, 0x10d8, 0x7, 0x359, 0x2, 0x2, 0x10d8, 
       0x1b3, 0x3, 0x2, 0x2, 0x2, 0x10d9, 0x10da, 0x5, 0x1f4, 0xfb, 0x2, 
       0x10da, 0x10db, 0x7, 0x353, 0x2, 0x2, 0x10db, 0x10dc, 0x5, 0x1f4, 
       0xfb, 0x2, 0x10dc, 0x10dd, 0x7, 0x353, 0x2, 0x2, 0x10dd, 0x10de, 
       0x5, 0x1f4, 0xfb, 0x2, 0x10de, 0x10df, 0x7, 0x353, 0x2, 0x2, 0x10df, 
       0x10eb, 0x3, 0x2, 0x2, 0x2, 0x10e0, 0x10e1, 0x5, 0x1f4, 0xfb, 0x2, 
       0x10e1, 0x10e3, 0x7, 0x353, 0x2, 0x2, 0x10e2, 0x10e4, 0x5, 0x1f4, 
       0xfb, 0x2, 0x10e3, 0x10e2, 0x3, 0x2, 0x2, 0x2, 0x10e3, 0x10e4, 0x3, 
       0x2, 0x2, 0x2, 0x10e4, 0x10e5, 0x3, 0x2, 0x2, 0x2, 0x10e5, 0x10e6, 
       0x7, 0x353, 0x2, 0x2, 0x10e6, 0x10eb, 0x3, 0x2, 0x2, 0x2, 0x10e7, 
       0x10e8, 0x5, 0x1f4, 0xfb, 0x2, 0x10e8, 0x10e9, 0x7, 0x353, 0x2, 0x2, 
       0x10e9, 0x10eb, 0x3, 0x2, 0x2, 0x2, 0x10ea, 0x10d9, 0x3, 0x2, 0x2, 
       0x2, 0x10ea, 0x10e0, 0x3, 0x2, 0x2, 0x2, 0x10ea, 0x10e7, 0x3, 0x2, 
       0x2, 0x2, 0x10ea, 0x10eb, 0x3, 0x2, 0x2, 0x2, 0x10eb, 0x10ec, 0x3, 
       0x2, 0x2, 0x2, 0x10ec, 0x10ed, 0x5, 0x1f4, 0xfb, 0x2, 0x10ed, 0x1b5, 
       0x3, 0x2, 0x2, 0x2, 0x10ee, 0x10f4, 0x5, 0x1f4, 0xfb, 0x2, 0x10ef, 
       0x10f0, 0x5, 0x1f4, 0xfb, 0x2, 0x10f0, 0x10f1, 0x7, 0x353, 0x2, 0x2, 
       0x10f1, 0x10f2, 0x5, 0x1f4, 0xfb, 0x2, 0x10f2, 0x10f4, 0x3, 0x2, 
       0x2, 0x2, 0x10f3, 0x10ee, 0x3, 0x2, 0x2, 0x2, 0x10f3, 0x10ef, 0x3, 
       0x2, 0x2, 0x2, 0x10f4, 0x1b7, 0x3, 0x2, 0x2, 0x2, 0x10f5, 0x10fb, 
       0x5, 0x1f4, 0xfb, 0x2, 0x10f6, 0x10f7, 0x5, 0x1f4, 0xfb, 0x2, 0x10f7, 
       0x10f8, 0x7, 0x353, 0x2, 0x2, 0x10f8, 0x10f9, 0x5, 0x1f4, 0xfb, 0x2, 
       0x10f9, 0x10fb, 0x3, 0x2, 0x2, 0x2, 0x10fa, 0x10f5, 0x3, 0x2, 0x2, 
       0x2, 0x10fa, 0x10f6, 0x3, 0x2, 0x2, 0x2, 0x10fb, 0x1b9, 0x3, 0x2, 
       0x2, 0x2, 0x10fc, 0x10fd, 0x5, 0x1f4, 0xfb, 0x2, 0x10fd, 0x10fe, 
       0x7, 0x353, 0x2, 0x2, 0x10fe, 0x10ff, 0x5, 0x1f4, 0xfb, 0x2, 0x10ff, 
       0x1100, 0x7, 0x353, 0x2, 0x2, 0x1100, 0x1101, 0x5, 0x1f4, 0xfb, 0x2, 
       0x1101, 0x1102, 0x7, 0x353, 0x2, 0x2, 0x1102, 0x110e, 0x3, 0x2, 0x2, 
       0x2, 0x1103, 0x1104, 0x5, 0x1f4, 0xfb, 0x2, 0x1104, 0x1106, 0x7, 
       0x353, 0x2, 0x2, 0x1105, 0x1107, 0x5, 0x1f4, 0xfb, 0x2, 0x1106, 0x1105, 
       0x3, 0x2, 0x2, 0x2, 0x1106, 0x1107, 0x3, 0x2, 0x2, 0x2, 0x1107, 0x1108, 
       0x3, 0x2, 0x2, 0x2, 0x1108, 0x1109, 0x7, 0x353, 0x2, 0x2, 0x1109, 
       0x110e, 0x3, 0x2, 0x2, 0x2, 0x110a, 0x110b, 0x5, 0x1f4, 0xfb, 0x2, 
       0x110b, 0x110c, 0x7, 0x353, 0x2, 0x2, 0x110c, 0x110e, 0x3, 0x2, 0x2, 
       0x2, 0x110d, 0x10fc, 0x3, 0x2, 0x2, 0x2, 0x110d, 0x1103, 0x3, 0x2, 
       0x2, 0x2, 0x110d, 0x110a, 0x3, 0x2, 0x2, 0x2, 0x110d, 0x110e, 0x3, 
       0x2, 0x2, 0x2, 0x110e, 0x110f, 0x3, 0x2, 0x2, 0x2, 0x110f, 0x1110, 
       0x5, 0x1f4, 0xfb, 0x2, 0x1110, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0x1111, 
       0x1112, 0x5, 0x1f4, 0xfb, 0x2, 0x1112, 0x1114, 0x7, 0x353, 0x2, 0x2, 
       0x1113, 0x1115, 0x5, 0x1f4, 0xfb, 0x2, 0x1114, 0x1113, 0x3, 0x2, 
       0x2, 0x2, 0x1114, 0x1115, 0x3, 0x2, 0x2, 0x2, 0x1115, 0x1116, 0x3, 
       0x2, 0x2, 0x2, 0x1116, 0x1117, 0x7, 0x353, 0x2, 0x2, 0x1117, 0x111c, 
       0x3, 0x2, 0x2, 0x2, 0x1118, 0x1119, 0x5, 0x1f4, 0xfb, 0x2, 0x1119, 
       0x111a, 0x7, 0x353, 0x2, 0x2, 0x111a, 0x111c, 0x3, 0x2, 0x2, 0x2, 
       0x111b, 0x1111, 0x3, 0x2, 0x2, 0x2, 0x111b, 0x1118, 0x3, 0x2, 0x2, 
       0x2, 0x111b, 0x111c, 0x3, 0x2, 0x2, 0x2, 0x111c, 0x111d, 0x3, 0x2, 
       0x2, 0x2, 0x111d, 0x112c, 0x5, 0x1f4, 0xfb, 0x2, 0x111e, 0x111f, 
       0x5, 0x1f4, 0xfb, 0x2, 0x111f, 0x1121, 0x7, 0x353, 0x2, 0x2, 0x1120, 
       0x1122, 0x5, 0x1f4, 0xfb, 0x2, 0x1121, 0x1120, 0x3, 0x2, 0x2, 0x2, 
       0x1121, 0x1122, 0x3, 0x2, 0x2, 0x2, 0x1122, 0x1123, 0x3, 0x2, 0x2, 
       0x2, 0x1123, 0x1124, 0x7, 0x353, 0x2, 0x2, 0x1124, 0x1129, 0x3, 0x2, 
       0x2, 0x2, 0x1125, 0x1126, 0x5, 0x1f4, 0xfb, 0x2, 0x1126, 0x1127, 
       0x7, 0x353, 0x2, 0x2, 0x1127, 0x1129, 0x3, 0x2, 0x2, 0x2, 0x1128, 
       0x111e, 0x3, 0x2, 0x2, 0x2, 0x1128, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x1128, 
       0x1129, 0x3, 0x2, 0x2, 0x2, 0x1129, 0x112a, 0x3, 0x2, 0x2, 0x2, 0x112a, 
       0x112c, 0x7, 0x22, 0x2, 0x2, 0x112b, 0x111b, 0x3, 0x2, 0x2, 0x2, 
       0x112b, 0x1128, 0x3, 0x2, 0x2, 0x2, 0x112c, 0x1bd, 0x3, 0x2, 0x2, 
       0x2, 0x112d, 0x112e, 0x5, 0x1f4, 0xfb, 0x2, 0x112e, 0x112f, 0x7, 
       0x353, 0x2, 0x2, 0x112f, 0x1131, 0x3, 0x2, 0x2, 0x2, 0x1130, 0x112d, 
       0x3, 0x2, 0x2, 0x2, 0x1130, 0x1131, 0x3, 0x2, 0x2, 0x2, 0x1131, 0x1132, 
       0x3, 0x2, 0x2, 0x2, 0x1132, 0x1133, 0x5, 0x1f4, 0xfb, 0x2, 0x1133, 
       0x1bf, 0x3, 0x2, 0x2, 0x2, 0x1134, 0x1135, 0x5, 0x1f4, 0xfb, 0x2, 
       0x1135, 0x1136, 0x7, 0x353, 0x2, 0x2, 0x1136, 0x1138, 0x3, 0x2, 0x2, 
       0x2, 0x1137, 0x1134, 0x3, 0x2, 0x2, 0x2, 0x1137, 0x1138, 0x3, 0x2, 
       0x2, 0x2, 0x1138, 0x1139, 0x3, 0x2, 0x2, 0x2, 0x1139, 0x113a, 0x5, 
       0x1f4, 0xfb, 0x2, 0x113a, 0x1c1, 0x3, 0x2, 0x2, 0x2, 0x113b, 0x1147, 
       0x5, 0x1c0, 0xe1, 0x2, 0x113c, 0x113d, 0x5, 0x1f4, 0xfb, 0x2, 0x113d, 
       0x113f, 0x7, 0x353, 0x2, 0x2, 0x113e, 0x1140, 0x5, 0x1f4, 0xfb, 0x2, 
       0x113f, 0x113e, 0x3, 0x2, 0x2, 0x2, 0x113f, 0x1140, 0x3, 0x2, 0x2, 
       0x2, 0x1140, 0x1141, 0x3, 0x2, 0x2, 0x2, 0x1141, 0x1142, 0x7, 0x353, 
       0x2, 0x2, 0x1142, 0x1144, 0x3, 0x2, 0x2, 0x2, 0x1143, 0x113c, 0x3, 
       0x2, 0x2, 0x2, 0x1143, 0x1144, 0x3, 0x2, 0x2, 0x2, 0x1144, 0x1145, 
       0x3, 0x2, 0x2, 0x2, 0x1145, 0x1147, 0x5, 0x1f4, 0xfb, 0x2, 0x1146, 
       0x113b, 0x3, 0x2, 0x2, 0x2, 0x1146, 0x1143, 0x3, 0x2, 0x2, 0x2, 0x1147, 
       0x1c3, 0x3, 0x2, 0x2, 0x2, 0x1148, 0x1156, 0x5, 0x1c2, 0xe2, 0x2, 
       0x1149, 0x114a, 0x5, 0x1f4, 0xfb, 0x2, 0x114a, 0x114b, 0x7, 0x353, 
       0x2, 0x2, 0x114b, 0x114c, 0x5, 0x1f4, 0xfb, 0x2, 0x114c, 0x114e, 
       0x7, 0x353, 0x2, 0x2, 0x114d, 0x114f, 0x5, 0x1f4, 0xfb, 0x2, 0x114e, 
       0x114d, 0x3, 0x2, 0x2, 0x2, 0x114e, 0x114f, 0x3, 0x2, 0x2, 0x2, 0x114f, 
       0x1150, 0x3, 0x2, 0x2, 0x2, 0x1150, 0x1151, 0x7, 0x353, 0x2, 0x2, 
       0x1151, 0x1153, 0x3, 0x2, 0x2, 0x2, 0x1152, 0x1149, 0x3, 0x2, 0x2, 
       0x2, 0x1152, 0x1153, 0x3, 0x2, 0x2, 0x2, 0x1153, 0x1154, 0x3, 0x2, 
       0x2, 0x2, 0x1154, 0x1156, 0x5, 0x1f4, 0xfb, 0x2, 0x1155, 0x1148, 
       0x3, 0x2, 0x2, 0x2, 0x1155, 0x1152, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1c5, 
       0x3, 0x2, 0x2, 0x2, 0x1157, 0x115a, 0x5, 0x1ba, 0xde, 0x2, 0x1158, 
       0x115a, 0x7, 0x33d, 0x2, 0x2, 0x1159, 0x1157, 0x3, 0x2, 0x2, 0x2, 
       0x1159, 0x1158, 0x3, 0x2, 0x2, 0x2, 0x115a, 0x1c7, 0x3, 0x2, 0x2, 
       0x2, 0x115b, 0x115c, 0x5, 0x1bc, 0xdf, 0x2, 0x115c, 0x115d, 0x7, 
       0x353, 0x2, 0x2, 0x115d, 0x115f, 0x3, 0x2, 0x2, 0x2, 0x115e, 0x115b, 
       0x3, 0x2, 0x2, 0x2, 0x115e, 0x115f, 0x3, 0x2, 0x2, 0x2, 0x115f, 0x1160, 
       0x3, 0x2, 0x2, 0x2, 0x1160, 0x118c, 0x5, 0x1f4, 0xfb, 0x2, 0x1161, 
       0x1162, 0x5, 0x1bc, 0xdf, 0x2, 0x1162, 0x1163, 0x7, 0x353, 0x2, 0x2, 
       0x1163, 0x1165, 0x3, 0x2, 0x2, 0x2, 0x1164, 0x1161, 0x3, 0x2, 0x2, 
       0x2, 0x1164, 0x1165, 0x3, 0x2, 0x2, 0x2, 0x1165, 0x1166, 0x3, 0x2, 
       0x2, 0x2, 0x1166, 0x118c, 0x7, 0x1d1, 0x2, 0x2, 0x1167, 0x1168, 0x5, 
       0x1bc, 0xdf, 0x2, 0x1168, 0x1169, 0x7, 0x353, 0x2, 0x2, 0x1169, 0x116b, 
       0x3, 0x2, 0x2, 0x2, 0x116a, 0x1167, 0x3, 0x2, 0x2, 0x2, 0x116a, 0x116b, 
       0x3, 0x2, 0x2, 0x2, 0x116b, 0x116c, 0x3, 0x2, 0x2, 0x2, 0x116c, 0x118c, 
       0x7, 0x2fb, 0x2, 0x2, 0x116d, 0x116e, 0x5, 0x1bc, 0xdf, 0x2, 0x116e, 
       0x116f, 0x7, 0x353, 0x2, 0x2, 0x116f, 0x1171, 0x3, 0x2, 0x2, 0x2, 
       0x1170, 0x116d, 0x3, 0x2, 0x2, 0x2, 0x1170, 0x1171, 0x3, 0x2, 0x2, 
       0x2, 0x1171, 0x1172, 0x3, 0x2, 0x2, 0x2, 0x1172, 0x118c, 0x7, 0x2b1, 
       0x2, 0x2, 0x1173, 0x1174, 0x5, 0x1bc, 0xdf, 0x2, 0x1174, 0x1175, 
       0x7, 0x353, 0x2, 0x2, 0x1175, 0x1177, 0x3, 0x2, 0x2, 0x2, 0x1176, 
       0x1173, 0x3, 0x2, 0x2, 0x2, 0x1176, 0x1177, 0x3, 0x2, 0x2, 0x2, 0x1177, 
       0x1178, 0x3, 0x2, 0x2, 0x2, 0x1178, 0x118c, 0x7, 0x1ad, 0x2, 0x2, 
       0x1179, 0x117a, 0x5, 0x1bc, 0xdf, 0x2, 0x117a, 0x117b, 0x7, 0x353, 
       0x2, 0x2, 0x117b, 0x117d, 0x3, 0x2, 0x2, 0x2, 0x117c, 0x1179, 0x3, 
       0x2, 0x2, 0x2, 0x117c, 0x117d, 0x3, 0x2, 0x2, 0x2, 0x117d, 0x117e, 
       0x3, 0x2, 0x2, 0x2, 0x117e, 0x118c, 0x7, 0x1aa, 0x2, 0x2, 0x117f, 
       0x1180, 0x5, 0x1bc, 0xdf, 0x2, 0x1180, 0x1181, 0x7, 0x353, 0x2, 0x2, 
       0x1181, 0x1183, 0x3, 0x2, 0x2, 0x2, 0x1182, 0x117f, 0x3, 0x2, 0x2, 
       0x2, 0x1182, 0x1183, 0x3, 0x2, 0x2, 0x2, 0x1183, 0x1184, 0x3, 0x2, 
       0x2, 0x2, 0x1184, 0x118c, 0x7, 0x1a9, 0x2, 0x2, 0x1185, 0x1186, 0x5, 
       0x1bc, 0xdf, 0x2, 0x1186, 0x1187, 0x7, 0x353, 0x2, 0x2, 0x1187, 0x1189, 
       0x3, 0x2, 0x2, 0x2, 0x1188, 0x1185, 0x3, 0x2, 0x2, 0x2, 0x1188, 0x1189, 
       0x3, 0x2, 0x2, 0x2, 0x1189, 0x118a, 0x3, 0x2, 0x2, 0x2, 0x118a, 0x118c, 
       0x7, 0x1a8, 0x2, 0x2, 0x118b, 0x115e, 0x3, 0x2, 0x2, 0x2, 0x118b, 
       0x1164, 0x3, 0x2, 0x2, 0x2, 0x118b, 0x116a, 0x3, 0x2, 0x2, 0x2, 0x118b, 
       0x1170, 0x3, 0x2, 0x2, 0x2, 0x118b, 0x1176, 0x3, 0x2, 0x2, 0x2, 0x118b, 
       0x117c, 0x3, 0x2, 0x2, 0x2, 0x118b, 0x1182, 0x3, 0x2, 0x2, 0x2, 0x118b, 
       0x1188, 0x3, 0x2, 0x2, 0x2, 0x118c, 0x1c9, 0x3, 0x2, 0x2, 0x2, 0x118d, 
       0x118f, 0x5, 0x1f4, 0xfb, 0x2, 0x118e, 0x1190, 0x9, 0x2d, 0x2, 0x2, 
       0x118f, 0x118e, 0x3, 0x2, 0x2, 0x2, 0x118f, 0x1190, 0x3, 0x2, 0x2, 
       0x2, 0x1190, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x1191, 0x1192, 0x7, 0x35a, 
       0x2, 0x2, 0x1192, 0x1194, 0x5, 0x1f4, 0xfb, 0x2, 0x1193, 0x1195, 
       0x9, 0x2d, 0x2, 0x2, 0x1194, 0x1193, 0x3, 0x2, 0x2, 0x2, 0x1194, 
       0x1195, 0x3, 0x2, 0x2, 0x2, 0x1195, 0x1197, 0x3, 0x2, 0x2, 0x2, 0x1196, 
       0x1191, 0x3, 0x2, 0x2, 0x2, 0x1197, 0x119a, 0x3, 0x2, 0x2, 0x2, 0x1198, 
       0x1196, 0x3, 0x2, 0x2, 0x2, 0x1198, 0x1199, 0x3, 0x2, 0x2, 0x2, 0x1199, 
       0x1cb, 0x3, 0x2, 0x2, 0x2, 0x119a, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x119b, 
       0x11a0, 0x5, 0x1f4, 0xfb, 0x2, 0x119c, 0x119d, 0x7, 0x35a, 0x2, 0x2, 
       0x119d, 0x119f, 0x5, 0x1f4, 0xfb, 0x2, 0x119e, 0x119c, 0x3, 0x2, 
       0x2, 0x2, 0x119f, 0x11a2, 0x3, 0x2, 0x2, 0x2, 0x11a0, 0x119e, 0x3, 
       0x2, 0x2, 0x2, 0x11a0, 0x11a1, 0x3, 0x2, 0x2, 0x2, 0x11a1, 0x1cd, 
       0x3, 0x2, 0x2, 0x2, 0x11a2, 0x11a0, 0x3, 0x2, 0x2, 0x2, 0x11a3, 0x11a6, 
       0x5, 0x1f4, 0xfb, 0x2, 0x11a4, 0x11a6, 0x7, 0x33d, 0x2, 0x2, 0x11a5, 
       0x11a3, 0x3, 0x2, 0x2, 0x2, 0x11a5, 0x11a4, 0x3, 0x2, 0x2, 0x2, 0x11a6, 
       0x1cf, 0x3, 0x2, 0x2, 0x2, 0x11a7, 0x11a8, 0x9, 0xf, 0x2, 0x2, 0x11a8, 
       0x1d1, 0x3, 0x2, 0x2, 0x2, 0x11a9, 0x11aa, 0x9, 0x3d, 0x2, 0x2, 0x11aa, 
       0x1d3, 0x3, 0x2, 0x2, 0x2, 0x11ab, 0x11ad, 0x7, 0xe9, 0x2, 0x2, 0x11ac, 
       0x11ab, 0x3, 0x2, 0x2, 0x2, 0x11ac, 0x11ad, 0x3, 0x2, 0x2, 0x2, 0x11ad, 
       0x11ae, 0x3, 0x2, 0x2, 0x2, 0x11ae, 0x11af, 0x7, 0xec, 0x2, 0x2, 
       0x11af, 0x1d5, 0x3, 0x2, 0x2, 0x2, 0x11b0, 0x11b8, 0x5, 0x1d4, 0xeb, 
       0x2, 0x11b1, 0x11b2, 0x7, 0x5e, 0x2, 0x2, 0x11b2, 0x11b5, 0x5, 0x110, 
       0x89, 0x2, 0x11b3, 0x11b4, 0x7, 0x191, 0x2, 0x2, 0x11b4, 0x11b6, 
       0x7, 0x187, 0x2, 0x2, 0x11b5, 0x11b3, 0x3, 0x2, 0x2, 0x2, 0x11b5, 
       0x11b6, 0x3, 0x2, 0x2, 0x2, 0x11b6, 0x11b8, 0x3, 0x2, 0x2, 0x2, 0x11b7, 
       0x11b0, 0x3, 0x2, 0x2, 0x2, 0x11b7, 0x11b1, 0x3, 0x2, 0x2, 0x2, 0x11b8, 
       0x1d7, 0x3, 0x2, 0x2, 0x2, 0x11b9, 0x11da, 0x5, 0x1c4, 0xe3, 0x2, 
       0x11ba, 0x11da, 0x7, 0x12f, 0x2, 0x2, 0x11bb, 0x11da, 0x7, 0xb9, 
       0x2, 0x2, 0x11bc, 0x11da, 0x7, 0x1be, 0x2, 0x2, 0x11bd, 0x11da, 0x7, 
       0x1cb, 0x2, 0x2, 0x11be, 0x11da, 0x7, 0x3, 0x2, 0x2, 0x11bf, 0x11da, 
       0x7, 0x13, 0x2, 0x2, 0x11c0, 0x11da, 0x7, 0x2d, 0x2, 0x2, 0x11c1, 
       0x11da, 0x7, 0x32, 0x2, 0x2, 0x11c2, 0x11da, 0x7, 0x1cb, 0x2, 0x2, 
       0x11c3, 0x11da, 0x7, 0x1e2, 0x2, 0x2, 0x11c4, 0x11da, 0x7, 0x1e8, 
       0x2, 0x2, 0x11c5, 0x11da, 0x7, 0x8a, 0x2, 0x2, 0x11c6, 0x11da, 0x7, 
       0xaf, 0x2, 0x2, 0x11c7, 0x11da, 0x7, 0xb1, 0x2, 0x2, 0x11c8, 0x11da, 
       0x7, 0xba, 0x2, 0x2, 0x11c9, 0x11da, 0x7, 0xc5, 0x2, 0x2, 0x11ca, 
       0x11da, 0x7, 0xc6, 0x2, 0x2, 0x11cb, 0x11da, 0x7, 0xd9, 0x2, 0x2, 
       0x11cc, 0x11da, 0x7, 0xdc, 0x2, 0x2, 0x11cd, 0x11da, 0x7, 0x102, 
       0x2, 0x2, 0x11ce, 0x11da, 0x7, 0x117, 0x2, 0x2, 0x11cf, 0x11da, 0x7, 
       0x121, 0x2, 0x2, 0x11d0, 0x11da, 0x7, 0x132, 0x2, 0x2, 0x11d1, 0x11da, 
       0x7, 0x13a, 0x2, 0x2, 0x11d2, 0x11da, 0x7, 0x150, 0x2, 0x2, 0x11d3, 
       0x11da, 0x7, 0x157, 0x2, 0x2, 0x11d4, 0x11da, 0x7, 0x166, 0x2, 0x2, 
       0x11d5, 0x11da, 0x7, 0x304, 0x2, 0x2, 0x11d6, 0x11da, 0x7, 0x181, 
       0x2, 0x2, 0x11d7, 0x11da, 0x7, 0x186, 0x2, 0x2, 0x11d8, 0x11da, 0x7, 
       0x196, 0x2, 0x2, 0x11d9, 0x11b9, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11ba, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11bb, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11bc, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11bd, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11be, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11bf, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c0, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c1, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c2, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c3, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c4, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c5, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c6, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c7, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c8, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11c9, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11ca, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11cb, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11cc, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11cd, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11ce, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11cf, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d0, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d1, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d2, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d3, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d4, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d5, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d6, 
       0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d7, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11d8, 
       0x3, 0x2, 0x2, 0x2, 0x11da, 0x1d9, 0x3, 0x2, 0x2, 0x2, 0x11db, 0x11dc, 
       0x7, 0x1e, 0x2, 0x2, 0x11dc, 0x11dd, 0x7, 0x4b, 0x2, 0x2, 0x11dd, 
       0x11de, 0x7, 0x313, 0x2, 0x2, 0x11de, 0x11df, 0x7, 0x358, 0x2, 0x2, 
       0x11df, 0x11e0, 0x7, 0x33d, 0x2, 0x2, 0x11e0, 0x11e1, 0x7, 0x359, 
       0x2, 0x2, 0x11e1, 0x11e2, 0x7, 0x312, 0x2, 0x2, 0x11e2, 0x11e3, 0x7, 
       0x346, 0x2, 0x2, 0x11e3, 0x11e5, 0x5, 0x70, 0x39, 0x2, 0x11e4, 0x11e6, 
       0x7, 0x35b, 0x2, 0x2, 0x11e5, 0x11e4, 0x3, 0x2, 0x2, 0x2, 0x11e5, 
       0x11e6, 0x3, 0x2, 0x2, 0x2, 0x11e6, 0x1db, 0x3, 0x2, 0x2, 0x2, 0x11e7, 
       0x11e8, 0x7, 0x1e, 0x2, 0x2, 0x11e8, 0x11ea, 0x7, 0x1f9, 0x2, 0x2, 
       0x11e9, 0x11eb, 0x7, 0x4b, 0x2, 0x2, 0x11ea, 0x11e9, 0x3, 0x2, 0x2, 
       0x2, 0x11ea, 0x11eb, 0x3, 0x2, 0x2, 0x2, 0x11eb, 0x11ec, 0x3, 0x2, 
       0x2, 0x2, 0x11ec, 0x11ed, 0x7, 0x33d, 0x2, 0x2, 0x11ed, 0x11ee, 0x7, 
       0x91, 0x2, 0x2, 0x11ee, 0x11ef, 0x7, 0x148, 0x2, 0x2, 0x11ef, 0x11f0, 
       0x5, 0x1e0, 0xf1, 0x2, 0x11f0, 0x11f1, 0x7, 0x170, 0x2, 0x2, 0x11f1, 
       0x11f2, 0x7, 0x148, 0x2, 0x2, 0x11f2, 0x11f5, 0x5, 0x1e0, 0xf1, 0x2, 
       0x11f3, 0x11f4, 0x7, 0x35a, 0x2, 0x2, 0x11f4, 0x11f6, 0x7, 0x342, 
       0x2, 0x2, 0x11f5, 0x11f3, 0x3, 0x2, 0x2, 0x2, 0x11f5, 0x11f6, 0x3, 
       0x2, 0x2, 0x2, 0x11f6, 0x11f7, 0x3, 0x2, 0x2, 0x2, 0x11f7, 0x11f8, 
       0x7, 0xf2, 0x2, 0x2, 0x11f8, 0x11f9, 0x7, 0x49, 0x2, 0x2, 0x11f9, 
       0x1210, 0x5, 0x1de, 0xf0, 0x2, 0x11fa, 0x1201, 0x7, 0x191, 0x2, 0x2, 
       0x11fb, 0x11fc, 0x9, 0x3e, 0x2, 0x2, 0x11fc, 0x11fd, 0x7, 0x346, 
       0x2, 0x2, 0x11fd, 0x11ff, 0x7, 0x33d, 0x2, 0x2, 0x11fe, 0x1200, 0x7, 
       0x35a, 0x2, 0x2, 0x11ff, 0x11fe, 0x3, 0x2, 0x2, 0x2, 0x11ff, 0x1200, 
       0x3, 0x2, 0x2, 0x2, 0x1200, 0x1202, 0x3, 0x2, 0x2, 0x2, 0x1201, 0x11fb, 
       0x3, 0x2, 0x2, 0x2, 0x1201, 0x1202, 0x3, 0x2, 0x2, 0x2, 0x1202, 0x1209, 
       0x3, 0x2, 0x2, 0x2, 0x1203, 0x1204, 0x7, 0xbc, 0x2, 0x2, 0x1204, 
       0x1205, 0x7, 0x346, 0x2, 0x2, 0x1205, 0x1207, 0x9, 0x2, 0x2, 0x2, 
       0x1206, 0x1208, 0x7, 0x35a, 0x2, 0x2, 0x1207, 0x1206, 0x3, 0x2, 0x2, 
       0x2, 0x1207, 0x1208, 0x3, 0x2, 0x2, 0x2, 0x1208, 0x120a, 0x3, 0x2, 
       0x2, 0x2, 0x1209, 0x1203, 0x3, 0x2, 0x2, 0x2, 0x1209, 0x120a, 0x3, 
       0x2, 0x2, 0x2, 0x120a, 0x120e, 0x3, 0x2, 0x2, 0x2, 0x120b, 0x120c, 
       0x7, 0x207, 0x2, 0x2, 0x120c, 0x120d, 0x7, 0x346, 0x2, 0x2, 0x120d, 
       0x120f, 0x9, 0xf, 0x2, 0x2, 0x120e, 0x120b, 0x3, 0x2, 0x2, 0x2, 0x120e, 
       0x120f, 0x3, 0x2, 0x2, 0x2, 0x120f, 0x1211, 0x3, 0x2, 0x2, 0x2, 0x1210, 
       0x11fa, 0x3, 0x2, 0x2, 0x2, 0x1210, 0x1211, 0x3, 0x2, 0x2, 0x2, 0x1211, 
       0x1213, 0x3, 0x2, 0x2, 0x2, 0x1212, 0x1214, 0x7, 0x35b, 0x2, 0x2, 
       0x1213, 0x1212, 0x3, 0x2, 0x2, 0x2, 0x1213, 0x1214, 0x3, 0x2, 0x2, 
       0x2, 0x1214, 0x1dd, 0x3, 0x2, 0x2, 0x2, 0x1215, 0x1218, 0x5, 0x1f4, 
       0xfb, 0x2, 0x1216, 0x1218, 0x5, 0x106, 0x84, 0x2, 0x1217, 0x1215, 
       0x3, 0x2, 0x2, 0x2, 0x1217, 0x1216, 0x3, 0x2, 0x2, 0x2, 0x1218, 0x1df, 
       0x3, 0x2, 0x2, 0x2, 0x1219, 0x121c, 0x5, 0x1f4, 0xfb, 0x2, 0x121a, 
       0x121c, 0x5, 0x106, 0x84, 0x2, 0x121b, 0x1219, 0x3, 0x2, 0x2, 0x2, 
       0x121b, 0x121a, 0x3, 0x2, 0x2, 0x2, 0x121c, 0x1e1, 0x3, 0x2, 0x2, 
       0x2, 0x121d, 0x121e, 0x7, 0x71, 0x2, 0x2, 0x121e, 0x121f, 0x7, 0x4b, 
       0x2, 0x2, 0x121f, 0x1221, 0x7, 0x33d, 0x2, 0x2, 0x1220, 0x1222, 0x7, 
       0x35b, 0x2, 0x2, 0x1221, 0x1220, 0x3, 0x2, 0x2, 0x2, 0x1221, 0x1222, 
       0x3, 0x2, 0x2, 0x2, 0x1222, 0x122f, 0x3, 0x2, 0x2, 0x2, 0x1223, 0x122a, 
       0x7, 0x191, 0x2, 0x2, 0x1224, 0x1225, 0x7, 0x75, 0x2, 0x2, 0x1225, 
       0x1226, 0x7, 0x346, 0x2, 0x2, 0x1226, 0x1227, 0x9, 0x3, 0x2, 0x2, 
       0x1227, 0x1228, 0x7, 0x1f6, 0x2, 0x2, 0x1228, 0x1229, 0x7, 0x346, 
       0x2, 0x2, 0x1229, 0x122b, 0x9, 0x3, 0x2, 0x2, 0x122a, 0x1224, 0x3, 
       0x2, 0x2, 0x2, 0x122a, 0x122b, 0x3, 0x2, 0x2, 0x2, 0x122b, 0x122d, 
       0x3, 0x2, 0x2, 0x2, 0x122c, 0x122e, 0x7, 0x1cd, 0x2, 0x2, 0x122d, 
       0x122c, 0x3, 0x2, 0x2, 0x2, 0x122d, 0x122e, 0x3, 0x2, 0x2, 0x2, 0x122e, 
       0x1230, 0x3, 0x2, 0x2, 0x2, 0x122f, 0x1223, 0x3, 0x2, 0x2, 0x2, 0x122f, 
       0x1230, 0x3, 0x2, 0x2, 0x2, 0x1230, 0x1e3, 0x3, 0x2, 0x2, 0x2, 0x1231, 
       0x1233, 0x7, 0x18c, 0x2, 0x2, 0x1232, 0x1231, 0x3, 0x2, 0x2, 0x2, 
       0x1232, 0x1233, 0x3, 0x2, 0x2, 0x2, 0x1233, 0x1234, 0x3, 0x2, 0x2, 
       0x2, 0x1234, 0x1235, 0x7, 0x358, 0x2, 0x2, 0x1235, 0x1236, 0x5, 0x1e6, 
       0xf4, 0x2, 0x1236, 0x123c, 0x7, 0x359, 0x2, 0x2, 0x1237, 0x1239, 
       0x7, 0x35a, 0x2, 0x2, 0x1238, 0x1237, 0x3, 0x2, 0x2, 0x2, 0x1238, 
       0x1239, 0x3, 0x2, 0x2, 0x2, 0x1239, 0x123a, 0x3, 0x2, 0x2, 0x2, 0x123a, 
       0x123b, 0x7, 0x312, 0x2, 0x2, 0x123b, 0x123d, 0x5, 0x70, 0x39, 0x2, 
       0x123c, 0x1238, 0x3, 0x2, 0x2, 0x2, 0x123c, 0x123d, 0x3, 0x2, 0x2, 
       0x2, 0x123d, 0x123f, 0x3, 0x2, 0x2, 0x2, 0x123e, 0x1240, 0x7, 0x35b, 
       0x2, 0x2, 0x123f, 0x123e, 0x3, 0x2, 0x2, 0x2, 0x123f, 0x1240, 0x3, 
       0x2, 0x2, 0x2, 0x1240, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1241, 0x1242, 
       0x7, 0x94, 0x2, 0x2, 0x1242, 0x1243, 0x7, 0x4b, 0x2, 0x2, 0x1243, 
       0x1244, 0x7, 0x98, 0x2, 0x2, 0x1244, 0x1245, 0x9, 0x3, 0x2, 0x2, 
       0x1245, 0x1246, 0x7, 0x91, 0x2, 0x2, 0x1246, 0x1248, 0x5, 0x1e8, 
       0xf5, 0x2, 0x1247, 0x1249, 0x7, 0x35b, 0x2, 0x2, 0x1248, 0x1247, 
       0x3, 0x2, 0x2, 0x2, 0x1248, 0x1249, 0x3, 0x2, 0x2, 0x2, 0x1249, 0x1e7, 
       0x3, 0x2, 0x2, 0x2, 0x124a, 0x124b, 0x5, 0x1f4, 0xfb, 0x2, 0x124b, 
       0x124c, 0x7, 0x353, 0x2, 0x2, 0x124c, 0x124d, 0x5, 0x1f4, 0xfb, 0x2, 
       0x124d, 0x124e, 0x7, 0x353, 0x2, 0x2, 0x124e, 0x124f, 0x5, 0x1f4, 
       0xfb, 0x2, 0x124f, 0x1252, 0x3, 0x2, 0x2, 0x2, 0x1250, 0x1252, 0x5, 
       0x1f4, 0xfb, 0x2, 0x1251, 0x124a, 0x3, 0x2, 0x2, 0x2, 0x1251, 0x1250, 
       0x3, 0x2, 0x2, 0x2, 0x1252, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0x1253, 0x1254, 
       0x7, 0x2e8, 0x2, 0x2, 0x1254, 0x1255, 0x7, 0xf2, 0x2, 0x2, 0x1255, 
       0x1256, 0x7, 0x4b, 0x2, 0x2, 0x1256, 0x1257, 0x9, 0x3, 0x2, 0x2, 
       0x1257, 0x1258, 0x7, 0x26b, 0x2, 0x2, 0x1258, 0x1259, 0x7, 0x31d, 
       0x2, 0x2, 0x1259, 0x125d, 0x5, 0x106, 0x84, 0x2, 0x125a, 0x125b, 
       0x7, 0x358, 0x2, 0x2, 0x125b, 0x125c, 0x9, 0x3, 0x2, 0x2, 0x125c, 
       0x125e, 0x7, 0x359, 0x2, 0x2, 0x125d, 0x125a, 0x3, 0x2, 0x2, 0x2, 
       0x125d, 0x125e, 0x3, 0x2, 0x2, 0x2, 0x125e, 0x1260, 0x3, 0x2, 0x2, 
       0x2, 0x125f, 0x1261, 0x7, 0x35b, 0x2, 0x2, 0x1260, 0x125f, 0x3, 0x2, 
       0x2, 0x2, 0x1260, 0x1261, 0x3, 0x2, 0x2, 0x2, 0x1261, 0x1eb, 0x3, 
       0x2, 0x2, 0x2, 0x1262, 0x1264, 0x5, 0x1f4, 0xfb, 0x2, 0x1263, 0x1265, 
       0x7, 0x9c, 0x2, 0x2, 0x1264, 0x1263, 0x3, 0x2, 0x2, 0x2, 0x1264, 
       0x1265, 0x3, 0x2, 0x2, 0x2, 0x1265, 0x126d, 0x3, 0x2, 0x2, 0x2, 0x1266, 
       0x1267, 0x7, 0x358, 0x2, 0x2, 0x1267, 0x126a, 0x9, 0x3f, 0x2, 0x2, 
       0x1268, 0x1269, 0x7, 0x35a, 0x2, 0x2, 0x1269, 0x126b, 0x7, 0x33e, 
       0x2, 0x2, 0x126a, 0x1268, 0x3, 0x2, 
  };
  static uint16_t serializedATNSegment2[] = {
    0x2, 0x2, 0x126a, 0x126b, 0x3, 0x2, 0x2, 0x2, 0x126b, 0x126c, 0x3, 0x2, 
       0x2, 0x2, 0x126c, 0x126e, 0x7, 0x359, 0x2, 0x2, 0x126d, 0x1266, 0x3, 
       0x2, 0x2, 0x2, 0x126d, 0x126e, 0x3, 0x2, 0x2, 0x2, 0x126e, 0x1278, 
       0x3, 0x2, 0x2, 0x2, 0x126f, 0x1271, 0x7, 0x69, 0x2, 0x2, 0x1270, 
       0x1272, 0x7, 0x10c, 0x2, 0x2, 0x1271, 0x1270, 0x3, 0x2, 0x2, 0x2, 
       0x1271, 0x1272, 0x3, 0x2, 0x2, 0x2, 0x1272, 0x1278, 0x3, 0x2, 0x2, 
       0x2, 0x1273, 0x1278, 0x7, 0x23e, 0x2, 0x2, 0x1274, 0x1278, 0x7, 0x314, 
       0x2, 0x2, 0x1275, 0x1278, 0x7, 0x2f4, 0x2, 0x2, 0x1276, 0x1278, 0x7, 
       0x1bc, 0x2, 0x2, 0x1277, 0x1262, 0x3, 0x2, 0x2, 0x2, 0x1277, 0x126f, 
       0x3, 0x2, 0x2, 0x2, 0x1277, 0x1273, 0x3, 0x2, 0x2, 0x2, 0x1277, 0x1274, 
       0x3, 0x2, 0x2, 0x2, 0x1277, 0x1275, 0x3, 0x2, 0x2, 0x2, 0x1277, 0x1276, 
       0x3, 0x2, 0x2, 0x2, 0x1278, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x1279, 0x127d, 
       0x7, 0xec, 0x2, 0x2, 0x127a, 0x127d, 0x7, 0x5e, 0x2, 0x2, 0x127b, 
       0x127d, 0x5, 0x1f0, 0xf9, 0x2, 0x127c, 0x1279, 0x3, 0x2, 0x2, 0x2, 
       0x127c, 0x127a, 0x3, 0x2, 0x2, 0x2, 0x127c, 0x127b, 0x3, 0x2, 0x2, 
       0x2, 0x127d, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0x127e, 0x128e, 0x7, 0x342, 
       0x2, 0x2, 0x127f, 0x128e, 0x7, 0x343, 0x2, 0x2, 0x1280, 0x1282, 0x5, 
       0x1f2, 0xfa, 0x2, 0x1281, 0x1280, 0x3, 0x2, 0x2, 0x2, 0x1281, 0x1282, 
       0x3, 0x2, 0x2, 0x2, 0x1282, 0x1283, 0x3, 0x2, 0x2, 0x2, 0x1283, 0x128e, 
       0x7, 0x33e, 0x2, 0x2, 0x1284, 0x1286, 0x5, 0x1f2, 0xfa, 0x2, 0x1285, 
       0x1284, 0x3, 0x2, 0x2, 0x2, 0x1285, 0x1286, 0x3, 0x2, 0x2, 0x2, 0x1286, 
       0x1287, 0x3, 0x2, 0x2, 0x2, 0x1287, 0x128e, 0x9, 0x28, 0x2, 0x2, 
       0x1288, 0x128a, 0x5, 0x1f2, 0xfa, 0x2, 0x1289, 0x1288, 0x3, 0x2, 
       0x2, 0x2, 0x1289, 0x128a, 0x3, 0x2, 0x2, 0x2, 0x128a, 0x128b, 0x3, 
       0x2, 0x2, 0x2, 0x128b, 0x128c, 0x7, 0x357, 0x2, 0x2, 0x128c, 0x128e, 
       0x9, 0x40, 0x2, 0x2, 0x128d, 0x127e, 0x3, 0x2, 0x2, 0x2, 0x128d, 
       0x127f, 0x3, 0x2, 0x2, 0x2, 0x128d, 0x1281, 0x3, 0x2, 0x2, 0x2, 0x128d, 
       0x1285, 0x3, 0x2, 0x2, 0x2, 0x128d, 0x1289, 0x3, 0x2, 0x2, 0x2, 0x128e, 
       0x1f1, 0x3, 0x2, 0x2, 0x2, 0x128f, 0x1290, 0x9, 0x25, 0x2, 0x2, 0x1290, 
       0x1f3, 0x3, 0x2, 0x2, 0x2, 0x1291, 0x1295, 0x5, 0x1f6, 0xfc, 0x2, 
       0x1292, 0x1295, 0x7, 0x33a, 0x2, 0x2, 0x1293, 0x1295, 0x7, 0x33c, 
       0x2, 0x2, 0x1294, 0x1291, 0x3, 0x2, 0x2, 0x2, 0x1294, 0x1292, 0x3, 
       0x2, 0x2, 0x2, 0x1294, 0x1293, 0x3, 0x2, 0x2, 0x2, 0x1295, 0x1f5, 
       0x3, 0x2, 0x2, 0x2, 0x1296, 0x1297, 0x9, 0x41, 0x2, 0x2, 0x1297, 
       0x1f7, 0x3, 0x2, 0x2, 0x2, 0x1298, 0x12a8, 0x7, 0x346, 0x2, 0x2, 
       0x1299, 0x12a8, 0x7, 0x347, 0x2, 0x2, 0x129a, 0x12a8, 0x7, 0x348, 
       0x2, 0x2, 0x129b, 0x129c, 0x7, 0x348, 0x2, 0x2, 0x129c, 0x12a8, 0x7, 
       0x346, 0x2, 0x2, 0x129d, 0x129e, 0x7, 0x347, 0x2, 0x2, 0x129e, 0x12a8, 
       0x7, 0x346, 0x2, 0x2, 0x129f, 0x12a0, 0x7, 0x348, 0x2, 0x2, 0x12a0, 
       0x12a8, 0x7, 0x347, 0x2, 0x2, 0x12a1, 0x12a2, 0x7, 0x349, 0x2, 0x2, 
       0x12a2, 0x12a8, 0x7, 0x346, 0x2, 0x2, 0x12a3, 0x12a4, 0x7, 0x349, 
       0x2, 0x2, 0x12a4, 0x12a8, 0x7, 0x347, 0x2, 0x2, 0x12a5, 0x12a6, 0x7, 
       0x349, 0x2, 0x2, 0x12a6, 0x12a8, 0x7, 0x348, 0x2, 0x2, 0x12a7, 0x1298, 
       0x3, 0x2, 0x2, 0x2, 0x12a7, 0x1299, 0x3, 0x2, 0x2, 0x2, 0x12a7, 0x129a, 
       0x3, 0x2, 0x2, 0x2, 0x12a7, 0x129b, 0x3, 0x2, 0x2, 0x2, 0x12a7, 0x129d, 
       0x3, 0x2, 0x2, 0x2, 0x12a7, 0x129f, 0x3, 0x2, 0x2, 0x2, 0x12a7, 0x12a1, 
       0x3, 0x2, 0x2, 0x2, 0x12a7, 0x12a3, 0x3, 0x2, 0x2, 0x2, 0x12a7, 0x12a5, 
       0x3, 0x2, 0x2, 0x2, 0x12a8, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0x12a9, 0x12aa, 
       0x9, 0x42, 0x2, 0x2, 0x12aa, 0x1fb, 0x3, 0x2, 0x2, 0x2, 0x12ab, 0x12ad, 
       0x7, 0x33e, 0x2, 0x2, 0x12ac, 0x12ae, 0x9, 0x43, 0x2, 0x2, 0x12ad, 
       0x12ac, 0x3, 0x2, 0x2, 0x2, 0x12ad, 0x12ae, 0x3, 0x2, 0x2, 0x2, 0x12ae, 
       0x1fd, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x201, 0x20a, 0x20e, 0x214, 0x217, 
       0x21b, 0x21f, 0x227, 0x22e, 0x243, 0x251, 0x255, 0x258, 0x25c, 0x260, 
       0x264, 0x269, 0x26e, 0x270, 0x274, 0x277, 0x27e, 0x281, 0x28a, 0x28d, 
       0x298, 0x29b, 0x2a0, 0x2a5, 0x2a8, 0x2ad, 0x2b1, 0x2b4, 0x2b8, 0x2bb, 
       0x2be, 0x2c5, 0x2c9, 0x2cb, 0x2d0, 0x2d6, 0x2da, 0x2e7, 0x2ed, 0x2f0, 
       0x2f9, 0x2fc, 0x30e, 0x314, 0x319, 0x32c, 0x339, 0x33c, 0x346, 0x34c, 
       0x350, 0x354, 0x357, 0x35a, 0x35d, 0x364, 0x368, 0x36f, 0x376, 0x37c, 
       0x389, 0x38d, 0x392, 0x39c, 0x3a5, 0x3a9, 0x3b4, 0x3b8, 0x3bd, 0x3c8, 
       0x3d2, 0x3de, 0x3e4, 0x3e6, 0x3f0, 0x3f7, 0x3fd, 0x400, 0x405, 0x40c, 
       0x40e, 0x414, 0x416, 0x41e, 0x420, 0x426, 0x428, 0x42e, 0x430, 0x437, 
       0x43a, 0x43c, 0x43f, 0x443, 0x445, 0x44e, 0x454, 0x458, 0x460, 0x467, 
       0x46d, 0x46f, 0x47b, 0x483, 0x48f, 0x492, 0x49a, 0x49c, 0x49f, 0x4a3, 
       0x4a6, 0x4b0, 0x4b6, 0x4be, 0x4c2, 0x4c6, 0x4cf, 0x4d5, 0x4d9, 0x4dc, 
       0x4e7, 0x4eb, 0x4f2, 0x4f7, 0x4fa, 0x502, 0x506, 0x509, 0x50d, 0x510, 
       0x514, 0x51b, 0x51f, 0x521, 0x523, 0x526, 0x529, 0x52c, 0x532, 0x535, 
       0x53d, 0x53f, 0x542, 0x546, 0x549, 0x54f, 0x552, 0x556, 0x559, 0x55c, 
       0x563, 0x566, 0x56d, 0x573, 0x577, 0x581, 0x584, 0x587, 0x58b, 0x58e, 
       0x591, 0x594, 0x598, 0x59b, 0x5a3, 0x5a5, 0x5a9, 0x5ac, 0x5b4, 0x5b8, 
       0x5bc, 0x5c3, 0x5c7, 0x5c9, 0x5cb, 0x5ce, 0x5d1, 0x5d4, 0x5dc, 0x5e2, 
       0x5e8, 0x5ea, 0x5ee, 0x5f1, 0x5f6, 0x5fb, 0x5fe, 0x606, 0x60a, 0x611, 
       0x614, 0x61d, 0x620, 0x624, 0x62c, 0x62f, 0x633, 0x636, 0x644, 0x648, 
       0x64b, 0x64f, 0x652, 0x657, 0x65a, 0x660, 0x663, 0x66a, 0x66e, 0x670, 
       0x678, 0x67b, 0x67f, 0x687, 0x68a, 0x694, 0x69b, 0x6a0, 0x6a3, 0x6ad, 
       0x6b0, 0x6b3, 0x6bb, 0x6c6, 0x6c9, 0x6cc, 0x6d2, 0x6d7, 0x6db, 0x6e5, 
       0x6e8, 0x6eb, 0x6f1, 0x6f7, 0x6ff, 0x702, 0x706, 0x70a, 0x70d, 0x712, 
       0x720, 0x728, 0x72d, 0x732, 0x738, 0x73d, 0x740, 0x749, 0x753, 0x756, 
       0x75f, 0x767, 0x76a, 0x771, 0x774, 0x7a2, 0x7a6, 0x7a9, 0x7af, 0x7bc, 
       0x7c2, 0x7c9, 0x7d1, 0x7d4, 0x7d7, 0x7e0, 0x7ea, 0x7f1, 0x7f5, 0x7fb, 
       0x802, 0x806, 0x80c, 0x810, 0x816, 0x81d, 0x821, 0x82a, 0x832, 0x838, 
       0x83e, 0x84f, 0x853, 0x85b, 0x85f, 0x867, 0x86b, 0x870, 0x874, 0x87b, 
       0x881, 0x883, 0x887, 0x88b, 0x88f, 0x892, 0x896, 0x89c, 0x8a0, 0x8a2, 
       0x8a8, 0x8ac, 0x8b0, 0x8b7, 0x8c2, 0x8c6, 0x8cd, 0x8d0, 0x8d3, 0x8db, 
       0x8e0, 0x8e5, 0x8e8, 0x8ea, 0x8ee, 0x8f2, 0x8f5, 0x8f9, 0x901, 0x906, 
       0x90d, 0x91a, 0x91c, 0x91e, 0x921, 0x924, 0x92b, 0x92e, 0x934, 0x939, 
       0x93b, 0x93e, 0x944, 0x94c, 0x94e, 0x951, 0x955, 0x958, 0x962, 0x965, 
       0x969, 0x96c, 0x972, 0x975, 0x977, 0x97b, 0x980, 0x984, 0x989, 0x98e, 
       0x996, 0x99a, 0x99d, 0x9a2, 0x9aa, 0x9af, 0x9b9, 0x9c4, 0x9c9, 0x9cf, 
       0x9d5, 0x9d9, 0x9dc, 0x9e0, 0x9e4, 0x9ec, 0x9f1, 0x9f3, 0x9f6, 0x9fb, 
       0xa04, 0xa08, 0xa0d, 0xa10, 0xa13, 0xa19, 0xa21, 0xa29, 0xa2c, 0xa2f, 
       0xa33, 0xa38, 0xa3b, 0xa41, 0xa45, 0xa4b, 0xa53, 0xa59, 0xa5b, 0xa5e, 
       0xa6d, 0xa70, 0xa73, 0xa75, 0xa80, 0xa8b, 0xa94, 0xa9e, 0xaa8, 0xaaa, 
       0xaac, 0xaaf, 0xab2, 0xabd, 0xabf, 0xac1, 0xac4, 0xac9, 0xad4, 0xadd, 
       0xae0, 0xae3, 0xaec, 0xaef, 0xaf2, 0xaf9, 0xafc, 0xb0b, 0xb0e, 0xb15, 
       0xb25, 0xb29, 0xb33, 0xb46, 0xb48, 0xb4f, 0xb56, 0xb5a, 0xb62, 0xb66, 
       0xb6a, 0xb70, 0xb7a, 0xb84, 0xb8b, 0xb92, 0xb9b, 0xba2, 0xba9, 0xbb2, 
       0xbb6, 0xbc0, 0xbc7, 0xbcf, 0xbd7, 0xbdb, 0xbf1, 0xbfa, 0xc00, 0xc06, 
       0xc0c, 0xc16, 0xc1d, 0xc22, 0xc27, 0xc2b, 0xc32, 0xc36, 0xc39, 0xc3e, 
       0xc42, 0xc46, 0xc4b, 0xc52, 0xc55, 0xc59, 0xc5e, 0xc62, 0xc6b, 0xc72, 
       0xc7b, 0xc87, 0xc89, 0xc93, 0xc96, 0xc9b, 0xca4, 0xca6, 0xca8, 0xcad, 
       0xcb5, 0xcba, 0xcc2, 0xcc7, 0xccd, 0xcd7, 0xcd9, 0xcdd, 0xce1, 0xce3, 
       0xcec, 0xcee, 0xcf2, 0xcfd, 0xd1f, 0xd2f, 0xd36, 0xd38, 0xd3f, 0xd48, 
       0xd50, 0xd57, 0xd5e, 0xd61, 0xd64, 0xd6b, 0xd72, 0xd75, 0xd77, 0xd7f, 
       0xd81, 0xd87, 0xd8e, 0xd96, 0xd9c, 0xda1, 0xda5, 0xda9, 0xdae, 0xdb0, 
       0xdb8, 0xdba, 0xdbe, 0xdc5, 0xdc7, 0xdce, 0xdd0, 0xdd9, 0xde1, 0xde8, 
       0xdee, 0xdf9, 0xdfd, 0xdff, 0xe02, 0xe1a, 0xe33, 0xe38, 0xe4c, 0xe50, 
       0xe54, 0xe64, 0xe78, 0xeb2, 0xeb6, 0xee6, 0xef6, 0xef8, 0xeff, 0xf05, 
       0xf12, 0xf21, 0xf2c, 0xf31, 0xf3b, 0xf44, 0xf66, 0xf6b, 0xf71, 0xf74, 
       0xf79, 0xf7e, 0xf87, 0xf8c, 0xf92, 0xf9b, 0xfa5, 0xfa8, 0xfb6, 0xfbc, 
       0xfc4, 0xfc8, 0xfd0, 0xfd7, 0xfe4, 0xfec, 0xff9, 0x1000, 0x1006, 
       0x100a, 0x101b, 0x102a, 0x102c, 0x1031, 0x1034, 0x103d, 0x1040, 0x1043, 
       0x1050, 0x1054, 0x105c, 0x1062, 0x106a, 0x1071, 0x1077, 0x1086, 0x108f, 
       0x1095, 0x109b, 0x109e, 0x10a2, 0x10a9, 0x10b1, 0x10b4, 0x10ba, 0x10c0, 
       0x10c2, 0x10c8, 0x10cb, 0x10cd, 0x10d3, 0x10d5, 0x10e3, 0x10ea, 0x10f3, 
       0x10fa, 0x1106, 0x110d, 0x1114, 0x111b, 0x1121, 0x1128, 0x112b, 0x1130, 
       0x1137, 0x113f, 0x1143, 0x1146, 0x114e, 0x1152, 0x1155, 0x1159, 0x115e, 
       0x1164, 0x116a, 0x1170, 0x1176, 0x117c, 0x1182, 0x1188, 0x118b, 0x118f, 
       0x1194, 0x1198, 0x11a0, 0x11a5, 0x11ac, 0x11b5, 0x11b7, 0x11d9, 0x11e5, 
       0x11ea, 0x11f5, 0x11ff, 0x1201, 0x1207, 0x1209, 0x120e, 0x1210, 0x1213, 
       0x1217, 0x121b, 0x1221, 0x122a, 0x122d, 0x122f, 0x1232, 0x1238, 0x123c, 
       0x123f, 0x1248, 0x1251, 0x125d, 0x1260, 0x1264, 0x126a, 0x126d, 0x1271, 
       0x1277, 0x127c, 0x1281, 0x1285, 0x1289, 0x128d, 0x1294, 0x12a7, 0x12ad, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment2,
    serializedATNSegment2 + sizeof(serializedATNSegment2) / sizeof(serializedATNSegment2[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

TSqlParser::Initializer TSqlParser::_init;
