
// Generated from TSqlParser.g4 by ANTLR 4.9.1


#include "TSqlParserListener.h"

#include "TSqlParser.h"


using namespace antlrcpp;
using namespace antlr4;

TSqlParser::TSqlParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

TSqlParser::~TSqlParser() {
  delete _interpreter;
}

std::string TSqlParser::getGrammarFileName() const {
  return "TSqlParser.g4";
}

const std::vector<std::string>& TSqlParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& TSqlParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- Tsql_fileContext ------------------------------------------------------------------

TSqlParser::Tsql_fileContext::Tsql_fileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Tsql_fileContext::EOF() {
  return getToken(TSqlParser::EOF, 0);
}

std::vector<TSqlParser::BatchContext *> TSqlParser::Tsql_fileContext::batch() {
  return getRuleContexts<TSqlParser::BatchContext>();
}

TSqlParser::BatchContext* TSqlParser::Tsql_fileContext::batch(size_t i) {
  return getRuleContext<TSqlParser::BatchContext>(i);
}

TSqlParser::Execute_body_batchContext* TSqlParser::Tsql_fileContext::execute_body_batch() {
  return getRuleContext<TSqlParser::Execute_body_batchContext>(0);
}

std::vector<TSqlParser::Go_batch_statementContext *> TSqlParser::Tsql_fileContext::go_batch_statement() {
  return getRuleContexts<TSqlParser::Go_batch_statementContext>();
}

TSqlParser::Go_batch_statementContext* TSqlParser::Tsql_fileContext::go_batch_statement(size_t i) {
  return getRuleContext<TSqlParser::Go_batch_statementContext>(i);
}


size_t TSqlParser::Tsql_fileContext::getRuleIndex() const {
  return TSqlParser::RuleTsql_file;
}

void TSqlParser::Tsql_fileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsql_file(this);
}

void TSqlParser::Tsql_fileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsql_file(this);
}

TSqlParser::Tsql_fileContext* TSqlParser::tsql_file() {
  Tsql_fileContext *_localctx = _tracker.createInstance<Tsql_fileContext>(_ctx, getState());
  enterRule(_localctx, 0, TSqlParser::RuleTsql_file);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(448);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(435);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT)
        | (1ULL << TSqlParser::ALTER)
        | (1ULL << TSqlParser::BEGIN)
        | (1ULL << TSqlParser::BREAK)
        | (1ULL << TSqlParser::CLOSE)
        | (1ULL << TSqlParser::COMMIT)
        | (1ULL << TSqlParser::CONTINUE)
        | (1ULL << TSqlParser::CREATE)
        | (1ULL << TSqlParser::DBCC))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (TSqlParser::DEALLOCATE - 64))
        | (1ULL << (TSqlParser::DECLARE - 64))
        | (1ULL << (TSqlParser::DELETE - 64))
        | (1ULL << (TSqlParser::DROP - 64))
        | (1ULL << (TSqlParser::EXECUTE - 64))
        | (1ULL << (TSqlParser::FETCH - 64))
        | (1ULL << (TSqlParser::GOTO - 64))
        | (1ULL << (TSqlParser::IF - 64))
        | (1ULL << (TSqlParser::INSERT - 64))
        | (1ULL << (TSqlParser::KILL - 64))
        | (1ULL << (TSqlParser::MERGE - 64))
        | (1ULL << (TSqlParser::OPEN - 64))
        | (1ULL << (TSqlParser::PRECISION - 64))
        | (1ULL << (TSqlParser::PRINT - 64))
        | (1ULL << (TSqlParser::RAISERROR - 64)))) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & ((1ULL << (TSqlParser::RETURN - 131))
        | (1ULL << (TSqlParser::ROLLBACK - 131))
        | (1ULL << (TSqlParser::SAVE - 131))
        | (1ULL << (TSqlParser::SELECT - 131))
        | (1ULL << (TSqlParser::SET - 131))
        | (1ULL << (TSqlParser::SHUTDOWN - 131))
        | (1ULL << (TSqlParser::TRUNCATE - 131))
        | (1ULL << (TSqlParser::UPDATE - 131))
        | (1ULL << (TSqlParser::USE - 131))
        | (1ULL << (TSqlParser::WHILE - 131))
        | (1ULL << (TSqlParser::WITH - 131))
        | (1ULL << (TSqlParser::ABSOLUTE - 131))
        | (1ULL << (TSqlParser::AT_KEYWORD - 131))
        | (1ULL << (TSqlParser::ACTION - 131))
        | (1ULL << (TSqlParser::AES_128 - 131))
        | (1ULL << (TSqlParser::AES_192 - 131))
        | (1ULL << (TSqlParser::AES_256 - 131))
        | (1ULL << (TSqlParser::ALGORITHM - 131))
        | (1ULL << (TSqlParser::ANSI_NULLS - 131))
        | (1ULL << (TSqlParser::ANSI_PADDING - 131))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 131))
        | (1ULL << (TSqlParser::APPLY - 131))
        | (1ULL << (TSqlParser::ARITHABORT - 131))
        | (1ULL << (TSqlParser::AUTO - 131))
        | (1ULL << (TSqlParser::AVG - 131))
        | (1ULL << (TSqlParser::BIGINT - 131))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 131))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 131))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 131))
        | (1ULL << (TSqlParser::CALLER - 131))
        | (1ULL << (TSqlParser::CAST - 131))
        | (1ULL << (TSqlParser::TRY_CAST - 131))
        | (1ULL << (TSqlParser::CATCH - 131))
        | (1ULL << (TSqlParser::CHECKSUM - 131))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 131))
        | (1ULL << (TSqlParser::COMMITTED - 131))
        | (1ULL << (TSqlParser::CONCAT - 131))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 131))
        | (1ULL << (TSqlParser::COUNT - 131))
        | (1ULL << (TSqlParser::COUNT_BIG - 131)))) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 195)) & ((1ULL << (TSqlParser::CUME_DIST - 195))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 195))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 195))
        | (1ULL << (TSqlParser::DATA - 195))
        | (1ULL << (TSqlParser::DATEADD - 195))
        | (1ULL << (TSqlParser::DATEDIFF - 195))
        | (1ULL << (TSqlParser::DATENAME - 195))
        | (1ULL << (TSqlParser::DATEPART - 195))
        | (1ULL << (TSqlParser::DAYS - 195))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 195))
        | (1ULL << (TSqlParser::DELAY - 195))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 195))
        | (1ULL << (TSqlParser::DELETED - 195))
        | (1ULL << (TSqlParser::DENSE_RANK - 195))
        | (1ULL << (TSqlParser::DES - 195))
        | (1ULL << (TSqlParser::DESCRIPTION - 195))
        | (1ULL << (TSqlParser::DESX - 195))
        | (1ULL << (TSqlParser::DISABLE - 195))
        | (1ULL << (TSqlParser::DYNAMIC - 195))
        | (1ULL << (TSqlParser::ELEMENTS - 195))
        | (1ULL << (TSqlParser::EMPTY - 195))
        | (1ULL << (TSqlParser::ENCRYPTION - 195))
        | (1ULL << (TSqlParser::EXCLUSIVE - 195))
        | (1ULL << (TSqlParser::FAST - 195))
        | (1ULL << (TSqlParser::FAST_FORWARD - 195))
        | (1ULL << (TSqlParser::FIRST - 195))
        | (1ULL << (TSqlParser::FIRST_VALUE - 195))
        | (1ULL << (TSqlParser::FOLLOWING - 195))
        | (1ULL << (TSqlParser::FORCE - 195))
        | (1ULL << (TSqlParser::FORCED - 195))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 195))
        | (1ULL << (TSqlParser::GETDATE - 195))
        | (1ULL << (TSqlParser::GETUTCDATE - 195))
        | (1ULL << (TSqlParser::GLOBAL - 195))
        | (1ULL << (TSqlParser::GO_BATCH - 195))
        | (1ULL << (TSqlParser::GO - 195))
        | (1ULL << (TSqlParser::GROUPING - 195))
        | (1ULL << (TSqlParser::GROUPING_ID - 195))
        | (1ULL << (TSqlParser::HASH - 195))
        | (1ULL << (TSqlParser::HIGH - 195))
        | (1ULL << (TSqlParser::HOURS - 195))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 195))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 195))
        | (1ULL << (TSqlParser::INPUT - 195))
        | (1ULL << (TSqlParser::INSENSITIVE - 195))
        | (1ULL << (TSqlParser::INSERTED - 195))
        | (1ULL << (TSqlParser::INT - 195))
        | (1ULL << (TSqlParser::ISOLATION - 195))
        | (1ULL << (TSqlParser::KEEP - 195))
        | (1ULL << (TSqlParser::KEEPFIXED - 195))
        | (1ULL << (TSqlParser::KEYSET - 195))
        | (1ULL << (TSqlParser::LAG - 195))
        | (1ULL << (TSqlParser::LAST - 195))
        | (1ULL << (TSqlParser::LAST_VALUE - 195))
        | (1ULL << (TSqlParser::LEAD - 195))
        | (1ULL << (TSqlParser::LEVEL - 195))
        | (1ULL << (TSqlParser::LOCAL - 195))
        | (1ULL << (TSqlParser::LOCATION - 195))
        | (1ULL << (TSqlParser::LOCK - 195))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 195))
        | (1ULL << (TSqlParser::LOOP - 195))
        | (1ULL << (TSqlParser::LOW - 195))
        | (1ULL << (TSqlParser::MANUAL - 195))
        | (1ULL << (TSqlParser::MARK - 195)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (TSqlParser::MAX - 259))
        | (1ULL << (TSqlParser::MAXDOP - 259))
        | (1ULL << (TSqlParser::MAXRECURSION - 259))
        | (1ULL << (TSqlParser::MIN - 259))
        | (1ULL << (TSqlParser::MINUTES - 259))
        | (1ULL << (TSqlParser::MODE - 259))
        | (1ULL << (TSqlParser::NEXT - 259))
        | (1ULL << (TSqlParser::NO - 259))
        | (1ULL << (TSqlParser::NOCOUNT - 259))
        | (1ULL << (TSqlParser::NODES - 259))
        | (1ULL << (TSqlParser::NOEXPAND - 259))
        | (1ULL << (TSqlParser::NOWAIT - 259))
        | (1ULL << (TSqlParser::NTILE - 259))
        | (1ULL << (TSqlParser::NUMANODE - 259))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 259))
        | (1ULL << (TSqlParser::OBJECT - 259))
        | (1ULL << (TSqlParser::OFFSET - 259))
        | (1ULL << (TSqlParser::ONLINE - 259))
        | (1ULL << (TSqlParser::ONLY - 259))
        | (1ULL << (TSqlParser::OPTIMISTIC - 259))
        | (1ULL << (TSqlParser::OPTIMIZE - 259))
        | (1ULL << (TSqlParser::OUT - 259))
        | (1ULL << (TSqlParser::OUTPUT - 259))
        | (1ULL << (TSqlParser::OWNER - 259))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 259))
        | (1ULL << (TSqlParser::PARTITION - 259))
        | (1ULL << (TSqlParser::PARTITIONS - 259))
        | (1ULL << (TSqlParser::PERCENT_RANK - 259))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 259))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 259))
        | (1ULL << (TSqlParser::PRECEDING - 259))
        | (1ULL << (TSqlParser::PRIOR - 259))
        | (1ULL << (TSqlParser::QUERY - 259))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 259))
        | (1ULL << (TSqlParser::RANGE - 259))
        | (1ULL << (TSqlParser::RANK - 259))
        | (1ULL << (TSqlParser::RC2 - 259))
        | (1ULL << (TSqlParser::RC4 - 259))
        | (1ULL << (TSqlParser::RC4_128 - 259))
        | (1ULL << (TSqlParser::READ_ONLY - 259))
        | (1ULL << (TSqlParser::READONLY - 259))
        | (1ULL << (TSqlParser::REBUILD - 259))
        | (1ULL << (TSqlParser::RECOMPILE - 259))
        | (1ULL << (TSqlParser::RELATIVE - 259))
        | (1ULL << (TSqlParser::REMOTE - 259))
        | (1ULL << (TSqlParser::REPEATABLE - 259))
        | (1ULL << (TSqlParser::ROBUST - 259))
        | (1ULL << (TSqlParser::ROW - 259))
        | (1ULL << (TSqlParser::ROW_NUMBER - 259))
        | (1ULL << (TSqlParser::ROWGUID - 259))
        | (1ULL << (TSqlParser::ROWS - 259))
        | (1ULL << (TSqlParser::SCHEMABINDING - 259))
        | (1ULL << (TSqlParser::SCROLL - 259))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 259))
        | (1ULL << (TSqlParser::SECONDS - 259))
        | (1ULL << (TSqlParser::SELF - 259))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 259))
        | (1ULL << (TSqlParser::SEQUENCE - 259))
        | (1ULL << (TSqlParser::SERIALIZABLE - 259))
        | (1ULL << (TSqlParser::SETERROR - 259))
        | (1ULL << (TSqlParser::SHARE - 259))
        | (1ULL << (TSqlParser::SIMPLE - 259))
        | (1ULL << (TSqlParser::SIZE - 259)))) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 323)) & ((1ULL << (TSqlParser::SMALLINT - 323))
        | (1ULL << (TSqlParser::SNAPSHOT - 323))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 323))
        | (1ULL << (TSqlParser::STATIC - 323))
        | (1ULL << (TSqlParser::STATUSONLY - 323))
        | (1ULL << (TSqlParser::STDEV - 323))
        | (1ULL << (TSqlParser::STDEVP - 323))
        | (1ULL << (TSqlParser::STRING_AGG - 323))
        | (1ULL << (TSqlParser::STUFF - 323))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 323))
        | (1ULL << (TSqlParser::SUM - 323))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 323))
        | (1ULL << (TSqlParser::THROW - 323))
        | (1ULL << (TSqlParser::TIES - 323))
        | (1ULL << (TSqlParser::TIME - 323))
        | (1ULL << (TSqlParser::TIMEOUT - 323))
        | (1ULL << (TSqlParser::TINYINT - 323))
        | (1ULL << (TSqlParser::TRIPLE_DES - 323))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 323))
        | (1ULL << (TSqlParser::TRY - 323))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 323))
        | (1ULL << (TSqlParser::TYPE - 323))
        | (1ULL << (TSqlParser::TYPE_WARNING - 323))
        | (1ULL << (TSqlParser::UNBOUNDED - 323))
        | (1ULL << (TSqlParser::UNCOMMITTED - 323))
        | (1ULL << (TSqlParser::UNKNOWN - 323))
        | (1ULL << (TSqlParser::UOW - 323))
        | (1ULL << (TSqlParser::USING - 323))
        | (1ULL << (TSqlParser::VAR - 323))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 323))
        | (1ULL << (TSqlParser::VARP - 323))
        | (1ULL << (TSqlParser::WAIT - 323))
        | (1ULL << (TSqlParser::WAITFOR - 323))
        | (1ULL << (TSqlParser::WORK - 323))
        | (1ULL << (TSqlParser::ZONE - 323))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 323))
        | (1ULL << (TSqlParser::CACHE - 323))
        | (1ULL << (TSqlParser::CALLED - 323))
        | (1ULL << (TSqlParser::CHANGETABLE - 323))
        | (1ULL << (TSqlParser::CHANGES - 323))
        | (1ULL << (TSqlParser::CYCLE - 323))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 323))
        | (1ULL << (TSqlParser::ERROR - 323))
        | (1ULL << (TSqlParser::FORCESEEK - 323))
        | (1ULL << (TSqlParser::IIF - 323))
        | (1ULL << (TSqlParser::INCREMENT - 323))
        | (1ULL << (TSqlParser::ISNULL - 323))
        | (1ULL << (TSqlParser::LOG - 323))
        | (1ULL << (TSqlParser::MATCHED - 323))
        | (1ULL << (TSqlParser::MAXVALUE - 323))
        | (1ULL << (TSqlParser::MINVALUE - 323))
        | (1ULL << (TSqlParser::NOTIFICATION - 323))
        | (1ULL << (TSqlParser::PERSISTED - 323))
        | (1ULL << (TSqlParser::PREDICATE - 323))
        | (1ULL << (TSqlParser::RESTART - 323))
        | (1ULL << (TSqlParser::RETURNS - 323))
        | (1ULL << (TSqlParser::SOURCE - 323)))) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 387)) & ((1ULL << (TSqlParser::STATE - 387))
        | (1ULL << (TSqlParser::START - 387))
        | (1ULL << (TSqlParser::TARGET - 387))
        | (1ULL << (TSqlParser::VARCHAR - 387))
        | (1ULL << (TSqlParser::NVARCHAR - 387))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 387))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 387))
        | (1ULL << (TSqlParser::ID - 387))
        | (1ULL << (TSqlParser::DOT - 387))
        | (1ULL << (TSqlParser::LR_BRACKET - 387))
        | (1ULL << (TSqlParser::SEMI - 387)))) != 0)) {
        setState(432);
        batch();
        setState(437);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(438);
      match(TSqlParser::EOF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(439);
      execute_body_batch();
      setState(443);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::GO_BATCH) {
        setState(440);
        go_batch_statement();
        setState(445);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(446);
      match(TSqlParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BatchContext ------------------------------------------------------------------

TSqlParser::BatchContext::BatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Go_batch_statementContext* TSqlParser::BatchContext::go_batch_statement() {
  return getRuleContext<TSqlParser::Go_batch_statementContext>(0);
}

TSqlParser::Execute_body_batchContext* TSqlParser::BatchContext::execute_body_batch() {
  return getRuleContext<TSqlParser::Execute_body_batchContext>(0);
}

std::vector<TSqlParser::Go_statementContext *> TSqlParser::BatchContext::go_statement() {
  return getRuleContexts<TSqlParser::Go_statementContext>();
}

TSqlParser::Go_statementContext* TSqlParser::BatchContext::go_statement(size_t i) {
  return getRuleContext<TSqlParser::Go_statementContext>(i);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::BatchContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::BatchContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

TSqlParser::Batch_level_statementContext* TSqlParser::BatchContext::batch_level_statement() {
  return getRuleContext<TSqlParser::Batch_level_statementContext>(0);
}


size_t TSqlParser::BatchContext::getRuleIndex() const {
  return TSqlParser::RuleBatch;
}

void TSqlParser::BatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBatch(this);
}

void TSqlParser::BatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBatch(this);
}

TSqlParser::BatchContext* TSqlParser::batch() {
  BatchContext *_localctx = _tracker.createInstance<BatchContext>(_ctx, getState());
  enterRule(_localctx, 2, TSqlParser::RuleBatch);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(476);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(450);
      go_batch_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(452);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
      case 1: {
        setState(451);
        execute_body_batch();
        break;
      }

      default:
        break;
      }
      setState(460);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
      case 1: {
        setState(454);
        go_batch_statement();
        break;
      }

      case 2: {
        setState(456); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(455);
                  sql_clauses();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(458); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      default:
        break;
      }
      setState(465);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(462);
          go_statement(); 
        }
        setState(467);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(468);
      batch_level_statement();
      setState(472);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(469);
          go_statement(); 
        }
        setState(474);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(475);
      go_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Batch_level_statementContext ------------------------------------------------------------------

TSqlParser::Batch_level_statementContext::Batch_level_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Create_or_alter_functionContext* TSqlParser::Batch_level_statementContext::create_or_alter_function() {
  return getRuleContext<TSqlParser::Create_or_alter_functionContext>(0);
}

TSqlParser::Create_or_alter_procedureContext* TSqlParser::Batch_level_statementContext::create_or_alter_procedure() {
  return getRuleContext<TSqlParser::Create_or_alter_procedureContext>(0);
}


size_t TSqlParser::Batch_level_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBatch_level_statement;
}

void TSqlParser::Batch_level_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBatch_level_statement(this);
}

void TSqlParser::Batch_level_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBatch_level_statement(this);
}

TSqlParser::Batch_level_statementContext* TSqlParser::batch_level_statement() {
  Batch_level_statementContext *_localctx = _tracker.createInstance<Batch_level_statementContext>(_ctx, getState());
  enterRule(_localctx, 4, TSqlParser::RuleBatch_level_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(480);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(478);
      create_or_alter_function();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(479);
      create_or_alter_procedure();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_clausesContext ------------------------------------------------------------------

TSqlParser::Sql_clausesContext::Sql_clausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Dml_clauseContext* TSqlParser::Sql_clausesContext::dml_clause() {
  return getRuleContext<TSqlParser::Dml_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Sql_clausesContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Cfl_statementContext* TSqlParser::Sql_clausesContext::cfl_statement() {
  return getRuleContext<TSqlParser::Cfl_statementContext>(0);
}

TSqlParser::Another_statementContext* TSqlParser::Sql_clausesContext::another_statement() {
  return getRuleContext<TSqlParser::Another_statementContext>(0);
}

TSqlParser::Ddl_clauseContext* TSqlParser::Sql_clausesContext::ddl_clause() {
  return getRuleContext<TSqlParser::Ddl_clauseContext>(0);
}

TSqlParser::Dbcc_specialContext* TSqlParser::Sql_clausesContext::dbcc_special() {
  return getRuleContext<TSqlParser::Dbcc_specialContext>(0);
}

TSqlParser::Dbcc_clauseContext* TSqlParser::Sql_clausesContext::dbcc_clause() {
  return getRuleContext<TSqlParser::Dbcc_clauseContext>(0);
}


size_t TSqlParser::Sql_clausesContext::getRuleIndex() const {
  return TSqlParser::RuleSql_clauses;
}

void TSqlParser::Sql_clausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_clauses(this);
}

void TSqlParser::Sql_clausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_clauses(this);
}

TSqlParser::Sql_clausesContext* TSqlParser::sql_clauses() {
  Sql_clausesContext *_localctx = _tracker.createInstance<Sql_clausesContext>(_ctx, getState());
  enterRule(_localctx, 6, TSqlParser::RuleSql_clauses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(507);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(482);
      dml_clause();
      setState(484);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
      case 1: {
        setState(483);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(486);
      cfl_statement();
      setState(488);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
      case 1: {
        setState(487);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(490);
      another_statement();
      setState(492);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
      case 1: {
        setState(491);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(494);
      ddl_clause();
      setState(496);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
      case 1: {
        setState(495);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(498);
      dbcc_special();
      setState(500);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
      case 1: {
        setState(499);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(502);
      dbcc_clause();
      setState(504);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
      case 1: {
        setState(503);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(506);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dml_clauseContext ------------------------------------------------------------------

TSqlParser::Dml_clauseContext::Dml_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Merge_statementContext* TSqlParser::Dml_clauseContext::merge_statement() {
  return getRuleContext<TSqlParser::Merge_statementContext>(0);
}

TSqlParser::Delete_statementContext* TSqlParser::Dml_clauseContext::delete_statement() {
  return getRuleContext<TSqlParser::Delete_statementContext>(0);
}

TSqlParser::Insert_statementContext* TSqlParser::Dml_clauseContext::insert_statement() {
  return getRuleContext<TSqlParser::Insert_statementContext>(0);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Dml_clauseContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

TSqlParser::Update_statementContext* TSqlParser::Dml_clauseContext::update_statement() {
  return getRuleContext<TSqlParser::Update_statementContext>(0);
}


size_t TSqlParser::Dml_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDml_clause;
}

void TSqlParser::Dml_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDml_clause(this);
}

void TSqlParser::Dml_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDml_clause(this);
}

TSqlParser::Dml_clauseContext* TSqlParser::dml_clause() {
  Dml_clauseContext *_localctx = _tracker.createInstance<Dml_clauseContext>(_ctx, getState());
  enterRule(_localctx, 8, TSqlParser::RuleDml_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(514);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(509);
      merge_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(510);
      delete_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(511);
      insert_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(512);
      select_statement_standalone();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(513);
      update_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_clauseContext ------------------------------------------------------------------

TSqlParser::Ddl_clauseContext::Ddl_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Alter_sequenceContext* TSqlParser::Ddl_clauseContext::alter_sequence() {
  return getRuleContext<TSqlParser::Alter_sequenceContext>(0);
}

TSqlParser::Alter_tableContext* TSqlParser::Ddl_clauseContext::alter_table() {
  return getRuleContext<TSqlParser::Alter_tableContext>(0);
}

TSqlParser::Create_sequenceContext* TSqlParser::Ddl_clauseContext::create_sequence() {
  return getRuleContext<TSqlParser::Create_sequenceContext>(0);
}

TSqlParser::Create_tableContext* TSqlParser::Ddl_clauseContext::create_table() {
  return getRuleContext<TSqlParser::Create_tableContext>(0);
}

TSqlParser::Drop_functionContext* TSqlParser::Ddl_clauseContext::drop_function() {
  return getRuleContext<TSqlParser::Drop_functionContext>(0);
}

TSqlParser::Drop_procedureContext* TSqlParser::Ddl_clauseContext::drop_procedure() {
  return getRuleContext<TSqlParser::Drop_procedureContext>(0);
}

TSqlParser::Drop_tableContext* TSqlParser::Ddl_clauseContext::drop_table() {
  return getRuleContext<TSqlParser::Drop_tableContext>(0);
}

TSqlParser::Lock_tableContext* TSqlParser::Ddl_clauseContext::lock_table() {
  return getRuleContext<TSqlParser::Lock_tableContext>(0);
}

TSqlParser::Truncate_tableContext* TSqlParser::Ddl_clauseContext::truncate_table() {
  return getRuleContext<TSqlParser::Truncate_tableContext>(0);
}


size_t TSqlParser::Ddl_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDdl_clause;
}

void TSqlParser::Ddl_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDdl_clause(this);
}

void TSqlParser::Ddl_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDdl_clause(this);
}

TSqlParser::Ddl_clauseContext* TSqlParser::ddl_clause() {
  Ddl_clauseContext *_localctx = _tracker.createInstance<Ddl_clauseContext>(_ctx, getState());
  enterRule(_localctx, 10, TSqlParser::RuleDdl_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(525);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(516);
      alter_sequence();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(517);
      alter_table();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(518);
      create_sequence();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(519);
      create_table();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(520);
      drop_function();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(521);
      drop_procedure();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(522);
      drop_table();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(523);
      lock_table();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(524);
      truncate_table();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cfl_statementContext ------------------------------------------------------------------

TSqlParser::Cfl_statementContext::Cfl_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Block_statementContext* TSqlParser::Cfl_statementContext::block_statement() {
  return getRuleContext<TSqlParser::Block_statementContext>(0);
}

TSqlParser::Break_statementContext* TSqlParser::Cfl_statementContext::break_statement() {
  return getRuleContext<TSqlParser::Break_statementContext>(0);
}

TSqlParser::Continue_statementContext* TSqlParser::Cfl_statementContext::continue_statement() {
  return getRuleContext<TSqlParser::Continue_statementContext>(0);
}

TSqlParser::Goto_statementContext* TSqlParser::Cfl_statementContext::goto_statement() {
  return getRuleContext<TSqlParser::Goto_statementContext>(0);
}

TSqlParser::If_statementContext* TSqlParser::Cfl_statementContext::if_statement() {
  return getRuleContext<TSqlParser::If_statementContext>(0);
}

TSqlParser::Return_statementContext* TSqlParser::Cfl_statementContext::return_statement() {
  return getRuleContext<TSqlParser::Return_statementContext>(0);
}

TSqlParser::Throw_statementContext* TSqlParser::Cfl_statementContext::throw_statement() {
  return getRuleContext<TSqlParser::Throw_statementContext>(0);
}

TSqlParser::Try_catch_statementContext* TSqlParser::Cfl_statementContext::try_catch_statement() {
  return getRuleContext<TSqlParser::Try_catch_statementContext>(0);
}

TSqlParser::Waitfor_statementContext* TSqlParser::Cfl_statementContext::waitfor_statement() {
  return getRuleContext<TSqlParser::Waitfor_statementContext>(0);
}

TSqlParser::While_statementContext* TSqlParser::Cfl_statementContext::while_statement() {
  return getRuleContext<TSqlParser::While_statementContext>(0);
}

TSqlParser::Print_statementContext* TSqlParser::Cfl_statementContext::print_statement() {
  return getRuleContext<TSqlParser::Print_statementContext>(0);
}

TSqlParser::Raiseerror_statementContext* TSqlParser::Cfl_statementContext::raiseerror_statement() {
  return getRuleContext<TSqlParser::Raiseerror_statementContext>(0);
}


size_t TSqlParser::Cfl_statementContext::getRuleIndex() const {
  return TSqlParser::RuleCfl_statement;
}

void TSqlParser::Cfl_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCfl_statement(this);
}

void TSqlParser::Cfl_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCfl_statement(this);
}

TSqlParser::Cfl_statementContext* TSqlParser::cfl_statement() {
  Cfl_statementContext *_localctx = _tracker.createInstance<Cfl_statementContext>(_ctx, getState());
  enterRule(_localctx, 12, TSqlParser::RuleCfl_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(527);
      block_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(528);
      break_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(529);
      continue_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(530);
      goto_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(531);
      if_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(532);
      return_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(533);
      throw_statement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(534);
      try_catch_statement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(535);
      waitfor_statement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(536);
      while_statement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(537);
      print_statement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(538);
      raiseerror_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_statementContext ------------------------------------------------------------------

TSqlParser::Block_statementContext::Block_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Block_statementContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Block_statementContext::END() {
  return getToken(TSqlParser::END, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Block_statementContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Block_statementContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Block_statementContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Block_statementContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}


size_t TSqlParser::Block_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBlock_statement;
}

void TSqlParser::Block_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_statement(this);
}

void TSqlParser::Block_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_statement(this);
}

TSqlParser::Block_statementContext* TSqlParser::block_statement() {
  Block_statementContext *_localctx = _tracker.createInstance<Block_statementContext>(_ctx, getState());
  enterRule(_localctx, 14, TSqlParser::RuleBlock_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    match(TSqlParser::BEGIN);
    setState(543);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(542);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
    setState(548);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
      | (1ULL << TSqlParser::NCHAR)
      | (1ULL << TSqlParser::TEXT)
      | (1ULL << TSqlParser::NTEXT)
      | (1ULL << TSqlParser::ALTER)
      | (1ULL << TSqlParser::BEGIN)
      | (1ULL << TSqlParser::BREAK)
      | (1ULL << TSqlParser::CLOSE)
      | (1ULL << TSqlParser::COMMIT)
      | (1ULL << TSqlParser::CONTINUE)
      | (1ULL << TSqlParser::CREATE)
      | (1ULL << TSqlParser::DBCC))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (TSqlParser::DEALLOCATE - 64))
      | (1ULL << (TSqlParser::DECLARE - 64))
      | (1ULL << (TSqlParser::DELETE - 64))
      | (1ULL << (TSqlParser::DROP - 64))
      | (1ULL << (TSqlParser::EXECUTE - 64))
      | (1ULL << (TSqlParser::FETCH - 64))
      | (1ULL << (TSqlParser::GOTO - 64))
      | (1ULL << (TSqlParser::IF - 64))
      | (1ULL << (TSqlParser::INSERT - 64))
      | (1ULL << (TSqlParser::KILL - 64))
      | (1ULL << (TSqlParser::MERGE - 64))
      | (1ULL << (TSqlParser::OPEN - 64))
      | (1ULL << (TSqlParser::PRECISION - 64))
      | (1ULL << (TSqlParser::PRINT - 64))
      | (1ULL << (TSqlParser::RAISERROR - 64)))) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & ((1ULL << (TSqlParser::RETURN - 131))
      | (1ULL << (TSqlParser::ROLLBACK - 131))
      | (1ULL << (TSqlParser::SAVE - 131))
      | (1ULL << (TSqlParser::SELECT - 131))
      | (1ULL << (TSqlParser::SET - 131))
      | (1ULL << (TSqlParser::SHUTDOWN - 131))
      | (1ULL << (TSqlParser::TRUNCATE - 131))
      | (1ULL << (TSqlParser::UPDATE - 131))
      | (1ULL << (TSqlParser::USE - 131))
      | (1ULL << (TSqlParser::WHILE - 131))
      | (1ULL << (TSqlParser::WITH - 131))
      | (1ULL << (TSqlParser::ABSOLUTE - 131))
      | (1ULL << (TSqlParser::AT_KEYWORD - 131))
      | (1ULL << (TSqlParser::ACTION - 131))
      | (1ULL << (TSqlParser::AES_128 - 131))
      | (1ULL << (TSqlParser::AES_192 - 131))
      | (1ULL << (TSqlParser::AES_256 - 131))
      | (1ULL << (TSqlParser::ALGORITHM - 131))
      | (1ULL << (TSqlParser::ANSI_NULLS - 131))
      | (1ULL << (TSqlParser::ANSI_PADDING - 131))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 131))
      | (1ULL << (TSqlParser::APPLY - 131))
      | (1ULL << (TSqlParser::ARITHABORT - 131))
      | (1ULL << (TSqlParser::AUTO - 131))
      | (1ULL << (TSqlParser::AVG - 131))
      | (1ULL << (TSqlParser::BIGINT - 131))
      | (1ULL << (TSqlParser::BINARY_KEYWORD - 131))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 131))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 131))
      | (1ULL << (TSqlParser::CALLER - 131))
      | (1ULL << (TSqlParser::CAST - 131))
      | (1ULL << (TSqlParser::TRY_CAST - 131))
      | (1ULL << (TSqlParser::CATCH - 131))
      | (1ULL << (TSqlParser::CHECKSUM - 131))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 131))
      | (1ULL << (TSqlParser::COMMITTED - 131))
      | (1ULL << (TSqlParser::CONCAT - 131))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 131))
      | (1ULL << (TSqlParser::COUNT - 131))
      | (1ULL << (TSqlParser::COUNT_BIG - 131)))) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 195)) & ((1ULL << (TSqlParser::CUME_DIST - 195))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 195))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 195))
      | (1ULL << (TSqlParser::DATA - 195))
      | (1ULL << (TSqlParser::DATEADD - 195))
      | (1ULL << (TSqlParser::DATEDIFF - 195))
      | (1ULL << (TSqlParser::DATENAME - 195))
      | (1ULL << (TSqlParser::DATEPART - 195))
      | (1ULL << (TSqlParser::DAYS - 195))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 195))
      | (1ULL << (TSqlParser::DELAY - 195))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 195))
      | (1ULL << (TSqlParser::DELETED - 195))
      | (1ULL << (TSqlParser::DENSE_RANK - 195))
      | (1ULL << (TSqlParser::DES - 195))
      | (1ULL << (TSqlParser::DESCRIPTION - 195))
      | (1ULL << (TSqlParser::DESX - 195))
      | (1ULL << (TSqlParser::DISABLE - 195))
      | (1ULL << (TSqlParser::DYNAMIC - 195))
      | (1ULL << (TSqlParser::ELEMENTS - 195))
      | (1ULL << (TSqlParser::EMPTY - 195))
      | (1ULL << (TSqlParser::ENCRYPTION - 195))
      | (1ULL << (TSqlParser::EXCLUSIVE - 195))
      | (1ULL << (TSqlParser::FAST - 195))
      | (1ULL << (TSqlParser::FAST_FORWARD - 195))
      | (1ULL << (TSqlParser::FIRST - 195))
      | (1ULL << (TSqlParser::FIRST_VALUE - 195))
      | (1ULL << (TSqlParser::FOLLOWING - 195))
      | (1ULL << (TSqlParser::FORCE - 195))
      | (1ULL << (TSqlParser::FORCED - 195))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 195))
      | (1ULL << (TSqlParser::GETDATE - 195))
      | (1ULL << (TSqlParser::GETUTCDATE - 195))
      | (1ULL << (TSqlParser::GLOBAL - 195))
      | (1ULL << (TSqlParser::GO_BATCH - 195))
      | (1ULL << (TSqlParser::GO - 195))
      | (1ULL << (TSqlParser::GROUPING - 195))
      | (1ULL << (TSqlParser::GROUPING_ID - 195))
      | (1ULL << (TSqlParser::HASH - 195))
      | (1ULL << (TSqlParser::HIGH - 195))
      | (1ULL << (TSqlParser::HOURS - 195))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 195))
      | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 195))
      | (1ULL << (TSqlParser::INPUT - 195))
      | (1ULL << (TSqlParser::INSENSITIVE - 195))
      | (1ULL << (TSqlParser::INSERTED - 195))
      | (1ULL << (TSqlParser::INT - 195))
      | (1ULL << (TSqlParser::ISOLATION - 195))
      | (1ULL << (TSqlParser::KEEP - 195))
      | (1ULL << (TSqlParser::KEEPFIXED - 195))
      | (1ULL << (TSqlParser::KEYSET - 195))
      | (1ULL << (TSqlParser::LAG - 195))
      | (1ULL << (TSqlParser::LAST - 195))
      | (1ULL << (TSqlParser::LAST_VALUE - 195))
      | (1ULL << (TSqlParser::LEAD - 195))
      | (1ULL << (TSqlParser::LEVEL - 195))
      | (1ULL << (TSqlParser::LOCAL - 195))
      | (1ULL << (TSqlParser::LOCATION - 195))
      | (1ULL << (TSqlParser::LOCK - 195))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 195))
      | (1ULL << (TSqlParser::LOOP - 195))
      | (1ULL << (TSqlParser::LOW - 195))
      | (1ULL << (TSqlParser::MANUAL - 195))
      | (1ULL << (TSqlParser::MARK - 195)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (TSqlParser::MAX - 259))
      | (1ULL << (TSqlParser::MAXDOP - 259))
      | (1ULL << (TSqlParser::MAXRECURSION - 259))
      | (1ULL << (TSqlParser::MIN - 259))
      | (1ULL << (TSqlParser::MINUTES - 259))
      | (1ULL << (TSqlParser::MODE - 259))
      | (1ULL << (TSqlParser::NEXT - 259))
      | (1ULL << (TSqlParser::NO - 259))
      | (1ULL << (TSqlParser::NOCOUNT - 259))
      | (1ULL << (TSqlParser::NODES - 259))
      | (1ULL << (TSqlParser::NOEXPAND - 259))
      | (1ULL << (TSqlParser::NOWAIT - 259))
      | (1ULL << (TSqlParser::NTILE - 259))
      | (1ULL << (TSqlParser::NUMANODE - 259))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 259))
      | (1ULL << (TSqlParser::OBJECT - 259))
      | (1ULL << (TSqlParser::OFFSET - 259))
      | (1ULL << (TSqlParser::ONLINE - 259))
      | (1ULL << (TSqlParser::ONLY - 259))
      | (1ULL << (TSqlParser::OPTIMISTIC - 259))
      | (1ULL << (TSqlParser::OPTIMIZE - 259))
      | (1ULL << (TSqlParser::OUT - 259))
      | (1ULL << (TSqlParser::OUTPUT - 259))
      | (1ULL << (TSqlParser::OWNER - 259))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 259))
      | (1ULL << (TSqlParser::PARTITION - 259))
      | (1ULL << (TSqlParser::PARTITIONS - 259))
      | (1ULL << (TSqlParser::PERCENT_RANK - 259))
      | (1ULL << (TSqlParser::PERCENTILE_CONT - 259))
      | (1ULL << (TSqlParser::PERCENTILE_DISC - 259))
      | (1ULL << (TSqlParser::PRECEDING - 259))
      | (1ULL << (TSqlParser::PRIOR - 259))
      | (1ULL << (TSqlParser::QUERY - 259))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 259))
      | (1ULL << (TSqlParser::RANGE - 259))
      | (1ULL << (TSqlParser::RANK - 259))
      | (1ULL << (TSqlParser::RC2 - 259))
      | (1ULL << (TSqlParser::RC4 - 259))
      | (1ULL << (TSqlParser::RC4_128 - 259))
      | (1ULL << (TSqlParser::READ_ONLY - 259))
      | (1ULL << (TSqlParser::READONLY - 259))
      | (1ULL << (TSqlParser::REBUILD - 259))
      | (1ULL << (TSqlParser::RECOMPILE - 259))
      | (1ULL << (TSqlParser::RELATIVE - 259))
      | (1ULL << (TSqlParser::REMOTE - 259))
      | (1ULL << (TSqlParser::REPEATABLE - 259))
      | (1ULL << (TSqlParser::ROBUST - 259))
      | (1ULL << (TSqlParser::ROW - 259))
      | (1ULL << (TSqlParser::ROW_NUMBER - 259))
      | (1ULL << (TSqlParser::ROWGUID - 259))
      | (1ULL << (TSqlParser::ROWS - 259))
      | (1ULL << (TSqlParser::SCHEMABINDING - 259))
      | (1ULL << (TSqlParser::SCROLL - 259))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 259))
      | (1ULL << (TSqlParser::SECONDS - 259))
      | (1ULL << (TSqlParser::SELF - 259))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 259))
      | (1ULL << (TSqlParser::SEQUENCE - 259))
      | (1ULL << (TSqlParser::SERIALIZABLE - 259))
      | (1ULL << (TSqlParser::SETERROR - 259))
      | (1ULL << (TSqlParser::SHARE - 259))
      | (1ULL << (TSqlParser::SIMPLE - 259))
      | (1ULL << (TSqlParser::SIZE - 259)))) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 323)) & ((1ULL << (TSqlParser::SMALLINT - 323))
      | (1ULL << (TSqlParser::SNAPSHOT - 323))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 323))
      | (1ULL << (TSqlParser::STATIC - 323))
      | (1ULL << (TSqlParser::STATUSONLY - 323))
      | (1ULL << (TSqlParser::STDEV - 323))
      | (1ULL << (TSqlParser::STDEVP - 323))
      | (1ULL << (TSqlParser::STRING_AGG - 323))
      | (1ULL << (TSqlParser::STUFF - 323))
      | (1ULL << (TSqlParser::SUBSCRIPTION - 323))
      | (1ULL << (TSqlParser::SUM - 323))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 323))
      | (1ULL << (TSqlParser::THROW - 323))
      | (1ULL << (TSqlParser::TIES - 323))
      | (1ULL << (TSqlParser::TIME - 323))
      | (1ULL << (TSqlParser::TIMEOUT - 323))
      | (1ULL << (TSqlParser::TINYINT - 323))
      | (1ULL << (TSqlParser::TRIPLE_DES - 323))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 323))
      | (1ULL << (TSqlParser::TRY - 323))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 323))
      | (1ULL << (TSqlParser::TYPE - 323))
      | (1ULL << (TSqlParser::TYPE_WARNING - 323))
      | (1ULL << (TSqlParser::UNBOUNDED - 323))
      | (1ULL << (TSqlParser::UNCOMMITTED - 323))
      | (1ULL << (TSqlParser::UNKNOWN - 323))
      | (1ULL << (TSqlParser::UOW - 323))
      | (1ULL << (TSqlParser::USING - 323))
      | (1ULL << (TSqlParser::VAR - 323))
      | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 323))
      | (1ULL << (TSqlParser::VARP - 323))
      | (1ULL << (TSqlParser::WAIT - 323))
      | (1ULL << (TSqlParser::WAITFOR - 323))
      | (1ULL << (TSqlParser::WORK - 323))
      | (1ULL << (TSqlParser::ZONE - 323))
      | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 323))
      | (1ULL << (TSqlParser::CACHE - 323))
      | (1ULL << (TSqlParser::CALLED - 323))
      | (1ULL << (TSqlParser::CHANGETABLE - 323))
      | (1ULL << (TSqlParser::CHANGES - 323))
      | (1ULL << (TSqlParser::CYCLE - 323))
      | (1ULL << (TSqlParser::DATA_COMPRESSION - 323))
      | (1ULL << (TSqlParser::ERROR - 323))
      | (1ULL << (TSqlParser::FORCESEEK - 323))
      | (1ULL << (TSqlParser::IIF - 323))
      | (1ULL << (TSqlParser::INCREMENT - 323))
      | (1ULL << (TSqlParser::ISNULL - 323))
      | (1ULL << (TSqlParser::LOG - 323))
      | (1ULL << (TSqlParser::MATCHED - 323))
      | (1ULL << (TSqlParser::MAXVALUE - 323))
      | (1ULL << (TSqlParser::MINVALUE - 323))
      | (1ULL << (TSqlParser::NOTIFICATION - 323))
      | (1ULL << (TSqlParser::PERSISTED - 323))
      | (1ULL << (TSqlParser::PREDICATE - 323))
      | (1ULL << (TSqlParser::RESTART - 323))
      | (1ULL << (TSqlParser::RETURNS - 323))
      | (1ULL << (TSqlParser::SOURCE - 323)))) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 387)) & ((1ULL << (TSqlParser::STATE - 387))
      | (1ULL << (TSqlParser::START - 387))
      | (1ULL << (TSqlParser::TARGET - 387))
      | (1ULL << (TSqlParser::VARCHAR - 387))
      | (1ULL << (TSqlParser::NVARCHAR - 387))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 387))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 387))
      | (1ULL << (TSqlParser::ID - 387))
      | (1ULL << (TSqlParser::LR_BRACKET - 387))
      | (1ULL << (TSqlParser::SEMI - 387)))) != 0)) {
      setState(545);
      sql_clauses();
      setState(550);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(551);
    match(TSqlParser::END);
    setState(553);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(552);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_statementContext ------------------------------------------------------------------

TSqlParser::Break_statementContext::Break_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Break_statementContext::BREAK() {
  return getToken(TSqlParser::BREAK, 0);
}

tree::TerminalNode* TSqlParser::Break_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Break_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBreak_statement;
}

void TSqlParser::Break_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_statement(this);
}

void TSqlParser::Break_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_statement(this);
}

TSqlParser::Break_statementContext* TSqlParser::break_statement() {
  Break_statementContext *_localctx = _tracker.createInstance<Break_statementContext>(_ctx, getState());
  enterRule(_localctx, 16, TSqlParser::RuleBreak_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(555);
    match(TSqlParser::BREAK);
    setState(557);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(556);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continue_statementContext ------------------------------------------------------------------

TSqlParser::Continue_statementContext::Continue_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Continue_statementContext::CONTINUE() {
  return getToken(TSqlParser::CONTINUE, 0);
}

tree::TerminalNode* TSqlParser::Continue_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Continue_statementContext::getRuleIndex() const {
  return TSqlParser::RuleContinue_statement;
}

void TSqlParser::Continue_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinue_statement(this);
}

void TSqlParser::Continue_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinue_statement(this);
}

TSqlParser::Continue_statementContext* TSqlParser::continue_statement() {
  Continue_statementContext *_localctx = _tracker.createInstance<Continue_statementContext>(_ctx, getState());
  enterRule(_localctx, 18, TSqlParser::RuleContinue_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(TSqlParser::CONTINUE);
    setState(561);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(560);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Goto_statementContext ------------------------------------------------------------------

TSqlParser::Goto_statementContext::Goto_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Goto_statementContext::GOTO() {
  return getToken(TSqlParser::GOTO, 0);
}

TSqlParser::Id_Context* TSqlParser::Goto_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Goto_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Goto_statementContext::COLON() {
  return getToken(TSqlParser::COLON, 0);
}


size_t TSqlParser::Goto_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGoto_statement;
}

void TSqlParser::Goto_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoto_statement(this);
}

void TSqlParser::Goto_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoto_statement(this);
}

TSqlParser::Goto_statementContext* TSqlParser::goto_statement() {
  Goto_statementContext *_localctx = _tracker.createInstance<Goto_statementContext>(_ctx, getState());
  enterRule(_localctx, 20, TSqlParser::RuleGoto_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(573);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::GOTO: {
        enterOuterAlt(_localctx, 1);
        setState(563);
        match(TSqlParser::GOTO);
        setState(564);
        id_();
        setState(566);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
        case 1: {
          setState(565);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 2);
        setState(568);
        id_();
        setState(569);
        match(TSqlParser::COLON);
        setState(571);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
        case 1: {
          setState(570);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_statementContext ------------------------------------------------------------------

TSqlParser::Return_statementContext::Return_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Return_statementContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Return_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Return_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Return_statementContext::getRuleIndex() const {
  return TSqlParser::RuleReturn_statement;
}

void TSqlParser::Return_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_statement(this);
}

void TSqlParser::Return_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_statement(this);
}

TSqlParser::Return_statementContext* TSqlParser::return_statement() {
  Return_statementContext *_localctx = _tracker.createInstance<Return_statementContext>(_ctx, getState());
  enterRule(_localctx, 22, TSqlParser::RuleReturn_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(575);
    match(TSqlParser::RETURN);
    setState(577);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(576);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(580);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      setState(579);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_statementContext ------------------------------------------------------------------

TSqlParser::If_statementContext::If_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::If_statementContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::If_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::If_statementContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::If_statementContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

tree::TerminalNode* TSqlParser::If_statementContext::ELSE() {
  return getToken(TSqlParser::ELSE, 0);
}

tree::TerminalNode* TSqlParser::If_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::If_statementContext::getRuleIndex() const {
  return TSqlParser::RuleIf_statement;
}

void TSqlParser::If_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_statement(this);
}

void TSqlParser::If_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_statement(this);
}

TSqlParser::If_statementContext* TSqlParser::if_statement() {
  If_statementContext *_localctx = _tracker.createInstance<If_statementContext>(_ctx, getState());
  enterRule(_localctx, 24, TSqlParser::RuleIf_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(582);
    match(TSqlParser::IF);
    setState(583);
    search_condition(0);
    setState(584);
    sql_clauses();
    setState(587);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(585);
      match(TSqlParser::ELSE);
      setState(586);
      sql_clauses();
      break;
    }

    default:
      break;
    }
    setState(590);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(589);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_statementContext ------------------------------------------------------------------

TSqlParser::Throw_statementContext::Throw_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_statementContext::THROW() {
  return getToken(TSqlParser::THROW, 0);
}

TSqlParser::Throw_error_numberContext* TSqlParser::Throw_statementContext::throw_error_number() {
  return getRuleContext<TSqlParser::Throw_error_numberContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Throw_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Throw_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Throw_messageContext* TSqlParser::Throw_statementContext::throw_message() {
  return getRuleContext<TSqlParser::Throw_messageContext>(0);
}

TSqlParser::Throw_stateContext* TSqlParser::Throw_statementContext::throw_state() {
  return getRuleContext<TSqlParser::Throw_stateContext>(0);
}

tree::TerminalNode* TSqlParser::Throw_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Throw_statementContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_statement;
}

void TSqlParser::Throw_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_statement(this);
}

void TSqlParser::Throw_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_statement(this);
}

TSqlParser::Throw_statementContext* TSqlParser::throw_statement() {
  Throw_statementContext *_localctx = _tracker.createInstance<Throw_statementContext>(_ctx, getState());
  enterRule(_localctx, 26, TSqlParser::RuleThrow_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(592);
    match(TSqlParser::THROW);
    setState(599);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL) {
      setState(593);
      throw_error_number();
      setState(594);
      match(TSqlParser::COMMA);
      setState(595);
      throw_message();
      setState(596);
      match(TSqlParser::COMMA);
      setState(597);
      throw_state();
    }
    setState(602);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      setState(601);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_error_numberContext ------------------------------------------------------------------

TSqlParser::Throw_error_numberContext::Throw_error_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_error_numberContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Throw_error_numberContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_error_numberContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_error_number;
}

void TSqlParser::Throw_error_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_error_number(this);
}

void TSqlParser::Throw_error_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_error_number(this);
}

TSqlParser::Throw_error_numberContext* TSqlParser::throw_error_number() {
  Throw_error_numberContext *_localctx = _tracker.createInstance<Throw_error_numberContext>(_ctx, getState());
  enterRule(_localctx, 28, TSqlParser::RuleThrow_error_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(604);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_messageContext ------------------------------------------------------------------

TSqlParser::Throw_messageContext::Throw_messageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_messageContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Throw_messageContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_messageContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_message;
}

void TSqlParser::Throw_messageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_message(this);
}

void TSqlParser::Throw_messageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_message(this);
}

TSqlParser::Throw_messageContext* TSqlParser::throw_message() {
  Throw_messageContext *_localctx = _tracker.createInstance<Throw_messageContext>(_ctx, getState());
  enterRule(_localctx, 30, TSqlParser::RuleThrow_message);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(606);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_stateContext ------------------------------------------------------------------

TSqlParser::Throw_stateContext::Throw_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_stateContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Throw_stateContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_stateContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_state;
}

void TSqlParser::Throw_stateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_state(this);
}

void TSqlParser::Throw_stateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_state(this);
}

TSqlParser::Throw_stateContext* TSqlParser::throw_state() {
  Throw_stateContext *_localctx = _tracker.createInstance<Throw_stateContext>(_ctx, getState());
  enterRule(_localctx, 32, TSqlParser::RuleThrow_state);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Try_catch_statementContext ------------------------------------------------------------------

TSqlParser::Try_catch_statementContext::Try_catch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::BEGIN() {
  return getTokens(TSqlParser::BEGIN);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::BEGIN(size_t i) {
  return getToken(TSqlParser::BEGIN, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::TRY() {
  return getTokens(TSqlParser::TRY);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::TRY(size_t i) {
  return getToken(TSqlParser::TRY, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::END() {
  return getTokens(TSqlParser::END);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::END(size_t i) {
  return getToken(TSqlParser::END, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::CATCH() {
  return getTokens(TSqlParser::CATCH);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::CATCH(size_t i) {
  return getToken(TSqlParser::CATCH, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Try_catch_statementContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Try_catch_statementContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}


size_t TSqlParser::Try_catch_statementContext::getRuleIndex() const {
  return TSqlParser::RuleTry_catch_statement;
}

void TSqlParser::Try_catch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTry_catch_statement(this);
}

void TSqlParser::Try_catch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTry_catch_statement(this);
}

TSqlParser::Try_catch_statementContext* TSqlParser::try_catch_statement() {
  Try_catch_statementContext *_localctx = _tracker.createInstance<Try_catch_statementContext>(_ctx, getState());
  enterRule(_localctx, 34, TSqlParser::RuleTry_catch_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    match(TSqlParser::BEGIN);
    setState(611);
    match(TSqlParser::TRY);
    setState(613);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(612);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
    setState(616); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(615);
      dynamic_cast<Try_catch_statementContext *>(_localctx)->try_clauses = sql_clauses();
      setState(618); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
      | (1ULL << TSqlParser::NCHAR)
      | (1ULL << TSqlParser::TEXT)
      | (1ULL << TSqlParser::NTEXT)
      | (1ULL << TSqlParser::ALTER)
      | (1ULL << TSqlParser::BEGIN)
      | (1ULL << TSqlParser::BREAK)
      | (1ULL << TSqlParser::CLOSE)
      | (1ULL << TSqlParser::COMMIT)
      | (1ULL << TSqlParser::CONTINUE)
      | (1ULL << TSqlParser::CREATE)
      | (1ULL << TSqlParser::DBCC))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (TSqlParser::DEALLOCATE - 64))
      | (1ULL << (TSqlParser::DECLARE - 64))
      | (1ULL << (TSqlParser::DELETE - 64))
      | (1ULL << (TSqlParser::DROP - 64))
      | (1ULL << (TSqlParser::EXECUTE - 64))
      | (1ULL << (TSqlParser::FETCH - 64))
      | (1ULL << (TSqlParser::GOTO - 64))
      | (1ULL << (TSqlParser::IF - 64))
      | (1ULL << (TSqlParser::INSERT - 64))
      | (1ULL << (TSqlParser::KILL - 64))
      | (1ULL << (TSqlParser::MERGE - 64))
      | (1ULL << (TSqlParser::OPEN - 64))
      | (1ULL << (TSqlParser::PRECISION - 64))
      | (1ULL << (TSqlParser::PRINT - 64))
      | (1ULL << (TSqlParser::RAISERROR - 64)))) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & ((1ULL << (TSqlParser::RETURN - 131))
      | (1ULL << (TSqlParser::ROLLBACK - 131))
      | (1ULL << (TSqlParser::SAVE - 131))
      | (1ULL << (TSqlParser::SELECT - 131))
      | (1ULL << (TSqlParser::SET - 131))
      | (1ULL << (TSqlParser::SHUTDOWN - 131))
      | (1ULL << (TSqlParser::TRUNCATE - 131))
      | (1ULL << (TSqlParser::UPDATE - 131))
      | (1ULL << (TSqlParser::USE - 131))
      | (1ULL << (TSqlParser::WHILE - 131))
      | (1ULL << (TSqlParser::WITH - 131))
      | (1ULL << (TSqlParser::ABSOLUTE - 131))
      | (1ULL << (TSqlParser::AT_KEYWORD - 131))
      | (1ULL << (TSqlParser::ACTION - 131))
      | (1ULL << (TSqlParser::AES_128 - 131))
      | (1ULL << (TSqlParser::AES_192 - 131))
      | (1ULL << (TSqlParser::AES_256 - 131))
      | (1ULL << (TSqlParser::ALGORITHM - 131))
      | (1ULL << (TSqlParser::ANSI_NULLS - 131))
      | (1ULL << (TSqlParser::ANSI_PADDING - 131))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 131))
      | (1ULL << (TSqlParser::APPLY - 131))
      | (1ULL << (TSqlParser::ARITHABORT - 131))
      | (1ULL << (TSqlParser::AUTO - 131))
      | (1ULL << (TSqlParser::AVG - 131))
      | (1ULL << (TSqlParser::BIGINT - 131))
      | (1ULL << (TSqlParser::BINARY_KEYWORD - 131))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 131))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 131))
      | (1ULL << (TSqlParser::CALLER - 131))
      | (1ULL << (TSqlParser::CAST - 131))
      | (1ULL << (TSqlParser::TRY_CAST - 131))
      | (1ULL << (TSqlParser::CATCH - 131))
      | (1ULL << (TSqlParser::CHECKSUM - 131))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 131))
      | (1ULL << (TSqlParser::COMMITTED - 131))
      | (1ULL << (TSqlParser::CONCAT - 131))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 131))
      | (1ULL << (TSqlParser::COUNT - 131))
      | (1ULL << (TSqlParser::COUNT_BIG - 131)))) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 195)) & ((1ULL << (TSqlParser::CUME_DIST - 195))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 195))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 195))
      | (1ULL << (TSqlParser::DATA - 195))
      | (1ULL << (TSqlParser::DATEADD - 195))
      | (1ULL << (TSqlParser::DATEDIFF - 195))
      | (1ULL << (TSqlParser::DATENAME - 195))
      | (1ULL << (TSqlParser::DATEPART - 195))
      | (1ULL << (TSqlParser::DAYS - 195))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 195))
      | (1ULL << (TSqlParser::DELAY - 195))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 195))
      | (1ULL << (TSqlParser::DELETED - 195))
      | (1ULL << (TSqlParser::DENSE_RANK - 195))
      | (1ULL << (TSqlParser::DES - 195))
      | (1ULL << (TSqlParser::DESCRIPTION - 195))
      | (1ULL << (TSqlParser::DESX - 195))
      | (1ULL << (TSqlParser::DISABLE - 195))
      | (1ULL << (TSqlParser::DYNAMIC - 195))
      | (1ULL << (TSqlParser::ELEMENTS - 195))
      | (1ULL << (TSqlParser::EMPTY - 195))
      | (1ULL << (TSqlParser::ENCRYPTION - 195))
      | (1ULL << (TSqlParser::EXCLUSIVE - 195))
      | (1ULL << (TSqlParser::FAST - 195))
      | (1ULL << (TSqlParser::FAST_FORWARD - 195))
      | (1ULL << (TSqlParser::FIRST - 195))
      | (1ULL << (TSqlParser::FIRST_VALUE - 195))
      | (1ULL << (TSqlParser::FOLLOWING - 195))
      | (1ULL << (TSqlParser::FORCE - 195))
      | (1ULL << (TSqlParser::FORCED - 195))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 195))
      | (1ULL << (TSqlParser::GETDATE - 195))
      | (1ULL << (TSqlParser::GETUTCDATE - 195))
      | (1ULL << (TSqlParser::GLOBAL - 195))
      | (1ULL << (TSqlParser::GO_BATCH - 195))
      | (1ULL << (TSqlParser::GO - 195))
      | (1ULL << (TSqlParser::GROUPING - 195))
      | (1ULL << (TSqlParser::GROUPING_ID - 195))
      | (1ULL << (TSqlParser::HASH - 195))
      | (1ULL << (TSqlParser::HIGH - 195))
      | (1ULL << (TSqlParser::HOURS - 195))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 195))
      | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 195))
      | (1ULL << (TSqlParser::INPUT - 195))
      | (1ULL << (TSqlParser::INSENSITIVE - 195))
      | (1ULL << (TSqlParser::INSERTED - 195))
      | (1ULL << (TSqlParser::INT - 195))
      | (1ULL << (TSqlParser::ISOLATION - 195))
      | (1ULL << (TSqlParser::KEEP - 195))
      | (1ULL << (TSqlParser::KEEPFIXED - 195))
      | (1ULL << (TSqlParser::KEYSET - 195))
      | (1ULL << (TSqlParser::LAG - 195))
      | (1ULL << (TSqlParser::LAST - 195))
      | (1ULL << (TSqlParser::LAST_VALUE - 195))
      | (1ULL << (TSqlParser::LEAD - 195))
      | (1ULL << (TSqlParser::LEVEL - 195))
      | (1ULL << (TSqlParser::LOCAL - 195))
      | (1ULL << (TSqlParser::LOCATION - 195))
      | (1ULL << (TSqlParser::LOCK - 195))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 195))
      | (1ULL << (TSqlParser::LOOP - 195))
      | (1ULL << (TSqlParser::LOW - 195))
      | (1ULL << (TSqlParser::MANUAL - 195))
      | (1ULL << (TSqlParser::MARK - 195)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (TSqlParser::MAX - 259))
      | (1ULL << (TSqlParser::MAXDOP - 259))
      | (1ULL << (TSqlParser::MAXRECURSION - 259))
      | (1ULL << (TSqlParser::MIN - 259))
      | (1ULL << (TSqlParser::MINUTES - 259))
      | (1ULL << (TSqlParser::MODE - 259))
      | (1ULL << (TSqlParser::NEXT - 259))
      | (1ULL << (TSqlParser::NO - 259))
      | (1ULL << (TSqlParser::NOCOUNT - 259))
      | (1ULL << (TSqlParser::NODES - 259))
      | (1ULL << (TSqlParser::NOEXPAND - 259))
      | (1ULL << (TSqlParser::NOWAIT - 259))
      | (1ULL << (TSqlParser::NTILE - 259))
      | (1ULL << (TSqlParser::NUMANODE - 259))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 259))
      | (1ULL << (TSqlParser::OBJECT - 259))
      | (1ULL << (TSqlParser::OFFSET - 259))
      | (1ULL << (TSqlParser::ONLINE - 259))
      | (1ULL << (TSqlParser::ONLY - 259))
      | (1ULL << (TSqlParser::OPTIMISTIC - 259))
      | (1ULL << (TSqlParser::OPTIMIZE - 259))
      | (1ULL << (TSqlParser::OUT - 259))
      | (1ULL << (TSqlParser::OUTPUT - 259))
      | (1ULL << (TSqlParser::OWNER - 259))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 259))
      | (1ULL << (TSqlParser::PARTITION - 259))
      | (1ULL << (TSqlParser::PARTITIONS - 259))
      | (1ULL << (TSqlParser::PERCENT_RANK - 259))
      | (1ULL << (TSqlParser::PERCENTILE_CONT - 259))
      | (1ULL << (TSqlParser::PERCENTILE_DISC - 259))
      | (1ULL << (TSqlParser::PRECEDING - 259))
      | (1ULL << (TSqlParser::PRIOR - 259))
      | (1ULL << (TSqlParser::QUERY - 259))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 259))
      | (1ULL << (TSqlParser::RANGE - 259))
      | (1ULL << (TSqlParser::RANK - 259))
      | (1ULL << (TSqlParser::RC2 - 259))
      | (1ULL << (TSqlParser::RC4 - 259))
      | (1ULL << (TSqlParser::RC4_128 - 259))
      | (1ULL << (TSqlParser::READ_ONLY - 259))
      | (1ULL << (TSqlParser::READONLY - 259))
      | (1ULL << (TSqlParser::REBUILD - 259))
      | (1ULL << (TSqlParser::RECOMPILE - 259))
      | (1ULL << (TSqlParser::RELATIVE - 259))
      | (1ULL << (TSqlParser::REMOTE - 259))
      | (1ULL << (TSqlParser::REPEATABLE - 259))
      | (1ULL << (TSqlParser::ROBUST - 259))
      | (1ULL << (TSqlParser::ROW - 259))
      | (1ULL << (TSqlParser::ROW_NUMBER - 259))
      | (1ULL << (TSqlParser::ROWGUID - 259))
      | (1ULL << (TSqlParser::ROWS - 259))
      | (1ULL << (TSqlParser::SCHEMABINDING - 259))
      | (1ULL << (TSqlParser::SCROLL - 259))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 259))
      | (1ULL << (TSqlParser::SECONDS - 259))
      | (1ULL << (TSqlParser::SELF - 259))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 259))
      | (1ULL << (TSqlParser::SEQUENCE - 259))
      | (1ULL << (TSqlParser::SERIALIZABLE - 259))
      | (1ULL << (TSqlParser::SETERROR - 259))
      | (1ULL << (TSqlParser::SHARE - 259))
      | (1ULL << (TSqlParser::SIMPLE - 259))
      | (1ULL << (TSqlParser::SIZE - 259)))) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 323)) & ((1ULL << (TSqlParser::SMALLINT - 323))
      | (1ULL << (TSqlParser::SNAPSHOT - 323))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 323))
      | (1ULL << (TSqlParser::STATIC - 323))
      | (1ULL << (TSqlParser::STATUSONLY - 323))
      | (1ULL << (TSqlParser::STDEV - 323))
      | (1ULL << (TSqlParser::STDEVP - 323))
      | (1ULL << (TSqlParser::STRING_AGG - 323))
      | (1ULL << (TSqlParser::STUFF - 323))
      | (1ULL << (TSqlParser::SUBSCRIPTION - 323))
      | (1ULL << (TSqlParser::SUM - 323))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 323))
      | (1ULL << (TSqlParser::THROW - 323))
      | (1ULL << (TSqlParser::TIES - 323))
      | (1ULL << (TSqlParser::TIME - 323))
      | (1ULL << (TSqlParser::TIMEOUT - 323))
      | (1ULL << (TSqlParser::TINYINT - 323))
      | (1ULL << (TSqlParser::TRIPLE_DES - 323))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 323))
      | (1ULL << (TSqlParser::TRY - 323))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 323))
      | (1ULL << (TSqlParser::TYPE - 323))
      | (1ULL << (TSqlParser::TYPE_WARNING - 323))
      | (1ULL << (TSqlParser::UNBOUNDED - 323))
      | (1ULL << (TSqlParser::UNCOMMITTED - 323))
      | (1ULL << (TSqlParser::UNKNOWN - 323))
      | (1ULL << (TSqlParser::UOW - 323))
      | (1ULL << (TSqlParser::USING - 323))
      | (1ULL << (TSqlParser::VAR - 323))
      | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 323))
      | (1ULL << (TSqlParser::VARP - 323))
      | (1ULL << (TSqlParser::WAIT - 323))
      | (1ULL << (TSqlParser::WAITFOR - 323))
      | (1ULL << (TSqlParser::WORK - 323))
      | (1ULL << (TSqlParser::ZONE - 323))
      | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 323))
      | (1ULL << (TSqlParser::CACHE - 323))
      | (1ULL << (TSqlParser::CALLED - 323))
      | (1ULL << (TSqlParser::CHANGETABLE - 323))
      | (1ULL << (TSqlParser::CHANGES - 323))
      | (1ULL << (TSqlParser::CYCLE - 323))
      | (1ULL << (TSqlParser::DATA_COMPRESSION - 323))
      | (1ULL << (TSqlParser::ERROR - 323))
      | (1ULL << (TSqlParser::FORCESEEK - 323))
      | (1ULL << (TSqlParser::IIF - 323))
      | (1ULL << (TSqlParser::INCREMENT - 323))
      | (1ULL << (TSqlParser::ISNULL - 323))
      | (1ULL << (TSqlParser::LOG - 323))
      | (1ULL << (TSqlParser::MATCHED - 323))
      | (1ULL << (TSqlParser::MAXVALUE - 323))
      | (1ULL << (TSqlParser::MINVALUE - 323))
      | (1ULL << (TSqlParser::NOTIFICATION - 323))
      | (1ULL << (TSqlParser::PERSISTED - 323))
      | (1ULL << (TSqlParser::PREDICATE - 323))
      | (1ULL << (TSqlParser::RESTART - 323))
      | (1ULL << (TSqlParser::RETURNS - 323))
      | (1ULL << (TSqlParser::SOURCE - 323)))) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 387)) & ((1ULL << (TSqlParser::STATE - 387))
      | (1ULL << (TSqlParser::START - 387))
      | (1ULL << (TSqlParser::TARGET - 387))
      | (1ULL << (TSqlParser::VARCHAR - 387))
      | (1ULL << (TSqlParser::NVARCHAR - 387))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 387))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 387))
      | (1ULL << (TSqlParser::ID - 387))
      | (1ULL << (TSqlParser::LR_BRACKET - 387))
      | (1ULL << (TSqlParser::SEMI - 387)))) != 0));
    setState(620);
    match(TSqlParser::END);
    setState(621);
    match(TSqlParser::TRY);
    setState(623);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(622);
      match(TSqlParser::SEMI);
    }
    setState(625);
    match(TSqlParser::BEGIN);
    setState(626);
    match(TSqlParser::CATCH);
    setState(628);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(627);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
    setState(633);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
      | (1ULL << TSqlParser::NCHAR)
      | (1ULL << TSqlParser::TEXT)
      | (1ULL << TSqlParser::NTEXT)
      | (1ULL << TSqlParser::ALTER)
      | (1ULL << TSqlParser::BEGIN)
      | (1ULL << TSqlParser::BREAK)
      | (1ULL << TSqlParser::CLOSE)
      | (1ULL << TSqlParser::COMMIT)
      | (1ULL << TSqlParser::CONTINUE)
      | (1ULL << TSqlParser::CREATE)
      | (1ULL << TSqlParser::DBCC))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (TSqlParser::DEALLOCATE - 64))
      | (1ULL << (TSqlParser::DECLARE - 64))
      | (1ULL << (TSqlParser::DELETE - 64))
      | (1ULL << (TSqlParser::DROP - 64))
      | (1ULL << (TSqlParser::EXECUTE - 64))
      | (1ULL << (TSqlParser::FETCH - 64))
      | (1ULL << (TSqlParser::GOTO - 64))
      | (1ULL << (TSqlParser::IF - 64))
      | (1ULL << (TSqlParser::INSERT - 64))
      | (1ULL << (TSqlParser::KILL - 64))
      | (1ULL << (TSqlParser::MERGE - 64))
      | (1ULL << (TSqlParser::OPEN - 64))
      | (1ULL << (TSqlParser::PRECISION - 64))
      | (1ULL << (TSqlParser::PRINT - 64))
      | (1ULL << (TSqlParser::RAISERROR - 64)))) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & ((1ULL << (TSqlParser::RETURN - 131))
      | (1ULL << (TSqlParser::ROLLBACK - 131))
      | (1ULL << (TSqlParser::SAVE - 131))
      | (1ULL << (TSqlParser::SELECT - 131))
      | (1ULL << (TSqlParser::SET - 131))
      | (1ULL << (TSqlParser::SHUTDOWN - 131))
      | (1ULL << (TSqlParser::TRUNCATE - 131))
      | (1ULL << (TSqlParser::UPDATE - 131))
      | (1ULL << (TSqlParser::USE - 131))
      | (1ULL << (TSqlParser::WHILE - 131))
      | (1ULL << (TSqlParser::WITH - 131))
      | (1ULL << (TSqlParser::ABSOLUTE - 131))
      | (1ULL << (TSqlParser::AT_KEYWORD - 131))
      | (1ULL << (TSqlParser::ACTION - 131))
      | (1ULL << (TSqlParser::AES_128 - 131))
      | (1ULL << (TSqlParser::AES_192 - 131))
      | (1ULL << (TSqlParser::AES_256 - 131))
      | (1ULL << (TSqlParser::ALGORITHM - 131))
      | (1ULL << (TSqlParser::ANSI_NULLS - 131))
      | (1ULL << (TSqlParser::ANSI_PADDING - 131))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 131))
      | (1ULL << (TSqlParser::APPLY - 131))
      | (1ULL << (TSqlParser::ARITHABORT - 131))
      | (1ULL << (TSqlParser::AUTO - 131))
      | (1ULL << (TSqlParser::AVG - 131))
      | (1ULL << (TSqlParser::BIGINT - 131))
      | (1ULL << (TSqlParser::BINARY_KEYWORD - 131))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 131))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 131))
      | (1ULL << (TSqlParser::CALLER - 131))
      | (1ULL << (TSqlParser::CAST - 131))
      | (1ULL << (TSqlParser::TRY_CAST - 131))
      | (1ULL << (TSqlParser::CATCH - 131))
      | (1ULL << (TSqlParser::CHECKSUM - 131))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 131))
      | (1ULL << (TSqlParser::COMMITTED - 131))
      | (1ULL << (TSqlParser::CONCAT - 131))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 131))
      | (1ULL << (TSqlParser::COUNT - 131))
      | (1ULL << (TSqlParser::COUNT_BIG - 131)))) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 195)) & ((1ULL << (TSqlParser::CUME_DIST - 195))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 195))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 195))
      | (1ULL << (TSqlParser::DATA - 195))
      | (1ULL << (TSqlParser::DATEADD - 195))
      | (1ULL << (TSqlParser::DATEDIFF - 195))
      | (1ULL << (TSqlParser::DATENAME - 195))
      | (1ULL << (TSqlParser::DATEPART - 195))
      | (1ULL << (TSqlParser::DAYS - 195))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 195))
      | (1ULL << (TSqlParser::DELAY - 195))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 195))
      | (1ULL << (TSqlParser::DELETED - 195))
      | (1ULL << (TSqlParser::DENSE_RANK - 195))
      | (1ULL << (TSqlParser::DES - 195))
      | (1ULL << (TSqlParser::DESCRIPTION - 195))
      | (1ULL << (TSqlParser::DESX - 195))
      | (1ULL << (TSqlParser::DISABLE - 195))
      | (1ULL << (TSqlParser::DYNAMIC - 195))
      | (1ULL << (TSqlParser::ELEMENTS - 195))
      | (1ULL << (TSqlParser::EMPTY - 195))
      | (1ULL << (TSqlParser::ENCRYPTION - 195))
      | (1ULL << (TSqlParser::EXCLUSIVE - 195))
      | (1ULL << (TSqlParser::FAST - 195))
      | (1ULL << (TSqlParser::FAST_FORWARD - 195))
      | (1ULL << (TSqlParser::FIRST - 195))
      | (1ULL << (TSqlParser::FIRST_VALUE - 195))
      | (1ULL << (TSqlParser::FOLLOWING - 195))
      | (1ULL << (TSqlParser::FORCE - 195))
      | (1ULL << (TSqlParser::FORCED - 195))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 195))
      | (1ULL << (TSqlParser::GETDATE - 195))
      | (1ULL << (TSqlParser::GETUTCDATE - 195))
      | (1ULL << (TSqlParser::GLOBAL - 195))
      | (1ULL << (TSqlParser::GO_BATCH - 195))
      | (1ULL << (TSqlParser::GO - 195))
      | (1ULL << (TSqlParser::GROUPING - 195))
      | (1ULL << (TSqlParser::GROUPING_ID - 195))
      | (1ULL << (TSqlParser::HASH - 195))
      | (1ULL << (TSqlParser::HIGH - 195))
      | (1ULL << (TSqlParser::HOURS - 195))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 195))
      | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 195))
      | (1ULL << (TSqlParser::INPUT - 195))
      | (1ULL << (TSqlParser::INSENSITIVE - 195))
      | (1ULL << (TSqlParser::INSERTED - 195))
      | (1ULL << (TSqlParser::INT - 195))
      | (1ULL << (TSqlParser::ISOLATION - 195))
      | (1ULL << (TSqlParser::KEEP - 195))
      | (1ULL << (TSqlParser::KEEPFIXED - 195))
      | (1ULL << (TSqlParser::KEYSET - 195))
      | (1ULL << (TSqlParser::LAG - 195))
      | (1ULL << (TSqlParser::LAST - 195))
      | (1ULL << (TSqlParser::LAST_VALUE - 195))
      | (1ULL << (TSqlParser::LEAD - 195))
      | (1ULL << (TSqlParser::LEVEL - 195))
      | (1ULL << (TSqlParser::LOCAL - 195))
      | (1ULL << (TSqlParser::LOCATION - 195))
      | (1ULL << (TSqlParser::LOCK - 195))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 195))
      | (1ULL << (TSqlParser::LOOP - 195))
      | (1ULL << (TSqlParser::LOW - 195))
      | (1ULL << (TSqlParser::MANUAL - 195))
      | (1ULL << (TSqlParser::MARK - 195)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (TSqlParser::MAX - 259))
      | (1ULL << (TSqlParser::MAXDOP - 259))
      | (1ULL << (TSqlParser::MAXRECURSION - 259))
      | (1ULL << (TSqlParser::MIN - 259))
      | (1ULL << (TSqlParser::MINUTES - 259))
      | (1ULL << (TSqlParser::MODE - 259))
      | (1ULL << (TSqlParser::NEXT - 259))
      | (1ULL << (TSqlParser::NO - 259))
      | (1ULL << (TSqlParser::NOCOUNT - 259))
      | (1ULL << (TSqlParser::NODES - 259))
      | (1ULL << (TSqlParser::NOEXPAND - 259))
      | (1ULL << (TSqlParser::NOWAIT - 259))
      | (1ULL << (TSqlParser::NTILE - 259))
      | (1ULL << (TSqlParser::NUMANODE - 259))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 259))
      | (1ULL << (TSqlParser::OBJECT - 259))
      | (1ULL << (TSqlParser::OFFSET - 259))
      | (1ULL << (TSqlParser::ONLINE - 259))
      | (1ULL << (TSqlParser::ONLY - 259))
      | (1ULL << (TSqlParser::OPTIMISTIC - 259))
      | (1ULL << (TSqlParser::OPTIMIZE - 259))
      | (1ULL << (TSqlParser::OUT - 259))
      | (1ULL << (TSqlParser::OUTPUT - 259))
      | (1ULL << (TSqlParser::OWNER - 259))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 259))
      | (1ULL << (TSqlParser::PARTITION - 259))
      | (1ULL << (TSqlParser::PARTITIONS - 259))
      | (1ULL << (TSqlParser::PERCENT_RANK - 259))
      | (1ULL << (TSqlParser::PERCENTILE_CONT - 259))
      | (1ULL << (TSqlParser::PERCENTILE_DISC - 259))
      | (1ULL << (TSqlParser::PRECEDING - 259))
      | (1ULL << (TSqlParser::PRIOR - 259))
      | (1ULL << (TSqlParser::QUERY - 259))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 259))
      | (1ULL << (TSqlParser::RANGE - 259))
      | (1ULL << (TSqlParser::RANK - 259))
      | (1ULL << (TSqlParser::RC2 - 259))
      | (1ULL << (TSqlParser::RC4 - 259))
      | (1ULL << (TSqlParser::RC4_128 - 259))
      | (1ULL << (TSqlParser::READ_ONLY - 259))
      | (1ULL << (TSqlParser::READONLY - 259))
      | (1ULL << (TSqlParser::REBUILD - 259))
      | (1ULL << (TSqlParser::RECOMPILE - 259))
      | (1ULL << (TSqlParser::RELATIVE - 259))
      | (1ULL << (TSqlParser::REMOTE - 259))
      | (1ULL << (TSqlParser::REPEATABLE - 259))
      | (1ULL << (TSqlParser::ROBUST - 259))
      | (1ULL << (TSqlParser::ROW - 259))
      | (1ULL << (TSqlParser::ROW_NUMBER - 259))
      | (1ULL << (TSqlParser::ROWGUID - 259))
      | (1ULL << (TSqlParser::ROWS - 259))
      | (1ULL << (TSqlParser::SCHEMABINDING - 259))
      | (1ULL << (TSqlParser::SCROLL - 259))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 259))
      | (1ULL << (TSqlParser::SECONDS - 259))
      | (1ULL << (TSqlParser::SELF - 259))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 259))
      | (1ULL << (TSqlParser::SEQUENCE - 259))
      | (1ULL << (TSqlParser::SERIALIZABLE - 259))
      | (1ULL << (TSqlParser::SETERROR - 259))
      | (1ULL << (TSqlParser::SHARE - 259))
      | (1ULL << (TSqlParser::SIMPLE - 259))
      | (1ULL << (TSqlParser::SIZE - 259)))) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 323)) & ((1ULL << (TSqlParser::SMALLINT - 323))
      | (1ULL << (TSqlParser::SNAPSHOT - 323))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 323))
      | (1ULL << (TSqlParser::STATIC - 323))
      | (1ULL << (TSqlParser::STATUSONLY - 323))
      | (1ULL << (TSqlParser::STDEV - 323))
      | (1ULL << (TSqlParser::STDEVP - 323))
      | (1ULL << (TSqlParser::STRING_AGG - 323))
      | (1ULL << (TSqlParser::STUFF - 323))
      | (1ULL << (TSqlParser::SUBSCRIPTION - 323))
      | (1ULL << (TSqlParser::SUM - 323))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 323))
      | (1ULL << (TSqlParser::THROW - 323))
      | (1ULL << (TSqlParser::TIES - 323))
      | (1ULL << (TSqlParser::TIME - 323))
      | (1ULL << (TSqlParser::TIMEOUT - 323))
      | (1ULL << (TSqlParser::TINYINT - 323))
      | (1ULL << (TSqlParser::TRIPLE_DES - 323))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 323))
      | (1ULL << (TSqlParser::TRY - 323))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 323))
      | (1ULL << (TSqlParser::TYPE - 323))
      | (1ULL << (TSqlParser::TYPE_WARNING - 323))
      | (1ULL << (TSqlParser::UNBOUNDED - 323))
      | (1ULL << (TSqlParser::UNCOMMITTED - 323))
      | (1ULL << (TSqlParser::UNKNOWN - 323))
      | (1ULL << (TSqlParser::UOW - 323))
      | (1ULL << (TSqlParser::USING - 323))
      | (1ULL << (TSqlParser::VAR - 323))
      | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 323))
      | (1ULL << (TSqlParser::VARP - 323))
      | (1ULL << (TSqlParser::WAIT - 323))
      | (1ULL << (TSqlParser::WAITFOR - 323))
      | (1ULL << (TSqlParser::WORK - 323))
      | (1ULL << (TSqlParser::ZONE - 323))
      | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 323))
      | (1ULL << (TSqlParser::CACHE - 323))
      | (1ULL << (TSqlParser::CALLED - 323))
      | (1ULL << (TSqlParser::CHANGETABLE - 323))
      | (1ULL << (TSqlParser::CHANGES - 323))
      | (1ULL << (TSqlParser::CYCLE - 323))
      | (1ULL << (TSqlParser::DATA_COMPRESSION - 323))
      | (1ULL << (TSqlParser::ERROR - 323))
      | (1ULL << (TSqlParser::FORCESEEK - 323))
      | (1ULL << (TSqlParser::IIF - 323))
      | (1ULL << (TSqlParser::INCREMENT - 323))
      | (1ULL << (TSqlParser::ISNULL - 323))
      | (1ULL << (TSqlParser::LOG - 323))
      | (1ULL << (TSqlParser::MATCHED - 323))
      | (1ULL << (TSqlParser::MAXVALUE - 323))
      | (1ULL << (TSqlParser::MINVALUE - 323))
      | (1ULL << (TSqlParser::NOTIFICATION - 323))
      | (1ULL << (TSqlParser::PERSISTED - 323))
      | (1ULL << (TSqlParser::PREDICATE - 323))
      | (1ULL << (TSqlParser::RESTART - 323))
      | (1ULL << (TSqlParser::RETURNS - 323))
      | (1ULL << (TSqlParser::SOURCE - 323)))) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 387)) & ((1ULL << (TSqlParser::STATE - 387))
      | (1ULL << (TSqlParser::START - 387))
      | (1ULL << (TSqlParser::TARGET - 387))
      | (1ULL << (TSqlParser::VARCHAR - 387))
      | (1ULL << (TSqlParser::NVARCHAR - 387))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 387))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 387))
      | (1ULL << (TSqlParser::ID - 387))
      | (1ULL << (TSqlParser::LR_BRACKET - 387))
      | (1ULL << (TSqlParser::SEMI - 387)))) != 0)) {
      setState(630);
      dynamic_cast<Try_catch_statementContext *>(_localctx)->catch_clauses = sql_clauses();
      setState(635);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(636);
    match(TSqlParser::END);
    setState(637);
    match(TSqlParser::CATCH);
    setState(639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(638);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Waitfor_statementContext ------------------------------------------------------------------

TSqlParser::Waitfor_statementContext::Waitfor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::WAITFOR() {
  return getToken(TSqlParser::WAITFOR, 0);
}

TSqlParser::Receive_statementContext* TSqlParser::Waitfor_statementContext::receive_statement() {
  return getRuleContext<TSqlParser::Receive_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

TSqlParser::TimeContext* TSqlParser::Waitfor_statementContext::time() {
  return getRuleContext<TSqlParser::TimeContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Waitfor_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::DELAY() {
  return getToken(TSqlParser::DELAY, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}


size_t TSqlParser::Waitfor_statementContext::getRuleIndex() const {
  return TSqlParser::RuleWaitfor_statement;
}

void TSqlParser::Waitfor_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWaitfor_statement(this);
}

void TSqlParser::Waitfor_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWaitfor_statement(this);
}

TSqlParser::Waitfor_statementContext* TSqlParser::waitfor_statement() {
  Waitfor_statementContext *_localctx = _tracker.createInstance<Waitfor_statementContext>(_ctx, getState());
  enterRule(_localctx, 36, TSqlParser::RuleWaitfor_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(TSqlParser::WAITFOR);
    setState(643);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      setState(642);
      receive_statement();
      break;
    }

    default:
      break;
    }
    setState(646);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(645);
      match(TSqlParser::COMMA);
    }
    setState(650);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(648);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DELAY || _la == TSqlParser::TIME

      || _la == TSqlParser::TIMEOUT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(649);
      time();
      break;
    }

    default:
      break;
    }
    setState(653);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(652);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(656);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(655);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_statementContext ------------------------------------------------------------------

TSqlParser::While_statementContext::While_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::While_statementContext::WHILE() {
  return getToken(TSqlParser::WHILE, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::While_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

TSqlParser::Sql_clausesContext* TSqlParser::While_statementContext::sql_clauses() {
  return getRuleContext<TSqlParser::Sql_clausesContext>(0);
}

tree::TerminalNode* TSqlParser::While_statementContext::BREAK() {
  return getToken(TSqlParser::BREAK, 0);
}

tree::TerminalNode* TSqlParser::While_statementContext::CONTINUE() {
  return getToken(TSqlParser::CONTINUE, 0);
}

tree::TerminalNode* TSqlParser::While_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::While_statementContext::getRuleIndex() const {
  return TSqlParser::RuleWhile_statement;
}

void TSqlParser::While_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_statement(this);
}

void TSqlParser::While_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_statement(this);
}

TSqlParser::While_statementContext* TSqlParser::while_statement() {
  While_statementContext *_localctx = _tracker.createInstance<While_statementContext>(_ctx, getState());
  enterRule(_localctx, 38, TSqlParser::RuleWhile_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(658);
    match(TSqlParser::WHILE);
    setState(659);
    search_condition(0);
    setState(669);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(660);
      sql_clauses();
      break;
    }

    case 2: {
      setState(661);
      match(TSqlParser::BREAK);
      setState(663);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
      case 1: {
        setState(662);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      setState(665);
      match(TSqlParser::CONTINUE);
      setState(667);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        setState(666);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Print_statementContext ------------------------------------------------------------------

TSqlParser::Print_statementContext::Print_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Print_statementContext::PRINT() {
  return getToken(TSqlParser::PRINT, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Print_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Print_statementContext::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Print_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Print_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Print_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Print_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Print_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Print_statementContext::getRuleIndex() const {
  return TSqlParser::RulePrint_statement;
}

void TSqlParser::Print_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrint_statement(this);
}

void TSqlParser::Print_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrint_statement(this);
}

TSqlParser::Print_statementContext* TSqlParser::print_statement() {
  Print_statementContext *_localctx = _tracker.createInstance<Print_statementContext>(_ctx, getState());
  enterRule(_localctx, 40, TSqlParser::RulePrint_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    match(TSqlParser::PRINT);
    setState(674);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(672);
      expression(0);
      break;
    }

    case 2: {
      setState(673);
      match(TSqlParser::DOUBLE_QUOTE_ID);
      break;
    }

    default:
      break;
    }
    setState(680);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(676);
      match(TSqlParser::COMMA);
      setState(677);
      match(TSqlParser::LOCAL_ID);
      setState(682);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(684);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      setState(683);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raiseerror_statementContext ------------------------------------------------------------------

TSqlParser::Raiseerror_statementContext::Raiseerror_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::RAISERROR() {
  return getToken(TSqlParser::RAISERROR, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Constant_LOCAL_IDContext *> TSqlParser::Raiseerror_statementContext::constant_LOCAL_ID() {
  return getRuleContexts<TSqlParser::Constant_LOCAL_IDContext>();
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::Raiseerror_statementContext::constant_LOCAL_ID(size_t i) {
  return getRuleContext<TSqlParser::Constant_LOCAL_IDContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LOG() {
  return getToken(TSqlParser::LOG, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::SETERROR() {
  return getToken(TSqlParser::SETERROR, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}


size_t TSqlParser::Raiseerror_statementContext::getRuleIndex() const {
  return TSqlParser::RuleRaiseerror_statement;
}

void TSqlParser::Raiseerror_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaiseerror_statement(this);
}

void TSqlParser::Raiseerror_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaiseerror_statement(this);
}

TSqlParser::Raiseerror_statementContext* TSqlParser::raiseerror_statement() {
  Raiseerror_statementContext *_localctx = _tracker.createInstance<Raiseerror_statementContext>(_ctx, getState());
  enterRule(_localctx, 42, TSqlParser::RuleRaiseerror_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(718);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(686);
      match(TSqlParser::RAISERROR);
      setState(687);
      match(TSqlParser::LR_BRACKET);
      setState(688);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->msg = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 399) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 399)) & ((1ULL << (TSqlParser::LOCAL_ID - 399))
        | (1ULL << (TSqlParser::DECIMAL - 399))
        | (1ULL << (TSqlParser::STRING - 399)))) != 0))) {
        dynamic_cast<Raiseerror_statementContext *>(_localctx)->msg = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(689);
      match(TSqlParser::COMMA);
      setState(690);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->severity = constant_LOCAL_ID();
      setState(691);
      match(TSqlParser::COMMA);
      setState(692);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->state = constant_LOCAL_ID();
      setState(697);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(693);
        match(TSqlParser::COMMA);
        setState(694);
        constant_LOCAL_ID();
        setState(699);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(700);
      match(TSqlParser::RR_BRACKET);
      setState(703);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
      case 1: {
        setState(701);
        match(TSqlParser::WITH);
        setState(702);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::NOWAIT

        || _la == TSqlParser::SETERROR || _la == TSqlParser::LOG)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      setState(706);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(705);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(708);
      match(TSqlParser::RAISERROR);
      setState(709);
      match(TSqlParser::DECIMAL);
      setState(710);
      dynamic_cast<Raiseerror_statementContext *>(_localctx)->formatstring = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 396) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 396)) & ((1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 396))
        | (1ULL << (TSqlParser::LOCAL_ID - 396))
        | (1ULL << (TSqlParser::STRING - 396)))) != 0))) {
        dynamic_cast<Raiseerror_statementContext *>(_localctx)->formatstring = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(715);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(711);
        match(TSqlParser::COMMA);
        setState(712);
        dynamic_cast<Raiseerror_statementContext *>(_localctx)->argument = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 399) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 399)) & ((1ULL << (TSqlParser::LOCAL_ID - 399))
          | (1ULL << (TSqlParser::DECIMAL - 399))
          | (1ULL << (TSqlParser::STRING - 399)))) != 0))) {
          dynamic_cast<Raiseerror_statementContext *>(_localctx)->argument = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(717);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Empty_statementContext ------------------------------------------------------------------

TSqlParser::Empty_statementContext::Empty_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Empty_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Empty_statementContext::getRuleIndex() const {
  return TSqlParser::RuleEmpty_statement;
}

void TSqlParser::Empty_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmpty_statement(this);
}

void TSqlParser::Empty_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmpty_statement(this);
}

TSqlParser::Empty_statementContext* TSqlParser::empty_statement() {
  Empty_statementContext *_localctx = _tracker.createInstance<Empty_statementContext>(_ctx, getState());
  enterRule(_localctx, 44, TSqlParser::RuleEmpty_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(720);
    match(TSqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Another_statementContext ------------------------------------------------------------------

TSqlParser::Another_statementContext::Another_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Declare_statementContext* TSqlParser::Another_statementContext::declare_statement() {
  return getRuleContext<TSqlParser::Declare_statementContext>(0);
}

TSqlParser::Execute_statementContext* TSqlParser::Another_statementContext::execute_statement() {
  return getRuleContext<TSqlParser::Execute_statementContext>(0);
}

TSqlParser::Cursor_statementContext* TSqlParser::Another_statementContext::cursor_statement() {
  return getRuleContext<TSqlParser::Cursor_statementContext>(0);
}

TSqlParser::Kill_statementContext* TSqlParser::Another_statementContext::kill_statement() {
  return getRuleContext<TSqlParser::Kill_statementContext>(0);
}

TSqlParser::Set_statementContext* TSqlParser::Another_statementContext::set_statement() {
  return getRuleContext<TSqlParser::Set_statementContext>(0);
}

TSqlParser::Transaction_statementContext* TSqlParser::Another_statementContext::transaction_statement() {
  return getRuleContext<TSqlParser::Transaction_statementContext>(0);
}

TSqlParser::Use_statementContext* TSqlParser::Another_statementContext::use_statement() {
  return getRuleContext<TSqlParser::Use_statementContext>(0);
}

TSqlParser::Shutdown_statementContext* TSqlParser::Another_statementContext::shutdown_statement() {
  return getRuleContext<TSqlParser::Shutdown_statementContext>(0);
}


size_t TSqlParser::Another_statementContext::getRuleIndex() const {
  return TSqlParser::RuleAnother_statement;
}

void TSqlParser::Another_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnother_statement(this);
}

void TSqlParser::Another_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnother_statement(this);
}

TSqlParser::Another_statementContext* TSqlParser::another_statement() {
  Another_statementContext *_localctx = _tracker.createInstance<Another_statementContext>(_ctx, getState());
  enterRule(_localctx, 46, TSqlParser::RuleAnother_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(730);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(722);
      declare_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(723);
      execute_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(724);
      cursor_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(725);
      kill_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(726);
      set_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(727);
      transaction_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(728);
      use_statement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(729);
      shutdown_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_toContext ------------------------------------------------------------------

TSqlParser::Entity_toContext::Entity_toContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Entity_toContext::TO() {
  return getToken(TSqlParser::TO, 0);
}


size_t TSqlParser::Entity_toContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_to;
}

void TSqlParser::Entity_toContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_to(this);
}

void TSqlParser::Entity_toContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_to(this);
}

TSqlParser::Entity_toContext* TSqlParser::entity_to() {
  Entity_toContext *_localctx = _tracker.createInstance<Entity_toContext>(_ctx, getState());
  enterRule(_localctx, 48, TSqlParser::RuleEntity_to);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(732);
    match(TSqlParser::TO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Colon_colonContext ------------------------------------------------------------------

TSqlParser::Colon_colonContext::Colon_colonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Colon_colonContext::DOUBLE_COLON() {
  return getToken(TSqlParser::DOUBLE_COLON, 0);
}


size_t TSqlParser::Colon_colonContext::getRuleIndex() const {
  return TSqlParser::RuleColon_colon;
}

void TSqlParser::Colon_colonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColon_colon(this);
}

void TSqlParser::Colon_colonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColon_colon(this);
}

TSqlParser::Colon_colonContext* TSqlParser::colon_colon() {
  Colon_colonContext *_localctx = _tracker.createInstance<Colon_colonContext>(_ctx, getState());
  enterRule(_localctx, 50, TSqlParser::RuleColon_colon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(734);
    match(TSqlParser::DOUBLE_COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_typeContext ------------------------------------------------------------------

TSqlParser::Class_typeContext::Class_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_typeContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Class_typeContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Class_typeContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}


size_t TSqlParser::Class_typeContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type;
}

void TSqlParser::Class_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type(this);
}

void TSqlParser::Class_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type(this);
}

TSqlParser::Class_typeContext* TSqlParser::class_type() {
  Class_typeContext *_localctx = _tracker.createInstance<Class_typeContext>(_ctx, getState());
  enterRule(_localctx, 52, TSqlParser::RuleClass_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(736);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT || _la == TSqlParser::TYPE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_sql_databaseContext ------------------------------------------------------------------

TSqlParser::Class_type_for_sql_databaseContext::Class_type_for_sql_databaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}


size_t TSqlParser::Class_type_for_sql_databaseContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_sql_database;
}

void TSqlParser::Class_type_for_sql_databaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_sql_database(this);
}

void TSqlParser::Class_type_for_sql_databaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_sql_database(this);
}

TSqlParser::Class_type_for_sql_databaseContext* TSqlParser::class_type_for_sql_database() {
  Class_type_for_sql_databaseContext *_localctx = _tracker.createInstance<Class_type_for_sql_databaseContext>(_ctx, getState());
  enterRule(_localctx, 54, TSqlParser::RuleClass_type_for_sql_database);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(738);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT || _la == TSqlParser::TYPE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_azure_dwContext ------------------------------------------------------------------

TSqlParser::Class_type_for_azure_dwContext::Class_type_for_azure_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_azure_dwContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_azure_dwContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}


size_t TSqlParser::Class_type_for_azure_dwContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_azure_dw;
}

void TSqlParser::Class_type_for_azure_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_azure_dw(this);
}

void TSqlParser::Class_type_for_azure_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_azure_dw(this);
}

TSqlParser::Class_type_for_azure_dwContext* TSqlParser::class_type_for_azure_dw() {
  Class_type_for_azure_dwContext *_localctx = _tracker.createInstance<Class_type_for_azure_dwContext>(_ctx, getState());
  enterRule(_localctx, 56, TSqlParser::RuleClass_type_for_azure_dw);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(740);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_parallel_dwContext ------------------------------------------------------------------

TSqlParser::Class_type_for_parallel_dwContext::Class_type_for_parallel_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::DATABASE() {
  return getToken(TSqlParser::DATABASE, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}


size_t TSqlParser::Class_type_for_parallel_dwContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_parallel_dw;
}

void TSqlParser::Class_type_for_parallel_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_parallel_dw(this);
}

void TSqlParser::Class_type_for_parallel_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_parallel_dw(this);
}

TSqlParser::Class_type_for_parallel_dwContext* TSqlParser::class_type_for_parallel_dw() {
  Class_type_for_parallel_dwContext *_localctx = _tracker.createInstance<Class_type_for_parallel_dwContext>(_ctx, getState());
  enterRule(_localctx, 58, TSqlParser::RuleClass_type_for_parallel_dw);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(742);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::DATABASE || _la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lock_tableContext ------------------------------------------------------------------

TSqlParser::Lock_tableContext::Lock_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Lock_tableContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Lock_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::MODE() {
  return getToken(TSqlParser::MODE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::SHARE() {
  return getToken(TSqlParser::SHARE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::EXCLUSIVE() {
  return getToken(TSqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::WAIT() {
  return getToken(TSqlParser::WAIT, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Lock_tableContext::getRuleIndex() const {
  return TSqlParser::RuleLock_table;
}

void TSqlParser::Lock_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLock_table(this);
}

void TSqlParser::Lock_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLock_table(this);
}

TSqlParser::Lock_tableContext* TSqlParser::lock_table() {
  Lock_tableContext *_localctx = _tracker.createInstance<Lock_tableContext>(_ctx, getState());
  enterRule(_localctx, 60, TSqlParser::RuleLock_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(744);
    match(TSqlParser::LOCK);
    setState(745);
    match(TSqlParser::TABLE);
    setState(746);
    table_name();
    setState(747);
    match(TSqlParser::IN);
    setState(748);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::EXCLUSIVE || _la == TSqlParser::SHARE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(749);
    match(TSqlParser::MODE);
    setState(753);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(750);
      match(TSqlParser::WAIT);
      setState(751);
      dynamic_cast<Lock_tableContext *>(_localctx)->seconds = match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(752);
      match(TSqlParser::NOWAIT);
      break;
    }

    default:
      break;
    }
    setState(756);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(755);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Truncate_tableContext ------------------------------------------------------------------

TSqlParser::Truncate_tableContext::Truncate_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TRUNCATE() {
  return getToken(TSqlParser::TRUNCATE, 0);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Truncate_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::PARTITIONS() {
  return getToken(TSqlParser::PARTITIONS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::TO() {
  return getTokens(TSqlParser::TO);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TO(size_t i) {
  return getToken(TSqlParser::TO, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Truncate_tableContext::getRuleIndex() const {
  return TSqlParser::RuleTruncate_table;
}

void TSqlParser::Truncate_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncate_table(this);
}

void TSqlParser::Truncate_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncate_table(this);
}

TSqlParser::Truncate_tableContext* TSqlParser::truncate_table() {
  Truncate_tableContext *_localctx = _tracker.createInstance<Truncate_tableContext>(_ctx, getState());
  enterRule(_localctx, 62, TSqlParser::RuleTruncate_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(758);
    match(TSqlParser::TRUNCATE);
    setState(759);
    match(TSqlParser::TABLE);
    setState(760);
    table_name();
    setState(780);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(761);
      match(TSqlParser::WITH);
      setState(762);
      match(TSqlParser::LR_BRACKET);
      setState(763);
      match(TSqlParser::PARTITIONS);
      setState(764);
      match(TSqlParser::LR_BRACKET);
      setState(774); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(766);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(765);
          match(TSqlParser::COMMA);
        }
        setState(772);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(768);
          match(TSqlParser::DECIMAL);
          break;
        }

        case 2: {
          setState(769);
          match(TSqlParser::DECIMAL);
          setState(770);
          match(TSqlParser::TO);
          setState(771);
          match(TSqlParser::DECIMAL);
          break;
        }

        default:
          break;
        }
        setState(776); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::DECIMAL

      || _la == TSqlParser::COMMA);
      setState(778);
      match(TSqlParser::RR_BRACKET);
      setState(779);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_sequenceContext ------------------------------------------------------------------

TSqlParser::Alter_sequenceContext::Alter_sequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::SEQUENCE() {
  return getToken(TSqlParser::SEQUENCE, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Alter_sequenceContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Alter_sequenceContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::RESTART() {
  return getToken(TSqlParser::RESTART, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::INCREMENT() {
  return getToken(TSqlParser::INCREMENT, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::MINVALUE() {
  return getToken(TSqlParser::MINVALUE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_sequenceContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_sequenceContext::NO() {
  return getTokens(TSqlParser::NO);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::NO(size_t i) {
  return getToken(TSqlParser::NO, i);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::MAXVALUE() {
  return getToken(TSqlParser::MAXVALUE, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::CYCLE() {
  return getToken(TSqlParser::CYCLE, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::CACHE() {
  return getToken(TSqlParser::CACHE, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}


size_t TSqlParser::Alter_sequenceContext::getRuleIndex() const {
  return TSqlParser::RuleAlter_sequence;
}

void TSqlParser::Alter_sequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_sequence(this);
}

void TSqlParser::Alter_sequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_sequence(this);
}

TSqlParser::Alter_sequenceContext* TSqlParser::alter_sequence() {
  Alter_sequenceContext *_localctx = _tracker.createInstance<Alter_sequenceContext>(_ctx, getState());
  enterRule(_localctx, 64, TSqlParser::RuleAlter_sequence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(782);
    match(TSqlParser::ALTER);
    setState(783);
    match(TSqlParser::SEQUENCE);
    setState(787);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(784);
      dynamic_cast<Alter_sequenceContext *>(_localctx)->schema_name = id_();
      setState(785);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(789);
    dynamic_cast<Alter_sequenceContext *>(_localctx)->sequence_name = id_();
    setState(795);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      setState(790);
      match(TSqlParser::RESTART);
      setState(793);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(791);
        match(TSqlParser::WITH);
        setState(792);
        match(TSqlParser::DECIMAL);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(800);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(797);
      match(TSqlParser::INCREMENT);
      setState(798);
      match(TSqlParser::BY);
      setState(799);
      dynamic_cast<Alter_sequenceContext *>(_localctx)->sequnce_increment = match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(806);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      setState(802);
      match(TSqlParser::MINVALUE);
      setState(803);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(804);
      match(TSqlParser::NO);
      setState(805);
      match(TSqlParser::MINVALUE);
      break;
    }

    default:
      break;
    }
    setState(812);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      setState(808);
      match(TSqlParser::MAXVALUE);
      setState(809);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(810);
      match(TSqlParser::NO);
      setState(811);
      match(TSqlParser::MAXVALUE);
      break;
    }

    default:
      break;
    }
    setState(817);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(814);
      match(TSqlParser::CYCLE);
      break;
    }

    case 2: {
      setState(815);
      match(TSqlParser::NO);
      setState(816);
      match(TSqlParser::CYCLE);
      break;
    }

    default:
      break;
    }
    setState(823);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      setState(819);
      match(TSqlParser::CACHE);
      setState(820);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(821);
      match(TSqlParser::NO);
      setState(822);
      match(TSqlParser::CACHE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_sequenceContext ------------------------------------------------------------------

TSqlParser::Create_sequenceContext::Create_sequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::SEQUENCE() {
  return getToken(TSqlParser::SEQUENCE, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Create_sequenceContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Create_sequenceContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Create_sequenceContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::START() {
  return getToken(TSqlParser::START, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_sequenceContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::INCREMENT() {
  return getToken(TSqlParser::INCREMENT, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::MINVALUE() {
  return getToken(TSqlParser::MINVALUE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_sequenceContext::NO() {
  return getTokens(TSqlParser::NO);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::NO(size_t i) {
  return getToken(TSqlParser::NO, i);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::MAXVALUE() {
  return getToken(TSqlParser::MAXVALUE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::CYCLE() {
  return getToken(TSqlParser::CYCLE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::CACHE() {
  return getToken(TSqlParser::CACHE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::Create_sequenceContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_sequence;
}

void TSqlParser::Create_sequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_sequence(this);
}

void TSqlParser::Create_sequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_sequence(this);
}

TSqlParser::Create_sequenceContext* TSqlParser::create_sequence() {
  Create_sequenceContext *_localctx = _tracker.createInstance<Create_sequenceContext>(_ctx, getState());
  enterRule(_localctx, 66, TSqlParser::RuleCreate_sequence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(825);
    match(TSqlParser::CREATE);
    setState(826);
    match(TSqlParser::SEQUENCE);
    setState(830);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(827);
      dynamic_cast<Create_sequenceContext *>(_localctx)->schema_name = id_();
      setState(828);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(832);
    dynamic_cast<Create_sequenceContext *>(_localctx)->sequence_name = id_();
    setState(835);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(833);
      match(TSqlParser::AS);
      setState(834);
      data_type();
    }
    setState(840);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(837);
      match(TSqlParser::START);
      setState(838);
      match(TSqlParser::WITH);
      setState(839);
      match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(848);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(842);
      match(TSqlParser::INCREMENT);
      setState(843);
      match(TSqlParser::BY);
      setState(845);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::MINUS) {
        setState(844);
        match(TSqlParser::MINUS);
      }
      setState(847);
      match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(856);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(850);
      match(TSqlParser::MINVALUE);
      setState(852);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DECIMAL) {
        setState(851);
        match(TSqlParser::DECIMAL);
      }
      break;
    }

    case 2: {
      setState(854);
      match(TSqlParser::NO);
      setState(855);
      match(TSqlParser::MINVALUE);
      break;
    }

    default:
      break;
    }
    setState(864);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(858);
      match(TSqlParser::MAXVALUE);
      setState(860);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DECIMAL) {
        setState(859);
        match(TSqlParser::DECIMAL);
      }
      break;
    }

    case 2: {
      setState(862);
      match(TSqlParser::NO);
      setState(863);
      match(TSqlParser::MAXVALUE);
      break;
    }

    default:
      break;
    }
    setState(869);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(866);
      match(TSqlParser::CYCLE);
      break;
    }

    case 2: {
      setState(867);
      match(TSqlParser::NO);
      setState(868);
      match(TSqlParser::CYCLE);
      break;
    }

    default:
      break;
    }
    setState(877);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(871);
      match(TSqlParser::CACHE);
      setState(873);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DECIMAL) {
        setState(872);
        match(TSqlParser::DECIMAL);
      }
      break;
    }

    case 2: {
      setState(875);
      match(TSqlParser::NO);
      setState(876);
      match(TSqlParser::CACHE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_statementContext ------------------------------------------------------------------

TSqlParser::Merge_statementContext::Merge_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_statementContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

TSqlParser::Ddl_objectContext* TSqlParser::Merge_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::USING() {
  return getToken(TSqlParser::USING, 0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Merge_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Merge_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::With_expressionContext* TSqlParser::Merge_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Merge_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Merge_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::Merge_statementContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}

std::vector<TSqlParser::When_matchesContext *> TSqlParser::Merge_statementContext::when_matches() {
  return getRuleContexts<TSqlParser::When_matchesContext>();
}

TSqlParser::When_matchesContext* TSqlParser::Merge_statementContext::when_matches(size_t i) {
  return getRuleContext<TSqlParser::When_matchesContext>(i);
}

TSqlParser::Output_clauseContext* TSqlParser::Merge_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Merge_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}


size_t TSqlParser::Merge_statementContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_statement;
}

void TSqlParser::Merge_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_statement(this);
}

void TSqlParser::Merge_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_statement(this);
}

TSqlParser::Merge_statementContext* TSqlParser::merge_statement() {
  Merge_statementContext *_localctx = _tracker.createInstance<Merge_statementContext>(_ctx, getState());
  enterRule(_localctx, 68, TSqlParser::RuleMerge_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(880);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(879);
      with_expression();
    }
    setState(882);
    match(TSqlParser::MERGE);
    setState(890);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(883);
      match(TSqlParser::TOP);
      setState(884);
      match(TSqlParser::LR_BRACKET);
      setState(885);
      expression(0);
      setState(886);
      match(TSqlParser::RR_BRACKET);
      setState(888);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(887);
        match(TSqlParser::PERCENT);
      }
    }
    setState(893);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(892);
      match(TSqlParser::INTO);
    }
    setState(895);
    ddl_object();
    setState(897);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(896);
      insert_with_table_hints();
    }
    setState(900);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
    case 1: {
      setState(899);
      as_table_alias();
      break;
    }

    default:
      break;
    }
    setState(902);
    match(TSqlParser::USING);
    setState(903);
    table_sources();
    setState(904);
    match(TSqlParser::ON);
    setState(905);
    search_condition(0);
    setState(907); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(906);
      when_matches();
      setState(909); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == TSqlParser::WHEN);
    setState(912);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OUTPUT) {
      setState(911);
      output_clause();
    }
    setState(915);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(914);
      option_clause();
    }
    setState(917);
    match(TSqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_matchesContext ------------------------------------------------------------------

TSqlParser::When_matchesContext::When_matchesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::WHEN() {
  return getTokens(TSqlParser::WHEN);
}

tree::TerminalNode* TSqlParser::When_matchesContext::WHEN(size_t i) {
  return getToken(TSqlParser::WHEN, i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::MATCHED() {
  return getTokens(TSqlParser::MATCHED);
}

tree::TerminalNode* TSqlParser::When_matchesContext::MATCHED(size_t i) {
  return getToken(TSqlParser::MATCHED, i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::THEN() {
  return getTokens(TSqlParser::THEN);
}

tree::TerminalNode* TSqlParser::When_matchesContext::THEN(size_t i) {
  return getToken(TSqlParser::THEN, i);
}

std::vector<TSqlParser::Merge_matchedContext *> TSqlParser::When_matchesContext::merge_matched() {
  return getRuleContexts<TSqlParser::Merge_matchedContext>();
}

TSqlParser::Merge_matchedContext* TSqlParser::When_matchesContext::merge_matched(size_t i) {
  return getRuleContext<TSqlParser::Merge_matchedContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::AND() {
  return getTokens(TSqlParser::AND);
}

tree::TerminalNode* TSqlParser::When_matchesContext::AND(size_t i) {
  return getToken(TSqlParser::AND, i);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::When_matchesContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::When_matchesContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::When_matchesContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

TSqlParser::Merge_not_matchedContext* TSqlParser::When_matchesContext::merge_not_matched() {
  return getRuleContext<TSqlParser::Merge_not_matchedContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::BY() {
  return getTokens(TSqlParser::BY);
}

tree::TerminalNode* TSqlParser::When_matchesContext::BY(size_t i) {
  return getToken(TSqlParser::BY, i);
}

tree::TerminalNode* TSqlParser::When_matchesContext::TARGET() {
  return getToken(TSqlParser::TARGET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::SOURCE() {
  return getTokens(TSqlParser::SOURCE);
}

tree::TerminalNode* TSqlParser::When_matchesContext::SOURCE(size_t i) {
  return getToken(TSqlParser::SOURCE, i);
}


size_t TSqlParser::When_matchesContext::getRuleIndex() const {
  return TSqlParser::RuleWhen_matches;
}

void TSqlParser::When_matchesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhen_matches(this);
}

void TSqlParser::When_matchesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhen_matches(this);
}

TSqlParser::When_matchesContext* TSqlParser::when_matches() {
  When_matchesContext *_localctx = _tracker.createInstance<When_matchesContext>(_ctx, getState());
  enterRule(_localctx, 70, TSqlParser::RuleWhen_matches);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(959);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(927); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(919);
                match(TSqlParser::WHEN);
                setState(920);
                match(TSqlParser::MATCHED);
                setState(923);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == TSqlParser::AND) {
                  setState(921);
                  match(TSqlParser::AND);
                  setState(922);
                  search_condition(0);
                }
                setState(925);
                match(TSqlParser::THEN);
                setState(926);
                merge_matched();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(929); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(931);
      match(TSqlParser::WHEN);
      setState(932);
      match(TSqlParser::NOT);
      setState(933);
      match(TSqlParser::MATCHED);
      setState(936);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::BY) {
        setState(934);
        match(TSqlParser::BY);
        setState(935);
        match(TSqlParser::TARGET);
      }
      setState(940);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AND) {
        setState(938);
        match(TSqlParser::AND);
        setState(939);
        search_condition(0);
      }
      setState(942);
      match(TSqlParser::THEN);
      setState(943);
      merge_not_matched();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(955); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(944);
                match(TSqlParser::WHEN);
                setState(945);
                match(TSqlParser::NOT);
                setState(946);
                match(TSqlParser::MATCHED);
                setState(947);
                match(TSqlParser::BY);
                setState(948);
                match(TSqlParser::SOURCE);
                setState(951);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == TSqlParser::AND) {
                  setState(949);
                  match(TSqlParser::AND);
                  setState(950);
                  search_condition(0);
                }
                setState(953);
                match(TSqlParser::THEN);
                setState(954);
                merge_matched();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(957); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_matchedContext ------------------------------------------------------------------

TSqlParser::Merge_matchedContext::Merge_matchedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Update_elem_mergeContext *> TSqlParser::Merge_matchedContext::update_elem_merge() {
  return getRuleContexts<TSqlParser::Update_elem_mergeContext>();
}

TSqlParser::Update_elem_mergeContext* TSqlParser::Merge_matchedContext::update_elem_merge(size_t i) {
  return getRuleContext<TSqlParser::Update_elem_mergeContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_matchedContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::DELETE() {
  return getToken(TSqlParser::DELETE, 0);
}


size_t TSqlParser::Merge_matchedContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_matched;
}

void TSqlParser::Merge_matchedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_matched(this);
}

void TSqlParser::Merge_matchedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_matched(this);
}

TSqlParser::Merge_matchedContext* TSqlParser::merge_matched() {
  Merge_matchedContext *_localctx = _tracker.createInstance<Merge_matchedContext>(_ctx, getState());
  enterRule(_localctx, 72, TSqlParser::RuleMerge_matched);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(972);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UPDATE: {
        enterOuterAlt(_localctx, 1);
        setState(961);
        match(TSqlParser::UPDATE);
        setState(962);
        match(TSqlParser::SET);
        setState(963);
        update_elem_merge();
        setState(968);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(964);
          match(TSqlParser::COMMA);
          setState(965);
          update_elem_merge();
          setState(970);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case TSqlParser::DELETE: {
        enterOuterAlt(_localctx, 2);
        setState(971);
        match(TSqlParser::DELETE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_not_matchedContext ------------------------------------------------------------------

TSqlParser::Merge_not_matchedContext::Merge_not_matchedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::INSERT() {
  return getToken(TSqlParser::INSERT, 0);
}

TSqlParser::Table_value_constructorContext* TSqlParser::Merge_not_matchedContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Merge_not_matchedContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Merge_not_matchedContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_not_matched;
}

void TSqlParser::Merge_not_matchedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_not_matched(this);
}

void TSqlParser::Merge_not_matchedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_not_matched(this);
}

TSqlParser::Merge_not_matchedContext* TSqlParser::merge_not_matched() {
  Merge_not_matchedContext *_localctx = _tracker.createInstance<Merge_not_matchedContext>(_ctx, getState());
  enterRule(_localctx, 74, TSqlParser::RuleMerge_not_matched);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(974);
    match(TSqlParser::INSERT);
    setState(979);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(975);
      match(TSqlParser::LR_BRACKET);
      setState(976);
      column_name_list();
      setState(977);
      match(TSqlParser::RR_BRACKET);
    }
    setState(984);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::VALUES: {
        setState(981);
        table_value_constructor();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(982);
        match(TSqlParser::DEFAULT);
        setState(983);
        match(TSqlParser::VALUES);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statementContext ------------------------------------------------------------------

TSqlParser::Delete_statementContext::Delete_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Delete_statementContext::DELETE() {
  return getToken(TSqlParser::DELETE, 0);
}

TSqlParser::Delete_statement_fromContext* TSqlParser::Delete_statementContext::delete_statement_from() {
  return getRuleContext<TSqlParser::Delete_statement_fromContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Delete_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Delete_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Delete_statementContext::FROM() {
  return getTokens(TSqlParser::FROM);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::FROM(size_t i) {
  return getToken(TSqlParser::FROM, i);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Delete_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::Output_clauseContext* TSqlParser::Delete_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Delete_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

TSqlParser::Option_clauseContext* TSqlParser::Delete_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Delete_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Delete_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Delete_statementContext::getRuleIndex() const {
  return TSqlParser::RuleDelete_statement;
}

void TSqlParser::Delete_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_statement(this);
}

void TSqlParser::Delete_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_statement(this);
}

TSqlParser::Delete_statementContext* TSqlParser::delete_statement() {
  Delete_statementContext *_localctx = _tracker.createInstance<Delete_statementContext>(_ctx, getState());
  enterRule(_localctx, 76, TSqlParser::RuleDelete_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(987);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(986);
      with_expression();
    }
    setState(989);
    match(TSqlParser::DELETE);
    setState(999);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(990);
      match(TSqlParser::TOP);
      setState(991);
      match(TSqlParser::LR_BRACKET);
      setState(992);
      expression(0);
      setState(993);
      match(TSqlParser::RR_BRACKET);
      setState(995);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(994);
        match(TSqlParser::PERCENT);
      }
      break;
    }

    case 2: {
      setState(997);
      match(TSqlParser::TOP);
      setState(998);
      match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(1002);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1001);
      match(TSqlParser::FROM);
    }
    setState(1004);
    delete_statement_from();
    setState(1006);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(1005);
      insert_with_table_hints();
      break;
    }

    default:
      break;
    }
    setState(1009);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      setState(1008);
      output_clause();
      break;
    }

    default:
      break;
    }
    setState(1013);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1011);
      match(TSqlParser::FROM);
      setState(1012);
      table_sources();
    }
    setState(1028);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(1015);
      match(TSqlParser::WHERE);
      setState(1026);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::ABS:
        case TSqlParser::ASCII:
        case TSqlParser::CEILING:
        case TSqlParser::CHAR:
        case TSqlParser::CHARINDEX:
        case TSqlParser::DATALENGTH:
        case TSqlParser::DAY:
        case TSqlParser::FLOOR:
        case TSqlParser::ISDATE:
        case TSqlParser::ISNUMERIC:
        case TSqlParser::LEN:
        case TSqlParser::LOWER:
        case TSqlParser::LTRIM:
        case TSqlParser::MONTH:
        case TSqlParser::NCHAR:
        case TSqlParser::PATINDEX:
        case TSqlParser::RAND:
        case TSqlParser::REPLACE:
        case TSqlParser::ROUND:
        case TSqlParser::RTRIM:
        case TSqlParser::SIGN:
        case TSqlParser::STR:
        case TSqlParser::SUBSTRING:
        case TSqlParser::UPPER:
        case TSqlParser::USER_NAME:
        case TSqlParser::YEAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::CASE:
        case TSqlParser::COALESCE:
        case TSqlParser::CONVERT:
        case TSqlParser::CURRENT_TIMESTAMP:
        case TSqlParser::CURRENT_USER:
        case TSqlParser::DEFAULT:
        case TSqlParser::EXISTS:
        case TSqlParser::IDENTITY:
        case TSqlParser::LEFT:
        case TSqlParser::NOT:
        case TSqlParser::NULL_:
        case TSqlParser::NULLIF:
        case TSqlParser::OVER:
        case TSqlParser::PRECISION:
        case TSqlParser::RIGHT:
        case TSqlParser::SESSION_USER:
        case TSqlParser::SYSTEM_USER:
        case TSqlParser::USER:
        case TSqlParser::DOLLAR_PARTITION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::DOLLAR_ACTION:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::SPACE:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOT:
        case TSqlParser::DOLLAR:
        case TSqlParser::LR_BRACKET:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS:
        case TSqlParser::BIT_NOT: {
          setState(1016);
          search_condition(0);
          break;
        }

        case TSqlParser::CURRENT: {
          setState(1017);
          match(TSqlParser::CURRENT);
          setState(1018);
          match(TSqlParser::OF);
          setState(1024);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
          case 1: {
            setState(1020);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
            case 1: {
              setState(1019);
              match(TSqlParser::GLOBAL);
              break;
            }

            default:
              break;
            }
            setState(1022);
            cursor_name();
            break;
          }

          case 2: {
            setState(1023);
            dynamic_cast<Delete_statementContext *>(_localctx)->cursor_var = match(TSqlParser::LOCAL_ID);
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(1031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1030);
      option_clause();
    }
    setState(1034);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      setState(1033);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statement_fromContext ------------------------------------------------------------------

TSqlParser::Delete_statement_fromContext::Delete_statement_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Ddl_objectContext* TSqlParser::Delete_statement_fromContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::Table_aliasContext* TSqlParser::Delete_statement_fromContext::table_alias() {
  return getRuleContext<TSqlParser::Table_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statement_fromContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Delete_statement_fromContext::getRuleIndex() const {
  return TSqlParser::RuleDelete_statement_from;
}

void TSqlParser::Delete_statement_fromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_statement_from(this);
}

void TSqlParser::Delete_statement_fromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_statement_from(this);
}

TSqlParser::Delete_statement_fromContext* TSqlParser::delete_statement_from() {
  Delete_statement_fromContext *_localctx = _tracker.createInstance<Delete_statement_fromContext>(_ctx, getState());
  enterRule(_localctx, 78, TSqlParser::RuleDelete_statement_from);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1039);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1036);
      ddl_object();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1037);
      table_alias();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1038);
      dynamic_cast<Delete_statement_fromContext *>(_localctx)->table_var = match(TSqlParser::LOCAL_ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statementContext ------------------------------------------------------------------

TSqlParser::Insert_statementContext::Insert_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Insert_statementContext::INSERT() {
  return getToken(TSqlParser::INSERT, 0);
}

TSqlParser::Insert_statement_valueContext* TSqlParser::Insert_statementContext::insert_statement_value() {
  return getRuleContext<TSqlParser::Insert_statement_valueContext>(0);
}

TSqlParser::Ddl_objectContext* TSqlParser::Insert_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Insert_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_statementContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::ExpressionContext* TSqlParser::Insert_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_statementContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Insert_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::Insert_column_name_listContext* TSqlParser::Insert_statementContext::insert_column_name_list() {
  return getRuleContext<TSqlParser::Insert_column_name_listContext>(0);
}

TSqlParser::Output_clauseContext* TSqlParser::Insert_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}


size_t TSqlParser::Insert_statementContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_statement;
}

void TSqlParser::Insert_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_statement(this);
}

void TSqlParser::Insert_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_statement(this);
}

TSqlParser::Insert_statementContext* TSqlParser::insert_statement() {
  Insert_statementContext *_localctx = _tracker.createInstance<Insert_statementContext>(_ctx, getState());
  enterRule(_localctx, 80, TSqlParser::RuleInsert_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1042);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1041);
      with_expression();
    }
    setState(1044);
    match(TSqlParser::INSERT);
    setState(1052);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(1045);
      match(TSqlParser::TOP);
      setState(1046);
      match(TSqlParser::LR_BRACKET);
      setState(1047);
      expression(0);
      setState(1048);
      match(TSqlParser::RR_BRACKET);
      setState(1050);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1049);
        match(TSqlParser::PERCENT);
      }
    }
    setState(1055);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1054);
      match(TSqlParser::INTO);
    }

    setState(1057);
    ddl_object();
    setState(1059);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1058);
      insert_with_table_hints();
    }
    setState(1065);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(1061);
      match(TSqlParser::LR_BRACKET);
      setState(1062);
      insert_column_name_list();
      setState(1063);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1068);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OUTPUT) {
      setState(1067);
      output_clause();
    }
    setState(1070);
    insert_statement_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statement_valueContext ------------------------------------------------------------------

TSqlParser::Insert_statement_valueContext::Insert_statement_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_value_constructorContext* TSqlParser::Insert_statement_valueContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}

TSqlParser::Derived_tableContext* TSqlParser::Insert_statement_valueContext::derived_table() {
  return getRuleContext<TSqlParser::Derived_tableContext>(0);
}

TSqlParser::Execute_statementContext* TSqlParser::Insert_statement_valueContext::execute_statement() {
  return getRuleContext<TSqlParser::Execute_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statement_valueContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Insert_statement_valueContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}


size_t TSqlParser::Insert_statement_valueContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_statement_value;
}

void TSqlParser::Insert_statement_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_statement_value(this);
}

void TSqlParser::Insert_statement_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_statement_value(this);
}

TSqlParser::Insert_statement_valueContext* TSqlParser::insert_statement_value() {
  Insert_statement_valueContext *_localctx = _tracker.createInstance<Insert_statement_valueContext>(_ctx, getState());
  enterRule(_localctx, 82, TSqlParser::RuleInsert_statement_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1077);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1072);
      table_value_constructor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1073);
      derived_table();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1074);
      execute_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1075);
      match(TSqlParser::DEFAULT);
      setState(1076);
      match(TSqlParser::VALUES);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Receive_statementContext ------------------------------------------------------------------

TSqlParser::Receive_statementContext::Receive_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Receive_statementContext::RECEIVE() {
  return getToken(TSqlParser::RECEIVE, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Receive_statementContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}

TSqlParser::Top_clauseContext* TSqlParser::Receive_statementContext::top_clause() {
  return getRuleContext<TSqlParser::Top_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Receive_statementContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Receive_statementContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Id_Context* TSqlParser::Receive_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Search_conditionContext* TSqlParser::Receive_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}


size_t TSqlParser::Receive_statementContext::getRuleIndex() const {
  return TSqlParser::RuleReceive_statement;
}

void TSqlParser::Receive_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReceive_statement(this);
}

void TSqlParser::Receive_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReceive_statement(this);
}

TSqlParser::Receive_statementContext* TSqlParser::receive_statement() {
  Receive_statementContext *_localctx = _tracker.createInstance<Receive_statementContext>(_ctx, getState());
  enterRule(_localctx, 84, TSqlParser::RuleReceive_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1080);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(1079);
      match(TSqlParser::LR_BRACKET);
    }
    setState(1082);
    match(TSqlParser::RECEIVE);
    setState(1087);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ALL: {
        setState(1083);
        match(TSqlParser::ALL);
        break;
      }

      case TSqlParser::DISTINCT: {
        setState(1084);
        match(TSqlParser::DISTINCT);
        break;
      }

      case TSqlParser::TOP: {
        setState(1085);
        top_clause();
        break;
      }

      case TSqlParser::STAR: {
        setState(1086);
        match(TSqlParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1097);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::LOCAL_ID) {
      setState(1089);
      match(TSqlParser::LOCAL_ID);
      setState(1090);
      match(TSqlParser::EQUAL);
      setState(1091);
      expression(0);
      setState(1093);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(1092);
        match(TSqlParser::COMMA);
      }
      setState(1099);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1100);
    match(TSqlParser::FROM);
    setState(1101);
    full_table_name();
    setState(1107);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1102);
      match(TSqlParser::INTO);
      setState(1103);
      dynamic_cast<Receive_statementContext *>(_localctx)->table_variable = id_();

      setState(1104);
      match(TSqlParser::WHERE);
      setState(1105);
      dynamic_cast<Receive_statementContext *>(_localctx)->where = search_condition(0);
    }
    setState(1110);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::RR_BRACKET) {
      setState(1109);
      match(TSqlParser::RR_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_statement_standaloneContext ------------------------------------------------------------------

TSqlParser::Select_statement_standaloneContext::Select_statement_standaloneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Select_statementContext* TSqlParser::Select_statement_standaloneContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Select_statement_standaloneContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}


size_t TSqlParser::Select_statement_standaloneContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_statement_standalone;
}

void TSqlParser::Select_statement_standaloneContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_statement_standalone(this);
}

void TSqlParser::Select_statement_standaloneContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_statement_standalone(this);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::select_statement_standalone() {
  Select_statement_standaloneContext *_localctx = _tracker.createInstance<Select_statement_standaloneContext>(_ctx, getState());
  enterRule(_localctx, 86, TSqlParser::RuleSelect_statement_standalone);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1113);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1112);
      with_expression();
    }
    setState(1115);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_statementContext ------------------------------------------------------------------

TSqlParser::Select_statementContext::Select_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Query_expressionContext* TSqlParser::Select_statementContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Select_statementContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Select_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Select_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Select_statementContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_statement;
}

void TSqlParser::Select_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_statement(this);
}

void TSqlParser::Select_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_statement(this);
}

TSqlParser::Select_statementContext* TSqlParser::select_statement() {
  Select_statementContext *_localctx = _tracker.createInstance<Select_statementContext>(_ctx, getState());
  enterRule(_localctx, 88, TSqlParser::RuleSelect_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1117);
    query_expression();
    setState(1119);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ORDER) {
      setState(1118);
      order_by_clause();
    }
    setState(1122);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1121);
      option_clause();
    }
    setState(1125);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      setState(1124);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeContext ------------------------------------------------------------------

TSqlParser::TimeContext::TimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::TimeContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ConstantContext* TSqlParser::TimeContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::TimeContext::getRuleIndex() const {
  return TSqlParser::RuleTime;
}

void TSqlParser::TimeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime(this);
}

void TSqlParser::TimeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime(this);
}

TSqlParser::TimeContext* TSqlParser::time() {
  TimeContext *_localctx = _tracker.createInstance<TimeContext>(_ctx, getState());
  enterRule(_localctx, 90, TSqlParser::RuleTime);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1129);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LOCAL_ID: {
        setState(1127);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        setState(1128);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_statementContext ------------------------------------------------------------------

TSqlParser::Update_statementContext::Update_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Update_statementContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Update_elemContext *> TSqlParser::Update_statementContext::update_elem() {
  return getRuleContexts<TSqlParser::Update_elemContext>();
}

TSqlParser::Update_elemContext* TSqlParser::Update_statementContext::update_elem(size_t i) {
  return getRuleContext<TSqlParser::Update_elemContext>(i);
}

TSqlParser::Ddl_objectContext* TSqlParser::Update_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Update_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Update_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Update_statementContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Update_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Update_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Output_clauseContext* TSqlParser::Update_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Update_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

TSqlParser::Option_clauseContext* TSqlParser::Update_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Update_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Update_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Update_statementContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_statement;
}

void TSqlParser::Update_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_statement(this);
}

void TSqlParser::Update_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_statement(this);
}

TSqlParser::Update_statementContext* TSqlParser::update_statement() {
  Update_statementContext *_localctx = _tracker.createInstance<Update_statementContext>(_ctx, getState());
  enterRule(_localctx, 92, TSqlParser::RuleUpdate_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1132);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1131);
      with_expression();
    }
    setState(1134);
    match(TSqlParser::UPDATE);
    setState(1142);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(1135);
      match(TSqlParser::TOP);
      setState(1136);
      match(TSqlParser::LR_BRACKET);
      setState(1137);
      expression(0);
      setState(1138);
      match(TSqlParser::RR_BRACKET);
      setState(1140);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1139);
        match(TSqlParser::PERCENT);
      }
    }

    setState(1144);
    ddl_object();
    setState(1146);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH || _la == TSqlParser::LR_BRACKET) {
      setState(1145);
      with_table_hints();
    }
    setState(1148);
    match(TSqlParser::SET);
    setState(1149);
    update_elem();
    setState(1154);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1150);
      match(TSqlParser::COMMA);
      setState(1151);
      update_elem();
      setState(1156);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1158);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      setState(1157);
      output_clause();
      break;
    }

    default:
      break;
    }
    setState(1162);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1160);
      match(TSqlParser::FROM);
      setState(1161);
      table_sources();
    }
    setState(1177);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(1164);
      match(TSqlParser::WHERE);
      setState(1175);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::ABS:
        case TSqlParser::ASCII:
        case TSqlParser::CEILING:
        case TSqlParser::CHAR:
        case TSqlParser::CHARINDEX:
        case TSqlParser::DATALENGTH:
        case TSqlParser::DAY:
        case TSqlParser::FLOOR:
        case TSqlParser::ISDATE:
        case TSqlParser::ISNUMERIC:
        case TSqlParser::LEN:
        case TSqlParser::LOWER:
        case TSqlParser::LTRIM:
        case TSqlParser::MONTH:
        case TSqlParser::NCHAR:
        case TSqlParser::PATINDEX:
        case TSqlParser::RAND:
        case TSqlParser::REPLACE:
        case TSqlParser::ROUND:
        case TSqlParser::RTRIM:
        case TSqlParser::SIGN:
        case TSqlParser::STR:
        case TSqlParser::SUBSTRING:
        case TSqlParser::UPPER:
        case TSqlParser::USER_NAME:
        case TSqlParser::YEAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::CASE:
        case TSqlParser::COALESCE:
        case TSqlParser::CONVERT:
        case TSqlParser::CURRENT_TIMESTAMP:
        case TSqlParser::CURRENT_USER:
        case TSqlParser::DEFAULT:
        case TSqlParser::EXISTS:
        case TSqlParser::IDENTITY:
        case TSqlParser::LEFT:
        case TSqlParser::NOT:
        case TSqlParser::NULL_:
        case TSqlParser::NULLIF:
        case TSqlParser::OVER:
        case TSqlParser::PRECISION:
        case TSqlParser::RIGHT:
        case TSqlParser::SESSION_USER:
        case TSqlParser::SYSTEM_USER:
        case TSqlParser::USER:
        case TSqlParser::DOLLAR_PARTITION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::DOLLAR_ACTION:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::SPACE:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOT:
        case TSqlParser::DOLLAR:
        case TSqlParser::LR_BRACKET:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS:
        case TSqlParser::BIT_NOT: {
          setState(1165);
          search_condition(0);
          break;
        }

        case TSqlParser::CURRENT: {
          setState(1166);
          match(TSqlParser::CURRENT);
          setState(1167);
          match(TSqlParser::OF);
          setState(1173);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
          case 1: {
            setState(1169);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
            case 1: {
              setState(1168);
              match(TSqlParser::GLOBAL);
              break;
            }

            default:
              break;
            }
            setState(1171);
            cursor_name();
            break;
          }

          case 2: {
            setState(1172);
            dynamic_cast<Update_statementContext *>(_localctx)->cursor_var = match(TSqlParser::LOCAL_ID);
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(1180);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1179);
      option_clause();
    }
    setState(1183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
    case 1: {
      setState(1182);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_clauseContext ------------------------------------------------------------------

TSqlParser::Output_clauseContext::Output_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Output_clauseContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

std::vector<TSqlParser::Output_dml_list_elemContext *> TSqlParser::Output_clauseContext::output_dml_list_elem() {
  return getRuleContexts<TSqlParser::Output_dml_list_elemContext>();
}

TSqlParser::Output_dml_list_elemContext* TSqlParser::Output_clauseContext::output_dml_list_elem(size_t i) {
  return getRuleContext<TSqlParser::Output_dml_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Output_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Output_clauseContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Output_clauseContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Output_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOutput_clause;
}

void TSqlParser::Output_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_clause(this);
}

void TSqlParser::Output_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_clause(this);
}

TSqlParser::Output_clauseContext* TSqlParser::output_clause() {
  Output_clauseContext *_localctx = _tracker.createInstance<Output_clauseContext>(_ctx, getState());
  enterRule(_localctx, 94, TSqlParser::RuleOutput_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1185);
    match(TSqlParser::OUTPUT);
    setState(1186);
    output_dml_list_elem();
    setState(1191);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1187);
      match(TSqlParser::COMMA);
      setState(1188);
      output_dml_list_elem();
      setState(1193);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1205);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1194);
      match(TSqlParser::INTO);
      setState(1197);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
      case 1: {
        setState(1195);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case 2: {
        setState(1196);
        table_name();
        break;
      }

      default:
        break;
      }
      setState(1203);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
      case 1: {
        setState(1199);
        match(TSqlParser::LR_BRACKET);
        setState(1200);
        column_name_list();
        setState(1201);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_dml_list_elemContext ------------------------------------------------------------------

TSqlParser::Output_dml_list_elemContext::Output_dml_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Output_dml_list_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::AsteriskContext* TSqlParser::Output_dml_list_elemContext::asterisk() {
  return getRuleContext<TSqlParser::AsteriskContext>(0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Output_dml_list_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Output_dml_list_elemContext::getRuleIndex() const {
  return TSqlParser::RuleOutput_dml_list_elem;
}

void TSqlParser::Output_dml_list_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_dml_list_elem(this);
}

void TSqlParser::Output_dml_list_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_dml_list_elem(this);
}

TSqlParser::Output_dml_list_elemContext* TSqlParser::output_dml_list_elem() {
  Output_dml_list_elemContext *_localctx = _tracker.createInstance<Output_dml_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 96, TSqlParser::RuleOutput_dml_list_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1209);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
    case 1: {
      setState(1207);
      expression(0);
      break;
    }

    case 2: {
      setState(1208);
      asterisk();
      break;
    }

    default:
      break;
    }
    setState(1212);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1211);
      as_column_alias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_procedureContext ------------------------------------------------------------------

TSqlParser::Create_or_alter_procedureContext::Create_or_alter_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Create_or_alter_procedureContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::PROC() {
  return getToken(TSqlParser::PROC, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::PROCEDURE() {
  return getToken(TSqlParser::PROCEDURE, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

std::vector<TSqlParser::Procedure_paramContext *> TSqlParser::Create_or_alter_procedureContext::procedure_param() {
  return getRuleContexts<TSqlParser::Procedure_paramContext>();
}

TSqlParser::Procedure_paramContext* TSqlParser::Create_or_alter_procedureContext::procedure_param(size_t i) {
  return getRuleContext<TSqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Procedure_optionContext *> TSqlParser::Create_or_alter_procedureContext::procedure_option() {
  return getRuleContexts<TSqlParser::Procedure_optionContext>();
}

TSqlParser::Procedure_optionContext* TSqlParser::Create_or_alter_procedureContext::procedure_option(size_t i) {
  return getRuleContext<TSqlParser::Procedure_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Create_or_alter_procedureContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Create_or_alter_procedureContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_or_alter_procedureContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::OR() {
  return getToken(TSqlParser::OR, 0);
}


size_t TSqlParser::Create_or_alter_procedureContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_or_alter_procedure;
}

void TSqlParser::Create_or_alter_procedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_or_alter_procedure(this);
}

void TSqlParser::Create_or_alter_procedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_or_alter_procedure(this);
}

TSqlParser::Create_or_alter_procedureContext* TSqlParser::create_or_alter_procedure() {
  Create_or_alter_procedureContext *_localctx = _tracker.createInstance<Create_or_alter_procedureContext>(_ctx, getState());
  enterRule(_localctx, 98, TSqlParser::RuleCreate_or_alter_procedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1220);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CREATE: {
        setState(1214);
        match(TSqlParser::CREATE);
        setState(1217);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OR) {
          setState(1215);
          match(TSqlParser::OR);
          setState(1216);
          match(TSqlParser::ALTER);
        }
        break;
      }

      case TSqlParser::ALTER: {
        setState(1219);
        match(TSqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1222);
    dynamic_cast<Create_or_alter_procedureContext *>(_localctx)->proc = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PROC

    || _la == TSqlParser::PROCEDURE)) {
      dynamic_cast<Create_or_alter_procedureContext *>(_localctx)->proc = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1223);
    dynamic_cast<Create_or_alter_procedureContext *>(_localctx)->procName = func_proc_name_schema();
    setState(1226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1224);
      match(TSqlParser::SEMI);
      setState(1225);
      match(TSqlParser::DECIMAL);
    }
    setState(1242);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::LR_BRACKET) {
      setState(1229);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LR_BRACKET) {
        setState(1228);
        match(TSqlParser::LR_BRACKET);
      }
      setState(1231);
      procedure_param();
      setState(1236);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1232);
        match(TSqlParser::COMMA);
        setState(1233);
        procedure_param();
        setState(1238);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1240);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::RR_BRACKET) {
        setState(1239);
        match(TSqlParser::RR_BRACKET);
      }
    }
    setState(1253);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1244);
      match(TSqlParser::WITH);
      setState(1245);
      procedure_option();
      setState(1250);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1246);
        match(TSqlParser::COMMA);
        setState(1247);
        procedure_option();
        setState(1252);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1257);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FOR) {
      setState(1255);
      match(TSqlParser::FOR);
      setState(1256);
      match(TSqlParser::REPLICATION);
    }
    setState(1259);
    match(TSqlParser::AS);

    setState(1263);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1260);
        sql_clauses(); 
      }
      setState(1265);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_functionContext ------------------------------------------------------------------

TSqlParser::Create_or_alter_functionContext::Create_or_alter_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::FUNCTION() {
  return getToken(TSqlParser::FUNCTION, 0);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Create_or_alter_functionContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Func_body_returns_selectContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_select() {
  return getRuleContext<TSqlParser::Func_body_returns_selectContext>(0);
}

TSqlParser::Func_body_returns_tableContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_table() {
  return getRuleContext<TSqlParser::Func_body_returns_tableContext>(0);
}

TSqlParser::Func_body_returns_scalarContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_scalar() {
  return getRuleContext<TSqlParser::Func_body_returns_scalarContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

std::vector<TSqlParser::Procedure_paramContext *> TSqlParser::Create_or_alter_functionContext::procedure_param() {
  return getRuleContexts<TSqlParser::Procedure_paramContext>();
}

TSqlParser::Procedure_paramContext* TSqlParser::Create_or_alter_functionContext::procedure_param(size_t i) {
  return getRuleContext<TSqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::OR() {
  return getToken(TSqlParser::OR, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_or_alter_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Create_or_alter_functionContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_or_alter_function;
}

void TSqlParser::Create_or_alter_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_or_alter_function(this);
}

void TSqlParser::Create_or_alter_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_or_alter_function(this);
}

TSqlParser::Create_or_alter_functionContext* TSqlParser::create_or_alter_function() {
  Create_or_alter_functionContext *_localctx = _tracker.createInstance<Create_or_alter_functionContext>(_ctx, getState());
  enterRule(_localctx, 100, TSqlParser::RuleCreate_or_alter_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1272);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CREATE: {
        setState(1266);
        match(TSqlParser::CREATE);
        setState(1269);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OR) {
          setState(1267);
          match(TSqlParser::OR);
          setState(1268);
          match(TSqlParser::ALTER);
        }
        break;
      }

      case TSqlParser::ALTER: {
        setState(1271);
        match(TSqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1274);
    match(TSqlParser::FUNCTION);
    setState(1275);
    dynamic_cast<Create_or_alter_functionContext *>(_localctx)->funcName = func_proc_name_schema();
    setState(1289);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      setState(1276);
      match(TSqlParser::LR_BRACKET);
      setState(1277);
      procedure_param();
      setState(1282);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1278);
        match(TSqlParser::COMMA);
        setState(1279);
        procedure_param();
        setState(1284);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1285);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1287);
      match(TSqlParser::LR_BRACKET);
      setState(1288);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1294);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
    case 1: {
      setState(1291);
      func_body_returns_select();
      break;
    }

    case 2: {
      setState(1292);
      func_body_returns_table();
      break;
    }

    case 3: {
      setState(1293);
      func_body_returns_scalar();
      break;
    }

    default:
      break;
    }
    setState(1297);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
    case 1: {
      setState(1296);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_selectContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_selectContext::Func_body_returns_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Func_body_returns_selectContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_selectContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_selectContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_selectContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_selectContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_select;
}

void TSqlParser::Func_body_returns_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_select(this);
}

void TSqlParser::Func_body_returns_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_select(this);
}

TSqlParser::Func_body_returns_selectContext* TSqlParser::func_body_returns_select() {
  Func_body_returns_selectContext *_localctx = _tracker.createInstance<Func_body_returns_selectContext>(_ctx, getState());
  enterRule(_localctx, 102, TSqlParser::RuleFunc_body_returns_select);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1299);
    match(TSqlParser::RETURNS);
    setState(1300);
    match(TSqlParser::TABLE);
    setState(1310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1301);
      match(TSqlParser::WITH);
      setState(1302);
      function_option();
      setState(1307);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1303);
        match(TSqlParser::COMMA);
        setState(1304);
        function_option();
        setState(1309);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1313);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1312);
      match(TSqlParser::AS);
    }
    setState(1315);
    match(TSqlParser::RETURN);
    setState(1321);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      setState(1316);
      match(TSqlParser::LR_BRACKET);
      setState(1317);
      select_statement_standalone();
      setState(1318);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1320);
      select_statement_standalone();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_tableContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_tableContext::Func_body_returns_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_type_definitionContext* TSqlParser::Func_body_returns_tableContext::table_type_definition() {
  return getRuleContext<TSqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::END() {
  return getToken(TSqlParser::END, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_tableContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_tableContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Func_body_returns_tableContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Func_body_returns_tableContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_tableContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_tableContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_table;
}

void TSqlParser::Func_body_returns_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_table(this);
}

void TSqlParser::Func_body_returns_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_table(this);
}

TSqlParser::Func_body_returns_tableContext* TSqlParser::func_body_returns_table() {
  Func_body_returns_tableContext *_localctx = _tracker.createInstance<Func_body_returns_tableContext>(_ctx, getState());
  enterRule(_localctx, 104, TSqlParser::RuleFunc_body_returns_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1323);
    match(TSqlParser::RETURNS);
    setState(1324);
    match(TSqlParser::LOCAL_ID);
    setState(1325);
    table_type_definition();
    setState(1335);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1326);
      match(TSqlParser::WITH);
      setState(1327);
      function_option();
      setState(1332);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1328);
        match(TSqlParser::COMMA);
        setState(1329);
        function_option();
        setState(1334);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1338);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1337);
      match(TSqlParser::AS);
    }
    setState(1340);
    match(TSqlParser::BEGIN);
    setState(1344);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1341);
        sql_clauses(); 
      }
      setState(1346);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx);
    }
    setState(1347);
    match(TSqlParser::RETURN);
    setState(1349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1348);
      match(TSqlParser::SEMI);
    }
    setState(1351);
    match(TSqlParser::END);
    setState(1353);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      setState(1352);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_scalarContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_scalarContext::Func_body_returns_scalarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Func_body_returns_scalarContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::END() {
  return getToken(TSqlParser::END, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Func_body_returns_scalarContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_scalarContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_scalarContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Func_body_returns_scalarContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Func_body_returns_scalarContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_scalarContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_scalarContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_scalar;
}

void TSqlParser::Func_body_returns_scalarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_scalar(this);
}

void TSqlParser::Func_body_returns_scalarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_scalar(this);
}

TSqlParser::Func_body_returns_scalarContext* TSqlParser::func_body_returns_scalar() {
  Func_body_returns_scalarContext *_localctx = _tracker.createInstance<Func_body_returns_scalarContext>(_ctx, getState());
  enterRule(_localctx, 106, TSqlParser::RuleFunc_body_returns_scalar);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1355);
    match(TSqlParser::RETURNS);
    setState(1356);
    data_type();
    setState(1366);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1357);
      match(TSqlParser::WITH);
      setState(1358);
      function_option();
      setState(1363);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1359);
        match(TSqlParser::COMMA);
        setState(1360);
        function_option();
        setState(1365);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1369);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1368);
      match(TSqlParser::AS);
    }
    setState(1371);
    match(TSqlParser::BEGIN);
    setState(1375);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1372);
        sql_clauses(); 
      }
      setState(1377);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx);
    }
    setState(1378);
    match(TSqlParser::RETURN);
    setState(1379);
    dynamic_cast<Func_body_returns_scalarContext *>(_localctx)->ret = expression(0);
    setState(1381);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1380);
      match(TSqlParser::SEMI);
    }
    setState(1383);
    match(TSqlParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_paramContext ------------------------------------------------------------------

TSqlParser::Procedure_paramContext::Procedure_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Procedure_paramContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::VARYING() {
  return getToken(TSqlParser::VARYING, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Id_Context* TSqlParser::Procedure_paramContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Default_valueContext* TSqlParser::Procedure_paramContext::default_value() {
  return getRuleContext<TSqlParser::Default_valueContext>(0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::READONLY() {
  return getToken(TSqlParser::READONLY, 0);
}


size_t TSqlParser::Procedure_paramContext::getRuleIndex() const {
  return TSqlParser::RuleProcedure_param;
}

void TSqlParser::Procedure_paramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedure_param(this);
}

void TSqlParser::Procedure_paramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedure_param(this);
}

TSqlParser::Procedure_paramContext* TSqlParser::procedure_param() {
  Procedure_paramContext *_localctx = _tracker.createInstance<Procedure_paramContext>(_ctx, getState());
  enterRule(_localctx, 108, TSqlParser::RuleProcedure_param);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1385);
    match(TSqlParser::LOCAL_ID);
    setState(1387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1386);
      match(TSqlParser::AS);
    }
    setState(1392);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {
    case 1: {
      setState(1389);
      dynamic_cast<Procedure_paramContext *>(_localctx)->type_schema = id_();
      setState(1390);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1394);
    data_type();
    setState(1396);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::VARYING) {
      setState(1395);
      match(TSqlParser::VARYING);
    }
    setState(1400);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::EQUAL) {
      setState(1398);
      match(TSqlParser::EQUAL);
      setState(1399);
      dynamic_cast<Procedure_paramContext *>(_localctx)->default_val = default_value();
    }
    setState(1403);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & ((1ULL << (TSqlParser::OUT - 281))
      | (1ULL << (TSqlParser::OUTPUT - 281))
      | (1ULL << (TSqlParser::READONLY - 281)))) != 0)) {
      setState(1402);
      _la = _input->LA(1);
      if (!(((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & ((1ULL << (TSqlParser::OUT - 281))
        | (1ULL << (TSqlParser::OUTPUT - 281))
        | (1ULL << (TSqlParser::READONLY - 281)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_optionContext ------------------------------------------------------------------

TSqlParser::Procedure_optionContext::Procedure_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Procedure_optionContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Procedure_optionContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

TSqlParser::Execute_clauseContext* TSqlParser::Procedure_optionContext::execute_clause() {
  return getRuleContext<TSqlParser::Execute_clauseContext>(0);
}


size_t TSqlParser::Procedure_optionContext::getRuleIndex() const {
  return TSqlParser::RuleProcedure_option;
}

void TSqlParser::Procedure_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedure_option(this);
}

void TSqlParser::Procedure_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedure_option(this);
}

TSqlParser::Procedure_optionContext* TSqlParser::procedure_option() {
  Procedure_optionContext *_localctx = _tracker.createInstance<Procedure_optionContext>(_ctx, getState());
  enterRule(_localctx, 110, TSqlParser::RuleProcedure_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1408);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(1405);
        match(TSqlParser::ENCRYPTION);
        break;
      }

      case TSqlParser::RECOMPILE: {
        enterOuterAlt(_localctx, 2);
        setState(1406);
        match(TSqlParser::RECOMPILE);
        break;
      }

      case TSqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 3);
        setState(1407);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_optionContext ------------------------------------------------------------------

TSqlParser::Function_optionContext::Function_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Function_optionContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::SCHEMABINDING() {
  return getToken(TSqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Function_optionContext::NULL_() {
  return getTokens(TSqlParser::NULL_);
}

tree::TerminalNode* TSqlParser::Function_optionContext::NULL_(size_t i) {
  return getToken(TSqlParser::NULL_, i);
}

tree::TerminalNode* TSqlParser::Function_optionContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::INPUT() {
  return getToken(TSqlParser::INPUT, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::CALLED() {
  return getToken(TSqlParser::CALLED, 0);
}

TSqlParser::Execute_clauseContext* TSqlParser::Function_optionContext::execute_clause() {
  return getRuleContext<TSqlParser::Execute_clauseContext>(0);
}


size_t TSqlParser::Function_optionContext::getRuleIndex() const {
  return TSqlParser::RuleFunction_option;
}

void TSqlParser::Function_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_option(this);
}

void TSqlParser::Function_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_option(this);
}

TSqlParser::Function_optionContext* TSqlParser::function_option() {
  Function_optionContext *_localctx = _tracker.createInstance<Function_optionContext>(_ctx, getState());
  enterRule(_localctx, 112, TSqlParser::RuleFunction_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1422);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(1410);
        match(TSqlParser::ENCRYPTION);
        break;
      }

      case TSqlParser::SCHEMABINDING: {
        enterOuterAlt(_localctx, 2);
        setState(1411);
        match(TSqlParser::SCHEMABINDING);
        break;
      }

      case TSqlParser::RETURNS: {
        enterOuterAlt(_localctx, 3);
        setState(1412);
        match(TSqlParser::RETURNS);
        setState(1413);
        match(TSqlParser::NULL_);
        setState(1414);
        match(TSqlParser::ON);
        setState(1415);
        match(TSqlParser::NULL_);
        setState(1416);
        match(TSqlParser::INPUT);
        break;
      }

      case TSqlParser::CALLED: {
        enterOuterAlt(_localctx, 4);
        setState(1417);
        match(TSqlParser::CALLED);
        setState(1418);
        match(TSqlParser::ON);
        setState(1419);
        match(TSqlParser::NULL_);
        setState(1420);
        match(TSqlParser::INPUT);
        break;
      }

      case TSqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 5);
        setState(1421);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_tableContext ------------------------------------------------------------------

TSqlParser::Create_tableContext::Create_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_tableContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Create_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Create_tableContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

TSqlParser::Simple_idContext* TSqlParser::Create_tableContext::simple_id() {
  return getRuleContext<TSqlParser::Simple_idContext>(0);
}

std::vector<TSqlParser::Table_optionsContext *> TSqlParser::Create_tableContext::table_options() {
  return getRuleContexts<TSqlParser::Table_optionsContext>();
}

TSqlParser::Table_optionsContext* TSqlParser::Create_tableContext::table_options(size_t i) {
  return getRuleContext<TSqlParser::Table_optionsContext>(i);
}

tree::TerminalNode* TSqlParser::Create_tableContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Create_tableContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Create_tableContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_tableContext::DEFAULT() {
  return getTokens(TSqlParser::DEFAULT);
}

tree::TerminalNode* TSqlParser::Create_tableContext::DEFAULT(size_t i) {
  return getToken(TSqlParser::DEFAULT, i);
}

tree::TerminalNode* TSqlParser::Create_tableContext::TEXTIMAGE_ON() {
  return getToken(TSqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Create_tableContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_table;
}

void TSqlParser::Create_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table(this);
}

void TSqlParser::Create_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table(this);
}

TSqlParser::Create_tableContext* TSqlParser::create_table() {
  Create_tableContext *_localctx = _tracker.createInstance<Create_tableContext>(_ctx, getState());
  enterRule(_localctx, 114, TSqlParser::RuleCreate_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1424);
    match(TSqlParser::CREATE);
    setState(1425);
    match(TSqlParser::TABLE);
    setState(1426);
    table_name();
    setState(1427);
    match(TSqlParser::LR_BRACKET);
    setState(1428);
    column_def_table_constraints();
    setState(1430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(1429);
      match(TSqlParser::COMMA);
    }
    setState(1432);
    match(TSqlParser::RR_BRACKET);
    setState(1435);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      setState(1433);
      match(TSqlParser::LOCK);
      setState(1434);
      simple_id();
      break;
    }

    default:
      break;
    }
    setState(1440);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1437);
        table_options(); 
      }
      setState(1442);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx);
    }
    setState(1446);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      setState(1443);
      match(TSqlParser::ON);
      setState(1444);
      id_();
      break;
    }

    case 2: {
      setState(1445);
      match(TSqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
    setState(1451);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(1448);
      match(TSqlParser::TEXTIMAGE_ON);
      setState(1449);
      id_();
      break;
    }

    case 2: {
      setState(1450);
      match(TSqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
    setState(1454);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
    case 1: {
      setState(1453);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_optionsContext ------------------------------------------------------------------

TSqlParser::Table_optionsContext::Table_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_optionsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Index_optionContext *> TSqlParser::Table_optionsContext::index_option() {
  return getRuleContexts<TSqlParser::Index_optionContext>();
}

TSqlParser::Index_optionContext* TSqlParser::Table_optionsContext::index_option(size_t i) {
  return getRuleContext<TSqlParser::Index_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_optionsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleTable_options;
}

void TSqlParser::Table_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_options(this);
}

void TSqlParser::Table_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_options(this);
}

TSqlParser::Table_optionsContext* TSqlParser::table_options() {
  Table_optionsContext *_localctx = _tracker.createInstance<Table_optionsContext>(_ctx, getState());
  enterRule(_localctx, 116, TSqlParser::RuleTable_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1456);
    match(TSqlParser::WITH);
    setState(1476);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LR_BRACKET: {
        setState(1457);
        match(TSqlParser::LR_BRACKET);
        setState(1458);
        index_option();
        setState(1463);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(1459);
          match(TSqlParser::COMMA);
          setState(1460);
          index_option();
          setState(1465);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1466);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::ID: {
        setState(1468);
        index_option();
        setState(1473);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(1469);
          match(TSqlParser::COMMA);
          setState(1470);
          index_option();
          setState(1475);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_tableContext ------------------------------------------------------------------

TSqlParser::Alter_tableContext::Alter_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::ALTER() {
  return getTokens(TSqlParser::ALTER);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::ALTER(size_t i) {
  return getToken(TSqlParser::ALTER, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::TABLE() {
  return getTokens(TSqlParser::TABLE);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::TABLE(size_t i) {
  return getToken(TSqlParser::TABLE, i);
}

std::vector<TSqlParser::Table_nameContext *> TSqlParser::Alter_tableContext::table_name() {
  return getRuleContexts<TSqlParser::Table_nameContext>();
}

TSqlParser::Table_nameContext* TSqlParser::Alter_tableContext::table_name(size_t i) {
  return getRuleContext<TSqlParser::Table_nameContext>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::LOCK_ESCALATION() {
  return getToken(TSqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::ADD() {
  return getToken(TSqlParser::ADD, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Alter_tableContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::COLUMN() {
  return getToken(TSqlParser::COLUMN, 0);
}

TSqlParser::Column_definitionContext* TSqlParser::Alter_tableContext::column_definition() {
  return getRuleContext<TSqlParser::Column_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Alter_tableContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Alter_tableContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::REBUILD() {
  return getToken(TSqlParser::REBUILD, 0);
}

TSqlParser::Table_optionsContext* TSqlParser::Alter_tableContext::table_options() {
  return getRuleContext<TSqlParser::Table_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::AUTO() {
  return getToken(TSqlParser::AUTO, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::DISABLE() {
  return getToken(TSqlParser::DISABLE, 0);
}

std::vector<TSqlParser::Column_name_listContext *> TSqlParser::Alter_tableContext::column_name_list() {
  return getRuleContexts<TSqlParser::Column_name_listContext>();
}

TSqlParser::Column_name_listContext* TSqlParser::Alter_tableContext::column_name_list(size_t i) {
  return getRuleContext<TSqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Alter_tableContext::getRuleIndex() const {
  return TSqlParser::RuleAlter_table;
}

void TSqlParser::Alter_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table(this);
}

void TSqlParser::Alter_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table(this);
}

TSqlParser::Alter_tableContext* TSqlParser::alter_table() {
  Alter_tableContext *_localctx = _tracker.createInstance<Alter_tableContext>(_ctx, getState());
  enterRule(_localctx, 118, TSqlParser::RuleAlter_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1478);
    match(TSqlParser::ALTER);
    setState(1479);
    match(TSqlParser::TABLE);
    setState(1480);
    table_name();
    setState(1526);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      setState(1481);
      match(TSqlParser::SET);
      setState(1482);
      match(TSqlParser::LR_BRACKET);
      setState(1483);
      match(TSqlParser::LOCK_ESCALATION);
      setState(1484);
      match(TSqlParser::EQUAL);
      setState(1485);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TABLE

      || _la == TSqlParser::AUTO || _la == TSqlParser::DISABLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1486);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1487);
      match(TSqlParser::ADD);
      setState(1488);
      column_def_table_constraints();
      break;
    }

    case 3: {
      setState(1489);
      match(TSqlParser::ALTER);
      setState(1490);
      match(TSqlParser::COLUMN);
      setState(1491);
      column_definition();
      break;
    }

    case 4: {
      setState(1492);
      match(TSqlParser::DROP);
      setState(1493);
      match(TSqlParser::COLUMN);
      setState(1494);
      id_();
      setState(1499);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1495);
        match(TSqlParser::COMMA);
        setState(1496);
        id_();
        setState(1501);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 5: {
      setState(1502);
      match(TSqlParser::DROP);
      setState(1503);
      match(TSqlParser::CONSTRAINT);
      setState(1504);
      dynamic_cast<Alter_tableContext *>(_localctx)->constraint = id_();
      break;
    }

    case 6: {
      setState(1505);
      match(TSqlParser::WITH);
      setState(1506);
      match(TSqlParser::CHECK);
      setState(1507);
      match(TSqlParser::ADD);
      setState(1508);
      match(TSqlParser::CONSTRAINT);
      setState(1509);
      dynamic_cast<Alter_tableContext *>(_localctx)->constraint = id_();
      setState(1510);
      match(TSqlParser::FOREIGN);
      setState(1511);
      match(TSqlParser::KEY);
      setState(1512);
      match(TSqlParser::LR_BRACKET);
      setState(1513);
      dynamic_cast<Alter_tableContext *>(_localctx)->fk = column_name_list();
      setState(1514);
      match(TSqlParser::RR_BRACKET);
      setState(1515);
      match(TSqlParser::REFERENCES);
      setState(1516);
      table_name();
      setState(1517);
      match(TSqlParser::LR_BRACKET);
      setState(1518);
      dynamic_cast<Alter_tableContext *>(_localctx)->pk = column_name_list();
      setState(1519);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 7: {
      setState(1521);
      match(TSqlParser::CHECK);
      setState(1522);
      match(TSqlParser::CONSTRAINT);
      setState(1523);
      dynamic_cast<Alter_tableContext *>(_localctx)->constraint = id_();
      break;
    }

    case 8: {
      setState(1524);
      match(TSqlParser::REBUILD);
      setState(1525);
      table_options();
      break;
    }

    default:
      break;
    }
    setState(1529);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
    case 1: {
      setState(1528);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_optionspecContext ------------------------------------------------------------------

TSqlParser::Database_optionspecContext::Database_optionspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Cursor_optionContext* TSqlParser::Database_optionspecContext::cursor_option() {
  return getRuleContext<TSqlParser::Cursor_optionContext>(0);
}


size_t TSqlParser::Database_optionspecContext::getRuleIndex() const {
  return TSqlParser::RuleDatabase_optionspec;
}

void TSqlParser::Database_optionspecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatabase_optionspec(this);
}

void TSqlParser::Database_optionspecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatabase_optionspec(this);
}

TSqlParser::Database_optionspecContext* TSqlParser::database_optionspec() {
  Database_optionspecContext *_localctx = _tracker.createInstance<Database_optionspecContext>(_ctx, getState());
  enterRule(_localctx, 120, TSqlParser::RuleDatabase_optionspec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1531);
    cursor_option();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_optionContext ------------------------------------------------------------------

TSqlParser::Cursor_optionContext::Cursor_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

TSqlParser::On_offContext* TSqlParser::Cursor_optionContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::CURSOR_DEFAULT() {
  return getToken(TSqlParser::CURSOR_DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Cursor_optionContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_option;
}

void TSqlParser::Cursor_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_option(this);
}

void TSqlParser::Cursor_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_option(this);
}

TSqlParser::Cursor_optionContext* TSqlParser::cursor_option() {
  Cursor_optionContext *_localctx = _tracker.createInstance<Cursor_optionContext>(_ctx, getState());
  enterRule(_localctx, 122, TSqlParser::RuleCursor_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1537);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT: {
        enterOuterAlt(_localctx, 1);
        setState(1533);
        match(TSqlParser::CURSOR_CLOSE_ON_COMMIT);
        setState(1534);
        on_off();
        break;
      }

      case TSqlParser::CURSOR_DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(1535);
        match(TSqlParser::CURSOR_DEFAULT);
        setState(1536);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::GLOBAL

        || _la == TSqlParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_procedureContext ------------------------------------------------------------------

TSqlParser::Drop_procedureContext::Drop_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

std::vector<TSqlParser::Func_proc_name_schemaContext *> TSqlParser::Drop_procedureContext::func_proc_name_schema() {
  return getRuleContexts<TSqlParser::Func_proc_name_schemaContext>();
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Drop_procedureContext::func_proc_name_schema(size_t i) {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::PROC() {
  return getToken(TSqlParser::PROC, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::PROCEDURE() {
  return getToken(TSqlParser::PROCEDURE, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_procedureContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_procedureContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_procedure;
}

void TSqlParser::Drop_procedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_procedure(this);
}

void TSqlParser::Drop_procedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_procedure(this);
}

TSqlParser::Drop_procedureContext* TSqlParser::drop_procedure() {
  Drop_procedureContext *_localctx = _tracker.createInstance<Drop_procedureContext>(_ctx, getState());
  enterRule(_localctx, 124, TSqlParser::RuleDrop_procedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1539);
    match(TSqlParser::DROP);
    setState(1540);
    dynamic_cast<Drop_procedureContext *>(_localctx)->proc = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PROC

    || _la == TSqlParser::PROCEDURE)) {
      dynamic_cast<Drop_procedureContext *>(_localctx)->proc = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1543);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(1541);
      match(TSqlParser::IF);
      setState(1542);
      match(TSqlParser::EXISTS);
    }
    setState(1545);
    func_proc_name_schema();
    setState(1550);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1546);
      match(TSqlParser::COMMA);
      setState(1547);
      func_proc_name_schema();
      setState(1552);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1554);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
    case 1: {
      setState(1553);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_functionContext ------------------------------------------------------------------

TSqlParser::Drop_functionContext::Drop_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_functionContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::FUNCTION() {
  return getToken(TSqlParser::FUNCTION, 0);
}

std::vector<TSqlParser::Func_proc_name_schemaContext *> TSqlParser::Drop_functionContext::func_proc_name_schema() {
  return getRuleContexts<TSqlParser::Func_proc_name_schemaContext>();
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Drop_functionContext::func_proc_name_schema(size_t i) {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_functionContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_function;
}

void TSqlParser::Drop_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_function(this);
}

void TSqlParser::Drop_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_function(this);
}

TSqlParser::Drop_functionContext* TSqlParser::drop_function() {
  Drop_functionContext *_localctx = _tracker.createInstance<Drop_functionContext>(_ctx, getState());
  enterRule(_localctx, 126, TSqlParser::RuleDrop_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1556);
    match(TSqlParser::DROP);
    setState(1557);
    match(TSqlParser::FUNCTION);
    setState(1560);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(1558);
      match(TSqlParser::IF);
      setState(1559);
      match(TSqlParser::EXISTS);
    }
    setState(1562);
    func_proc_name_schema();
    setState(1567);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1563);
      match(TSqlParser::COMMA);
      setState(1564);
      func_proc_name_schema();
      setState(1569);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1571);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
    case 1: {
      setState(1570);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_tableContext ------------------------------------------------------------------

TSqlParser::Drop_tableContext::Drop_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_tableContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Drop_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_tableContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_table;
}

void TSqlParser::Drop_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_table(this);
}

void TSqlParser::Drop_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_table(this);
}

TSqlParser::Drop_tableContext* TSqlParser::drop_table() {
  Drop_tableContext *_localctx = _tracker.createInstance<Drop_tableContext>(_ctx, getState());
  enterRule(_localctx, 128, TSqlParser::RuleDrop_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1573);
    match(TSqlParser::DROP);
    setState(1574);
    match(TSqlParser::TABLE);
    setState(1577);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(1575);
      match(TSqlParser::IF);
      setState(1576);
      match(TSqlParser::EXISTS);
    }
    setState(1579);
    table_name();
    setState(1581);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
    case 1: {
      setState(1580);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_statementContext ------------------------------------------------------------------

TSqlParser::Declare_statementContext::Declare_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_statementContext::DECLARE() {
  return getToken(TSqlParser::DECLARE, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_type_definitionContext* TSqlParser::Declare_statementContext::table_type_definition() {
  return getRuleContext<TSqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<TSqlParser::Declare_localContext *> TSqlParser::Declare_statementContext::declare_local() {
  return getRuleContexts<TSqlParser::Declare_localContext>();
}

TSqlParser::Declare_localContext* TSqlParser::Declare_statementContext::declare_local(size_t i) {
  return getRuleContext<TSqlParser::Declare_localContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Declare_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Declare_statementContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_statement;
}

void TSqlParser::Declare_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_statement(this);
}

void TSqlParser::Declare_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_statement(this);
}

TSqlParser::Declare_statementContext* TSqlParser::declare_statement() {
  Declare_statementContext *_localctx = _tracker.createInstance<Declare_statementContext>(_ctx, getState());
  enterRule(_localctx, 130, TSqlParser::RuleDeclare_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1604);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1583);
      match(TSqlParser::DECLARE);
      setState(1584);
      match(TSqlParser::LOCAL_ID);
      setState(1586);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AS) {
        setState(1585);
        match(TSqlParser::AS);
      }
      setState(1588);
      table_type_definition();
      setState(1590);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx)) {
      case 1: {
        setState(1589);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1592);
      match(TSqlParser::DECLARE);
      setState(1593);
      dynamic_cast<Declare_statementContext *>(_localctx)->declare_localContext = declare_local();
      dynamic_cast<Declare_statementContext *>(_localctx)->loc.push_back(dynamic_cast<Declare_statementContext *>(_localctx)->declare_localContext);
      setState(1598);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1594);
        match(TSqlParser::COMMA);
        setState(1595);
        dynamic_cast<Declare_statementContext *>(_localctx)->declare_localContext = declare_local();
        dynamic_cast<Declare_statementContext *>(_localctx)->loc.push_back(dynamic_cast<Declare_statementContext *>(_localctx)->declare_localContext);
        setState(1600);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1602);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
      case 1: {
        setState(1601);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_statementContext ------------------------------------------------------------------

TSqlParser::Cursor_statementContext::Cursor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::CLOSE() {
  return getToken(TSqlParser::CLOSE, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Cursor_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::DEALLOCATE() {
  return getToken(TSqlParser::DEALLOCATE, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

TSqlParser::Declare_cursorContext* TSqlParser::Cursor_statementContext::declare_cursor() {
  return getRuleContext<TSqlParser::Declare_cursorContext>(0);
}

TSqlParser::Fetch_cursorContext* TSqlParser::Cursor_statementContext::fetch_cursor() {
  return getRuleContext<TSqlParser::Fetch_cursorContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::OPEN() {
  return getToken(TSqlParser::OPEN, 0);
}


size_t TSqlParser::Cursor_statementContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_statement;
}

void TSqlParser::Cursor_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_statement(this);
}

void TSqlParser::Cursor_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_statement(this);
}

TSqlParser::Cursor_statementContext* TSqlParser::cursor_statement() {
  Cursor_statementContext *_localctx = _tracker.createInstance<Cursor_statementContext>(_ctx, getState());
  enterRule(_localctx, 132, TSqlParser::RuleCursor_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1635);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CLOSE: {
        enterOuterAlt(_localctx, 1);
        setState(1606);
        match(TSqlParser::CLOSE);
        setState(1608);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
        case 1: {
          setState(1607);
          match(TSqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1610);
        cursor_name();
        setState(1612);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
        case 1: {
          setState(1611);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::DEALLOCATE: {
        enterOuterAlt(_localctx, 2);
        setState(1614);
        match(TSqlParser::DEALLOCATE);
        setState(1616);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
        case 1: {
          setState(1615);
          match(TSqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1619);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CURSOR) {
          setState(1618);
          match(TSqlParser::CURSOR);
        }
        setState(1621);
        cursor_name();
        setState(1623);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
        case 1: {
          setState(1622);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::DECLARE: {
        enterOuterAlt(_localctx, 3);
        setState(1625);
        declare_cursor();
        break;
      }

      case TSqlParser::FETCH: {
        enterOuterAlt(_localctx, 4);
        setState(1626);
        fetch_cursor();
        break;
      }

      case TSqlParser::OPEN: {
        enterOuterAlt(_localctx, 5);
        setState(1627);
        match(TSqlParser::OPEN);
        setState(1629);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
        case 1: {
          setState(1628);
          match(TSqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1631);
        cursor_name();
        setState(1633);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx)) {
        case 1: {
          setState(1632);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_statementContext ------------------------------------------------------------------

TSqlParser::Kill_statementContext::Kill_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_statementContext::KILL() {
  return getToken(TSqlParser::KILL, 0);
}

TSqlParser::Kill_processContext* TSqlParser::Kill_statementContext::kill_process() {
  return getRuleContext<TSqlParser::Kill_processContext>(0);
}

TSqlParser::Kill_query_notificationContext* TSqlParser::Kill_statementContext::kill_query_notification() {
  return getRuleContext<TSqlParser::Kill_query_notificationContext>(0);
}


size_t TSqlParser::Kill_statementContext::getRuleIndex() const {
  return TSqlParser::RuleKill_statement;
}

void TSqlParser::Kill_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_statement(this);
}

void TSqlParser::Kill_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_statement(this);
}

TSqlParser::Kill_statementContext* TSqlParser::kill_statement() {
  Kill_statementContext *_localctx = _tracker.createInstance<Kill_statementContext>(_ctx, getState());
  enterRule(_localctx, 134, TSqlParser::RuleKill_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1637);
    match(TSqlParser::KILL);
    setState(1640);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UOW:
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING: {
        setState(1638);
        kill_process();
        break;
      }

      case TSqlParser::QUERY: {
        setState(1639);
        kill_query_notification();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_processContext ------------------------------------------------------------------

TSqlParser::Kill_processContext::Kill_processContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_processContext::UOW() {
  return getToken(TSqlParser::UOW, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::STATUSONLY() {
  return getToken(TSqlParser::STATUSONLY, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Kill_processContext::getRuleIndex() const {
  return TSqlParser::RuleKill_process;
}

void TSqlParser::Kill_processContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_process(this);
}

void TSqlParser::Kill_processContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_process(this);
}

TSqlParser::Kill_processContext* TSqlParser::kill_process() {
  Kill_processContext *_localctx = _tracker.createInstance<Kill_processContext>(_ctx, getState());
  enterRule(_localctx, 136, TSqlParser::RuleKill_process);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1644);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING: {
        setState(1642);
        dynamic_cast<Kill_processContext *>(_localctx)->session_id = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DECIMAL

        || _la == TSqlParser::STRING)) {
          dynamic_cast<Kill_processContext *>(_localctx)->session_id = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::UOW: {
        setState(1643);
        match(TSqlParser::UOW);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1648);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
    case 1: {
      setState(1646);
      match(TSqlParser::WITH);
      setState(1647);
      match(TSqlParser::STATUSONLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_query_notificationContext ------------------------------------------------------------------

TSqlParser::Kill_query_notificationContext::Kill_query_notificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::QUERY() {
  return getToken(TSqlParser::QUERY, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::NOTIFICATION() {
  return getToken(TSqlParser::NOTIFICATION, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::SUBSCRIPTION() {
  return getToken(TSqlParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Kill_query_notificationContext::getRuleIndex() const {
  return TSqlParser::RuleKill_query_notification;
}

void TSqlParser::Kill_query_notificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_query_notification(this);
}

void TSqlParser::Kill_query_notificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_query_notification(this);
}

TSqlParser::Kill_query_notificationContext* TSqlParser::kill_query_notification() {
  Kill_query_notificationContext *_localctx = _tracker.createInstance<Kill_query_notificationContext>(_ctx, getState());
  enterRule(_localctx, 138, TSqlParser::RuleKill_query_notification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1650);
    match(TSqlParser::QUERY);
    setState(1651);
    match(TSqlParser::NOTIFICATION);
    setState(1652);
    match(TSqlParser::SUBSCRIPTION);
    setState(1655);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ALL: {
        setState(1653);
        match(TSqlParser::ALL);
        break;
      }

      case TSqlParser::DECIMAL: {
        setState(1654);
        dynamic_cast<Kill_query_notificationContext *>(_localctx)->subscription_id = match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statementContext ------------------------------------------------------------------

TSqlParser::Execute_statementContext::Execute_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_statementContext::EXECUTE() {
  return getToken(TSqlParser::EXECUTE, 0);
}

TSqlParser::Execute_bodyContext* TSqlParser::Execute_statementContext::execute_body() {
  return getRuleContext<TSqlParser::Execute_bodyContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Execute_statementContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement;
}

void TSqlParser::Execute_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement(this);
}

void TSqlParser::Execute_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement(this);
}

TSqlParser::Execute_statementContext* TSqlParser::execute_statement() {
  Execute_statementContext *_localctx = _tracker.createInstance<Execute_statementContext>(_ctx, getState());
  enterRule(_localctx, 140, TSqlParser::RuleExecute_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1657);
    match(TSqlParser::EXECUTE);
    setState(1658);
    execute_body();
    setState(1660);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
    case 1: {
      setState(1659);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_body_batchContext ------------------------------------------------------------------

TSqlParser::Execute_body_batchContext::Execute_body_batchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Execute_body_batchContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

std::vector<TSqlParser::Execute_statement_argContext *> TSqlParser::Execute_body_batchContext::execute_statement_arg() {
  return getRuleContexts<TSqlParser::Execute_statement_argContext>();
}

TSqlParser::Execute_statement_argContext* TSqlParser::Execute_body_batchContext::execute_statement_arg(size_t i) {
  return getRuleContext<TSqlParser::Execute_statement_argContext>(i);
}

tree::TerminalNode* TSqlParser::Execute_body_batchContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_body_batchContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Execute_body_batchContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Execute_body_batchContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_body_batch;
}

void TSqlParser::Execute_body_batchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_body_batch(this);
}

void TSqlParser::Execute_body_batchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_body_batch(this);
}

TSqlParser::Execute_body_batchContext* TSqlParser::execute_body_batch() {
  Execute_body_batchContext *_localctx = _tracker.createInstance<Execute_body_batchContext>(_ctx, getState());
  enterRule(_localctx, 142, TSqlParser::RuleExecute_body_batch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1662);
    func_proc_name_server_database_schema();
    setState(1671);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
    case 1: {
      setState(1663);
      execute_statement_arg();
      setState(1668);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1664);
        match(TSqlParser::COMMA);
        setState(1665);
        execute_statement_arg();
        setState(1670);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(1674);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx)) {
    case 1: {
      setState(1673);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_bodyContext ------------------------------------------------------------------

TSqlParser::Execute_bodyContext::Execute_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Execute_bodyContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

std::vector<TSqlParser::Execute_var_stringContext *> TSqlParser::Execute_bodyContext::execute_var_string() {
  return getRuleContexts<TSqlParser::Execute_var_stringContext>();
}

TSqlParser::Execute_var_stringContext* TSqlParser::Execute_bodyContext::execute_var_string(size_t i) {
  return getRuleContext<TSqlParser::Execute_var_stringContext>(i);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Execute_statement_argContext* TSqlParser::Execute_bodyContext::execute_statement_arg() {
  return getRuleContext<TSqlParser::Execute_statement_argContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_bodyContext::PLUS() {
  return getTokens(TSqlParser::PLUS);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::PLUS(size_t i) {
  return getToken(TSqlParser::PLUS, i);
}


size_t TSqlParser::Execute_bodyContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_body;
}

void TSqlParser::Execute_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_body(this);
}

void TSqlParser::Execute_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_body(this);
}

TSqlParser::Execute_bodyContext* TSqlParser::execute_body() {
  Execute_bodyContext *_localctx = _tracker.createInstance<Execute_bodyContext>(_ctx, getState());
  enterRule(_localctx, 144, TSqlParser::RuleExecute_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1698);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::LOCAL_ID:
      case TSqlParser::ID:
      case TSqlParser::STRING:
      case TSqlParser::DOT: {
        enterOuterAlt(_localctx, 1);
        setState(1678);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
        case 1: {
          setState(1676);
          dynamic_cast<Execute_bodyContext *>(_localctx)->return_status = match(TSqlParser::LOCAL_ID);
          setState(1677);
          match(TSqlParser::EQUAL);
          break;
        }

        default:
          break;
        }
        setState(1682);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CHAR:
          case TSqlParser::NCHAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::PRECISION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID:
          case TSqlParser::DOT: {
            setState(1680);
            func_proc_name_server_database_schema();
            break;
          }

          case TSqlParser::LOCAL_ID:
          case TSqlParser::STRING: {
            setState(1681);
            execute_var_string();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1685);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
        case 1: {
          setState(1684);
          execute_statement_arg();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(1687);
        match(TSqlParser::LR_BRACKET);
        setState(1688);
        execute_var_string();
        setState(1693);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::PLUS) {
          setState(1689);
          match(TSqlParser::PLUS);
          setState(1690);
          execute_var_string();
          setState(1695);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1696);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_argContext ------------------------------------------------------------------

TSqlParser::Execute_statement_argContext::Execute_statement_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Execute_statement_arg_unnamedContext* TSqlParser::Execute_statement_argContext::execute_statement_arg_unnamed() {
  return getRuleContext<TSqlParser::Execute_statement_arg_unnamedContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_statement_argContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<TSqlParser::Execute_statement_argContext *> TSqlParser::Execute_statement_argContext::execute_statement_arg() {
  return getRuleContexts<TSqlParser::Execute_statement_argContext>();
}

TSqlParser::Execute_statement_argContext* TSqlParser::Execute_statement_argContext::execute_statement_arg(size_t i) {
  return getRuleContext<TSqlParser::Execute_statement_argContext>(i);
}

std::vector<TSqlParser::Execute_statement_arg_namedContext *> TSqlParser::Execute_statement_argContext::execute_statement_arg_named() {
  return getRuleContexts<TSqlParser::Execute_statement_arg_namedContext>();
}

TSqlParser::Execute_statement_arg_namedContext* TSqlParser::Execute_statement_argContext::execute_statement_arg_named(size_t i) {
  return getRuleContext<TSqlParser::Execute_statement_arg_namedContext>(i);
}


size_t TSqlParser::Execute_statement_argContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement_arg;
}

void TSqlParser::Execute_statement_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement_arg(this);
}

void TSqlParser::Execute_statement_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement_arg(this);
}

TSqlParser::Execute_statement_argContext* TSqlParser::execute_statement_arg() {
  Execute_statement_argContext *_localctx = _tracker.createInstance<Execute_statement_argContext>(_ctx, getState());
  enterRule(_localctx, 146, TSqlParser::RuleExecute_statement_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1716);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1700);
      execute_statement_arg_unnamed();
      setState(1705);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1701);
          match(TSqlParser::COMMA);
          setState(1702);
          execute_statement_arg(); 
        }
        setState(1707);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1708);
      execute_statement_arg_named();
      setState(1713);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1709);
          match(TSqlParser::COMMA);
          setState(1710);
          execute_statement_arg_named(); 
        }
        setState(1715);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_arg_namedContext ------------------------------------------------------------------

TSqlParser::Execute_statement_arg_namedContext::Execute_statement_arg_namedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_statement_arg_namedContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Execute_statement_arg_namedContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Execute_parameterContext* TSqlParser::Execute_statement_arg_namedContext::execute_parameter() {
  return getRuleContext<TSqlParser::Execute_parameterContext>(0);
}


size_t TSqlParser::Execute_statement_arg_namedContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement_arg_named;
}

void TSqlParser::Execute_statement_arg_namedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement_arg_named(this);
}

void TSqlParser::Execute_statement_arg_namedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement_arg_named(this);
}

TSqlParser::Execute_statement_arg_namedContext* TSqlParser::execute_statement_arg_named() {
  Execute_statement_arg_namedContext *_localctx = _tracker.createInstance<Execute_statement_arg_namedContext>(_ctx, getState());
  enterRule(_localctx, 148, TSqlParser::RuleExecute_statement_arg_named);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1718);
    dynamic_cast<Execute_statement_arg_namedContext *>(_localctx)->name = match(TSqlParser::LOCAL_ID);
    setState(1719);
    match(TSqlParser::EQUAL);
    setState(1720);
    dynamic_cast<Execute_statement_arg_namedContext *>(_localctx)->value = execute_parameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_arg_unnamedContext ------------------------------------------------------------------

TSqlParser::Execute_statement_arg_unnamedContext::Execute_statement_arg_unnamedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Execute_parameterContext* TSqlParser::Execute_statement_arg_unnamedContext::execute_parameter() {
  return getRuleContext<TSqlParser::Execute_parameterContext>(0);
}


size_t TSqlParser::Execute_statement_arg_unnamedContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement_arg_unnamed;
}

void TSqlParser::Execute_statement_arg_unnamedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement_arg_unnamed(this);
}

void TSqlParser::Execute_statement_arg_unnamedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement_arg_unnamed(this);
}

TSqlParser::Execute_statement_arg_unnamedContext* TSqlParser::execute_statement_arg_unnamed() {
  Execute_statement_arg_unnamedContext *_localctx = _tracker.createInstance<Execute_statement_arg_unnamedContext>(_ctx, getState());
  enterRule(_localctx, 150, TSqlParser::RuleExecute_statement_arg_unnamed);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1722);
    dynamic_cast<Execute_statement_arg_unnamedContext *>(_localctx)->value = execute_parameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_parameterContext ------------------------------------------------------------------

TSqlParser::Execute_parameterContext::Execute_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ConstantContext* TSqlParser::Execute_parameterContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Id_Context* TSqlParser::Execute_parameterContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}


size_t TSqlParser::Execute_parameterContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_parameter;
}

void TSqlParser::Execute_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_parameter(this);
}

void TSqlParser::Execute_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_parameter(this);
}

TSqlParser::Execute_parameterContext* TSqlParser::execute_parameter() {
  Execute_parameterContext *_localctx = _tracker.createInstance<Execute_parameterContext>(_ctx, getState());
  enterRule(_localctx, 152, TSqlParser::RuleExecute_parameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1732);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        setState(1724);
        constant();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        setState(1725);
        match(TSqlParser::LOCAL_ID);
        setState(1727);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
        case 1: {
          setState(1726);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::OUT

          || _la == TSqlParser::OUTPUT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(1729);
        id_();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(1730);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::NULL_: {
        setState(1731);
        match(TSqlParser::NULL_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_var_stringContext ------------------------------------------------------------------

TSqlParser::Execute_var_stringContext::Execute_var_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_var_stringContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Execute_var_stringContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Execute_var_stringContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_var_string;
}

void TSqlParser::Execute_var_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_var_string(this);
}

void TSqlParser::Execute_var_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_var_string(this);
}

TSqlParser::Execute_var_stringContext* TSqlParser::execute_var_string() {
  Execute_var_stringContext *_localctx = _tracker.createInstance<Execute_var_stringContext>(_ctx, getState());
  enterRule(_localctx, 154, TSqlParser::RuleExecute_var_string);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1734);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlgorithmContext ------------------------------------------------------------------

TSqlParser::AlgorithmContext::AlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::AlgorithmContext::DES() {
  return getToken(TSqlParser::DES, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::TRIPLE_DES() {
  return getToken(TSqlParser::TRIPLE_DES, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::TRIPLE_DES_3KEY() {
  return getToken(TSqlParser::TRIPLE_DES_3KEY, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::RC2() {
  return getToken(TSqlParser::RC2, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::RC4() {
  return getToken(TSqlParser::RC4, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::RC4_128() {
  return getToken(TSqlParser::RC4_128, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::DESX() {
  return getToken(TSqlParser::DESX, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::AES_128() {
  return getToken(TSqlParser::AES_128, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::AES_192() {
  return getToken(TSqlParser::AES_192, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::AES_256() {
  return getToken(TSqlParser::AES_256, 0);
}


size_t TSqlParser::AlgorithmContext::getRuleIndex() const {
  return TSqlParser::RuleAlgorithm;
}

void TSqlParser::AlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlgorithm(this);
}

void TSqlParser::AlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlgorithm(this);
}

TSqlParser::AlgorithmContext* TSqlParser::algorithm() {
  AlgorithmContext *_localctx = _tracker.createInstance<AlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 156, TSqlParser::RuleAlgorithm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1736);
    _la = _input->LA(1);
    if (!(((((_la - 169) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 169)) & ((1ULL << (TSqlParser::AES_128 - 169))
      | (1ULL << (TSqlParser::AES_192 - 169))
      | (1ULL << (TSqlParser::AES_256 - 169))
      | (1ULL << (TSqlParser::DES - 169))
      | (1ULL << (TSqlParser::DESX - 169)))) != 0) || ((((_la - 296) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 296)) & ((1ULL << (TSqlParser::RC2 - 296))
      | (1ULL << (TSqlParser::RC4 - 296))
      | (1ULL << (TSqlParser::RC4_128 - 296))
      | (1ULL << (TSqlParser::TRIPLE_DES - 296))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 296)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_statementContext ------------------------------------------------------------------

TSqlParser::Set_statementContext::Set_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Set_statementContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Set_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Id_Context* TSqlParser::Set_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Set_statementContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::Set_statementContext::declare_set_cursor_common() {
  return getRuleContext<TSqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Set_statementContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

TSqlParser::Set_specialContext* TSqlParser::Set_statementContext::set_special() {
  return getRuleContext<TSqlParser::Set_specialContext>(0);
}


size_t TSqlParser::Set_statementContext::getRuleIndex() const {
  return TSqlParser::RuleSet_statement;
}

void TSqlParser::Set_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_statement(this);
}

void TSqlParser::Set_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_statement(this);
}

TSqlParser::Set_statementContext* TSqlParser::set_statement() {
  Set_statementContext *_localctx = _tracker.createInstance<Set_statementContext>(_ctx, getState());
  enterRule(_localctx, 158, TSqlParser::RuleSet_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1777);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1738);
      match(TSqlParser::SET);
      setState(1739);
      match(TSqlParser::LOCAL_ID);
      setState(1742);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DOT) {
        setState(1740);
        match(TSqlParser::DOT);
        setState(1741);
        dynamic_cast<Set_statementContext *>(_localctx)->member_name = id_();
      }
      setState(1744);
      match(TSqlParser::EQUAL);
      setState(1745);
      expression(0);
      setState(1747);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
      case 1: {
        setState(1746);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1749);
      match(TSqlParser::SET);
      setState(1750);
      match(TSqlParser::LOCAL_ID);
      setState(1751);
      assignment_operator();
      setState(1752);
      expression(0);
      setState(1754);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
      case 1: {
        setState(1753);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1756);
      match(TSqlParser::SET);
      setState(1757);
      match(TSqlParser::LOCAL_ID);
      setState(1758);
      match(TSqlParser::EQUAL);
      setState(1759);
      match(TSqlParser::CURSOR);
      setState(1760);
      declare_set_cursor_common();
      setState(1771);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::FOR) {
        setState(1761);
        match(TSqlParser::FOR);
        setState(1769);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::READ: {
            setState(1762);
            match(TSqlParser::READ);
            setState(1763);
            match(TSqlParser::ONLY);
            break;
          }

          case TSqlParser::UPDATE: {
            setState(1764);
            match(TSqlParser::UPDATE);
            setState(1767);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == TSqlParser::OF) {
              setState(1765);
              match(TSqlParser::OF);
              setState(1766);
              column_name_list();
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(1774);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        setState(1773);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1776);
      set_special();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_statementContext ------------------------------------------------------------------

TSqlParser::Transaction_statementContext::Transaction_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::DISTRIBUTED() {
  return getToken(TSqlParser::DISTRIBUTED, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::TRAN() {
  return getToken(TSqlParser::TRAN, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::TRANSACTION() {
  return getToken(TSqlParser::TRANSACTION, 0);
}

TSqlParser::Id_Context* TSqlParser::Transaction_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::MARK() {
  return getToken(TSqlParser::MARK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::COMMIT() {
  return getToken(TSqlParser::COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::DELAYED_DURABILITY() {
  return getToken(TSqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::WORK() {
  return getToken(TSqlParser::WORK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::ROLLBACK() {
  return getToken(TSqlParser::ROLLBACK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::SAVE() {
  return getToken(TSqlParser::SAVE, 0);
}


size_t TSqlParser::Transaction_statementContext::getRuleIndex() const {
  return TSqlParser::RuleTransaction_statement;
}

void TSqlParser::Transaction_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_statement(this);
}

void TSqlParser::Transaction_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_statement(this);
}

TSqlParser::Transaction_statementContext* TSqlParser::transaction_statement() {
  Transaction_statementContext *_localctx = _tracker.createInstance<Transaction_statementContext>(_ctx, getState());
  enterRule(_localctx, 160, TSqlParser::RuleTransaction_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1860);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1779);
      match(TSqlParser::BEGIN);
      setState(1780);
      match(TSqlParser::DISTRIBUTED);
      setState(1781);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1784);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
      case 1: {
        setState(1782);
        id_();
        break;
      }

      case 2: {
        setState(1783);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1787);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
      case 1: {
        setState(1786);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1789);
      match(TSqlParser::BEGIN);
      setState(1790);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1800);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
      case 1: {
        setState(1793);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CHAR:
          case TSqlParser::NCHAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::PRECISION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(1791);
            id_();
            break;
          }

          case TSqlParser::LOCAL_ID: {
            setState(1792);
            match(TSqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1798);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, _ctx)) {
        case 1: {
          setState(1795);
          match(TSqlParser::WITH);
          setState(1796);
          match(TSqlParser::MARK);
          setState(1797);
          match(TSqlParser::STRING);
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(1803);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
      case 1: {
        setState(1802);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1805);
      match(TSqlParser::COMMIT);
      setState(1806);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1819);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
      case 1: {
        setState(1809);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CHAR:
          case TSqlParser::NCHAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::PRECISION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(1807);
            id_();
            break;
          }

          case TSqlParser::LOCAL_ID: {
            setState(1808);
            match(TSqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1817);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
        case 1: {
          setState(1811);
          match(TSqlParser::WITH);
          setState(1812);
          match(TSqlParser::LR_BRACKET);
          setState(1813);
          match(TSqlParser::DELAYED_DURABILITY);
          setState(1814);
          match(TSqlParser::EQUAL);
          setState(1815);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::OFF

          || _la == TSqlParser::ON)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1816);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(1822);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
      case 1: {
        setState(1821);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1824);
      match(TSqlParser::COMMIT);
      setState(1826);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
      case 1: {
        setState(1825);
        match(TSqlParser::WORK);
        break;
      }

      default:
        break;
      }
      setState(1829);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
      case 1: {
        setState(1828);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1831);
      match(TSqlParser::COMMIT);
      setState(1832);
      id_();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1833);
      match(TSqlParser::ROLLBACK);
      setState(1834);
      id_();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1835);
      match(TSqlParser::ROLLBACK);
      setState(1836);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1839);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
      case 1: {
        setState(1837);
        id_();
        break;
      }

      case 2: {
        setState(1838);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1842);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
      case 1: {
        setState(1841);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1844);
      match(TSqlParser::ROLLBACK);
      setState(1846);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx)) {
      case 1: {
        setState(1845);
        match(TSqlParser::WORK);
        break;
      }

      default:
        break;
      }
      setState(1849);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
      case 1: {
        setState(1848);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1851);
      match(TSqlParser::SAVE);
      setState(1852);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1855);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
      case 1: {
        setState(1853);
        id_();
        break;
      }

      case 2: {
        setState(1854);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1858);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
      case 1: {
        setState(1857);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Go_batch_statementContext ------------------------------------------------------------------

TSqlParser::Go_batch_statementContext::Go_batch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Go_batch_statementContext::GO_BATCH() {
  return getToken(TSqlParser::GO_BATCH, 0);
}

tree::TerminalNode* TSqlParser::Go_batch_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Go_batch_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGo_batch_statement;
}

void TSqlParser::Go_batch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGo_batch_statement(this);
}

void TSqlParser::Go_batch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGo_batch_statement(this);
}

TSqlParser::Go_batch_statementContext* TSqlParser::go_batch_statement() {
  Go_batch_statementContext *_localctx = _tracker.createInstance<Go_batch_statementContext>(_ctx, getState());
  enterRule(_localctx, 162, TSqlParser::RuleGo_batch_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1862);
    match(TSqlParser::GO_BATCH);
    setState(1864);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::DECIMAL) {
      setState(1863);
      dynamic_cast<Go_batch_statementContext *>(_localctx)->count = match(TSqlParser::DECIMAL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Go_statementContext ------------------------------------------------------------------

TSqlParser::Go_statementContext::Go_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Go_statementContext::GO() {
  return getToken(TSqlParser::GO, 0);
}

tree::TerminalNode* TSqlParser::Go_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Go_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGo_statement;
}

void TSqlParser::Go_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGo_statement(this);
}

void TSqlParser::Go_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGo_statement(this);
}

TSqlParser::Go_statementContext* TSqlParser::go_statement() {
  Go_statementContext *_localctx = _tracker.createInstance<Go_statementContext>(_ctx, getState());
  enterRule(_localctx, 164, TSqlParser::RuleGo_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1866);
    match(TSqlParser::GO);
    setState(1868);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::DECIMAL) {
      setState(1867);
      dynamic_cast<Go_statementContext *>(_localctx)->count = match(TSqlParser::DECIMAL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_statementContext ------------------------------------------------------------------

TSqlParser::Use_statementContext::Use_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Use_statementContext::USE() {
  return getToken(TSqlParser::USE, 0);
}

TSqlParser::Id_Context* TSqlParser::Use_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Use_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Use_statementContext::getRuleIndex() const {
  return TSqlParser::RuleUse_statement;
}

void TSqlParser::Use_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse_statement(this);
}

void TSqlParser::Use_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse_statement(this);
}

TSqlParser::Use_statementContext* TSqlParser::use_statement() {
  Use_statementContext *_localctx = _tracker.createInstance<Use_statementContext>(_ctx, getState());
  enterRule(_localctx, 166, TSqlParser::RuleUse_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1870);
    match(TSqlParser::USE);
    setState(1871);
    dynamic_cast<Use_statementContext *>(_localctx)->database = id_();
    setState(1873);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      setState(1872);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Shutdown_statementContext ------------------------------------------------------------------

TSqlParser::Shutdown_statementContext::Shutdown_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::SHUTDOWN() {
  return getToken(TSqlParser::SHUTDOWN, 0);
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}


size_t TSqlParser::Shutdown_statementContext::getRuleIndex() const {
  return TSqlParser::RuleShutdown_statement;
}

void TSqlParser::Shutdown_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShutdown_statement(this);
}

void TSqlParser::Shutdown_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShutdown_statement(this);
}

TSqlParser::Shutdown_statementContext* TSqlParser::shutdown_statement() {
  Shutdown_statementContext *_localctx = _tracker.createInstance<Shutdown_statementContext>(_ctx, getState());
  enterRule(_localctx, 168, TSqlParser::RuleShutdown_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1875);
    match(TSqlParser::SHUTDOWN);
    setState(1878);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      setState(1876);
      match(TSqlParser::WITH);
      setState(1877);
      match(TSqlParser::NOWAIT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_specialContext ------------------------------------------------------------------

TSqlParser::Dbcc_specialContext::Dbcc_specialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::DBCC() {
  return getToken(TSqlParser::DBCC, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::SHRINKLOG() {
  return getToken(TSqlParser::SHRINKLOG, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::SIZE() {
  return getToken(TSqlParser::SIZE, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Dbcc_specialContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

TSqlParser::Id_Context* TSqlParser::Dbcc_specialContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}


size_t TSqlParser::Dbcc_specialContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_special;
}

void TSqlParser::Dbcc_specialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_special(this);
}

void TSqlParser::Dbcc_specialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_special(this);
}

TSqlParser::Dbcc_specialContext* TSqlParser::dbcc_special() {
  Dbcc_specialContext *_localctx = _tracker.createInstance<Dbcc_specialContext>(_ctx, getState());
  enterRule(_localctx, 170, TSqlParser::RuleDbcc_special);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1880);
    match(TSqlParser::DBCC);
    setState(1881);
    match(TSqlParser::SHRINKLOG);
    setState(1891);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      setState(1882);
      match(TSqlParser::LR_BRACKET);
      setState(1883);
      match(TSqlParser::SIZE);
      setState(1884);
      match(TSqlParser::EQUAL);
      setState(1888);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
      case 1: {
        setState(1885);
        constant_expression();
        break;
      }

      case 2: {
        setState(1886);
        id_();
        break;
      }

      case 3: {
        setState(1887);
        match(TSqlParser::DEFAULT);
        break;
      }

      default:
        break;
      }
      setState(1890);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1894);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
    case 1: {
      setState(1893);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_clauseContext ------------------------------------------------------------------

TSqlParser::Dbcc_clauseContext::Dbcc_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::DBCC() {
  return getToken(TSqlParser::DBCC, 0);
}

TSqlParser::Dbcc_commandContext* TSqlParser::Dbcc_clauseContext::dbcc_command() {
  return getRuleContext<TSqlParser::Dbcc_commandContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Dbcc_clauseContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

TSqlParser::Dbcc_optionsContext* TSqlParser::Dbcc_clauseContext::dbcc_options() {
  return getRuleContext<TSqlParser::Dbcc_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Dbcc_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_clause;
}

void TSqlParser::Dbcc_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_clause(this);
}

void TSqlParser::Dbcc_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_clause(this);
}

TSqlParser::Dbcc_clauseContext* TSqlParser::dbcc_clause() {
  Dbcc_clauseContext *_localctx = _tracker.createInstance<Dbcc_clauseContext>(_ctx, getState());
  enterRule(_localctx, 172, TSqlParser::RuleDbcc_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1896);
    match(TSqlParser::DBCC);
    setState(1897);
    dynamic_cast<Dbcc_clauseContext *>(_localctx)->name = dbcc_command();
    setState(1902);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
    case 1: {
      setState(1898);
      match(TSqlParser::LR_BRACKET);
      setState(1899);
      expression_list();
      setState(1900);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1906);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
    case 1: {
      setState(1904);
      match(TSqlParser::WITH);
      setState(1905);
      dbcc_options();
      break;
    }

    default:
      break;
    }
    setState(1909);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
    case 1: {
      setState(1908);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_commandContext ------------------------------------------------------------------

TSqlParser::Dbcc_commandContext::Dbcc_commandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Simple_idContext* TSqlParser::Dbcc_commandContext::simple_id() {
  return getRuleContext<TSqlParser::Simple_idContext>(0);
}

TSqlParser::KeywordContext* TSqlParser::Dbcc_commandContext::keyword() {
  return getRuleContext<TSqlParser::KeywordContext>(0);
}


size_t TSqlParser::Dbcc_commandContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_command;
}

void TSqlParser::Dbcc_commandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_command(this);
}

void TSqlParser::Dbcc_commandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_command(this);
}

TSqlParser::Dbcc_commandContext* TSqlParser::dbcc_command() {
  Dbcc_commandContext *_localctx = _tracker.createInstance<Dbcc_commandContext>(_ctx, getState());
  enterRule(_localctx, 174, TSqlParser::RuleDbcc_command);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1913);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1911);
        simple_id();
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        enterOuterAlt(_localctx, 2);
        setState(1912);
        keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_optionsContext ------------------------------------------------------------------

TSqlParser::Dbcc_optionsContext::Dbcc_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Simple_idContext *> TSqlParser::Dbcc_optionsContext::simple_id() {
  return getRuleContexts<TSqlParser::Simple_idContext>();
}

TSqlParser::Simple_idContext* TSqlParser::Dbcc_optionsContext::simple_id(size_t i) {
  return getRuleContext<TSqlParser::Simple_idContext>(i);
}

tree::TerminalNode* TSqlParser::Dbcc_optionsContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}


size_t TSqlParser::Dbcc_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_options;
}

void TSqlParser::Dbcc_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_options(this);
}

void TSqlParser::Dbcc_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_options(this);
}

TSqlParser::Dbcc_optionsContext* TSqlParser::dbcc_options() {
  Dbcc_optionsContext *_localctx = _tracker.createInstance<Dbcc_optionsContext>(_ctx, getState());
  enterRule(_localctx, 176, TSqlParser::RuleDbcc_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1915);
    simple_id();
    setState(1918);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(1916);
      match(TSqlParser::COMMA);
      setState(1917);
      simple_id();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_clauseContext ------------------------------------------------------------------

TSqlParser::Execute_clauseContext::Execute_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::EXECUTE() {
  return getToken(TSqlParser::EXECUTE, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::CALLER() {
  return getToken(TSqlParser::CALLER, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::SELF() {
  return getToken(TSqlParser::SELF, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::OWNER() {
  return getToken(TSqlParser::OWNER, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Execute_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_clause;
}

void TSqlParser::Execute_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_clause(this);
}

void TSqlParser::Execute_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_clause(this);
}

TSqlParser::Execute_clauseContext* TSqlParser::execute_clause() {
  Execute_clauseContext *_localctx = _tracker.createInstance<Execute_clauseContext>(_ctx, getState());
  enterRule(_localctx, 178, TSqlParser::RuleExecute_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1920);
    match(TSqlParser::EXECUTE);
    setState(1921);
    match(TSqlParser::AS);
    setState(1922);
    dynamic_cast<Execute_clauseContext *>(_localctx)->clause = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::CALLER || _la == TSqlParser::OWNER

    || _la == TSqlParser::SELF || _la == TSqlParser::STRING)) {
      dynamic_cast<Execute_clauseContext *>(_localctx)->clause = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_localContext ------------------------------------------------------------------

TSqlParser::Declare_localContext::Declare_localContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_localContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Declare_localContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_localContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Declare_localContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Declare_localContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Declare_localContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_local;
}

void TSqlParser::Declare_localContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_local(this);
}

void TSqlParser::Declare_localContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_local(this);
}

TSqlParser::Declare_localContext* TSqlParser::declare_local() {
  Declare_localContext *_localctx = _tracker.createInstance<Declare_localContext>(_ctx, getState());
  enterRule(_localctx, 180, TSqlParser::RuleDeclare_local);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1924);
    match(TSqlParser::LOCAL_ID);
    setState(1926);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1925);
      match(TSqlParser::AS);
    }
    setState(1928);
    data_type();
    setState(1931);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::EQUAL) {
      setState(1929);
      match(TSqlParser::EQUAL);
      setState(1930);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_type_definitionContext ------------------------------------------------------------------

TSqlParser::Table_type_definitionContext::Table_type_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Table_type_definitionContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_type_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleTable_type_definition;
}

void TSqlParser::Table_type_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_type_definition(this);
}

void TSqlParser::Table_type_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_type_definition(this);
}

TSqlParser::Table_type_definitionContext* TSqlParser::table_type_definition() {
  Table_type_definitionContext *_localctx = _tracker.createInstance<Table_type_definitionContext>(_ctx, getState());
  enterRule(_localctx, 182, TSqlParser::RuleTable_type_definition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1933);
    match(TSqlParser::TABLE);
    setState(1934);
    match(TSqlParser::LR_BRACKET);
    setState(1935);
    column_def_table_constraints();
    setState(1936);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintsContext ------------------------------------------------------------------

TSqlParser::Column_def_table_constraintsContext::Column_def_table_constraintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Column_def_table_constraintContext *> TSqlParser::Column_def_table_constraintsContext::column_def_table_constraint() {
  return getRuleContexts<TSqlParser::Column_def_table_constraintContext>();
}

TSqlParser::Column_def_table_constraintContext* TSqlParser::Column_def_table_constraintsContext::column_def_table_constraint(size_t i) {
  return getRuleContext<TSqlParser::Column_def_table_constraintContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_def_table_constraintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_def_table_constraintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_def_table_constraintsContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_def_table_constraints;
}

void TSqlParser::Column_def_table_constraintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def_table_constraints(this);
}

void TSqlParser::Column_def_table_constraintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def_table_constraints(this);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::column_def_table_constraints() {
  Column_def_table_constraintsContext *_localctx = _tracker.createInstance<Column_def_table_constraintsContext>(_ctx, getState());
  enterRule(_localctx, 184, TSqlParser::RuleColumn_def_table_constraints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1938);
    column_def_table_constraint();
    setState(1945);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1940);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(1939);
          match(TSqlParser::COMMA);
        }
        setState(1942);
        column_def_table_constraint(); 
      }
      setState(1947);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintContext ------------------------------------------------------------------

TSqlParser::Column_def_table_constraintContext::Column_def_table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_definitionContext* TSqlParser::Column_def_table_constraintContext::column_definition() {
  return getRuleContext<TSqlParser::Column_definitionContext>(0);
}

TSqlParser::Table_constraintContext* TSqlParser::Column_def_table_constraintContext::table_constraint() {
  return getRuleContext<TSqlParser::Table_constraintContext>(0);
}


size_t TSqlParser::Column_def_table_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_def_table_constraint;
}

void TSqlParser::Column_def_table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def_table_constraint(this);
}

void TSqlParser::Column_def_table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def_table_constraint(this);
}

TSqlParser::Column_def_table_constraintContext* TSqlParser::column_def_table_constraint() {
  Column_def_table_constraintContext *_localctx = _tracker.createInstance<Column_def_table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 186, TSqlParser::RuleColumn_def_table_constraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1950);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1948);
        column_definition();
        break;
      }

      case TSqlParser::CHECK:
      case TSqlParser::CONSTRAINT:
      case TSqlParser::DEFAULT:
      case TSqlParser::FOREIGN:
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        enterOuterAlt(_localctx, 2);
        setState(1949);
        table_constraint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_definitionContext ------------------------------------------------------------------

TSqlParser::Column_definitionContext::Column_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Column_definitionContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Column_definitionContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Data_typeContext* TSqlParser::Column_definitionContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Column_definitionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::Null_notnullContext* TSqlParser::Column_definitionContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

std::vector<TSqlParser::Null_or_defaultContext *> TSqlParser::Column_definitionContext::null_or_default() {
  return getRuleContexts<TSqlParser::Null_or_defaultContext>();
}

TSqlParser::Null_or_defaultContext* TSqlParser::Column_definitionContext::null_or_default(size_t i) {
  return getRuleContext<TSqlParser::Null_or_defaultContext>(i);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::ROWGUIDCOL() {
  return getToken(TSqlParser::ROWGUIDCOL, 0);
}

std::vector<TSqlParser::Column_constraintContext *> TSqlParser::Column_definitionContext::column_constraint() {
  return getRuleContexts<TSqlParser::Column_constraintContext>();
}

TSqlParser::Column_constraintContext* TSqlParser::Column_definitionContext::column_constraint(size_t i) {
  return getRuleContext<TSqlParser::Column_constraintContext>(i);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::PERSISTED() {
  return getToken(TSqlParser::PERSISTED, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_definitionContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}


size_t TSqlParser::Column_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_definition;
}

void TSqlParser::Column_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_definition(this);
}

void TSqlParser::Column_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_definition(this);
}

TSqlParser::Column_definitionContext* TSqlParser::column_definition() {
  Column_definitionContext *_localctx = _tracker.createInstance<Column_definitionContext>(_ctx, getState());
  enterRule(_localctx, 188, TSqlParser::RuleColumn_definition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1952);
    id_();
    setState(1959);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::DOUBLE:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(1953);
        data_type();
        break;
      }

      case TSqlParser::AS: {
        setState(1954);
        match(TSqlParser::AS);
        setState(1955);
        expression(0);
        setState(1957);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
        case 1: {
          setState(1956);
          match(TSqlParser::PERSISTED);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1963);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COLLATE) {
      setState(1961);
      match(TSqlParser::COLLATE);
      setState(1962);
      id_();
    }
    setState(1966);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
    case 1: {
      setState(1965);
      null_notnull();
      break;
    }

    default:
      break;
    }
    setState(1989);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      setState(1970);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::CONSTRAINT) {
        setState(1968);
        match(TSqlParser::CONSTRAINT);
        setState(1969);
        dynamic_cast<Column_definitionContext *>(_localctx)->constraint = id_();
      }
      setState(1972);
      null_or_default();
      setState(1974);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
      case 1: {
        setState(1973);
        null_or_default();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(1976);
      match(TSqlParser::IDENTITY);
      setState(1982);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
      case 1: {
        setState(1977);
        match(TSqlParser::LR_BRACKET);
        setState(1978);
        dynamic_cast<Column_definitionContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
        setState(1979);
        match(TSqlParser::COMMA);
        setState(1980);
        dynamic_cast<Column_definitionContext *>(_localctx)->increment = match(TSqlParser::DECIMAL);
        setState(1981);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      setState(1987);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
      case 1: {
        setState(1984);
        match(TSqlParser::NOT);
        setState(1985);
        match(TSqlParser::FOR);
        setState(1986);
        match(TSqlParser::REPLICATION);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(1992);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ROWGUIDCOL) {
      setState(1991);
      match(TSqlParser::ROWGUIDCOL);
    }
    setState(1997);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1994);
        column_constraint(); 
      }
      setState(1999);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_constraintContext ------------------------------------------------------------------

TSqlParser::Column_constraintContext::Column_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_constraintContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Column_constraintContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Column_constraintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::Null_notnullContext* TSqlParser::Column_constraintContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Column_constraintContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

TSqlParser::Id_Context* TSqlParser::Column_constraintContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::PRIMARY() {
  return getToken(TSqlParser::PRIMARY, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::UNIQUE() {
  return getToken(TSqlParser::UNIQUE, 0);
}

TSqlParser::Index_optionsContext* TSqlParser::Column_constraintContext::index_options() {
  return getRuleContext<TSqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}


size_t TSqlParser::Column_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_constraint;
}

void TSqlParser::Column_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_constraint(this);
}

void TSqlParser::Column_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_constraint(this);
}

TSqlParser::Column_constraintContext* TSqlParser::column_constraint() {
  Column_constraintContext *_localctx = _tracker.createInstance<Column_constraintContext>(_ctx, getState());
  enterRule(_localctx, 190, TSqlParser::RuleColumn_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2002);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONSTRAINT) {
      setState(2000);
      match(TSqlParser::CONSTRAINT);
      setState(2001);
      dynamic_cast<Column_constraintContext *>(_localctx)->constraint = id_();
    }
    setState(2033);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        setState(2007);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::PRIMARY: {
            setState(2004);
            match(TSqlParser::PRIMARY);
            setState(2005);
            match(TSqlParser::KEY);
            break;
          }

          case TSqlParser::UNIQUE: {
            setState(2006);
            match(TSqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2010);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
        case 1: {
          setState(2009);
          index_options();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHECK: {
        setState(2012);
        match(TSqlParser::CHECK);
        setState(2016);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::NOT) {
          setState(2013);
          match(TSqlParser::NOT);
          setState(2014);
          match(TSqlParser::FOR);
          setState(2015);
          match(TSqlParser::REPLICATION);
        }
        setState(2018);
        match(TSqlParser::LR_BRACKET);
        setState(2019);
        search_condition(0);
        setState(2020);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::FOREIGN:
      case TSqlParser::REFERENCES: {
        setState(2024);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::FOREIGN) {
          setState(2022);
          match(TSqlParser::FOREIGN);
          setState(2023);
          match(TSqlParser::KEY);
        }
        setState(2026);
        match(TSqlParser::REFERENCES);
        setState(2027);
        table_name();
        setState(2028);
        match(TSqlParser::LR_BRACKET);
        setState(2029);
        dynamic_cast<Column_constraintContext *>(_localctx)->pk = column_name_list();
        setState(2030);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::NOT:
      case TSqlParser::NULL_: {
        setState(2032);
        null_notnull();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

TSqlParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::Column_name_list_with_orderContext* TSqlParser::Table_constraintContext::column_name_list_with_order() {
  return getRuleContext<TSqlParser::Column_name_list_with_orderContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Table_constraintContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Table_constraintContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Table_constraintContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Table_constraintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

std::vector<TSqlParser::Column_name_listContext *> TSqlParser::Table_constraintContext::column_name_list() {
  return getRuleContexts<TSqlParser::Column_name_listContext>();
}

TSqlParser::Column_name_listContext* TSqlParser::Table_constraintContext::column_name_list(size_t i) {
  return getRuleContext<TSqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::PRIMARY() {
  return getToken(TSqlParser::PRIMARY, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::UNIQUE() {
  return getToken(TSqlParser::UNIQUE, 0);
}

TSqlParser::Index_optionsContext* TSqlParser::Table_constraintContext::index_options() {
  return getRuleContext<TSqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::PLUS() {
  return getTokens(TSqlParser::PLUS);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::PLUS(size_t i) {
  return getToken(TSqlParser::PLUS, i);
}

std::vector<TSqlParser::Function_callContext *> TSqlParser::Table_constraintContext::function_call() {
  return getRuleContexts<TSqlParser::Function_callContext>();
}

TSqlParser::Function_callContext* TSqlParser::Table_constraintContext::function_call(size_t i) {
  return getRuleContext<TSqlParser::Function_callContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}


size_t TSqlParser::Table_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_constraint;
}

void TSqlParser::Table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_constraint(this);
}

void TSqlParser::Table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_constraint(this);
}

TSqlParser::Table_constraintContext* TSqlParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 192, TSqlParser::RuleTable_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2037);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONSTRAINT) {
      setState(2035);
      match(TSqlParser::CONSTRAINT);
      setState(2036);
      dynamic_cast<Table_constraintContext *>(_localctx)->constraint = id_();
    }
    setState(2094);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        setState(2042);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::PRIMARY: {
            setState(2039);
            match(TSqlParser::PRIMARY);
            setState(2040);
            match(TSqlParser::KEY);
            break;
          }

          case TSqlParser::UNIQUE: {
            setState(2041);
            match(TSqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2044);
        match(TSqlParser::LR_BRACKET);
        setState(2045);
        column_name_list_with_order();
        setState(2046);
        match(TSqlParser::RR_BRACKET);
        setState(2048);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
        case 1: {
          setState(2047);
          index_options();
          break;
        }

        default:
          break;
        }
        setState(2052);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ON) {
          setState(2050);
          match(TSqlParser::ON);
          setState(2051);
          id_();
        }
        break;
      }

      case TSqlParser::CHECK: {
        setState(2054);
        match(TSqlParser::CHECK);
        setState(2058);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::NOT) {
          setState(2055);
          match(TSqlParser::NOT);
          setState(2056);
          match(TSqlParser::FOR);
          setState(2057);
          match(TSqlParser::REPLICATION);
        }
        setState(2060);
        match(TSqlParser::LR_BRACKET);
        setState(2061);
        search_condition(0);
        setState(2062);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(2064);
        match(TSqlParser::DEFAULT);
        setState(2066);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::LR_BRACKET) {
          setState(2065);
          match(TSqlParser::LR_BRACKET);
        }
        setState(2072); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2072);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case TSqlParser::STRING: {
              setState(2068);
              match(TSqlParser::STRING);
              break;
            }

            case TSqlParser::PLUS: {
              setState(2069);
              match(TSqlParser::PLUS);
              break;
            }

            case TSqlParser::ABS:
            case TSqlParser::ASCII:
            case TSqlParser::CEILING:
            case TSqlParser::CHAR:
            case TSqlParser::CHARINDEX:
            case TSqlParser::DATALENGTH:
            case TSqlParser::DAY:
            case TSqlParser::FLOOR:
            case TSqlParser::ISDATE:
            case TSqlParser::ISNUMERIC:
            case TSqlParser::LEN:
            case TSqlParser::LOWER:
            case TSqlParser::LTRIM:
            case TSqlParser::MONTH:
            case TSqlParser::NCHAR:
            case TSqlParser::PATINDEX:
            case TSqlParser::RAND:
            case TSqlParser::REPLACE:
            case TSqlParser::ROUND:
            case TSqlParser::RTRIM:
            case TSqlParser::SIGN:
            case TSqlParser::STR:
            case TSqlParser::SUBSTRING:
            case TSqlParser::UPPER:
            case TSqlParser::USER_NAME:
            case TSqlParser::YEAR:
            case TSqlParser::TEXT:
            case TSqlParser::NTEXT:
            case TSqlParser::COALESCE:
            case TSqlParser::CONVERT:
            case TSqlParser::CURRENT_TIMESTAMP:
            case TSqlParser::CURRENT_USER:
            case TSqlParser::IDENTITY:
            case TSqlParser::LEFT:
            case TSqlParser::NULLIF:
            case TSqlParser::PRECISION:
            case TSqlParser::RIGHT:
            case TSqlParser::SESSION_USER:
            case TSqlParser::SYSTEM_USER:
            case TSqlParser::USER:
            case TSqlParser::DOLLAR_PARTITION:
            case TSqlParser::ABSOLUTE:
            case TSqlParser::AT_KEYWORD:
            case TSqlParser::ACTION:
            case TSqlParser::AES_128:
            case TSqlParser::AES_192:
            case TSqlParser::AES_256:
            case TSqlParser::ALGORITHM:
            case TSqlParser::ANSI_NULLS:
            case TSqlParser::ANSI_PADDING:
            case TSqlParser::ANSI_WARNINGS:
            case TSqlParser::APPLY:
            case TSqlParser::ARITHABORT:
            case TSqlParser::AUTO:
            case TSqlParser::AVG:
            case TSqlParser::BIGINT:
            case TSqlParser::BINARY_KEYWORD:
            case TSqlParser::BINARY_BASE64:
            case TSqlParser::BINARY_CHECKSUM:
            case TSqlParser::CALLER:
            case TSqlParser::CAST:
            case TSqlParser::TRY_CAST:
            case TSqlParser::CATCH:
            case TSqlParser::CHECKSUM:
            case TSqlParser::CHECKSUM_AGG:
            case TSqlParser::COMMITTED:
            case TSqlParser::CONCAT:
            case TSqlParser::CONCAT_NULL_YIELDS_NULL:
            case TSqlParser::COUNT:
            case TSqlParser::COUNT_BIG:
            case TSqlParser::CUME_DIST:
            case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
            case TSqlParser::CURSOR_DEFAULT:
            case TSqlParser::DATA:
            case TSqlParser::DATEADD:
            case TSqlParser::DATEDIFF:
            case TSqlParser::DATENAME:
            case TSqlParser::DATEPART:
            case TSqlParser::DAYS:
            case TSqlParser::DEFAULT_DOUBLE_QUOTE:
            case TSqlParser::DELAY:
            case TSqlParser::DELAYED_DURABILITY:
            case TSqlParser::DELETED:
            case TSqlParser::DENSE_RANK:
            case TSqlParser::DES:
            case TSqlParser::DESCRIPTION:
            case TSqlParser::DESX:
            case TSqlParser::DISABLE:
            case TSqlParser::DYNAMIC:
            case TSqlParser::ELEMENTS:
            case TSqlParser::EMPTY:
            case TSqlParser::ENCRYPTION:
            case TSqlParser::EXCLUSIVE:
            case TSqlParser::FAST:
            case TSqlParser::FAST_FORWARD:
            case TSqlParser::FIRST:
            case TSqlParser::FIRST_VALUE:
            case TSqlParser::FOLLOWING:
            case TSqlParser::FORCE:
            case TSqlParser::FORCED:
            case TSqlParser::FORWARD_ONLY:
            case TSqlParser::GETDATE:
            case TSqlParser::GETUTCDATE:
            case TSqlParser::GLOBAL:
            case TSqlParser::GO_BATCH:
            case TSqlParser::GO:
            case TSqlParser::GROUPING:
            case TSqlParser::GROUPING_ID:
            case TSqlParser::HASH:
            case TSqlParser::HIGH:
            case TSqlParser::HOURS:
            case TSqlParser::IDENTITY_VALUE:
            case TSqlParser::INCLUDE_NULL_VALUES:
            case TSqlParser::INPUT:
            case TSqlParser::INSENSITIVE:
            case TSqlParser::INSERTED:
            case TSqlParser::INT:
            case TSqlParser::ISOLATION:
            case TSqlParser::KEEP:
            case TSqlParser::KEEPFIXED:
            case TSqlParser::KEYSET:
            case TSqlParser::LAG:
            case TSqlParser::LAST:
            case TSqlParser::LAST_VALUE:
            case TSqlParser::LEAD:
            case TSqlParser::LEVEL:
            case TSqlParser::LOCAL:
            case TSqlParser::LOCATION:
            case TSqlParser::LOCK:
            case TSqlParser::LOCK_ESCALATION:
            case TSqlParser::LOOP:
            case TSqlParser::LOW:
            case TSqlParser::MANUAL:
            case TSqlParser::MARK:
            case TSqlParser::MAX:
            case TSqlParser::MAXDOP:
            case TSqlParser::MAXRECURSION:
            case TSqlParser::MIN:
            case TSqlParser::MIN_ACTIVE_ROWVERSION:
            case TSqlParser::MINUTES:
            case TSqlParser::MODE:
            case TSqlParser::NEXT:
            case TSqlParser::NO:
            case TSqlParser::NOCOUNT:
            case TSqlParser::NODES:
            case TSqlParser::NOEXPAND:
            case TSqlParser::NOWAIT:
            case TSqlParser::NTILE:
            case TSqlParser::NUMANODE:
            case TSqlParser::NUMERIC_ROUNDABORT:
            case TSqlParser::OBJECT:
            case TSqlParser::OFFSET:
            case TSqlParser::ONLINE:
            case TSqlParser::ONLY:
            case TSqlParser::OPTIMISTIC:
            case TSqlParser::OPTIMIZE:
            case TSqlParser::OUT:
            case TSqlParser::OUTPUT:
            case TSqlParser::OWNER:
            case TSqlParser::PARAMETERIZATION:
            case TSqlParser::PARTITION:
            case TSqlParser::PARTITIONS:
            case TSqlParser::PERCENT_RANK:
            case TSqlParser::PERCENTILE_CONT:
            case TSqlParser::PERCENTILE_DISC:
            case TSqlParser::PRECEDING:
            case TSqlParser::PRIOR:
            case TSqlParser::QUERY:
            case TSqlParser::QUOTED_IDENTIFIER:
            case TSqlParser::RANGE:
            case TSqlParser::RANK:
            case TSqlParser::RC2:
            case TSqlParser::RC4:
            case TSqlParser::RC4_128:
            case TSqlParser::READ_ONLY:
            case TSqlParser::READONLY:
            case TSqlParser::REBUILD:
            case TSqlParser::RECOMPILE:
            case TSqlParser::RELATIVE:
            case TSqlParser::REMOTE:
            case TSqlParser::REPEATABLE:
            case TSqlParser::ROBUST:
            case TSqlParser::ROW:
            case TSqlParser::ROW_NUMBER:
            case TSqlParser::ROWGUID:
            case TSqlParser::ROWS:
            case TSqlParser::SCHEMABINDING:
            case TSqlParser::SCROLL:
            case TSqlParser::SCROLL_LOCKS:
            case TSqlParser::SECONDS:
            case TSqlParser::SELF:
            case TSqlParser::SEMI_SENSITIVE:
            case TSqlParser::SEQUENCE:
            case TSqlParser::SERIALIZABLE:
            case TSqlParser::SETERROR:
            case TSqlParser::SHARE:
            case TSqlParser::SIMPLE:
            case TSqlParser::SIZE:
            case TSqlParser::SMALLINT:
            case TSqlParser::SNAPSHOT:
            case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
            case TSqlParser::STATIC:
            case TSqlParser::STATUSONLY:
            case TSqlParser::STDEV:
            case TSqlParser::STDEVP:
            case TSqlParser::STRING_AGG:
            case TSqlParser::STUFF:
            case TSqlParser::SUBSCRIPTION:
            case TSqlParser::SUM:
            case TSqlParser::TEXTIMAGE_ON:
            case TSqlParser::THROW:
            case TSqlParser::TIES:
            case TSqlParser::TIME:
            case TSqlParser::TIMEOUT:
            case TSqlParser::TINYINT:
            case TSqlParser::TRIPLE_DES:
            case TSqlParser::TRIPLE_DES_3KEY:
            case TSqlParser::TRY:
            case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
            case TSqlParser::TYPE:
            case TSqlParser::TYPE_WARNING:
            case TSqlParser::UNBOUNDED:
            case TSqlParser::UNCOMMITTED:
            case TSqlParser::UNKNOWN:
            case TSqlParser::UOW:
            case TSqlParser::USING:
            case TSqlParser::VAR:
            case TSqlParser::VARBINARY_KEYWORD:
            case TSqlParser::VARP:
            case TSqlParser::WAIT:
            case TSqlParser::WORK:
            case TSqlParser::ZONE:
            case TSqlParser::BLOCKING_HIERARCHY:
            case TSqlParser::CACHE:
            case TSqlParser::CALLED:
            case TSqlParser::CHANGETABLE:
            case TSqlParser::CHANGES:
            case TSqlParser::CYCLE:
            case TSqlParser::DATA_COMPRESSION:
            case TSqlParser::ERROR:
            case TSqlParser::FORCESEEK:
            case TSqlParser::IIF:
            case TSqlParser::INCREMENT:
            case TSqlParser::ISNULL:
            case TSqlParser::LOG:
            case TSqlParser::MATCHED:
            case TSqlParser::MAXVALUE:
            case TSqlParser::MINVALUE:
            case TSqlParser::NOTIFICATION:
            case TSqlParser::PERSISTED:
            case TSqlParser::PREDICATE:
            case TSqlParser::RESTART:
            case TSqlParser::RETURNS:
            case TSqlParser::SOURCE:
            case TSqlParser::STATE:
            case TSqlParser::START:
            case TSqlParser::TARGET:
            case TSqlParser::VARCHAR:
            case TSqlParser::NVARCHAR:
            case TSqlParser::SPACE:
            case TSqlParser::DOUBLE_QUOTE_ID:
            case TSqlParser::SQUARE_BRACKET_ID:
            case TSqlParser::ID:
            case TSqlParser::DOT: {
              setState(2070);
              function_call();
              break;
            }

            case TSqlParser::DECIMAL: {
              setState(2071);
              match(TSqlParser::DECIMAL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(2074); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << TSqlParser::ABS)
          | (1ULL << TSqlParser::ASCII)
          | (1ULL << TSqlParser::CEILING)
          | (1ULL << TSqlParser::CHAR)
          | (1ULL << TSqlParser::CHARINDEX)
          | (1ULL << TSqlParser::DATALENGTH)
          | (1ULL << TSqlParser::DAY)
          | (1ULL << TSqlParser::FLOOR)
          | (1ULL << TSqlParser::ISDATE)
          | (1ULL << TSqlParser::ISNUMERIC)
          | (1ULL << TSqlParser::LEN)
          | (1ULL << TSqlParser::LOWER)
          | (1ULL << TSqlParser::LTRIM)
          | (1ULL << TSqlParser::MONTH)
          | (1ULL << TSqlParser::NCHAR)
          | (1ULL << TSqlParser::PATINDEX)
          | (1ULL << TSqlParser::RAND)
          | (1ULL << TSqlParser::REPLACE)
          | (1ULL << TSqlParser::ROUND)
          | (1ULL << TSqlParser::RTRIM)
          | (1ULL << TSqlParser::SIGN)
          | (1ULL << TSqlParser::STR)
          | (1ULL << TSqlParser::SUBSTRING)
          | (1ULL << TSqlParser::UPPER)
          | (1ULL << TSqlParser::USER_NAME)
          | (1ULL << TSqlParser::YEAR)
          | (1ULL << TSqlParser::TEXT)
          | (1ULL << TSqlParser::NTEXT)
          | (1ULL << TSqlParser::COALESCE)
          | (1ULL << TSqlParser::CONVERT)
          | (1ULL << TSqlParser::CURRENT_TIMESTAMP)
          | (1ULL << TSqlParser::CURRENT_USER))) != 0) || ((((_la - 91) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 91)) & ((1ULL << (TSqlParser::IDENTITY - 91))
          | (1ULL << (TSqlParser::LEFT - 91))
          | (1ULL << (TSqlParser::NULLIF - 91))
          | (1ULL << (TSqlParser::PRECISION - 91))
          | (1ULL << (TSqlParser::RIGHT - 91))
          | (1ULL << (TSqlParser::SESSION_USER - 91))
          | (1ULL << (TSqlParser::SYSTEM_USER - 91)))) != 0) || ((((_la - 157) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 157)) & ((1ULL << (TSqlParser::USER - 157))
          | (1ULL << (TSqlParser::DOLLAR_PARTITION - 157))
          | (1ULL << (TSqlParser::ABSOLUTE - 157))
          | (1ULL << (TSqlParser::AT_KEYWORD - 157))
          | (1ULL << (TSqlParser::ACTION - 157))
          | (1ULL << (TSqlParser::AES_128 - 157))
          | (1ULL << (TSqlParser::AES_192 - 157))
          | (1ULL << (TSqlParser::AES_256 - 157))
          | (1ULL << (TSqlParser::ALGORITHM - 157))
          | (1ULL << (TSqlParser::ANSI_NULLS - 157))
          | (1ULL << (TSqlParser::ANSI_PADDING - 157))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 157))
          | (1ULL << (TSqlParser::APPLY - 157))
          | (1ULL << (TSqlParser::ARITHABORT - 157))
          | (1ULL << (TSqlParser::AUTO - 157))
          | (1ULL << (TSqlParser::AVG - 157))
          | (1ULL << (TSqlParser::BIGINT - 157))
          | (1ULL << (TSqlParser::BINARY_KEYWORD - 157))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 157))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 157))
          | (1ULL << (TSqlParser::CALLER - 157))
          | (1ULL << (TSqlParser::CAST - 157))
          | (1ULL << (TSqlParser::TRY_CAST - 157))
          | (1ULL << (TSqlParser::CATCH - 157))
          | (1ULL << (TSqlParser::CHECKSUM - 157))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 157))
          | (1ULL << (TSqlParser::COMMITTED - 157))
          | (1ULL << (TSqlParser::CONCAT - 157))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 157))
          | (1ULL << (TSqlParser::COUNT - 157))
          | (1ULL << (TSqlParser::COUNT_BIG - 157))
          | (1ULL << (TSqlParser::CUME_DIST - 157))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 157))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 157))
          | (1ULL << (TSqlParser::DATA - 157))
          | (1ULL << (TSqlParser::DATEADD - 157))
          | (1ULL << (TSqlParser::DATEDIFF - 157))
          | (1ULL << (TSqlParser::DATENAME - 157))
          | (1ULL << (TSqlParser::DATEPART - 157))
          | (1ULL << (TSqlParser::DAYS - 157))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 157))
          | (1ULL << (TSqlParser::DELAY - 157))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 157))
          | (1ULL << (TSqlParser::DELETED - 157))
          | (1ULL << (TSqlParser::DENSE_RANK - 157))
          | (1ULL << (TSqlParser::DES - 157))
          | (1ULL << (TSqlParser::DESCRIPTION - 157))
          | (1ULL << (TSqlParser::DESX - 157))
          | (1ULL << (TSqlParser::DISABLE - 157))
          | (1ULL << (TSqlParser::DYNAMIC - 157))
          | (1ULL << (TSqlParser::ELEMENTS - 157))
          | (1ULL << (TSqlParser::EMPTY - 157))
          | (1ULL << (TSqlParser::ENCRYPTION - 157))
          | (1ULL << (TSqlParser::EXCLUSIVE - 157))
          | (1ULL << (TSqlParser::FAST - 157))
          | (1ULL << (TSqlParser::FAST_FORWARD - 157))
          | (1ULL << (TSqlParser::FIRST - 157)))) != 0) || ((((_la - 221) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 221)) & ((1ULL << (TSqlParser::FIRST_VALUE - 221))
          | (1ULL << (TSqlParser::FOLLOWING - 221))
          | (1ULL << (TSqlParser::FORCE - 221))
          | (1ULL << (TSqlParser::FORCED - 221))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 221))
          | (1ULL << (TSqlParser::GETDATE - 221))
          | (1ULL << (TSqlParser::GETUTCDATE - 221))
          | (1ULL << (TSqlParser::GLOBAL - 221))
          | (1ULL << (TSqlParser::GO_BATCH - 221))
          | (1ULL << (TSqlParser::GO - 221))
          | (1ULL << (TSqlParser::GROUPING - 221))
          | (1ULL << (TSqlParser::GROUPING_ID - 221))
          | (1ULL << (TSqlParser::HASH - 221))
          | (1ULL << (TSqlParser::HIGH - 221))
          | (1ULL << (TSqlParser::HOURS - 221))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 221))
          | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 221))
          | (1ULL << (TSqlParser::INPUT - 221))
          | (1ULL << (TSqlParser::INSENSITIVE - 221))
          | (1ULL << (TSqlParser::INSERTED - 221))
          | (1ULL << (TSqlParser::INT - 221))
          | (1ULL << (TSqlParser::ISOLATION - 221))
          | (1ULL << (TSqlParser::KEEP - 221))
          | (1ULL << (TSqlParser::KEEPFIXED - 221))
          | (1ULL << (TSqlParser::KEYSET - 221))
          | (1ULL << (TSqlParser::LAG - 221))
          | (1ULL << (TSqlParser::LAST - 221))
          | (1ULL << (TSqlParser::LAST_VALUE - 221))
          | (1ULL << (TSqlParser::LEAD - 221))
          | (1ULL << (TSqlParser::LEVEL - 221))
          | (1ULL << (TSqlParser::LOCAL - 221))
          | (1ULL << (TSqlParser::LOCATION - 221))
          | (1ULL << (TSqlParser::LOCK - 221))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 221))
          | (1ULL << (TSqlParser::LOOP - 221))
          | (1ULL << (TSqlParser::LOW - 221))
          | (1ULL << (TSqlParser::MANUAL - 221))
          | (1ULL << (TSqlParser::MARK - 221))
          | (1ULL << (TSqlParser::MAX - 221))
          | (1ULL << (TSqlParser::MAXDOP - 221))
          | (1ULL << (TSqlParser::MAXRECURSION - 221))
          | (1ULL << (TSqlParser::MIN - 221))
          | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 221))
          | (1ULL << (TSqlParser::MINUTES - 221))
          | (1ULL << (TSqlParser::MODE - 221))
          | (1ULL << (TSqlParser::NEXT - 221))
          | (1ULL << (TSqlParser::NO - 221))
          | (1ULL << (TSqlParser::NOCOUNT - 221))
          | (1ULL << (TSqlParser::NODES - 221))
          | (1ULL << (TSqlParser::NOEXPAND - 221))
          | (1ULL << (TSqlParser::NOWAIT - 221))
          | (1ULL << (TSqlParser::NTILE - 221))
          | (1ULL << (TSqlParser::NUMANODE - 221))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 221))
          | (1ULL << (TSqlParser::OBJECT - 221))
          | (1ULL << (TSqlParser::OFFSET - 221))
          | (1ULL << (TSqlParser::ONLINE - 221))
          | (1ULL << (TSqlParser::ONLY - 221))
          | (1ULL << (TSqlParser::OPTIMISTIC - 221))
          | (1ULL << (TSqlParser::OPTIMIZE - 221))
          | (1ULL << (TSqlParser::OUT - 221))
          | (1ULL << (TSqlParser::OUTPUT - 221))
          | (1ULL << (TSqlParser::OWNER - 221))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 221)))) != 0) || ((((_la - 285) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 285)) & ((1ULL << (TSqlParser::PARTITION - 285))
          | (1ULL << (TSqlParser::PARTITIONS - 285))
          | (1ULL << (TSqlParser::PERCENT_RANK - 285))
          | (1ULL << (TSqlParser::PERCENTILE_CONT - 285))
          | (1ULL << (TSqlParser::PERCENTILE_DISC - 285))
          | (1ULL << (TSqlParser::PRECEDING - 285))
          | (1ULL << (TSqlParser::PRIOR - 285))
          | (1ULL << (TSqlParser::QUERY - 285))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 285))
          | (1ULL << (TSqlParser::RANGE - 285))
          | (1ULL << (TSqlParser::RANK - 285))
          | (1ULL << (TSqlParser::RC2 - 285))
          | (1ULL << (TSqlParser::RC4 - 285))
          | (1ULL << (TSqlParser::RC4_128 - 285))
          | (1ULL << (TSqlParser::READ_ONLY - 285))
          | (1ULL << (TSqlParser::READONLY - 285))
          | (1ULL << (TSqlParser::REBUILD - 285))
          | (1ULL << (TSqlParser::RECOMPILE - 285))
          | (1ULL << (TSqlParser::RELATIVE - 285))
          | (1ULL << (TSqlParser::REMOTE - 285))
          | (1ULL << (TSqlParser::REPEATABLE - 285))
          | (1ULL << (TSqlParser::ROBUST - 285))
          | (1ULL << (TSqlParser::ROW - 285))
          | (1ULL << (TSqlParser::ROW_NUMBER - 285))
          | (1ULL << (TSqlParser::ROWGUID - 285))
          | (1ULL << (TSqlParser::ROWS - 285))
          | (1ULL << (TSqlParser::SCHEMABINDING - 285))
          | (1ULL << (TSqlParser::SCROLL - 285))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 285))
          | (1ULL << (TSqlParser::SECONDS - 285))
          | (1ULL << (TSqlParser::SELF - 285))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 285))
          | (1ULL << (TSqlParser::SEQUENCE - 285))
          | (1ULL << (TSqlParser::SERIALIZABLE - 285))
          | (1ULL << (TSqlParser::SETERROR - 285))
          | (1ULL << (TSqlParser::SHARE - 285))
          | (1ULL << (TSqlParser::SIMPLE - 285))
          | (1ULL << (TSqlParser::SIZE - 285))
          | (1ULL << (TSqlParser::SMALLINT - 285))
          | (1ULL << (TSqlParser::SNAPSHOT - 285))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 285))
          | (1ULL << (TSqlParser::STATIC - 285))
          | (1ULL << (TSqlParser::STATUSONLY - 285))
          | (1ULL << (TSqlParser::STDEV - 285))
          | (1ULL << (TSqlParser::STDEVP - 285))
          | (1ULL << (TSqlParser::STRING_AGG - 285))
          | (1ULL << (TSqlParser::STUFF - 285))
          | (1ULL << (TSqlParser::SUBSCRIPTION - 285))
          | (1ULL << (TSqlParser::SUM - 285))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 285))
          | (1ULL << (TSqlParser::THROW - 285))
          | (1ULL << (TSqlParser::TIES - 285))
          | (1ULL << (TSqlParser::TIME - 285))
          | (1ULL << (TSqlParser::TIMEOUT - 285))
          | (1ULL << (TSqlParser::TINYINT - 285))
          | (1ULL << (TSqlParser::TRIPLE_DES - 285))
          | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 285))
          | (1ULL << (TSqlParser::TRY - 285))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 285))
          | (1ULL << (TSqlParser::TYPE - 285))
          | (1ULL << (TSqlParser::TYPE_WARNING - 285))
          | (1ULL << (TSqlParser::UNBOUNDED - 285))
          | (1ULL << (TSqlParser::UNCOMMITTED - 285))
          | (1ULL << (TSqlParser::UNKNOWN - 285)))) != 0) || ((((_la - 349) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 349)) & ((1ULL << (TSqlParser::UOW - 349))
          | (1ULL << (TSqlParser::USING - 349))
          | (1ULL << (TSqlParser::VAR - 349))
          | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 349))
          | (1ULL << (TSqlParser::VARP - 349))
          | (1ULL << (TSqlParser::WAIT - 349))
          | (1ULL << (TSqlParser::WORK - 349))
          | (1ULL << (TSqlParser::ZONE - 349))
          | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 349))
          | (1ULL << (TSqlParser::CACHE - 349))
          | (1ULL << (TSqlParser::CALLED - 349))
          | (1ULL << (TSqlParser::CHANGETABLE - 349))
          | (1ULL << (TSqlParser::CHANGES - 349))
          | (1ULL << (TSqlParser::CYCLE - 349))
          | (1ULL << (TSqlParser::DATA_COMPRESSION - 349))
          | (1ULL << (TSqlParser::ERROR - 349))
          | (1ULL << (TSqlParser::FORCESEEK - 349))
          | (1ULL << (TSqlParser::IIF - 349))
          | (1ULL << (TSqlParser::INCREMENT - 349))
          | (1ULL << (TSqlParser::ISNULL - 349))
          | (1ULL << (TSqlParser::LOG - 349))
          | (1ULL << (TSqlParser::MATCHED - 349))
          | (1ULL << (TSqlParser::MAXVALUE - 349))
          | (1ULL << (TSqlParser::MINVALUE - 349))
          | (1ULL << (TSqlParser::NOTIFICATION - 349))
          | (1ULL << (TSqlParser::PERSISTED - 349))
          | (1ULL << (TSqlParser::PREDICATE - 349))
          | (1ULL << (TSqlParser::RESTART - 349))
          | (1ULL << (TSqlParser::RETURNS - 349))
          | (1ULL << (TSqlParser::SOURCE - 349))
          | (1ULL << (TSqlParser::STATE - 349))
          | (1ULL << (TSqlParser::START - 349))
          | (1ULL << (TSqlParser::TARGET - 349))
          | (1ULL << (TSqlParser::VARCHAR - 349))
          | (1ULL << (TSqlParser::NVARCHAR - 349))
          | (1ULL << (TSqlParser::SPACE - 349))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 349))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 349))
          | (1ULL << (TSqlParser::DECIMAL - 349))
          | (1ULL << (TSqlParser::ID - 349))
          | (1ULL << (TSqlParser::STRING - 349)))) != 0) || _la == TSqlParser::DOT

        || _la == TSqlParser::PLUS);
        setState(2077);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::RR_BRACKET) {
          setState(2076);
          match(TSqlParser::RR_BRACKET);
        }
        setState(2079);
        match(TSqlParser::FOR);
        setState(2080);
        id_();
        break;
      }

      case TSqlParser::FOREIGN: {
        setState(2081);
        match(TSqlParser::FOREIGN);
        setState(2082);
        match(TSqlParser::KEY);
        setState(2083);
        match(TSqlParser::LR_BRACKET);
        setState(2084);
        dynamic_cast<Table_constraintContext *>(_localctx)->fk = column_name_list();
        setState(2085);
        match(TSqlParser::RR_BRACKET);
        setState(2086);
        match(TSqlParser::REFERENCES);
        setState(2087);
        table_name();
        setState(2092);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
        case 1: {
          setState(2088);
          match(TSqlParser::LR_BRACKET);
          setState(2089);
          dynamic_cast<Table_constraintContext *>(_localctx)->pk = column_name_list();
          setState(2090);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionsContext ------------------------------------------------------------------

TSqlParser::Index_optionsContext::Index_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Index_optionsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Index_optionContext *> TSqlParser::Index_optionsContext::index_option() {
  return getRuleContexts<TSqlParser::Index_optionContext>();
}

TSqlParser::Index_optionContext* TSqlParser::Index_optionsContext::index_option(size_t i) {
  return getRuleContext<TSqlParser::Index_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Index_optionsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Index_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_options;
}

void TSqlParser::Index_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_options(this);
}

void TSqlParser::Index_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_options(this);
}

TSqlParser::Index_optionsContext* TSqlParser::index_options() {
  Index_optionsContext *_localctx = _tracker.createInstance<Index_optionsContext>(_ctx, getState());
  enterRule(_localctx, 194, TSqlParser::RuleIndex_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2096);
    match(TSqlParser::WITH);
    setState(2097);
    match(TSqlParser::LR_BRACKET);
    setState(2098);
    index_option();
    setState(2103);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2099);
      match(TSqlParser::COMMA);
      setState(2100);
      index_option();
      setState(2105);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2106);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionContext ------------------------------------------------------------------

TSqlParser::Index_optionContext::Index_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Index_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<TSqlParser::Simple_idContext *> TSqlParser::Index_optionContext::simple_id() {
  return getRuleContexts<TSqlParser::Simple_idContext>();
}

TSqlParser::Simple_idContext* TSqlParser::Index_optionContext::simple_id(size_t i) {
  return getRuleContext<TSqlParser::Simple_idContext>(i);
}

std::vector<TSqlParser::KeywordContext *> TSqlParser::Index_optionContext::keyword() {
  return getRuleContexts<TSqlParser::KeywordContext>();
}

TSqlParser::KeywordContext* TSqlParser::Index_optionContext::keyword(size_t i) {
  return getRuleContext<TSqlParser::KeywordContext>(i);
}

TSqlParser::On_offContext* TSqlParser::Index_optionContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Index_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Index_optionContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_option;
}

void TSqlParser::Index_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_option(this);
}

void TSqlParser::Index_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_option(this);
}

TSqlParser::Index_optionContext* TSqlParser::index_option() {
  Index_optionContext *_localctx = _tracker.createInstance<Index_optionContext>(_ctx, getState());
  enterRule(_localctx, 196, TSqlParser::RuleIndex_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2110);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        setState(2108);
        simple_id();
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        setState(2109);
        keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2112);
    match(TSqlParser::EQUAL);
    setState(2117);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        setState(2113);
        simple_id();
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        setState(2114);
        keyword();
        break;
      }

      case TSqlParser::OFF:
      case TSqlParser::ON: {
        setState(2115);
        on_off();
        break;
      }

      case TSqlParser::DECIMAL: {
        setState(2116);
        match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_cursorContext ------------------------------------------------------------------

TSqlParser::Declare_cursorContext::Declare_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::DECLARE() {
  return getToken(TSqlParser::DECLARE, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Declare_cursorContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Declare_cursorContext::FOR() {
  return getTokens(TSqlParser::FOR);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::FOR(size_t i) {
  return getToken(TSqlParser::FOR, i);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Declare_cursorContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::Declare_cursorContext::declare_set_cursor_common() {
  return getRuleContext<TSqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SEMI_SENSITIVE() {
  return getToken(TSqlParser::SEMI_SENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::INSENSITIVE() {
  return getToken(TSqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Declare_cursorContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}


size_t TSqlParser::Declare_cursorContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_cursor;
}

void TSqlParser::Declare_cursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_cursor(this);
}

void TSqlParser::Declare_cursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_cursor(this);
}

TSqlParser::Declare_cursorContext* TSqlParser::declare_cursor() {
  Declare_cursorContext *_localctx = _tracker.createInstance<Declare_cursorContext>(_ctx, getState());
  enterRule(_localctx, 198, TSqlParser::RuleDeclare_cursor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2119);
    match(TSqlParser::DECLARE);
    setState(2120);
    cursor_name();
    setState(2152);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
    case 1: {
      setState(2121);
      match(TSqlParser::CURSOR);
      setState(2131);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx)) {
      case 1: {
        setState(2122);
        declare_set_cursor_common();
        setState(2129);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::FOR) {
          setState(2123);
          match(TSqlParser::FOR);
          setState(2124);
          match(TSqlParser::UPDATE);
          setState(2127);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::OF) {
            setState(2125);
            match(TSqlParser::OF);
            setState(2126);
            column_name_list();
          }
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(2134);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::INSENSITIVE || _la == TSqlParser::SEMI_SENSITIVE) {
        setState(2133);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::INSENSITIVE || _la == TSqlParser::SEMI_SENSITIVE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2137);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::SCROLL) {
        setState(2136);
        match(TSqlParser::SCROLL);
      }
      setState(2139);
      match(TSqlParser::CURSOR);
      setState(2140);
      match(TSqlParser::FOR);
      setState(2141);
      select_statement_standalone();
      setState(2150);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::FOR) {
        setState(2142);
        match(TSqlParser::FOR);
        setState(2148);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::READ: {
            setState(2143);
            match(TSqlParser::READ);
            setState(2144);
            match(TSqlParser::ONLY);
            break;
          }

          case TSqlParser::UPDATE: {
            setState(2145);
            match(TSqlParser::UPDATE);
            break;
          }

          case TSqlParser::OF: {
            setState(2146);
            match(TSqlParser::OF);
            setState(2147);
            column_name_list();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      break;
    }

    default:
      break;
    }
    setState(2155);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
    case 1: {
      setState(2154);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_set_cursor_commonContext ------------------------------------------------------------------

TSqlParser::Declare_set_cursor_commonContext::Declare_set_cursor_commonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_commonContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Declare_set_cursor_commonContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

std::vector<TSqlParser::Declare_set_cursor_common_partialContext *> TSqlParser::Declare_set_cursor_commonContext::declare_set_cursor_common_partial() {
  return getRuleContexts<TSqlParser::Declare_set_cursor_common_partialContext>();
}

TSqlParser::Declare_set_cursor_common_partialContext* TSqlParser::Declare_set_cursor_commonContext::declare_set_cursor_common_partial(size_t i) {
  return getRuleContext<TSqlParser::Declare_set_cursor_common_partialContext>(i);
}


size_t TSqlParser::Declare_set_cursor_commonContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_set_cursor_common;
}

void TSqlParser::Declare_set_cursor_commonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_set_cursor_common(this);
}

void TSqlParser::Declare_set_cursor_commonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_set_cursor_common(this);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::declare_set_cursor_common() {
  Declare_set_cursor_commonContext *_localctx = _tracker.createInstance<Declare_set_cursor_commonContext>(_ctx, getState());
  enterRule(_localctx, 200, TSqlParser::RuleDeclare_set_cursor_common);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2160);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 213) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 213)) & ((1ULL << (TSqlParser::DYNAMIC - 213))
      | (1ULL << (TSqlParser::FAST_FORWARD - 213))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 213))
      | (1ULL << (TSqlParser::GLOBAL - 213))
      | (1ULL << (TSqlParser::KEYSET - 213))
      | (1ULL << (TSqlParser::LOCAL - 213)))) != 0) || ((((_la - 279) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 279)) & ((1ULL << (TSqlParser::OPTIMISTIC - 279))
      | (1ULL << (TSqlParser::READ_ONLY - 279))
      | (1ULL << (TSqlParser::SCROLL - 279))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 279))
      | (1ULL << (TSqlParser::STATIC - 279)))) != 0) || _la == TSqlParser::TYPE_WARNING) {
      setState(2157);
      declare_set_cursor_common_partial();
      setState(2162);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2163);
    match(TSqlParser::FOR);
    setState(2164);
    select_statement_standalone();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_set_cursor_common_partialContext ------------------------------------------------------------------

TSqlParser::Declare_set_cursor_common_partialContext::Declare_set_cursor_common_partialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::FORWARD_ONLY() {
  return getToken(TSqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::STATIC() {
  return getToken(TSqlParser::STATIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::KEYSET() {
  return getToken(TSqlParser::KEYSET, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::DYNAMIC() {
  return getToken(TSqlParser::DYNAMIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::FAST_FORWARD() {
  return getToken(TSqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::READ_ONLY() {
  return getToken(TSqlParser::READ_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::SCROLL_LOCKS() {
  return getToken(TSqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::OPTIMISTIC() {
  return getToken(TSqlParser::OPTIMISTIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::TYPE_WARNING() {
  return getToken(TSqlParser::TYPE_WARNING, 0);
}


size_t TSqlParser::Declare_set_cursor_common_partialContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_set_cursor_common_partial;
}

void TSqlParser::Declare_set_cursor_common_partialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_set_cursor_common_partial(this);
}

void TSqlParser::Declare_set_cursor_common_partialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_set_cursor_common_partial(this);
}

TSqlParser::Declare_set_cursor_common_partialContext* TSqlParser::declare_set_cursor_common_partial() {
  Declare_set_cursor_common_partialContext *_localctx = _tracker.createInstance<Declare_set_cursor_common_partialContext>(_ctx, getState());
  enterRule(_localctx, 202, TSqlParser::RuleDeclare_set_cursor_common_partial);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2171);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::GLOBAL:
      case TSqlParser::LOCAL: {
        enterOuterAlt(_localctx, 1);
        setState(2166);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::GLOBAL

        || _la == TSqlParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::SCROLL: {
        enterOuterAlt(_localctx, 2);
        setState(2167);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FORWARD_ONLY || _la == TSqlParser::SCROLL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::DYNAMIC:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::KEYSET:
      case TSqlParser::STATIC: {
        enterOuterAlt(_localctx, 3);
        setState(2168);
        _la = _input->LA(1);
        if (!(((((_la - 213) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 213)) & ((1ULL << (TSqlParser::DYNAMIC - 213))
          | (1ULL << (TSqlParser::FAST_FORWARD - 213))
          | (1ULL << (TSqlParser::KEYSET - 213)))) != 0) || _la == TSqlParser::STATIC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::OPTIMISTIC:
      case TSqlParser::READ_ONLY:
      case TSqlParser::SCROLL_LOCKS: {
        enterOuterAlt(_localctx, 4);
        setState(2169);
        _la = _input->LA(1);
        if (!(((((_la - 279) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 279)) & ((1ULL << (TSqlParser::OPTIMISTIC - 279))
          | (1ULL << (TSqlParser::READ_ONLY - 279))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 279)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::TYPE_WARNING: {
        enterOuterAlt(_localctx, 5);
        setState(2170);
        match(TSqlParser::TYPE_WARNING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_cursorContext ------------------------------------------------------------------

TSqlParser::Fetch_cursorContext::Fetch_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FETCH() {
  return getToken(TSqlParser::FETCH, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Fetch_cursorContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Fetch_cursorContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::PRIOR() {
  return getToken(TSqlParser::PRIOR, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::LAST() {
  return getToken(TSqlParser::LAST, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Fetch_cursorContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Fetch_cursorContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::ABSOLUTE() {
  return getToken(TSqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::RELATIVE() {
  return getToken(TSqlParser::RELATIVE, 0);
}


size_t TSqlParser::Fetch_cursorContext::getRuleIndex() const {
  return TSqlParser::RuleFetch_cursor;
}

void TSqlParser::Fetch_cursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFetch_cursor(this);
}

void TSqlParser::Fetch_cursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFetch_cursor(this);
}

TSqlParser::Fetch_cursorContext* TSqlParser::fetch_cursor() {
  Fetch_cursorContext *_localctx = _tracker.createInstance<Fetch_cursorContext>(_ctx, getState());
  enterRule(_localctx, 204, TSqlParser::RuleFetch_cursor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2173);
    match(TSqlParser::FETCH);
    setState(2183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
    case 1: {
      setState(2180);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::NEXT: {
          setState(2174);
          match(TSqlParser::NEXT);
          break;
        }

        case TSqlParser::PRIOR: {
          setState(2175);
          match(TSqlParser::PRIOR);
          break;
        }

        case TSqlParser::FIRST: {
          setState(2176);
          match(TSqlParser::FIRST);
          break;
        }

        case TSqlParser::LAST: {
          setState(2177);
          match(TSqlParser::LAST);
          break;
        }

        case TSqlParser::ABSOLUTE:
        case TSqlParser::RELATIVE: {
          setState(2178);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::ABSOLUTE || _la == TSqlParser::RELATIVE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2179);
          expression(0);
          break;
        }

        case TSqlParser::FROM: {
          break;
        }

      default:
        break;
      }
      setState(2182);
      match(TSqlParser::FROM);
      break;
    }

    default:
      break;
    }
    setState(2186);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx)) {
    case 1: {
      setState(2185);
      match(TSqlParser::GLOBAL);
      break;
    }

    default:
      break;
    }
    setState(2188);
    cursor_name();
    setState(2198);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(2189);
      match(TSqlParser::INTO);
      setState(2190);
      match(TSqlParser::LOCAL_ID);
      setState(2195);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2191);
        match(TSqlParser::COMMA);
        setState(2192);
        match(TSqlParser::LOCAL_ID);
        setState(2197);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2201);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
    case 1: {
      setState(2200);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_specialContext ------------------------------------------------------------------

TSqlParser::Set_specialContext::Set_specialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Set_specialContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Set_specialContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Set_specialContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::Set_specialContext::constant_LOCAL_ID() {
  return getRuleContext<TSqlParser::Constant_LOCAL_IDContext>(0);
}

TSqlParser::On_offContext* TSqlParser::Set_specialContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ROWCOUNT() {
  return getToken(TSqlParser::ROWCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::TRANSACTION() {
  return getToken(TSqlParser::TRANSACTION, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ISOLATION() {
  return getToken(TSqlParser::ISOLATION, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::LEVEL() {
  return getToken(TSqlParser::LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::UNCOMMITTED() {
  return getToken(TSqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::COMMITTED() {
  return getToken(TSqlParser::COMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::REPEATABLE() {
  return getToken(TSqlParser::REPEATABLE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::IDENTITY_INSERT() {
  return getToken(TSqlParser::IDENTITY_INSERT, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Set_specialContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_NULLS() {
  return getToken(TSqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::QUOTED_IDENTIFIER() {
  return getToken(TSqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_PADDING() {
  return getToken(TSqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_WARNINGS() {
  return getToken(TSqlParser::ANSI_WARNINGS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_DEFAULTS() {
  return getToken(TSqlParser::ANSI_DEFAULTS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_NULL_DFLT_OFF() {
  return getToken(TSqlParser::ANSI_NULL_DFLT_OFF, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_NULL_DFLT_ON() {
  return getToken(TSqlParser::ANSI_NULL_DFLT_ON, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ARITHABORT() {
  return getToken(TSqlParser::ARITHABORT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ARITHIGNORE() {
  return getToken(TSqlParser::ARITHIGNORE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::CONCAT_NULL_YIELDS_NULL() {
  return getToken(TSqlParser::CONCAT_NULL_YIELDS_NULL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::FMTONLY() {
  return getToken(TSqlParser::FMTONLY, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::FORCEPLAN() {
  return getToken(TSqlParser::FORCEPLAN, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::IMPLICIT_TRANSACTIONS() {
  return getToken(TSqlParser::IMPLICIT_TRANSACTIONS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::NOCOUNT() {
  return getToken(TSqlParser::NOCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::NOEXEC() {
  return getToken(TSqlParser::NOEXEC, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::NUMERIC_ROUNDABORT() {
  return getToken(TSqlParser::NUMERIC_ROUNDABORT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::PARSEONLY() {
  return getToken(TSqlParser::PARSEONLY, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::REMOTE_PROC_TRANSACTIONS() {
  return getToken(TSqlParser::REMOTE_PROC_TRANSACTIONS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SHOWPLAN_ALL() {
  return getToken(TSqlParser::SHOWPLAN_ALL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SHOWPLAN_TEXT() {
  return getToken(TSqlParser::SHOWPLAN_TEXT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SHOWPLAN_XML() {
  return getToken(TSqlParser::SHOWPLAN_XML, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::XACT_ABORT() {
  return getToken(TSqlParser::XACT_ABORT, 0);
}


size_t TSqlParser::Set_specialContext::getRuleIndex() const {
  return TSqlParser::RuleSet_special;
}

void TSqlParser::Set_specialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_special(this);
}

void TSqlParser::Set_specialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_special(this);
}

TSqlParser::Set_specialContext* TSqlParser::set_special() {
  Set_specialContext *_localctx = _tracker.createInstance<Set_specialContext>(_ctx, getState());
  enterRule(_localctx, 206, TSqlParser::RuleSet_special);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2247);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2203);
      match(TSqlParser::SET);
      setState(2204);
      id_();
      setState(2208);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID: {
          setState(2205);
          id_();
          break;
        }

        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOLLAR:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS: {
          setState(2206);
          constant_LOCAL_ID();
          break;
        }

        case TSqlParser::OFF:
        case TSqlParser::ON: {
          setState(2207);
          on_off();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2211);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
      case 1: {
        setState(2210);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2213);
      match(TSqlParser::SET);
      setState(2214);
      match(TSqlParser::ROWCOUNT);
      setState(2215);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::LOCAL_ID

      || _la == TSqlParser::DECIMAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2217);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
      case 1: {
        setState(2216);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2219);
      match(TSqlParser::SET);
      setState(2220);
      match(TSqlParser::TRANSACTION);
      setState(2221);
      match(TSqlParser::ISOLATION);
      setState(2222);
      match(TSqlParser::LEVEL);
      setState(2232);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
      case 1: {
        setState(2223);
        match(TSqlParser::READ);
        setState(2224);
        match(TSqlParser::UNCOMMITTED);
        break;
      }

      case 2: {
        setState(2225);
        match(TSqlParser::READ);
        setState(2226);
        match(TSqlParser::COMMITTED);
        break;
      }

      case 3: {
        setState(2227);
        match(TSqlParser::REPEATABLE);
        setState(2228);
        match(TSqlParser::READ);
        break;
      }

      case 4: {
        setState(2229);
        match(TSqlParser::SNAPSHOT);
        break;
      }

      case 5: {
        setState(2230);
        match(TSqlParser::SERIALIZABLE);
        break;
      }

      case 6: {
        setState(2231);
        match(TSqlParser::DECIMAL);
        break;
      }

      default:
        break;
      }
      setState(2235);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
      case 1: {
        setState(2234);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2237);
      match(TSqlParser::SET);
      setState(2238);
      match(TSqlParser::IDENTITY_INSERT);
      setState(2239);
      table_name();
      setState(2240);
      on_off();
      setState(2242);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
      case 1: {
        setState(2241);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2244);
      match(TSqlParser::SET);
      setState(2245);
      _la = _input->LA(1);
      if (!(((((_la - 173) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 173)) & ((1ULL << (TSqlParser::ANSI_NULLS - 173))
        | (1ULL << (TSqlParser::ANSI_PADDING - 173))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 173))
        | (1ULL << (TSqlParser::ARITHABORT - 173))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 173))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 173)))) != 0) || ((((_la - 268) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 268)) & ((1ULL << (TSqlParser::NOCOUNT - 268))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 268))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 268)))) != 0) || ((((_la - 440) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 440)) & ((1ULL << (TSqlParser::ANSI_DEFAULTS - 440))
        | (1ULL << (TSqlParser::ANSI_NULL_DFLT_OFF - 440))
        | (1ULL << (TSqlParser::ANSI_NULL_DFLT_ON - 440))
        | (1ULL << (TSqlParser::ARITHIGNORE - 440))
        | (1ULL << (TSqlParser::FMTONLY - 440))
        | (1ULL << (TSqlParser::FORCEPLAN - 440))
        | (1ULL << (TSqlParser::IMPLICIT_TRANSACTIONS - 440))
        | (1ULL << (TSqlParser::NOEXEC - 440))
        | (1ULL << (TSqlParser::PARSEONLY - 440))
        | (1ULL << (TSqlParser::REMOTE_PROC_TRANSACTIONS - 440))
        | (1ULL << (TSqlParser::SHOWPLAN_ALL - 440))
        | (1ULL << (TSqlParser::SHOWPLAN_TEXT - 440))
        | (1ULL << (TSqlParser::SHOWPLAN_XML - 440))
        | (1ULL << (TSqlParser::XACT_ABORT - 440)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2246);
      on_off();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_LOCAL_IDContext ------------------------------------------------------------------

TSqlParser::Constant_LOCAL_IDContext::Constant_LOCAL_IDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ConstantContext* TSqlParser::Constant_LOCAL_IDContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_LOCAL_IDContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Constant_LOCAL_IDContext::getRuleIndex() const {
  return TSqlParser::RuleConstant_LOCAL_ID;
}

void TSqlParser::Constant_LOCAL_IDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_LOCAL_ID(this);
}

void TSqlParser::Constant_LOCAL_IDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_LOCAL_ID(this);
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::constant_LOCAL_ID() {
  Constant_LOCAL_IDContext *_localctx = _tracker.createInstance<Constant_LOCAL_IDContext>(_ctx, getState());
  enterRule(_localctx, 208, TSqlParser::RuleConstant_LOCAL_ID);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2251);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 1);
        setState(2249);
        constant();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(2250);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

TSqlParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Primitive_expressionContext* TSqlParser::ExpressionContext::primitive_expression() {
  return getRuleContext<TSqlParser::Primitive_expressionContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::ExpressionContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

TSqlParser::Case_expressionContext* TSqlParser::ExpressionContext::case_expression() {
  return getRuleContext<TSqlParser::Case_expressionContext>(0);
}

TSqlParser::Full_column_nameContext* TSqlParser::ExpressionContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

TSqlParser::Bracket_expressionContext* TSqlParser::ExpressionContext::bracket_expression() {
  return getRuleContext<TSqlParser::Bracket_expressionContext>(0);
}

TSqlParser::Unary_operator_expressionContext* TSqlParser::ExpressionContext::unary_operator_expression() {
  return getRuleContext<TSqlParser::Unary_operator_expressionContext>(0);
}

TSqlParser::Over_clauseContext* TSqlParser::ExpressionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DOLLAR_ACTION() {
  return getToken(TSqlParser::DOLLAR_ACTION, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::ExpressionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::ExpressionContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DIVIDE() {
  return getToken(TSqlParser::DIVIDE, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::MODULE() {
  return getToken(TSqlParser::MODULE, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_AND() {
  return getToken(TSqlParser::BIT_AND, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_XOR() {
  return getToken(TSqlParser::BIT_XOR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_OR() {
  return getToken(TSqlParser::BIT_OR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DOUBLE_BAR() {
  return getToken(TSqlParser::DOUBLE_BAR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::Id_Context* TSqlParser::ExpressionContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Time_zoneContext* TSqlParser::ExpressionContext::time_zone() {
  return getRuleContext<TSqlParser::Time_zoneContext>(0);
}


size_t TSqlParser::ExpressionContext::getRuleIndex() const {
  return TSqlParser::RuleExpression;
}

void TSqlParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void TSqlParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


TSqlParser::ExpressionContext* TSqlParser::expression() {
   return expression(0);
}

TSqlParser::ExpressionContext* TSqlParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TSqlParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  TSqlParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 210;
  enterRecursionRule(_localctx, 210, TSqlParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2262);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
    case 1: {
      setState(2254);
      primitive_expression();
      break;
    }

    case 2: {
      setState(2255);
      function_call();
      break;
    }

    case 3: {
      setState(2256);
      case_expression();
      break;
    }

    case 4: {
      setState(2257);
      full_column_name();
      break;
    }

    case 5: {
      setState(2258);
      bracket_expression();
      break;
    }

    case 6: {
      setState(2259);
      unary_operator_expression();
      break;
    }

    case 7: {
      setState(2260);
      over_clause();
      break;
    }

    case 8: {
      setState(2261);
      match(TSqlParser::DOLLAR_ACTION);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2277);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2275);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2264);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(2265);
          dynamic_cast<ExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 430) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 430)) & ((1ULL << (TSqlParser::STAR - 430))
            | (1ULL << (TSqlParser::DIVIDE - 430))
            | (1ULL << (TSqlParser::MODULE - 430)))) != 0))) {
            dynamic_cast<ExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2266);
          expression(6);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2267);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(2268);
          dynamic_cast<ExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 418) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 418)) & ((1ULL << (TSqlParser::DOUBLE_BAR - 418))
            | (1ULL << (TSqlParser::PLUS - 418))
            | (1ULL << (TSqlParser::MINUS - 418))
            | (1ULL << (TSqlParser::BIT_OR - 418))
            | (1ULL << (TSqlParser::BIT_AND - 418))
            | (1ULL << (TSqlParser::BIT_XOR - 418)))) != 0))) {
            dynamic_cast<ExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2269);
          expression(5);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2270);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(2271);
          match(TSqlParser::COLLATE);
          setState(2272);
          id_();
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2273);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(2274);
          time_zone();
          break;
        }

        default:
          break;
        } 
      }
      setState(2279);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Time_zoneContext ------------------------------------------------------------------

TSqlParser::Time_zoneContext::Time_zoneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Time_zoneContext::AT_KEYWORD() {
  return getToken(TSqlParser::AT_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::Time_zoneContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::Time_zoneContext::ZONE() {
  return getToken(TSqlParser::ZONE, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Time_zoneContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Time_zoneContext::getRuleIndex() const {
  return TSqlParser::RuleTime_zone;
}

void TSqlParser::Time_zoneContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime_zone(this);
}

void TSqlParser::Time_zoneContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime_zone(this);
}

TSqlParser::Time_zoneContext* TSqlParser::time_zone() {
  Time_zoneContext *_localctx = _tracker.createInstance<Time_zoneContext>(_ctx, getState());
  enterRule(_localctx, 212, TSqlParser::RuleTime_zone);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2280);
    match(TSqlParser::AT_KEYWORD);
    setState(2281);
    match(TSqlParser::TIME);
    setState(2282);
    match(TSqlParser::ZONE);
    setState(2283);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Primitive_expressionContext ------------------------------------------------------------------

TSqlParser::Primitive_expressionContext::Primitive_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ConstantContext* TSqlParser::Primitive_expressionContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::Primitive_expressionContext::getRuleIndex() const {
  return TSqlParser::RulePrimitive_expression;
}

void TSqlParser::Primitive_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimitive_expression(this);
}

void TSqlParser::Primitive_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimitive_expression(this);
}

TSqlParser::Primitive_expressionContext* TSqlParser::primitive_expression() {
  Primitive_expressionContext *_localctx = _tracker.createInstance<Primitive_expressionContext>(_ctx, getState());
  enterRule(_localctx, 214, TSqlParser::RulePrimitive_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2289);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(2285);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::NULL_: {
        enterOuterAlt(_localctx, 2);
        setState(2286);
        match(TSqlParser::NULL_);
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 3);
        setState(2287);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 4);
        setState(2288);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_expressionContext ------------------------------------------------------------------

TSqlParser::Case_expressionContext::Case_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Case_expressionContext::CASE() {
  return getToken(TSqlParser::CASE, 0);
}

tree::TerminalNode* TSqlParser::Case_expressionContext::END() {
  return getToken(TSqlParser::END, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Case_expressionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Case_expressionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<TSqlParser::Switch_sectionContext *> TSqlParser::Case_expressionContext::switch_section() {
  return getRuleContexts<TSqlParser::Switch_sectionContext>();
}

TSqlParser::Switch_sectionContext* TSqlParser::Case_expressionContext::switch_section(size_t i) {
  return getRuleContext<TSqlParser::Switch_sectionContext>(i);
}

tree::TerminalNode* TSqlParser::Case_expressionContext::ELSE() {
  return getToken(TSqlParser::ELSE, 0);
}

std::vector<TSqlParser::Switch_search_condition_sectionContext *> TSqlParser::Case_expressionContext::switch_search_condition_section() {
  return getRuleContexts<TSqlParser::Switch_search_condition_sectionContext>();
}

TSqlParser::Switch_search_condition_sectionContext* TSqlParser::Case_expressionContext::switch_search_condition_section(size_t i) {
  return getRuleContext<TSqlParser::Switch_search_condition_sectionContext>(i);
}


size_t TSqlParser::Case_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleCase_expression;
}

void TSqlParser::Case_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_expression(this);
}

void TSqlParser::Case_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_expression(this);
}

TSqlParser::Case_expressionContext* TSqlParser::case_expression() {
  Case_expressionContext *_localctx = _tracker.createInstance<Case_expressionContext>(_ctx, getState());
  enterRule(_localctx, 216, TSqlParser::RuleCase_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2316);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2291);
      match(TSqlParser::CASE);
      setState(2292);
      dynamic_cast<Case_expressionContext *>(_localctx)->caseExpr = expression(0);
      setState(2294); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2293);
        switch_section();
        setState(2296); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::WHEN);
      setState(2300);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ELSE) {
        setState(2298);
        match(TSqlParser::ELSE);
        setState(2299);
        dynamic_cast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2302);
      match(TSqlParser::END);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2304);
      match(TSqlParser::CASE);
      setState(2306); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2305);
        switch_search_condition_section();
        setState(2308); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::WHEN);
      setState(2312);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ELSE) {
        setState(2310);
        match(TSqlParser::ELSE);
        setState(2311);
        dynamic_cast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2314);
      match(TSqlParser::END);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operator_expressionContext ------------------------------------------------------------------

TSqlParser::Unary_operator_expressionContext::Unary_operator_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::BIT_NOT() {
  return getToken(TSqlParser::BIT_NOT, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Unary_operator_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::Unary_operator_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleUnary_operator_expression;
}

void TSqlParser::Unary_operator_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_operator_expression(this);
}

void TSqlParser::Unary_operator_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_operator_expression(this);
}

TSqlParser::Unary_operator_expressionContext* TSqlParser::unary_operator_expression() {
  Unary_operator_expressionContext *_localctx = _tracker.createInstance<Unary_operator_expressionContext>(_ctx, getState());
  enterRule(_localctx, 218, TSqlParser::RuleUnary_operator_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2322);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BIT_NOT: {
        enterOuterAlt(_localctx, 1);
        setState(2318);
        match(TSqlParser::BIT_NOT);
        setState(2319);
        expression(0);
        break;
      }

      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(2320);
        dynamic_cast<Unary_operator_expressionContext *>(_localctx)->op = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::PLUS

        || _la == TSqlParser::MINUS)) {
          dynamic_cast<Unary_operator_expressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2321);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bracket_expressionContext ------------------------------------------------------------------

TSqlParser::Bracket_expressionContext::Bracket_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Bracket_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Bracket_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Bracket_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::SubqueryContext* TSqlParser::Bracket_expressionContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}


size_t TSqlParser::Bracket_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleBracket_expression;
}

void TSqlParser::Bracket_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBracket_expression(this);
}

void TSqlParser::Bracket_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBracket_expression(this);
}

TSqlParser::Bracket_expressionContext* TSqlParser::bracket_expression() {
  Bracket_expressionContext *_localctx = _tracker.createInstance<Bracket_expressionContext>(_ctx, getState());
  enterRule(_localctx, 220, TSqlParser::RuleBracket_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2332);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2324);
      match(TSqlParser::LR_BRACKET);
      setState(2325);
      expression(0);
      setState(2326);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2328);
      match(TSqlParser::LR_BRACKET);
      setState(2329);
      subquery();
      setState(2330);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

TSqlParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

TSqlParser::ConstantContext* TSqlParser::Constant_expressionContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::Constant_expressionContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Constant_expressionContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Constant_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleConstant_expression;
}

void TSqlParser::Constant_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_expression(this);
}

void TSqlParser::Constant_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_expression(this);
}

TSqlParser::Constant_expressionContext* TSqlParser::constant_expression() {
  Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 222, TSqlParser::RuleConstant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2342);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(2334);
        match(TSqlParser::NULL_);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(2335);
        constant();
        break;
      }

      case TSqlParser::ABS:
      case TSqlParser::ASCII:
      case TSqlParser::CEILING:
      case TSqlParser::CHAR:
      case TSqlParser::CHARINDEX:
      case TSqlParser::DATALENGTH:
      case TSqlParser::DAY:
      case TSqlParser::FLOOR:
      case TSqlParser::ISDATE:
      case TSqlParser::ISNUMERIC:
      case TSqlParser::LEN:
      case TSqlParser::LOWER:
      case TSqlParser::LTRIM:
      case TSqlParser::MONTH:
      case TSqlParser::NCHAR:
      case TSqlParser::PATINDEX:
      case TSqlParser::RAND:
      case TSqlParser::REPLACE:
      case TSqlParser::ROUND:
      case TSqlParser::RTRIM:
      case TSqlParser::SIGN:
      case TSqlParser::STR:
      case TSqlParser::SUBSTRING:
      case TSqlParser::UPPER:
      case TSqlParser::USER_NAME:
      case TSqlParser::YEAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::COALESCE:
      case TSqlParser::CONVERT:
      case TSqlParser::CURRENT_TIMESTAMP:
      case TSqlParser::CURRENT_USER:
      case TSqlParser::IDENTITY:
      case TSqlParser::LEFT:
      case TSqlParser::NULLIF:
      case TSqlParser::PRECISION:
      case TSqlParser::RIGHT:
      case TSqlParser::SESSION_USER:
      case TSqlParser::SYSTEM_USER:
      case TSqlParser::USER:
      case TSqlParser::DOLLAR_PARTITION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::SPACE:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID:
      case TSqlParser::DOT: {
        enterOuterAlt(_localctx, 3);
        setState(2336);
        function_call();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 4);
        setState(2337);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 5);
        setState(2338);
        match(TSqlParser::LR_BRACKET);
        setState(2339);
        constant_expression();
        setState(2340);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

TSqlParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Select_statementContext* TSqlParser::SubqueryContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}


size_t TSqlParser::SubqueryContext::getRuleIndex() const {
  return TSqlParser::RuleSubquery;
}

void TSqlParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}

void TSqlParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}

TSqlParser::SubqueryContext* TSqlParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 224, TSqlParser::RuleSubquery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2344);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_expressionContext ------------------------------------------------------------------

TSqlParser::With_expressionContext::With_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::With_expressionContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Common_table_expressionContext *> TSqlParser::With_expressionContext::common_table_expression() {
  return getRuleContexts<TSqlParser::Common_table_expressionContext>();
}

TSqlParser::Common_table_expressionContext* TSqlParser::With_expressionContext::common_table_expression(size_t i) {
  return getRuleContext<TSqlParser::Common_table_expressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::With_expressionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::With_expressionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::With_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleWith_expression;
}

void TSqlParser::With_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_expression(this);
}

void TSqlParser::With_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_expression(this);
}

TSqlParser::With_expressionContext* TSqlParser::with_expression() {
  With_expressionContext *_localctx = _tracker.createInstance<With_expressionContext>(_ctx, getState());
  enterRule(_localctx, 226, TSqlParser::RuleWith_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2346);
    match(TSqlParser::WITH);
    setState(2347);
    dynamic_cast<With_expressionContext *>(_localctx)->common_table_expressionContext = common_table_expression();
    dynamic_cast<With_expressionContext *>(_localctx)->ctes.push_back(dynamic_cast<With_expressionContext *>(_localctx)->common_table_expressionContext);
    setState(2352);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2348);
      match(TSqlParser::COMMA);
      setState(2349);
      dynamic_cast<With_expressionContext *>(_localctx)->common_table_expressionContext = common_table_expression();
      dynamic_cast<With_expressionContext *>(_localctx)->ctes.push_back(dynamic_cast<With_expressionContext *>(_localctx)->common_table_expressionContext);
      setState(2354);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_expressionContext ------------------------------------------------------------------

TSqlParser::Common_table_expressionContext::Common_table_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Common_table_expressionContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Common_table_expressionContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::Id_Context* TSqlParser::Common_table_expressionContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Select_statementContext* TSqlParser::Common_table_expressionContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

TSqlParser::Column_name_listContext* TSqlParser::Common_table_expressionContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}


size_t TSqlParser::Common_table_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleCommon_table_expression;
}

void TSqlParser::Common_table_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_expression(this);
}

void TSqlParser::Common_table_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_expression(this);
}

TSqlParser::Common_table_expressionContext* TSqlParser::common_table_expression() {
  Common_table_expressionContext *_localctx = _tracker.createInstance<Common_table_expressionContext>(_ctx, getState());
  enterRule(_localctx, 228, TSqlParser::RuleCommon_table_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2355);
    dynamic_cast<Common_table_expressionContext *>(_localctx)->expression_name = id_();
    setState(2360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(2356);
      match(TSqlParser::LR_BRACKET);
      setState(2357);
      dynamic_cast<Common_table_expressionContext *>(_localctx)->columns = column_name_list();
      setState(2358);
      match(TSqlParser::RR_BRACKET);
    }
    setState(2362);
    match(TSqlParser::AS);
    setState(2363);
    match(TSqlParser::LR_BRACKET);
    setState(2364);
    dynamic_cast<Common_table_expressionContext *>(_localctx)->cte_query = select_statement();
    setState(2365);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_elemContext ------------------------------------------------------------------

TSqlParser::Update_elemContext::Update_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Update_elemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Update_elemContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::Update_elemContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

TSqlParser::Full_column_nameContext* TSqlParser::Update_elemContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Update_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Update_elemContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Update_elemContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Update_elemContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Update_elemContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Update_elemContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_elem;
}

void TSqlParser::Update_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_elem(this);
}

void TSqlParser::Update_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_elem(this);
}

TSqlParser::Update_elemContext* TSqlParser::update_elem() {
  Update_elemContext *_localctx = _tracker.createInstance<Update_elemContext>(_ctx, getState());
  enterRule(_localctx, 230, TSqlParser::RuleUpdate_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2392);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2367);
      match(TSqlParser::LOCAL_ID);
      setState(2368);
      match(TSqlParser::EQUAL);
      setState(2369);
      full_column_name();
      setState(2372);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EQUAL: {
          setState(2370);
          match(TSqlParser::EQUAL);
          break;
        }

        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2371);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2374);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2378);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID:
        case TSqlParser::DOT: {
          setState(2376);
          full_column_name();
          break;
        }

        case TSqlParser::LOCAL_ID: {
          setState(2377);
          match(TSqlParser::LOCAL_ID);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2382);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EQUAL: {
          setState(2380);
          match(TSqlParser::EQUAL);
          break;
        }

        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2381);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2384);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2385);
      dynamic_cast<Update_elemContext *>(_localctx)->udt_column_name = id_();
      setState(2386);
      match(TSqlParser::DOT);
      setState(2387);
      dynamic_cast<Update_elemContext *>(_localctx)->method_name = id_();
      setState(2388);
      match(TSqlParser::LR_BRACKET);
      setState(2389);
      expression_list();
      setState(2390);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_elem_mergeContext ------------------------------------------------------------------

TSqlParser::Update_elem_mergeContext::Update_elem_mergeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Update_elem_mergeContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Update_elem_mergeContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Update_elem_mergeContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Update_elem_mergeContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Update_elem_mergeContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Update_elem_mergeContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Update_elem_mergeContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_elem_merge;
}

void TSqlParser::Update_elem_mergeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_elem_merge(this);
}

void TSqlParser::Update_elem_mergeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_elem_merge(this);
}

TSqlParser::Update_elem_mergeContext* TSqlParser::update_elem_merge() {
  Update_elem_mergeContext *_localctx = _tracker.createInstance<Update_elem_mergeContext>(_ctx, getState());
  enterRule(_localctx, 232, TSqlParser::RuleUpdate_elem_merge);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2410);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2396);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID:
        case TSqlParser::DOT: {
          setState(2394);
          full_column_name();
          break;
        }

        case TSqlParser::LOCAL_ID: {
          setState(2395);
          match(TSqlParser::LOCAL_ID);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2400);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EQUAL: {
          setState(2398);
          match(TSqlParser::EQUAL);
          break;
        }

        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2399);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2402);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2403);
      dynamic_cast<Update_elem_mergeContext *>(_localctx)->udt_column_name = id_();
      setState(2404);
      match(TSqlParser::DOT);
      setState(2405);
      dynamic_cast<Update_elem_mergeContext *>(_localctx)->method_name = id_();
      setState(2406);
      match(TSqlParser::LR_BRACKET);
      setState(2407);
      expression_list();
      setState(2408);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_conditionContext ------------------------------------------------------------------

TSqlParser::Search_conditionContext::Search_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::PredicateContext* TSqlParser::Search_conditionContext::predicate() {
  return getRuleContext<TSqlParser::PredicateContext>(0);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::Search_conditionContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::Search_conditionContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Search_conditionContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::AND() {
  return getToken(TSqlParser::AND, 0);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::OR() {
  return getToken(TSqlParser::OR, 0);
}


size_t TSqlParser::Search_conditionContext::getRuleIndex() const {
  return TSqlParser::RuleSearch_condition;
}

void TSqlParser::Search_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_condition(this);
}

void TSqlParser::Search_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_condition(this);
}


TSqlParser::Search_conditionContext* TSqlParser::search_condition() {
   return search_condition(0);
}

TSqlParser::Search_conditionContext* TSqlParser::search_condition(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TSqlParser::Search_conditionContext *_localctx = _tracker.createInstance<Search_conditionContext>(_ctx, parentState);
  TSqlParser::Search_conditionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 234;
  enterRecursionRule(_localctx, 234, TSqlParser::RuleSearch_condition, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2416);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::NOT) {
      setState(2413);
      match(TSqlParser::NOT);
      setState(2418);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2424);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      setState(2419);
      predicate();
      break;
    }

    case 2: {
      setState(2420);
      match(TSqlParser::LR_BRACKET);
      setState(2421);
      search_condition(0);
      setState(2422);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2434);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2432);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Search_conditionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSearch_condition);
          setState(2426);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(2427);
          match(TSqlParser::AND);
          setState(2428);
          search_condition(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Search_conditionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSearch_condition);
          setState(2429);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(2430);
          match(TSqlParser::OR);
          setState(2431);
          search_condition(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(2436);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

TSqlParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::PredicateContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::SubqueryContext* TSqlParser::PredicateContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::PredicateContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::PredicateContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::Comparison_operatorContext* TSqlParser::PredicateContext::comparison_operator() {
  return getRuleContext<TSqlParser::Comparison_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::SOME() {
  return getToken(TSqlParser::SOME, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ANY() {
  return getToken(TSqlParser::ANY, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::BETWEEN() {
  return getToken(TSqlParser::BETWEEN, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::AND() {
  return getToken(TSqlParser::AND, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::PredicateContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::PredicateContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

tree::TerminalNode* TSqlParser::PredicateContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Expression_listContext* TSqlParser::PredicateContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::LIKE() {
  return getToken(TSqlParser::LIKE, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ESCAPE() {
  return getToken(TSqlParser::ESCAPE, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::IS() {
  return getToken(TSqlParser::IS, 0);
}

TSqlParser::Null_notnullContext* TSqlParser::PredicateContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}


size_t TSqlParser::PredicateContext::getRuleIndex() const {
  return TSqlParser::RulePredicate;
}

void TSqlParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void TSqlParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

TSqlParser::PredicateContext* TSqlParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 236, TSqlParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2497);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2437);
      match(TSqlParser::EXISTS);
      setState(2438);
      match(TSqlParser::LR_BRACKET);
      setState(2439);
      subquery();
      setState(2440);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2442);
      expression(0);
      setState(2443);
      comparison_operator();
      setState(2444);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2446);
      expression(0);
      setState(2447);
      comparison_operator();
      setState(2448);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL

      || _la == TSqlParser::ANY || _la == TSqlParser::SOME)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2449);
      match(TSqlParser::LR_BRACKET);
      setState(2450);
      subquery();
      setState(2451);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2453);
      expression(0);
      setState(2457);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::NOT) {
        setState(2454);
        match(TSqlParser::NOT);
        setState(2459);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2460);
      match(TSqlParser::BETWEEN);
      setState(2461);
      expression(0);
      setState(2462);
      match(TSqlParser::AND);
      setState(2463);
      expression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2465);
      expression(0);
      setState(2469);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::NOT) {
        setState(2466);
        match(TSqlParser::NOT);
        setState(2471);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2472);
      match(TSqlParser::IN);
      setState(2473);
      match(TSqlParser::LR_BRACKET);
      setState(2476);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx)) {
      case 1: {
        setState(2474);
        subquery();
        break;
      }

      case 2: {
        setState(2475);
        expression_list();
        break;
      }

      default:
        break;
      }
      setState(2478);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2480);
      expression(0);
      setState(2484);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::NOT) {
        setState(2481);
        match(TSqlParser::NOT);
        setState(2486);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2487);
      match(TSqlParser::LIKE);
      setState(2488);
      expression(0);
      setState(2491);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx)) {
      case 1: {
        setState(2489);
        match(TSqlParser::ESCAPE);
        setState(2490);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2493);
      expression(0);
      setState(2494);
      match(TSqlParser::IS);
      setState(2495);
      null_notnull();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_expressionContext ------------------------------------------------------------------

TSqlParser::Query_expressionContext::Query_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Query_specificationContext* TSqlParser::Query_expressionContext::query_specification() {
  return getRuleContext<TSqlParser::Query_specificationContext>(0);
}

tree::TerminalNode* TSqlParser::Query_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Query_expressionContext* TSqlParser::Query_expressionContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Query_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Query_expressionContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

std::vector<TSqlParser::Sql_unionContext *> TSqlParser::Query_expressionContext::sql_union() {
  return getRuleContexts<TSqlParser::Sql_unionContext>();
}

TSqlParser::Sql_unionContext* TSqlParser::Query_expressionContext::sql_union(size_t i) {
  return getRuleContext<TSqlParser::Sql_unionContext>(i);
}


size_t TSqlParser::Query_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleQuery_expression;
}

void TSqlParser::Query_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery_expression(this);
}

void TSqlParser::Query_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery_expression(this);
}

TSqlParser::Query_expressionContext* TSqlParser::query_expression() {
  Query_expressionContext *_localctx = _tracker.createInstance<Query_expressionContext>(_ctx, getState());
  enterRule(_localctx, 238, TSqlParser::RuleQuery_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2515);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2504);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::SELECT: {
          setState(2499);
          query_specification();
          break;
        }

        case TSqlParser::LR_BRACKET: {
          setState(2500);
          match(TSqlParser::LR_BRACKET);
          setState(2501);
          query_expression();
          setState(2502);
          match(TSqlParser::RR_BRACKET);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2506);
      query_specification();
      setState(2508);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ORDER) {
        setState(2507);
        order_by_clause();
      }
      setState(2511); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2510);
        dynamic_cast<Query_expressionContext *>(_localctx)->sql_unionContext = sql_union();
        dynamic_cast<Query_expressionContext *>(_localctx)->unions.push_back(dynamic_cast<Query_expressionContext *>(_localctx)->sql_unionContext);
        setState(2513); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::EXCEPT

      || _la == TSqlParser::INTERSECT || _la == TSqlParser::UNION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_unionContext ------------------------------------------------------------------

TSqlParser::Sql_unionContext::Sql_unionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Sql_unionContext::UNION() {
  return getToken(TSqlParser::UNION, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::EXCEPT() {
  return getToken(TSqlParser::EXCEPT, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::INTERSECT() {
  return getToken(TSqlParser::INTERSECT, 0);
}

TSqlParser::Query_specificationContext* TSqlParser::Sql_unionContext::query_specification() {
  return getRuleContext<TSqlParser::Query_specificationContext>(0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

TSqlParser::Query_expressionContext* TSqlParser::Sql_unionContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}


size_t TSqlParser::Sql_unionContext::getRuleIndex() const {
  return TSqlParser::RuleSql_union;
}

void TSqlParser::Sql_unionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_union(this);
}

void TSqlParser::Sql_unionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_union(this);
}

TSqlParser::Sql_unionContext* TSqlParser::sql_union() {
  Sql_unionContext *_localctx = _tracker.createInstance<Sql_unionContext>(_ctx, getState());
  enterRule(_localctx, 240, TSqlParser::RuleSql_union);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2523);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNION: {
        setState(2517);
        match(TSqlParser::UNION);
        setState(2519);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ALL) {
          setState(2518);
          match(TSqlParser::ALL);
        }
        break;
      }

      case TSqlParser::EXCEPT: {
        setState(2521);
        match(TSqlParser::EXCEPT);
        break;
      }

      case TSqlParser::INTERSECT: {
        setState(2522);
        match(TSqlParser::INTERSECT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2530);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::SELECT: {
        setState(2525);
        dynamic_cast<Sql_unionContext *>(_localctx)->spec = query_specification();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        setState(2526);
        match(TSqlParser::LR_BRACKET);
        setState(2527);
        dynamic_cast<Sql_unionContext *>(_localctx)->op = query_expression();
        setState(2528);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_specificationContext ------------------------------------------------------------------

TSqlParser::Query_specificationContext::Query_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Query_specificationContext::SELECT() {
  return getToken(TSqlParser::SELECT, 0);
}

TSqlParser::Select_listContext* TSqlParser::Query_specificationContext::select_list() {
  return getRuleContext<TSqlParser::Select_listContext>(0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::HAVING() {
  return getToken(TSqlParser::HAVING, 0);
}

TSqlParser::Top_clauseContext* TSqlParser::Query_specificationContext::top_clause() {
  return getRuleContext<TSqlParser::Top_clauseContext>(0);
}

TSqlParser::Table_nameContext* TSqlParser::Query_specificationContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Query_specificationContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::Query_specificationContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::Query_specificationContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

std::vector<TSqlParser::Group_by_itemContext *> TSqlParser::Query_specificationContext::group_by_item() {
  return getRuleContexts<TSqlParser::Group_by_itemContext>();
}

TSqlParser::Group_by_itemContext* TSqlParser::Query_specificationContext::group_by_item(size_t i) {
  return getRuleContext<TSqlParser::Group_by_itemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Query_specificationContext::ALL() {
  return getTokens(TSqlParser::ALL);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::ALL(size_t i) {
  return getToken(TSqlParser::ALL, i);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Query_specificationContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Query_specificationContext::getRuleIndex() const {
  return TSqlParser::RuleQuery_specification;
}

void TSqlParser::Query_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery_specification(this);
}

void TSqlParser::Query_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery_specification(this);
}

TSqlParser::Query_specificationContext* TSqlParser::query_specification() {
  Query_specificationContext *_localctx = _tracker.createInstance<Query_specificationContext>(_ctx, getState());
  enterRule(_localctx, 242, TSqlParser::RuleQuery_specification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2532);
    match(TSqlParser::SELECT);
    setState(2534);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ALL

    || _la == TSqlParser::DISTINCT) {
      setState(2533);
      dynamic_cast<Query_specificationContext *>(_localctx)->allOrDistinct = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL

      || _la == TSqlParser::DISTINCT)) {
        dynamic_cast<Query_specificationContext *>(_localctx)->allOrDistinct = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(2536);
      dynamic_cast<Query_specificationContext *>(_localctx)->top = top_clause();
    }
    setState(2539);
    dynamic_cast<Query_specificationContext *>(_localctx)->columns = select_list();
    setState(2542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(2540);
      match(TSqlParser::INTO);
      setState(2541);
      dynamic_cast<Query_specificationContext *>(_localctx)->into = table_name();
    }
    setState(2546);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(2544);
      match(TSqlParser::FROM);
      setState(2545);
      dynamic_cast<Query_specificationContext *>(_localctx)->from = table_sources();
    }
    setState(2550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(2548);
      match(TSqlParser::WHERE);
      setState(2549);
      dynamic_cast<Query_specificationContext *>(_localctx)->where = search_condition(0);
    }
    setState(2565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::GROUP) {
      setState(2552);
      match(TSqlParser::GROUP);
      setState(2553);
      match(TSqlParser::BY);
      setState(2555);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ALL) {
        setState(2554);
        dynamic_cast<Query_specificationContext *>(_localctx)->groupByAll = match(TSqlParser::ALL);
      }
      setState(2557);
      dynamic_cast<Query_specificationContext *>(_localctx)->group_by_itemContext = group_by_item();
      dynamic_cast<Query_specificationContext *>(_localctx)->groupBys.push_back(dynamic_cast<Query_specificationContext *>(_localctx)->group_by_itemContext);
      setState(2562);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2558);
        match(TSqlParser::COMMA);
        setState(2559);
        dynamic_cast<Query_specificationContext *>(_localctx)->group_by_itemContext = group_by_item();
        dynamic_cast<Query_specificationContext *>(_localctx)->groupBys.push_back(dynamic_cast<Query_specificationContext *>(_localctx)->group_by_itemContext);
        setState(2564);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::HAVING) {
      setState(2567);
      match(TSqlParser::HAVING);
      setState(2568);
      dynamic_cast<Query_specificationContext *>(_localctx)->having = search_condition(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_clauseContext ------------------------------------------------------------------

TSqlParser::Top_clauseContext::Top_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_clauseContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

TSqlParser::Top_percentContext* TSqlParser::Top_clauseContext::top_percent() {
  return getRuleContext<TSqlParser::Top_percentContext>(0);
}

TSqlParser::Top_countContext* TSqlParser::Top_clauseContext::top_count() {
  return getRuleContext<TSqlParser::Top_countContext>(0);
}

tree::TerminalNode* TSqlParser::Top_clauseContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Top_clauseContext::TIES() {
  return getToken(TSqlParser::TIES, 0);
}


size_t TSqlParser::Top_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleTop_clause;
}

void TSqlParser::Top_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_clause(this);
}

void TSqlParser::Top_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_clause(this);
}

TSqlParser::Top_clauseContext* TSqlParser::top_clause() {
  Top_clauseContext *_localctx = _tracker.createInstance<Top_clauseContext>(_ctx, getState());
  enterRule(_localctx, 244, TSqlParser::RuleTop_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2571);
    match(TSqlParser::TOP);
    setState(2574);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      setState(2572);
      top_percent();
      break;
    }

    case 2: {
      setState(2573);
      top_count();
      break;
    }

    default:
      break;
    }
    setState(2578);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(2576);
      match(TSqlParser::WITH);
      setState(2577);
      match(TSqlParser::TIES);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_percentContext ------------------------------------------------------------------

TSqlParser::Top_percentContext::Top_percentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_percentContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::REAL() {
  return getToken(TSqlParser::REAL, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::FLOAT() {
  return getToken(TSqlParser::FLOAT, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Top_percentContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Top_percentContext::getRuleIndex() const {
  return TSqlParser::RuleTop_percent;
}

void TSqlParser::Top_percentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_percent(this);
}

void TSqlParser::Top_percentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_percent(this);
}

TSqlParser::Top_percentContext* TSqlParser::top_percent() {
  Top_percentContext *_localctx = _tracker.createInstance<Top_percentContext>(_ctx, getState());
  enterRule(_localctx, 246, TSqlParser::RuleTop_percent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2587);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL: {
        enterOuterAlt(_localctx, 1);
        setState(2580);
        dynamic_cast<Top_percentContext *>(_localctx)->percent_constant = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 400) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 400)) & ((1ULL << (TSqlParser::DECIMAL - 400))
          | (1ULL << (TSqlParser::FLOAT - 400))
          | (1ULL << (TSqlParser::REAL - 400)))) != 0))) {
          dynamic_cast<Top_percentContext *>(_localctx)->percent_constant = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2581);
        match(TSqlParser::PERCENT);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(2582);
        match(TSqlParser::LR_BRACKET);
        setState(2583);
        dynamic_cast<Top_percentContext *>(_localctx)->topper_expression = expression(0);
        setState(2584);
        match(TSqlParser::RR_BRACKET);
        setState(2585);
        match(TSqlParser::PERCENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_countContext ------------------------------------------------------------------

TSqlParser::Top_countContext::Top_countContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_countContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Top_countContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Top_countContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Top_countContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Top_countContext::getRuleIndex() const {
  return TSqlParser::RuleTop_count;
}

void TSqlParser::Top_countContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_count(this);
}

void TSqlParser::Top_countContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_count(this);
}

TSqlParser::Top_countContext* TSqlParser::top_count() {
  Top_countContext *_localctx = _tracker.createInstance<Top_countContext>(_ctx, getState());
  enterRule(_localctx, 248, TSqlParser::RuleTop_count);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2594);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(2589);
        dynamic_cast<Top_countContext *>(_localctx)->count_constant = match(TSqlParser::DECIMAL);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(2590);
        match(TSqlParser::LR_BRACKET);
        setState(2591);
        dynamic_cast<Top_countContext *>(_localctx)->topcount_expression = expression(0);
        setState(2592);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_clauseContext ------------------------------------------------------------------

TSqlParser::Order_by_clauseContext::Order_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

std::vector<TSqlParser::Order_by_expressionContext *> TSqlParser::Order_by_clauseContext::order_by_expression() {
  return getRuleContexts<TSqlParser::Order_by_expressionContext>();
}

TSqlParser::Order_by_expressionContext* TSqlParser::Order_by_clauseContext::order_by_expression(size_t i) {
  return getRuleContext<TSqlParser::Order_by_expressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::OFFSET() {
  return getToken(TSqlParser::OFFSET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Order_by_clauseContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Order_by_clauseContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::ROW() {
  return getTokens(TSqlParser::ROW);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ROW(size_t i) {
  return getToken(TSqlParser::ROW, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::ROWS() {
  return getTokens(TSqlParser::ROWS);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ROWS(size_t i) {
  return getToken(TSqlParser::ROWS, i);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::FETCH() {
  return getToken(TSqlParser::FETCH, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}


size_t TSqlParser::Order_by_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOrder_by_clause;
}

void TSqlParser::Order_by_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_clause(this);
}

void TSqlParser::Order_by_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_clause(this);
}

TSqlParser::Order_by_clauseContext* TSqlParser::order_by_clause() {
  Order_by_clauseContext *_localctx = _tracker.createInstance<Order_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 250, TSqlParser::RuleOrder_by_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2596);
    match(TSqlParser::ORDER);
    setState(2597);
    match(TSqlParser::BY);
    setState(2598);
    dynamic_cast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext = order_by_expression();
    dynamic_cast<Order_by_clauseContext *>(_localctx)->order_bys.push_back(dynamic_cast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext);
    setState(2603);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2599);
      match(TSqlParser::COMMA);
      setState(2600);
      dynamic_cast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext = order_by_expression();
      dynamic_cast<Order_by_clauseContext *>(_localctx)->order_bys.push_back(dynamic_cast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext);
      setState(2605);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2617);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
    case 1: {
      setState(2606);
      match(TSqlParser::OFFSET);
      setState(2607);
      dynamic_cast<Order_by_clauseContext *>(_localctx)->offset_exp = expression(0);
      setState(2608);
      dynamic_cast<Order_by_clauseContext *>(_localctx)->offset_rows = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ROW

      || _la == TSqlParser::ROWS)) {
        dynamic_cast<Order_by_clauseContext *>(_localctx)->offset_rows = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2615);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx)) {
      case 1: {
        setState(2609);
        match(TSqlParser::FETCH);
        setState(2610);
        dynamic_cast<Order_by_clauseContext *>(_localctx)->fetch_offset = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FIRST

        || _la == TSqlParser::NEXT)) {
          dynamic_cast<Order_by_clauseContext *>(_localctx)->fetch_offset = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2611);
        dynamic_cast<Order_by_clauseContext *>(_localctx)->fetch_exp = expression(0);
        setState(2612);
        dynamic_cast<Order_by_clauseContext *>(_localctx)->fetch_rows = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ROW

        || _la == TSqlParser::ROWS)) {
          dynamic_cast<Order_by_clauseContext *>(_localctx)->fetch_rows = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2613);
        match(TSqlParser::ONLY);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_expressionContext ------------------------------------------------------------------

TSqlParser::Order_by_expressionContext::Order_by_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Order_by_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Order_by_expressionContext::ASC() {
  return getToken(TSqlParser::ASC, 0);
}

tree::TerminalNode* TSqlParser::Order_by_expressionContext::DESC() {
  return getToken(TSqlParser::DESC, 0);
}


size_t TSqlParser::Order_by_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleOrder_by_expression;
}

void TSqlParser::Order_by_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_expression(this);
}

void TSqlParser::Order_by_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_expression(this);
}

TSqlParser::Order_by_expressionContext* TSqlParser::order_by_expression() {
  Order_by_expressionContext *_localctx = _tracker.createInstance<Order_by_expressionContext>(_ctx, getState());
  enterRule(_localctx, 252, TSqlParser::RuleOrder_by_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2619);
    dynamic_cast<Order_by_expressionContext *>(_localctx)->order_by = expression(0);
    setState(2622);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ASC: {
        setState(2620);
        dynamic_cast<Order_by_expressionContext *>(_localctx)->ascending = match(TSqlParser::ASC);
        break;
      }

      case TSqlParser::DESC: {
        setState(2621);
        dynamic_cast<Order_by_expressionContext *>(_localctx)->descending = match(TSqlParser::DESC);
        break;
      }

      case TSqlParser::EOF:
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::ALTER:
      case TSqlParser::BEGIN:
      case TSqlParser::BREAK:
      case TSqlParser::CLOSE:
      case TSqlParser::COMMIT:
      case TSqlParser::CONTINUE:
      case TSqlParser::CREATE:
      case TSqlParser::DBCC:
      case TSqlParser::DEALLOCATE:
      case TSqlParser::DECLARE:
      case TSqlParser::DELETE:
      case TSqlParser::DROP:
      case TSqlParser::ELSE:
      case TSqlParser::END:
      case TSqlParser::EXCEPT:
      case TSqlParser::EXECUTE:
      case TSqlParser::FETCH:
      case TSqlParser::FOR:
      case TSqlParser::GOTO:
      case TSqlParser::IF:
      case TSqlParser::INSERT:
      case TSqlParser::INTERSECT:
      case TSqlParser::KILL:
      case TSqlParser::MERGE:
      case TSqlParser::OPEN:
      case TSqlParser::OPTION:
      case TSqlParser::PRECISION:
      case TSqlParser::PRINT:
      case TSqlParser::RAISERROR:
      case TSqlParser::RETURN:
      case TSqlParser::ROLLBACK:
      case TSqlParser::SAVE:
      case TSqlParser::SELECT:
      case TSqlParser::SET:
      case TSqlParser::SHUTDOWN:
      case TSqlParser::TRUNCATE:
      case TSqlParser::UNION:
      case TSqlParser::UPDATE:
      case TSqlParser::USE:
      case TSqlParser::WHILE:
      case TSqlParser::WITH:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WAITFOR:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID:
      case TSqlParser::DOT:
      case TSqlParser::LR_BRACKET:
      case TSqlParser::RR_BRACKET:
      case TSqlParser::COMMA:
      case TSqlParser::SEMI: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_itemContext ------------------------------------------------------------------

TSqlParser::Group_by_itemContext::Group_by_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Group_by_itemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Group_by_itemContext::getRuleIndex() const {
  return TSqlParser::RuleGroup_by_item;
}

void TSqlParser::Group_by_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_by_item(this);
}

void TSqlParser::Group_by_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_by_item(this);
}

TSqlParser::Group_by_itemContext* TSqlParser::group_by_item() {
  Group_by_itemContext *_localctx = _tracker.createInstance<Group_by_itemContext>(_ctx, getState());
  enterRule(_localctx, 254, TSqlParser::RuleGroup_by_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2624);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Option_clauseContext ------------------------------------------------------------------

TSqlParser::Option_clauseContext::Option_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Option_clauseContext::OPTION() {
  return getToken(TSqlParser::OPTION, 0);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::OptionContext *> TSqlParser::Option_clauseContext::option() {
  return getRuleContexts<TSqlParser::OptionContext>();
}

TSqlParser::OptionContext* TSqlParser::Option_clauseContext::option(size_t i) {
  return getRuleContext<TSqlParser::OptionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Option_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Option_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOption_clause;
}

void TSqlParser::Option_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption_clause(this);
}

void TSqlParser::Option_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption_clause(this);
}

TSqlParser::Option_clauseContext* TSqlParser::option_clause() {
  Option_clauseContext *_localctx = _tracker.createInstance<Option_clauseContext>(_ctx, getState());
  enterRule(_localctx, 256, TSqlParser::RuleOption_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2626);
    match(TSqlParser::OPTION);
    setState(2627);
    match(TSqlParser::LR_BRACKET);
    setState(2628);
    dynamic_cast<Option_clauseContext *>(_localctx)->optionContext = option();
    dynamic_cast<Option_clauseContext *>(_localctx)->options.push_back(dynamic_cast<Option_clauseContext *>(_localctx)->optionContext);
    setState(2633);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2629);
      match(TSqlParser::COMMA);
      setState(2630);
      dynamic_cast<Option_clauseContext *>(_localctx)->optionContext = option();
      dynamic_cast<Option_clauseContext *>(_localctx)->options.push_back(dynamic_cast<Option_clauseContext *>(_localctx)->optionContext);
      setState(2635);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2636);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext ------------------------------------------------------------------

TSqlParser::OptionContext::OptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::OptionContext::FAST() {
  return getToken(TSqlParser::FAST, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::UNION() {
  return getToken(TSqlParser::UNION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::CONCAT() {
  return getToken(TSqlParser::CONCAT, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FORCE() {
  return getToken(TSqlParser::FORCE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::KEEP() {
  return getToken(TSqlParser::KEEP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::PLAN() {
  return getToken(TSqlParser::PLAN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::KEEPFIXED() {
  return getToken(TSqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MAXDOP() {
  return getToken(TSqlParser::MAXDOP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MAXRECURSION() {
  return getToken(TSqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::OPTIMIZE() {
  return getToken(TSqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Optimize_for_argContext *> TSqlParser::OptionContext::optimize_for_arg() {
  return getRuleContexts<TSqlParser::Optimize_for_argContext>();
}

TSqlParser::Optimize_for_argContext* TSqlParser::OptionContext::optimize_for_arg(size_t i) {
  return getRuleContext<TSqlParser::Optimize_for_argContext>(i);
}

tree::TerminalNode* TSqlParser::OptionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::OptionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::OptionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::OptionContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::PARAMETERIZATION() {
  return getToken(TSqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::SIMPLE() {
  return getToken(TSqlParser::SIMPLE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FORCED() {
  return getToken(TSqlParser::FORCED, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::ROBUST() {
  return getToken(TSqlParser::ROBUST, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::USE() {
  return getToken(TSqlParser::USE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::OptionContext::getRuleIndex() const {
  return TSqlParser::RuleOption;
}

void TSqlParser::OptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption(this);
}

void TSqlParser::OptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption(this);
}

TSqlParser::OptionContext* TSqlParser::option() {
  OptionContext *_localctx = _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 258, TSqlParser::RuleOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2680);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2638);
      match(TSqlParser::FAST);
      setState(2639);
      dynamic_cast<OptionContext *>(_localctx)->number_rows = match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2640);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ORDER || _la == TSqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2641);
      match(TSqlParser::GROUP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2642);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::CONCAT

      || _la == TSqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2643);
      match(TSqlParser::UNION);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2644);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::HASH

      || _la == TSqlParser::LOOP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2645);
      match(TSqlParser::JOIN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2646);
      match(TSqlParser::FORCE);
      setState(2647);
      match(TSqlParser::ORDER);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2648);
      match(TSqlParser::KEEP);
      setState(2649);
      match(TSqlParser::PLAN);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2650);
      match(TSqlParser::KEEPFIXED);
      setState(2651);
      match(TSqlParser::PLAN);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2652);
      match(TSqlParser::MAXDOP);
      setState(2653);
      dynamic_cast<OptionContext *>(_localctx)->number_of_processors = match(TSqlParser::DECIMAL);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2654);
      match(TSqlParser::MAXRECURSION);
      setState(2655);
      dynamic_cast<OptionContext *>(_localctx)->number_recursion = match(TSqlParser::DECIMAL);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2656);
      match(TSqlParser::OPTIMIZE);
      setState(2657);
      match(TSqlParser::FOR);
      setState(2658);
      match(TSqlParser::LR_BRACKET);
      setState(2659);
      optimize_for_arg();
      setState(2664);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2660);
        match(TSqlParser::COMMA);
        setState(2661);
        optimize_for_arg();
        setState(2666);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2667);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2669);
      match(TSqlParser::OPTIMIZE);
      setState(2670);
      match(TSqlParser::FOR);
      setState(2671);
      match(TSqlParser::UNKNOWN);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2672);
      match(TSqlParser::PARAMETERIZATION);
      setState(2673);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::FORCED || _la == TSqlParser::SIMPLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2674);
      match(TSqlParser::RECOMPILE);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2675);
      match(TSqlParser::ROBUST);
      setState(2676);
      match(TSqlParser::PLAN);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2677);
      match(TSqlParser::USE);
      setState(2678);
      match(TSqlParser::PLAN);
      setState(2679);
      match(TSqlParser::STRING);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optimize_for_argContext ------------------------------------------------------------------

TSqlParser::Optimize_for_argContext::Optimize_for_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ConstantContext* TSqlParser::Optimize_for_argContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}


size_t TSqlParser::Optimize_for_argContext::getRuleIndex() const {
  return TSqlParser::RuleOptimize_for_arg;
}

void TSqlParser::Optimize_for_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptimize_for_arg(this);
}

void TSqlParser::Optimize_for_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptimize_for_arg(this);
}

TSqlParser::Optimize_for_argContext* TSqlParser::optimize_for_arg() {
  Optimize_for_argContext *_localctx = _tracker.createInstance<Optimize_for_argContext>(_ctx, getState());
  enterRule(_localctx, 260, TSqlParser::RuleOptimize_for_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2682);
    match(TSqlParser::LOCAL_ID);
    setState(2689);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNKNOWN: {
        setState(2683);
        match(TSqlParser::UNKNOWN);
        break;
      }

      case TSqlParser::EQUAL: {
        setState(2684);
        match(TSqlParser::EQUAL);
        setState(2687);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::DECIMAL:
          case TSqlParser::STRING:
          case TSqlParser::BINARY:
          case TSqlParser::FLOAT:
          case TSqlParser::REAL:
          case TSqlParser::DOLLAR:
          case TSqlParser::PLUS:
          case TSqlParser::MINUS: {
            setState(2685);
            constant();
            break;
          }

          case TSqlParser::NULL_: {
            setState(2686);
            match(TSqlParser::NULL_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_listContext ------------------------------------------------------------------

TSqlParser::Select_listContext::Select_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Select_list_elemContext *> TSqlParser::Select_listContext::select_list_elem() {
  return getRuleContexts<TSqlParser::Select_list_elemContext>();
}

TSqlParser::Select_list_elemContext* TSqlParser::Select_listContext::select_list_elem(size_t i) {
  return getRuleContext<TSqlParser::Select_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Select_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Select_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Select_listContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_list;
}

void TSqlParser::Select_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list(this);
}

void TSqlParser::Select_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list(this);
}

TSqlParser::Select_listContext* TSqlParser::select_list() {
  Select_listContext *_localctx = _tracker.createInstance<Select_listContext>(_ctx, getState());
  enterRule(_localctx, 262, TSqlParser::RuleSelect_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2691);
    dynamic_cast<Select_listContext *>(_localctx)->select_list_elemContext = select_list_elem();
    dynamic_cast<Select_listContext *>(_localctx)->selectElement.push_back(dynamic_cast<Select_listContext *>(_localctx)->select_list_elemContext);
    setState(2696);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2692);
      match(TSqlParser::COMMA);
      setState(2693);
      dynamic_cast<Select_listContext *>(_localctx)->select_list_elemContext = select_list_elem();
      dynamic_cast<Select_listContext *>(_localctx)->selectElement.push_back(dynamic_cast<Select_listContext *>(_localctx)->select_list_elemContext);
      setState(2698);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udt_method_argumentsContext ------------------------------------------------------------------

TSqlParser::Udt_method_argumentsContext::Udt_method_argumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Execute_var_stringContext *> TSqlParser::Udt_method_argumentsContext::execute_var_string() {
  return getRuleContexts<TSqlParser::Execute_var_stringContext>();
}

TSqlParser::Execute_var_stringContext* TSqlParser::Udt_method_argumentsContext::execute_var_string(size_t i) {
  return getRuleContext<TSqlParser::Execute_var_stringContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Udt_method_argumentsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Udt_method_argumentsContext::getRuleIndex() const {
  return TSqlParser::RuleUdt_method_arguments;
}

void TSqlParser::Udt_method_argumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdt_method_arguments(this);
}

void TSqlParser::Udt_method_argumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdt_method_arguments(this);
}

TSqlParser::Udt_method_argumentsContext* TSqlParser::udt_method_arguments() {
  Udt_method_argumentsContext *_localctx = _tracker.createInstance<Udt_method_argumentsContext>(_ctx, getState());
  enterRule(_localctx, 264, TSqlParser::RuleUdt_method_arguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2699);
    match(TSqlParser::LR_BRACKET);
    setState(2700);
    dynamic_cast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext = execute_var_string();
    dynamic_cast<Udt_method_argumentsContext *>(_localctx)->argument.push_back(dynamic_cast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext);
    setState(2705);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2701);
      match(TSqlParser::COMMA);
      setState(2702);
      dynamic_cast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext = execute_var_string();
      dynamic_cast<Udt_method_argumentsContext *>(_localctx)->argument.push_back(dynamic_cast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext);
      setState(2707);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2708);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsteriskContext ------------------------------------------------------------------

TSqlParser::AsteriskContext::AsteriskContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::AsteriskContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

TSqlParser::Table_nameContext* TSqlParser::AsteriskContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::AsteriskContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::AsteriskContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

tree::TerminalNode* TSqlParser::AsteriskContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}


size_t TSqlParser::AsteriskContext::getRuleIndex() const {
  return TSqlParser::RuleAsterisk;
}

void TSqlParser::AsteriskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsterisk(this);
}

void TSqlParser::AsteriskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsterisk(this);
}

TSqlParser::AsteriskContext* TSqlParser::asterisk() {
  AsteriskContext *_localctx = _tracker.createInstance<AsteriskContext>(_ctx, getState());
  enterRule(_localctx, 266, TSqlParser::RuleAsterisk);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2719);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2713);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::LOCAL_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(2710);
        table_name();
        setState(2711);
        match(TSqlParser::DOT);
      }
      setState(2715);
      match(TSqlParser::STAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2716);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DELETED

      || _la == TSqlParser::INSERTED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2717);
      match(TSqlParser::DOT);
      setState(2718);
      match(TSqlParser::STAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_elemContext ------------------------------------------------------------------

TSqlParser::Column_elemContext::Column_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Full_column_nameContext* TSqlParser::Column_elemContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::DOLLAR() {
  return getToken(TSqlParser::DOLLAR, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::ROWGUID() {
  return getToken(TSqlParser::ROWGUID, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Column_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Column_elemContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_elem;
}

void TSqlParser::Column_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_elem(this);
}

void TSqlParser::Column_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_elem(this);
}

TSqlParser::Column_elemContext* TSqlParser::column_elem() {
  Column_elemContext *_localctx = _tracker.createInstance<Column_elemContext>(_ctx, getState());
  enterRule(_localctx, 268, TSqlParser::RuleColumn_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2727);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx)) {
    case 1: {
      setState(2721);
      full_column_name();
      break;
    }

    case 2: {
      setState(2722);
      match(TSqlParser::DOLLAR);
      setState(2723);
      match(TSqlParser::IDENTITY);
      break;
    }

    case 3: {
      setState(2724);
      match(TSqlParser::DOLLAR);
      setState(2725);
      match(TSqlParser::ROWGUID);
      break;
    }

    case 4: {
      setState(2726);
      match(TSqlParser::NULL_);
      break;
    }

    default:
      break;
    }
    setState(2730);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
    case 1: {
      setState(2729);
      as_column_alias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udt_elemContext ------------------------------------------------------------------

TSqlParser::Udt_elemContext::Udt_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Udt_elemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

TSqlParser::Udt_method_argumentsContext* TSqlParser::Udt_elemContext::udt_method_arguments() {
  return getRuleContext<TSqlParser::Udt_method_argumentsContext>(0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Udt_elemContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Udt_elemContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::As_column_aliasContext* TSqlParser::Udt_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Udt_elemContext::DOUBLE_COLON() {
  return getToken(TSqlParser::DOUBLE_COLON, 0);
}


size_t TSqlParser::Udt_elemContext::getRuleIndex() const {
  return TSqlParser::RuleUdt_elem;
}

void TSqlParser::Udt_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdt_elem(this);
}

void TSqlParser::Udt_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdt_elem(this);
}

TSqlParser::Udt_elemContext* TSqlParser::udt_elem() {
  Udt_elemContext *_localctx = _tracker.createInstance<Udt_elemContext>(_ctx, getState());
  enterRule(_localctx, 270, TSqlParser::RuleUdt_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2748);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2732);
      dynamic_cast<Udt_elemContext *>(_localctx)->udt_column_name = id_();
      setState(2733);
      match(TSqlParser::DOT);
      setState(2734);
      dynamic_cast<Udt_elemContext *>(_localctx)->non_static_attr = id_();
      setState(2735);
      udt_method_arguments();
      setState(2737);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 412, _ctx)) {
      case 1: {
        setState(2736);
        as_column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2739);
      dynamic_cast<Udt_elemContext *>(_localctx)->udt_column_name = id_();
      setState(2740);
      match(TSqlParser::DOUBLE_COLON);
      setState(2741);
      dynamic_cast<Udt_elemContext *>(_localctx)->static_attr = id_();
      setState(2743);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx)) {
      case 1: {
        setState(2742);
        udt_method_arguments();
        break;
      }

      default:
        break;
      }
      setState(2746);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
      case 1: {
        setState(2745);
        as_column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_elemContext ------------------------------------------------------------------

TSqlParser::Expression_elemContext::Expression_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_aliasContext* TSqlParser::Expression_elemContext::column_alias() {
  return getRuleContext<TSqlParser::Column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Expression_elemContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Expression_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Expression_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Expression_elemContext::getRuleIndex() const {
  return TSqlParser::RuleExpression_elem;
}

void TSqlParser::Expression_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_elem(this);
}

void TSqlParser::Expression_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_elem(this);
}

TSqlParser::Expression_elemContext* TSqlParser::expression_elem() {
  Expression_elemContext *_localctx = _tracker.createInstance<Expression_elemContext>(_ctx, getState());
  enterRule(_localctx, 272, TSqlParser::RuleExpression_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2758);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2750);
      dynamic_cast<Expression_elemContext *>(_localctx)->leftAlias = column_alias();
      setState(2751);
      dynamic_cast<Expression_elemContext *>(_localctx)->eq = match(TSqlParser::EQUAL);
      setState(2752);
      dynamic_cast<Expression_elemContext *>(_localctx)->leftAssignment = expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2754);
      dynamic_cast<Expression_elemContext *>(_localctx)->expressionAs = expression(0);
      setState(2756);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
      case 1: {
        setState(2755);
        as_column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_elemContext ------------------------------------------------------------------

TSqlParser::Select_list_elemContext::Select_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::AsteriskContext* TSqlParser::Select_list_elemContext::asterisk() {
  return getRuleContext<TSqlParser::AsteriskContext>(0);
}

TSqlParser::Column_elemContext* TSqlParser::Select_list_elemContext::column_elem() {
  return getRuleContext<TSqlParser::Column_elemContext>(0);
}

TSqlParser::Udt_elemContext* TSqlParser::Select_list_elemContext::udt_elem() {
  return getRuleContext<TSqlParser::Udt_elemContext>(0);
}

tree::TerminalNode* TSqlParser::Select_list_elemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Select_list_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Select_list_elemContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Select_list_elemContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Expression_elemContext* TSqlParser::Select_list_elemContext::expression_elem() {
  return getRuleContext<TSqlParser::Expression_elemContext>(0);
}


size_t TSqlParser::Select_list_elemContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_list_elem;
}

void TSqlParser::Select_list_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_elem(this);
}

void TSqlParser::Select_list_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_elem(this);
}

TSqlParser::Select_list_elemContext* TSqlParser::select_list_elem() {
  Select_list_elemContext *_localctx = _tracker.createInstance<Select_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 274, TSqlParser::RuleSelect_list_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2770);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2760);
      asterisk();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2761);
      column_elem();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2762);
      udt_elem();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2763);
      match(TSqlParser::LOCAL_ID);
      setState(2766);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2764);
          assignment_operator();
          break;
        }

        case TSqlParser::EQUAL: {
          setState(2765);
          match(TSqlParser::EQUAL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2768);
      expression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2769);
      expression_elem();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourcesContext ------------------------------------------------------------------

TSqlParser::Table_sourcesContext::Table_sourcesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Table_sourceContext *> TSqlParser::Table_sourcesContext::table_source() {
  return getRuleContexts<TSqlParser::Table_sourceContext>();
}

TSqlParser::Table_sourceContext* TSqlParser::Table_sourcesContext::table_source(size_t i) {
  return getRuleContext<TSqlParser::Table_sourceContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_sourcesContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_sourcesContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_sourcesContext::getRuleIndex() const {
  return TSqlParser::RuleTable_sources;
}

void TSqlParser::Table_sourcesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_sources(this);
}

void TSqlParser::Table_sourcesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_sources(this);
}

TSqlParser::Table_sourcesContext* TSqlParser::table_sources() {
  Table_sourcesContext *_localctx = _tracker.createInstance<Table_sourcesContext>(_ctx, getState());
  enterRule(_localctx, 276, TSqlParser::RuleTable_sources);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2772);
    dynamic_cast<Table_sourcesContext *>(_localctx)->table_sourceContext = table_source();
    dynamic_cast<Table_sourcesContext *>(_localctx)->source.push_back(dynamic_cast<Table_sourcesContext *>(_localctx)->table_sourceContext);
    setState(2777);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2773);
      match(TSqlParser::COMMA);
      setState(2774);
      dynamic_cast<Table_sourcesContext *>(_localctx)->table_sourceContext = table_source();
      dynamic_cast<Table_sourcesContext *>(_localctx)->source.push_back(dynamic_cast<Table_sourcesContext *>(_localctx)->table_sourceContext);
      setState(2779);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourceContext ------------------------------------------------------------------

TSqlParser::Table_sourceContext::Table_sourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::Table_sourceContext::table_source_item_joined() {
  return getRuleContext<TSqlParser::Table_source_item_joinedContext>(0);
}

tree::TerminalNode* TSqlParser::Table_sourceContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Table_sourceContext::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}

tree::TerminalNode* TSqlParser::Table_sourceContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_sourceContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source;
}

void TSqlParser::Table_sourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source(this);
}

void TSqlParser::Table_sourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source(this);
}

TSqlParser::Table_sourceContext* TSqlParser::table_source() {
  Table_sourceContext *_localctx = _tracker.createInstance<Table_sourceContext>(_ctx, getState());
  enterRule(_localctx, 278, TSqlParser::RuleTable_source);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2780);
      table_source_item_joined();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2781);
      match(TSqlParser::LR_BRACKET);
      setState(2782);
      table_source();
      setState(2783);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_source_item_joinedContext ------------------------------------------------------------------

TSqlParser::Table_source_item_joinedContext::Table_source_item_joinedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_source_itemContext* TSqlParser::Table_source_item_joinedContext::table_source_item() {
  return getRuleContext<TSqlParser::Table_source_itemContext>(0);
}

std::vector<TSqlParser::Join_partContext *> TSqlParser::Table_source_item_joinedContext::join_part() {
  return getRuleContexts<TSqlParser::Join_partContext>();
}

TSqlParser::Join_partContext* TSqlParser::Table_source_item_joinedContext::join_part(size_t i) {
  return getRuleContext<TSqlParser::Join_partContext>(i);
}

tree::TerminalNode* TSqlParser::Table_source_item_joinedContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::Table_source_item_joinedContext::table_source_item_joined() {
  return getRuleContext<TSqlParser::Table_source_item_joinedContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_item_joinedContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_source_item_joinedContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source_item_joined;
}

void TSqlParser::Table_source_item_joinedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source_item_joined(this);
}

void TSqlParser::Table_source_item_joinedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source_item_joined(this);
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::table_source_item_joined() {
  Table_source_item_joinedContext *_localctx = _tracker.createInstance<Table_source_item_joinedContext>(_ctx, getState());
  enterRule(_localctx, 280, TSqlParser::RuleTable_source_item_joined);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2787);
      table_source_item();
      setState(2791);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2788);
          dynamic_cast<Table_source_item_joinedContext *>(_localctx)->join_partContext = join_part();
          dynamic_cast<Table_source_item_joinedContext *>(_localctx)->joins.push_back(dynamic_cast<Table_source_item_joinedContext *>(_localctx)->join_partContext); 
        }
        setState(2793);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2794);
      match(TSqlParser::LR_BRACKET);
      setState(2795);
      table_source_item_joined();
      setState(2796);
      match(TSqlParser::RR_BRACKET);
      setState(2800);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2797);
          dynamic_cast<Table_source_item_joinedContext *>(_localctx)->join_partContext = join_part();
          dynamic_cast<Table_source_item_joinedContext *>(_localctx)->joins.push_back(dynamic_cast<Table_source_item_joinedContext *>(_localctx)->join_partContext); 
        }
        setState(2802);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_source_itemContext ------------------------------------------------------------------

TSqlParser::Table_source_itemContext::Table_source_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::As_table_aliasContext* TSqlParser::Table_source_itemContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}

TSqlParser::Table_name_with_hintContext* TSqlParser::Table_source_itemContext::table_name_with_hint() {
  return getRuleContext<TSqlParser::Table_name_with_hintContext>(0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Table_source_itemContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Derived_tableContext* TSqlParser::Table_source_itemContext::derived_table() {
  return getRuleContext<TSqlParser::Derived_tableContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Column_alias_listContext* TSqlParser::Table_source_itemContext::column_alias_list() {
  return getRuleContext<TSqlParser::Column_alias_listContext>(0);
}

TSqlParser::Change_tableContext* TSqlParser::Table_source_itemContext::change_table() {
  return getRuleContext<TSqlParser::Change_tableContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::Table_source_itemContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

TSqlParser::Nodes_methodContext* TSqlParser::Table_source_itemContext::nodes_method() {
  return getRuleContext<TSqlParser::Nodes_methodContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::DOUBLE_COLON() {
  return getToken(TSqlParser::DOUBLE_COLON, 0);
}


size_t TSqlParser::Table_source_itemContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source_item;
}

void TSqlParser::Table_source_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source_item(this);
}

void TSqlParser::Table_source_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source_item(this);
}

TSqlParser::Table_source_itemContext* TSqlParser::table_source_item() {
  Table_source_itemContext *_localctx = _tracker.createInstance<Table_source_itemContext>(_ctx, getState());
  enterRule(_localctx, 282, TSqlParser::RuleTable_source_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2858);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2805);
      dynamic_cast<Table_source_itemContext *>(_localctx)->loc_id = match(TSqlParser::LOCAL_ID);
      setState(2807);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx)) {
      case 1: {
        setState(2806);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2809);
      table_name_with_hint();
      setState(2811);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx)) {
      case 1: {
        setState(2810);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2813);
      full_table_name();
      setState(2815);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx)) {
      case 1: {
        setState(2814);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2817);
      match(TSqlParser::LR_BRACKET);
      setState(2818);
      derived_table();
      setState(2819);
      match(TSqlParser::RR_BRACKET);
      setState(2824);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx)) {
      case 1: {
        setState(2820);
        as_table_alias();
        setState(2822);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx)) {
        case 1: {
          setState(2821);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2826);
      change_table();
      setState(2828);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx)) {
      case 1: {
        setState(2827);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2830);
      function_call();
      setState(2835);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx)) {
      case 1: {
        setState(2831);
        as_table_alias();
        setState(2833);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx)) {
        case 1: {
          setState(2832);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2837);
      nodes_method();
      setState(2842);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx)) {
      case 1: {
        setState(2838);
        as_table_alias();
        setState(2840);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx)) {
        case 1: {
          setState(2839);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2844);
      dynamic_cast<Table_source_itemContext *>(_localctx)->loc_id_call = match(TSqlParser::LOCAL_ID);
      setState(2845);
      match(TSqlParser::DOT);
      setState(2846);
      dynamic_cast<Table_source_itemContext *>(_localctx)->loc_fcall = function_call();
      setState(2851);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx)) {
      case 1: {
        setState(2847);
        as_table_alias();
        setState(2849);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
        case 1: {
          setState(2848);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2853);
      match(TSqlParser::DOUBLE_COLON);
      setState(2854);
      dynamic_cast<Table_source_itemContext *>(_localctx)->oldstyle_fcall = function_call();
      setState(2856);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
      case 1: {
        setState(2855);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_declarationContext ------------------------------------------------------------------

TSqlParser::Schema_declarationContext::Schema_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Column_declarationContext *> TSqlParser::Schema_declarationContext::column_declaration() {
  return getRuleContexts<TSqlParser::Column_declarationContext>();
}

TSqlParser::Column_declarationContext* TSqlParser::Schema_declarationContext::column_declaration(size_t i) {
  return getRuleContext<TSqlParser::Column_declarationContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Schema_declarationContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Schema_declarationContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Schema_declarationContext::getRuleIndex() const {
  return TSqlParser::RuleSchema_declaration;
}

void TSqlParser::Schema_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_declaration(this);
}

void TSqlParser::Schema_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_declaration(this);
}

TSqlParser::Schema_declarationContext* TSqlParser::schema_declaration() {
  Schema_declarationContext *_localctx = _tracker.createInstance<Schema_declarationContext>(_ctx, getState());
  enterRule(_localctx, 284, TSqlParser::RuleSchema_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2860);
    dynamic_cast<Schema_declarationContext *>(_localctx)->column_declarationContext = column_declaration();
    dynamic_cast<Schema_declarationContext *>(_localctx)->xml_col.push_back(dynamic_cast<Schema_declarationContext *>(_localctx)->column_declarationContext);
    setState(2865);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2861);
      match(TSqlParser::COMMA);
      setState(2862);
      dynamic_cast<Schema_declarationContext *>(_localctx)->column_declarationContext = column_declaration();
      dynamic_cast<Schema_declarationContext *>(_localctx)->xml_col.push_back(dynamic_cast<Schema_declarationContext *>(_localctx)->column_declarationContext);
      setState(2867);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_declarationContext ------------------------------------------------------------------

TSqlParser::Column_declarationContext::Column_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Column_declarationContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Data_typeContext* TSqlParser::Column_declarationContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Column_declarationContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Column_declarationContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_declaration;
}

void TSqlParser::Column_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_declaration(this);
}

void TSqlParser::Column_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_declaration(this);
}

TSqlParser::Column_declarationContext* TSqlParser::column_declaration() {
  Column_declarationContext *_localctx = _tracker.createInstance<Column_declarationContext>(_ctx, getState());
  enterRule(_localctx, 286, TSqlParser::RuleColumn_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2868);
    id_();
    setState(2869);
    data_type();
    setState(2871);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::STRING) {
      setState(2870);
      match(TSqlParser::STRING);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_tableContext ------------------------------------------------------------------

TSqlParser::Change_tableContext::Change_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Change_table_changesContext* TSqlParser::Change_tableContext::change_table_changes() {
  return getRuleContext<TSqlParser::Change_table_changesContext>(0);
}

TSqlParser::Change_table_versionContext* TSqlParser::Change_tableContext::change_table_version() {
  return getRuleContext<TSqlParser::Change_table_versionContext>(0);
}


size_t TSqlParser::Change_tableContext::getRuleIndex() const {
  return TSqlParser::RuleChange_table;
}

void TSqlParser::Change_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange_table(this);
}

void TSqlParser::Change_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange_table(this);
}

TSqlParser::Change_tableContext* TSqlParser::change_table() {
  Change_tableContext *_localctx = _tracker.createInstance<Change_tableContext>(_ctx, getState());
  enterRule(_localctx, 288, TSqlParser::RuleChange_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2875);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2873);
      change_table_changes();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2874);
      change_table_version();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_table_changesContext ------------------------------------------------------------------

TSqlParser::Change_table_changesContext::Change_table_changesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::CHANGETABLE() {
  return getToken(TSqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::CHANGES() {
  return getToken(TSqlParser::CHANGES, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Change_table_changesContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Change_table_changesContext::getRuleIndex() const {
  return TSqlParser::RuleChange_table_changes;
}

void TSqlParser::Change_table_changesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange_table_changes(this);
}

void TSqlParser::Change_table_changesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange_table_changes(this);
}

TSqlParser::Change_table_changesContext* TSqlParser::change_table_changes() {
  Change_table_changesContext *_localctx = _tracker.createInstance<Change_table_changesContext>(_ctx, getState());
  enterRule(_localctx, 290, TSqlParser::RuleChange_table_changes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2877);
    match(TSqlParser::CHANGETABLE);
    setState(2878);
    match(TSqlParser::LR_BRACKET);
    setState(2879);
    match(TSqlParser::CHANGES);
    setState(2880);
    dynamic_cast<Change_table_changesContext *>(_localctx)->changetable = table_name();
    setState(2881);
    match(TSqlParser::COMMA);
    setState(2882);
    dynamic_cast<Change_table_changesContext *>(_localctx)->changesid = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::NULL_ || _la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
      dynamic_cast<Change_table_changesContext *>(_localctx)->changesid = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2883);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_table_versionContext ------------------------------------------------------------------

TSqlParser::Change_table_versionContext::Change_table_versionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::CHANGETABLE() {
  return getToken(TSqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::VERSION() {
  return getToken(TSqlParser::VERSION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Change_table_versionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Change_table_versionContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::Full_column_name_listContext* TSqlParser::Change_table_versionContext::full_column_name_list() {
  return getRuleContext<TSqlParser::Full_column_name_listContext>(0);
}

TSqlParser::Select_listContext* TSqlParser::Change_table_versionContext::select_list() {
  return getRuleContext<TSqlParser::Select_listContext>(0);
}


size_t TSqlParser::Change_table_versionContext::getRuleIndex() const {
  return TSqlParser::RuleChange_table_version;
}

void TSqlParser::Change_table_versionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange_table_version(this);
}

void TSqlParser::Change_table_versionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange_table_version(this);
}

TSqlParser::Change_table_versionContext* TSqlParser::change_table_version() {
  Change_table_versionContext *_localctx = _tracker.createInstance<Change_table_versionContext>(_ctx, getState());
  enterRule(_localctx, 292, TSqlParser::RuleChange_table_version);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2885);
    match(TSqlParser::CHANGETABLE);
    setState(2886);
    match(TSqlParser::LR_BRACKET);
    setState(2887);
    match(TSqlParser::VERSION);
    setState(2888);
    dynamic_cast<Change_table_versionContext *>(_localctx)->versiontable = table_name();
    setState(2889);
    match(TSqlParser::COMMA);
    setState(2890);
    dynamic_cast<Change_table_versionContext *>(_localctx)->pk_columns = full_column_name_list();
    setState(2891);
    match(TSqlParser::COMMA);
    setState(2892);
    dynamic_cast<Change_table_versionContext *>(_localctx)->pk_values = select_list();
    setState(2893);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_partContext ------------------------------------------------------------------

TSqlParser::Join_partContext::Join_partContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Join_onContext* TSqlParser::Join_partContext::join_on() {
  return getRuleContext<TSqlParser::Join_onContext>(0);
}

TSqlParser::Cross_joinContext* TSqlParser::Join_partContext::cross_join() {
  return getRuleContext<TSqlParser::Cross_joinContext>(0);
}

TSqlParser::Apply_Context* TSqlParser::Join_partContext::apply_() {
  return getRuleContext<TSqlParser::Apply_Context>(0);
}

TSqlParser::PivotContext* TSqlParser::Join_partContext::pivot() {
  return getRuleContext<TSqlParser::PivotContext>(0);
}

TSqlParser::UnpivotContext* TSqlParser::Join_partContext::unpivot() {
  return getRuleContext<TSqlParser::UnpivotContext>(0);
}


size_t TSqlParser::Join_partContext::getRuleIndex() const {
  return TSqlParser::RuleJoin_part;
}

void TSqlParser::Join_partContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_part(this);
}

void TSqlParser::Join_partContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_part(this);
}

TSqlParser::Join_partContext* TSqlParser::join_part() {
  Join_partContext *_localctx = _tracker.createInstance<Join_partContext>(_ctx, getState());
  enterRule(_localctx, 294, TSqlParser::RuleJoin_part);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2900);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2895);
      join_on();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2896);
      cross_join();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2897);
      apply_();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2898);
      pivot();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2899);
      unpivot();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_onContext ------------------------------------------------------------------

TSqlParser::Join_onContext::Join_onContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Join_onContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Join_onContext::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}

TSqlParser::Search_conditionContext* TSqlParser::Join_onContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Join_onContext::LEFT() {
  return getToken(TSqlParser::LEFT, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::RIGHT() {
  return getToken(TSqlParser::RIGHT, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::FULL() {
  return getToken(TSqlParser::FULL, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::REMOTE() {
  return getToken(TSqlParser::REMOTE, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::INNER() {
  return getToken(TSqlParser::INNER, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::OUTER() {
  return getToken(TSqlParser::OUTER, 0);
}


size_t TSqlParser::Join_onContext::getRuleIndex() const {
  return TSqlParser::RuleJoin_on;
}

void TSqlParser::Join_onContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_on(this);
}

void TSqlParser::Join_onContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_on(this);
}

TSqlParser::Join_onContext* TSqlParser::join_on() {
  Join_onContext *_localctx = _tracker.createInstance<Join_onContext>(_ctx, getState());
  enterRule(_localctx, 296, TSqlParser::RuleJoin_on);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2909);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::INNER:
      case TSqlParser::JOIN:
      case TSqlParser::MERGE:
      case TSqlParser::HASH:
      case TSqlParser::LOOP:
      case TSqlParser::REMOTE: {
        setState(2903);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::INNER) {
          setState(2902);
          dynamic_cast<Join_onContext *>(_localctx)->inner = match(TSqlParser::INNER);
        }
        break;
      }

      case TSqlParser::FULL:
      case TSqlParser::LEFT:
      case TSqlParser::RIGHT: {
        setState(2905);
        dynamic_cast<Join_onContext *>(_localctx)->join_type = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & ((1ULL << (TSqlParser::FULL - 85))
          | (1ULL << (TSqlParser::LEFT - 85))
          | (1ULL << (TSqlParser::RIGHT - 85)))) != 0))) {
          dynamic_cast<Join_onContext *>(_localctx)->join_type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2907);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OUTER) {
          setState(2906);
          dynamic_cast<Join_onContext *>(_localctx)->outer = match(TSqlParser::OUTER);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2912);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::MERGE || _la == TSqlParser::HASH

    || _la == TSqlParser::LOOP || _la == TSqlParser::REMOTE) {
      setState(2911);
      dynamic_cast<Join_onContext *>(_localctx)->join_hint = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::HASH

      || _la == TSqlParser::LOOP || _la == TSqlParser::REMOTE)) {
        dynamic_cast<Join_onContext *>(_localctx)->join_hint = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2914);
    match(TSqlParser::JOIN);
    setState(2915);
    dynamic_cast<Join_onContext *>(_localctx)->source = table_source();
    setState(2916);
    match(TSqlParser::ON);
    setState(2917);
    dynamic_cast<Join_onContext *>(_localctx)->cond = search_condition(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cross_joinContext ------------------------------------------------------------------

TSqlParser::Cross_joinContext::Cross_joinContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cross_joinContext::CROSS() {
  return getToken(TSqlParser::CROSS, 0);
}

tree::TerminalNode* TSqlParser::Cross_joinContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Cross_joinContext::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}


size_t TSqlParser::Cross_joinContext::getRuleIndex() const {
  return TSqlParser::RuleCross_join;
}

void TSqlParser::Cross_joinContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCross_join(this);
}

void TSqlParser::Cross_joinContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCross_join(this);
}

TSqlParser::Cross_joinContext* TSqlParser::cross_join() {
  Cross_joinContext *_localctx = _tracker.createInstance<Cross_joinContext>(_ctx, getState());
  enterRule(_localctx, 298, TSqlParser::RuleCross_join);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2919);
    match(TSqlParser::CROSS);
    setState(2920);
    match(TSqlParser::JOIN);
    setState(2921);
    table_source();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Apply_Context ------------------------------------------------------------------

TSqlParser::Apply_Context::Apply_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Apply_Context::APPLY() {
  return getToken(TSqlParser::APPLY, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Apply_Context::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}

tree::TerminalNode* TSqlParser::Apply_Context::CROSS() {
  return getToken(TSqlParser::CROSS, 0);
}

tree::TerminalNode* TSqlParser::Apply_Context::OUTER() {
  return getToken(TSqlParser::OUTER, 0);
}


size_t TSqlParser::Apply_Context::getRuleIndex() const {
  return TSqlParser::RuleApply_;
}

void TSqlParser::Apply_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_(this);
}

void TSqlParser::Apply_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_(this);
}

TSqlParser::Apply_Context* TSqlParser::apply_() {
  Apply_Context *_localctx = _tracker.createInstance<Apply_Context>(_ctx, getState());
  enterRule(_localctx, 300, TSqlParser::RuleApply_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2923);
    dynamic_cast<Apply_Context *>(_localctx)->apply_style = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::CROSS

    || _la == TSqlParser::OUTER)) {
      dynamic_cast<Apply_Context *>(_localctx)->apply_style = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2924);
    match(TSqlParser::APPLY);
    setState(2925);
    dynamic_cast<Apply_Context *>(_localctx)->source = table_source();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PivotContext ------------------------------------------------------------------

TSqlParser::PivotContext::PivotContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::PivotContext::PIVOT() {
  return getToken(TSqlParser::PIVOT, 0);
}

TSqlParser::Pivot_clauseContext* TSqlParser::PivotContext::pivot_clause() {
  return getRuleContext<TSqlParser::Pivot_clauseContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::PivotContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}


size_t TSqlParser::PivotContext::getRuleIndex() const {
  return TSqlParser::RulePivot;
}

void TSqlParser::PivotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPivot(this);
}

void TSqlParser::PivotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPivot(this);
}

TSqlParser::PivotContext* TSqlParser::pivot() {
  PivotContext *_localctx = _tracker.createInstance<PivotContext>(_ctx, getState());
  enterRule(_localctx, 302, TSqlParser::RulePivot);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2927);
    match(TSqlParser::PIVOT);
    setState(2928);
    pivot_clause();
    setState(2929);
    as_table_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnpivotContext ------------------------------------------------------------------

TSqlParser::UnpivotContext::UnpivotContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::UnpivotContext::UNPIVOT() {
  return getToken(TSqlParser::UNPIVOT, 0);
}

TSqlParser::Unpivot_clauseContext* TSqlParser::UnpivotContext::unpivot_clause() {
  return getRuleContext<TSqlParser::Unpivot_clauseContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::UnpivotContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}


size_t TSqlParser::UnpivotContext::getRuleIndex() const {
  return TSqlParser::RuleUnpivot;
}

void TSqlParser::UnpivotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnpivot(this);
}

void TSqlParser::UnpivotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnpivot(this);
}

TSqlParser::UnpivotContext* TSqlParser::unpivot() {
  UnpivotContext *_localctx = _tracker.createInstance<UnpivotContext>(_ctx, getState());
  enterRule(_localctx, 304, TSqlParser::RuleUnpivot);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2931);
    match(TSqlParser::UNPIVOT);
    setState(2932);
    unpivot_clause();
    setState(2933);
    as_table_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pivot_clauseContext ------------------------------------------------------------------

TSqlParser::Pivot_clauseContext::Pivot_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::Pivot_clauseContext::aggregate_windowed_function() {
  return getRuleContext<TSqlParser::Aggregate_windowed_functionContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Pivot_clauseContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Column_alias_listContext* TSqlParser::Pivot_clauseContext::column_alias_list() {
  return getRuleContext<TSqlParser::Column_alias_listContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Pivot_clauseContext::getRuleIndex() const {
  return TSqlParser::RulePivot_clause;
}

void TSqlParser::Pivot_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPivot_clause(this);
}

void TSqlParser::Pivot_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPivot_clause(this);
}

TSqlParser::Pivot_clauseContext* TSqlParser::pivot_clause() {
  Pivot_clauseContext *_localctx = _tracker.createInstance<Pivot_clauseContext>(_ctx, getState());
  enterRule(_localctx, 306, TSqlParser::RulePivot_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2935);
    match(TSqlParser::LR_BRACKET);
    setState(2936);
    aggregate_windowed_function();
    setState(2937);
    match(TSqlParser::FOR);
    setState(2938);
    full_column_name();
    setState(2939);
    match(TSqlParser::IN);
    setState(2940);
    column_alias_list();
    setState(2941);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unpivot_clauseContext ------------------------------------------------------------------

TSqlParser::Unpivot_clauseContext::Unpivot_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Unpivot_clauseContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Unpivot_clauseContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Full_column_name_listContext* TSqlParser::Unpivot_clauseContext::full_column_name_list() {
  return getRuleContext<TSqlParser::Full_column_name_listContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Unpivot_clauseContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::ExpressionContext* TSqlParser::Unpivot_clauseContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Unpivot_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleUnpivot_clause;
}

void TSqlParser::Unpivot_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnpivot_clause(this);
}

void TSqlParser::Unpivot_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnpivot_clause(this);
}

TSqlParser::Unpivot_clauseContext* TSqlParser::unpivot_clause() {
  Unpivot_clauseContext *_localctx = _tracker.createInstance<Unpivot_clauseContext>(_ctx, getState());
  enterRule(_localctx, 308, TSqlParser::RuleUnpivot_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2943);
    match(TSqlParser::LR_BRACKET);
    setState(2944);
    dynamic_cast<Unpivot_clauseContext *>(_localctx)->unpivot_exp = expression(0);
    setState(2945);
    match(TSqlParser::FOR);
    setState(2946);
    full_column_name();
    setState(2947);
    match(TSqlParser::IN);
    setState(2948);
    match(TSqlParser::LR_BRACKET);
    setState(2949);
    full_column_name_list();
    setState(2950);
    match(TSqlParser::RR_BRACKET);
    setState(2951);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_column_name_listContext ------------------------------------------------------------------

TSqlParser::Full_column_name_listContext::Full_column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Full_column_nameContext *> TSqlParser::Full_column_name_listContext::full_column_name() {
  return getRuleContexts<TSqlParser::Full_column_nameContext>();
}

TSqlParser::Full_column_nameContext* TSqlParser::Full_column_name_listContext::full_column_name(size_t i) {
  return getRuleContext<TSqlParser::Full_column_nameContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Full_column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Full_column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Full_column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleFull_column_name_list;
}

void TSqlParser::Full_column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_column_name_list(this);
}

void TSqlParser::Full_column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_column_name_list(this);
}

TSqlParser::Full_column_name_listContext* TSqlParser::full_column_name_list() {
  Full_column_name_listContext *_localctx = _tracker.createInstance<Full_column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 310, TSqlParser::RuleFull_column_name_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2953);
    dynamic_cast<Full_column_name_listContext *>(_localctx)->full_column_nameContext = full_column_name();
    dynamic_cast<Full_column_name_listContext *>(_localctx)->column.push_back(dynamic_cast<Full_column_name_listContext *>(_localctx)->full_column_nameContext);
    setState(2958);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2954);
        match(TSqlParser::COMMA);
        setState(2955);
        dynamic_cast<Full_column_name_listContext *>(_localctx)->full_column_nameContext = full_column_name();
        dynamic_cast<Full_column_name_listContext *>(_localctx)->column.push_back(dynamic_cast<Full_column_name_listContext *>(_localctx)->full_column_nameContext); 
      }
      setState(2960);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_name_with_hintContext ------------------------------------------------------------------

TSqlParser::Table_name_with_hintContext::Table_name_with_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_nameContext* TSqlParser::Table_name_with_hintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Table_name_with_hintContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}


size_t TSqlParser::Table_name_with_hintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_name_with_hint;
}

void TSqlParser::Table_name_with_hintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name_with_hint(this);
}

void TSqlParser::Table_name_with_hintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name_with_hint(this);
}

TSqlParser::Table_name_with_hintContext* TSqlParser::table_name_with_hint() {
  Table_name_with_hintContext *_localctx = _tracker.createInstance<Table_name_with_hintContext>(_ctx, getState());
  enterRule(_localctx, 312, TSqlParser::RuleTable_name_with_hint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2961);
    table_name();
    setState(2963);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
    case 1: {
      setState(2962);
      with_table_hints();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bulk_optionContext ------------------------------------------------------------------

TSqlParser::Bulk_optionContext::Bulk_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Bulk_optionContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Bulk_optionContext::getRuleIndex() const {
  return TSqlParser::RuleBulk_option;
}

void TSqlParser::Bulk_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBulk_option(this);
}

void TSqlParser::Bulk_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBulk_option(this);
}

TSqlParser::Bulk_optionContext* TSqlParser::bulk_option() {
  Bulk_optionContext *_localctx = _tracker.createInstance<Bulk_optionContext>(_ctx, getState());
  enterRule(_localctx, 314, TSqlParser::RuleBulk_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2965);
    id_();
    setState(2966);
    match(TSqlParser::EQUAL);
    setState(2967);
    dynamic_cast<Bulk_optionContext *>(_localctx)->bulk_option_value = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::DECIMAL

    || _la == TSqlParser::STRING)) {
      dynamic_cast<Bulk_optionContext *>(_localctx)->bulk_option_value = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Derived_tableContext ------------------------------------------------------------------

TSqlParser::Derived_tableContext::Derived_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::SubqueryContext* TSqlParser::Derived_tableContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::Derived_tableContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Derived_tableContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Table_value_constructorContext* TSqlParser::Derived_tableContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}


size_t TSqlParser::Derived_tableContext::getRuleIndex() const {
  return TSqlParser::RuleDerived_table;
}

void TSqlParser::Derived_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerived_table(this);
}

void TSqlParser::Derived_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerived_table(this);
}

TSqlParser::Derived_tableContext* TSqlParser::derived_table() {
  Derived_tableContext *_localctx = _tracker.createInstance<Derived_tableContext>(_ctx, getState());
  enterRule(_localctx, 316, TSqlParser::RuleDerived_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2979);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 449, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2969);
      subquery();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2970);
      match(TSqlParser::LR_BRACKET);
      setState(2971);
      subquery();
      setState(2972);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2974);
      table_value_constructor();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2975);
      match(TSqlParser::LR_BRACKET);
      setState(2976);
      table_value_constructor();
      setState(2977);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

TSqlParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TSqlParser::Function_callContext::getRuleIndex() const {
  return TSqlParser::RuleFunction_call;
}

void TSqlParser::Function_callContext::copyFrom(Function_callContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- RANKING_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Ranking_windowed_functionContext* TSqlParser::RANKING_WINDOWED_FUNCContext::ranking_windowed_function() {
  return getRuleContext<TSqlParser::Ranking_windowed_functionContext>(0);
}

TSqlParser::RANKING_WINDOWED_FUNCContext::RANKING_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::RANKING_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRANKING_WINDOWED_FUNC(this);
}
void TSqlParser::RANKING_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRANKING_WINDOWED_FUNC(this);
}
//----------------- BUILT_IN_FUNCContext ------------------------------------------------------------------

TSqlParser::Built_in_functionsContext* TSqlParser::BUILT_IN_FUNCContext::built_in_functions() {
  return getRuleContext<TSqlParser::Built_in_functionsContext>(0);
}

TSqlParser::BUILT_IN_FUNCContext::BUILT_IN_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::BUILT_IN_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBUILT_IN_FUNC(this);
}
void TSqlParser::BUILT_IN_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBUILT_IN_FUNC(this);
}
//----------------- ANALYTIC_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Analytic_windowed_functionContext* TSqlParser::ANALYTIC_WINDOWED_FUNCContext::analytic_windowed_function() {
  return getRuleContext<TSqlParser::Analytic_windowed_functionContext>(0);
}

TSqlParser::ANALYTIC_WINDOWED_FUNCContext::ANALYTIC_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::ANALYTIC_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterANALYTIC_WINDOWED_FUNC(this);
}
void TSqlParser::ANALYTIC_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitANALYTIC_WINDOWED_FUNC(this);
}
//----------------- SCALAR_FUNCTIONContext ------------------------------------------------------------------

TSqlParser::Scalar_function_nameContext* TSqlParser::SCALAR_FUNCTIONContext::scalar_function_name() {
  return getRuleContext<TSqlParser::Scalar_function_nameContext>(0);
}

tree::TerminalNode* TSqlParser::SCALAR_FUNCTIONContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::SCALAR_FUNCTIONContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::SCALAR_FUNCTIONContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

TSqlParser::SCALAR_FUNCTIONContext::SCALAR_FUNCTIONContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::SCALAR_FUNCTIONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSCALAR_FUNCTION(this);
}
void TSqlParser::SCALAR_FUNCTIONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSCALAR_FUNCTION(this);
}
//----------------- PARTITION_FUNCContext ------------------------------------------------------------------

TSqlParser::Partition_functionContext* TSqlParser::PARTITION_FUNCContext::partition_function() {
  return getRuleContext<TSqlParser::Partition_functionContext>(0);
}

TSqlParser::PARTITION_FUNCContext::PARTITION_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::PARTITION_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPARTITION_FUNC(this);
}
void TSqlParser::PARTITION_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPARTITION_FUNC(this);
}
//----------------- AGGREGATE_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::AGGREGATE_WINDOWED_FUNCContext::aggregate_windowed_function() {
  return getRuleContext<TSqlParser::Aggregate_windowed_functionContext>(0);
}

TSqlParser::AGGREGATE_WINDOWED_FUNCContext::AGGREGATE_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::AGGREGATE_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAGGREGATE_WINDOWED_FUNC(this);
}
void TSqlParser::AGGREGATE_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAGGREGATE_WINDOWED_FUNC(this);
}
TSqlParser::Function_callContext* TSqlParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 318, TSqlParser::RuleFunction_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2993);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 451, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::RANKING_WINDOWED_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(2981);
      ranking_windowed_function();
      break;
    }

    case 2: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::AGGREGATE_WINDOWED_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(2982);
      aggregate_windowed_function();
      break;
    }

    case 3: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::ANALYTIC_WINDOWED_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(2983);
      analytic_windowed_function();
      break;
    }

    case 4: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::BUILT_IN_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 4);
      setState(2984);
      built_in_functions();
      break;
    }

    case 5: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::SCALAR_FUNCTIONContext>(_localctx));
      enterOuterAlt(_localctx, 5);
      setState(2985);
      scalar_function_name();
      setState(2986);
      match(TSqlParser::LR_BRACKET);
      setState(2988);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::ABS)
        | (1ULL << TSqlParser::ASCII)
        | (1ULL << TSqlParser::CEILING)
        | (1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::CHARINDEX)
        | (1ULL << TSqlParser::DATALENGTH)
        | (1ULL << TSqlParser::DAY)
        | (1ULL << TSqlParser::FLOOR)
        | (1ULL << TSqlParser::ISDATE)
        | (1ULL << TSqlParser::ISNUMERIC)
        | (1ULL << TSqlParser::LEN)
        | (1ULL << TSqlParser::LOWER)
        | (1ULL << TSqlParser::LTRIM)
        | (1ULL << TSqlParser::MONTH)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::PATINDEX)
        | (1ULL << TSqlParser::RAND)
        | (1ULL << TSqlParser::REPLACE)
        | (1ULL << TSqlParser::ROUND)
        | (1ULL << TSqlParser::RTRIM)
        | (1ULL << TSqlParser::SIGN)
        | (1ULL << TSqlParser::STR)
        | (1ULL << TSqlParser::SUBSTRING)
        | (1ULL << TSqlParser::UPPER)
        | (1ULL << TSqlParser::USER_NAME)
        | (1ULL << TSqlParser::YEAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT)
        | (1ULL << TSqlParser::CASE)
        | (1ULL << TSqlParser::COALESCE)
        | (1ULL << TSqlParser::CONVERT)
        | (1ULL << TSqlParser::CURRENT_TIMESTAMP)
        | (1ULL << TSqlParser::CURRENT_USER))) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & ((1ULL << (TSqlParser::DEFAULT - 66))
        | (1ULL << (TSqlParser::IDENTITY - 66))
        | (1ULL << (TSqlParser::LEFT - 66))
        | (1ULL << (TSqlParser::NULL_ - 66))
        | (1ULL << (TSqlParser::NULLIF - 66))
        | (1ULL << (TSqlParser::OVER - 66))
        | (1ULL << (TSqlParser::PRECISION - 66)))) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 133)) & ((1ULL << (TSqlParser::RIGHT - 133))
        | (1ULL << (TSqlParser::SESSION_USER - 133))
        | (1ULL << (TSqlParser::SYSTEM_USER - 133))
        | (1ULL << (TSqlParser::USER - 133))
        | (1ULL << (TSqlParser::DOLLAR_PARTITION - 133))
        | (1ULL << (TSqlParser::ABSOLUTE - 133))
        | (1ULL << (TSqlParser::AT_KEYWORD - 133))
        | (1ULL << (TSqlParser::ACTION - 133))
        | (1ULL << (TSqlParser::AES_128 - 133))
        | (1ULL << (TSqlParser::AES_192 - 133))
        | (1ULL << (TSqlParser::AES_256 - 133))
        | (1ULL << (TSqlParser::ALGORITHM - 133))
        | (1ULL << (TSqlParser::ANSI_NULLS - 133))
        | (1ULL << (TSqlParser::ANSI_PADDING - 133))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 133))
        | (1ULL << (TSqlParser::APPLY - 133))
        | (1ULL << (TSqlParser::ARITHABORT - 133))
        | (1ULL << (TSqlParser::AUTO - 133))
        | (1ULL << (TSqlParser::AVG - 133))
        | (1ULL << (TSqlParser::BIGINT - 133))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 133))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 133))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 133))
        | (1ULL << (TSqlParser::CALLER - 133))
        | (1ULL << (TSqlParser::CAST - 133))
        | (1ULL << (TSqlParser::TRY_CAST - 133))
        | (1ULL << (TSqlParser::CATCH - 133))
        | (1ULL << (TSqlParser::CHECKSUM - 133))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 133))
        | (1ULL << (TSqlParser::COMMITTED - 133))
        | (1ULL << (TSqlParser::CONCAT - 133))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 133))
        | (1ULL << (TSqlParser::COUNT - 133))
        | (1ULL << (TSqlParser::COUNT_BIG - 133))
        | (1ULL << (TSqlParser::CUME_DIST - 133))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 133)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 197)) & ((1ULL << (TSqlParser::CURSOR_DEFAULT - 197))
        | (1ULL << (TSqlParser::DATA - 197))
        | (1ULL << (TSqlParser::DATEADD - 197))
        | (1ULL << (TSqlParser::DATEDIFF - 197))
        | (1ULL << (TSqlParser::DATENAME - 197))
        | (1ULL << (TSqlParser::DATEPART - 197))
        | (1ULL << (TSqlParser::DAYS - 197))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 197))
        | (1ULL << (TSqlParser::DELAY - 197))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 197))
        | (1ULL << (TSqlParser::DELETED - 197))
        | (1ULL << (TSqlParser::DENSE_RANK - 197))
        | (1ULL << (TSqlParser::DES - 197))
        | (1ULL << (TSqlParser::DESCRIPTION - 197))
        | (1ULL << (TSqlParser::DESX - 197))
        | (1ULL << (TSqlParser::DISABLE - 197))
        | (1ULL << (TSqlParser::DYNAMIC - 197))
        | (1ULL << (TSqlParser::ELEMENTS - 197))
        | (1ULL << (TSqlParser::EMPTY - 197))
        | (1ULL << (TSqlParser::ENCRYPTION - 197))
        | (1ULL << (TSqlParser::EXCLUSIVE - 197))
        | (1ULL << (TSqlParser::FAST - 197))
        | (1ULL << (TSqlParser::FAST_FORWARD - 197))
        | (1ULL << (TSqlParser::FIRST - 197))
        | (1ULL << (TSqlParser::FIRST_VALUE - 197))
        | (1ULL << (TSqlParser::FOLLOWING - 197))
        | (1ULL << (TSqlParser::FORCE - 197))
        | (1ULL << (TSqlParser::FORCED - 197))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 197))
        | (1ULL << (TSqlParser::GETDATE - 197))
        | (1ULL << (TSqlParser::GETUTCDATE - 197))
        | (1ULL << (TSqlParser::GLOBAL - 197))
        | (1ULL << (TSqlParser::GO_BATCH - 197))
        | (1ULL << (TSqlParser::GO - 197))
        | (1ULL << (TSqlParser::GROUPING - 197))
        | (1ULL << (TSqlParser::GROUPING_ID - 197))
        | (1ULL << (TSqlParser::HASH - 197))
        | (1ULL << (TSqlParser::HIGH - 197))
        | (1ULL << (TSqlParser::HOURS - 197))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 197))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 197))
        | (1ULL << (TSqlParser::INPUT - 197))
        | (1ULL << (TSqlParser::INSENSITIVE - 197))
        | (1ULL << (TSqlParser::INSERTED - 197))
        | (1ULL << (TSqlParser::INT - 197))
        | (1ULL << (TSqlParser::ISOLATION - 197))
        | (1ULL << (TSqlParser::KEEP - 197))
        | (1ULL << (TSqlParser::KEEPFIXED - 197))
        | (1ULL << (TSqlParser::KEYSET - 197))
        | (1ULL << (TSqlParser::LAG - 197))
        | (1ULL << (TSqlParser::LAST - 197))
        | (1ULL << (TSqlParser::LAST_VALUE - 197))
        | (1ULL << (TSqlParser::LEAD - 197))
        | (1ULL << (TSqlParser::LEVEL - 197))
        | (1ULL << (TSqlParser::LOCAL - 197))
        | (1ULL << (TSqlParser::LOCATION - 197))
        | (1ULL << (TSqlParser::LOCK - 197))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 197))
        | (1ULL << (TSqlParser::LOOP - 197))
        | (1ULL << (TSqlParser::LOW - 197))
        | (1ULL << (TSqlParser::MANUAL - 197))
        | (1ULL << (TSqlParser::MARK - 197))
        | (1ULL << (TSqlParser::MAX - 197))
        | (1ULL << (TSqlParser::MAXDOP - 197)))) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 261)) & ((1ULL << (TSqlParser::MAXRECURSION - 261))
        | (1ULL << (TSqlParser::MIN - 261))
        | (1ULL << (TSqlParser::MIN_ACTIVE_ROWVERSION - 261))
        | (1ULL << (TSqlParser::MINUTES - 261))
        | (1ULL << (TSqlParser::MODE - 261))
        | (1ULL << (TSqlParser::NEXT - 261))
        | (1ULL << (TSqlParser::NO - 261))
        | (1ULL << (TSqlParser::NOCOUNT - 261))
        | (1ULL << (TSqlParser::NODES - 261))
        | (1ULL << (TSqlParser::NOEXPAND - 261))
        | (1ULL << (TSqlParser::NOWAIT - 261))
        | (1ULL << (TSqlParser::NTILE - 261))
        | (1ULL << (TSqlParser::NUMANODE - 261))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 261))
        | (1ULL << (TSqlParser::OBJECT - 261))
        | (1ULL << (TSqlParser::OFFSET - 261))
        | (1ULL << (TSqlParser::ONLINE - 261))
        | (1ULL << (TSqlParser::ONLY - 261))
        | (1ULL << (TSqlParser::OPTIMISTIC - 261))
        | (1ULL << (TSqlParser::OPTIMIZE - 261))
        | (1ULL << (TSqlParser::OUT - 261))
        | (1ULL << (TSqlParser::OUTPUT - 261))
        | (1ULL << (TSqlParser::OWNER - 261))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 261))
        | (1ULL << (TSqlParser::PARTITION - 261))
        | (1ULL << (TSqlParser::PARTITIONS - 261))
        | (1ULL << (TSqlParser::PERCENT_RANK - 261))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 261))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 261))
        | (1ULL << (TSqlParser::PRECEDING - 261))
        | (1ULL << (TSqlParser::PRIOR - 261))
        | (1ULL << (TSqlParser::QUERY - 261))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 261))
        | (1ULL << (TSqlParser::RANGE - 261))
        | (1ULL << (TSqlParser::RANK - 261))
        | (1ULL << (TSqlParser::RC2 - 261))
        | (1ULL << (TSqlParser::RC4 - 261))
        | (1ULL << (TSqlParser::RC4_128 - 261))
        | (1ULL << (TSqlParser::READ_ONLY - 261))
        | (1ULL << (TSqlParser::READONLY - 261))
        | (1ULL << (TSqlParser::REBUILD - 261))
        | (1ULL << (TSqlParser::RECOMPILE - 261))
        | (1ULL << (TSqlParser::RELATIVE - 261))
        | (1ULL << (TSqlParser::REMOTE - 261))
        | (1ULL << (TSqlParser::REPEATABLE - 261))
        | (1ULL << (TSqlParser::ROBUST - 261))
        | (1ULL << (TSqlParser::ROW - 261))
        | (1ULL << (TSqlParser::ROW_NUMBER - 261))
        | (1ULL << (TSqlParser::ROWGUID - 261))
        | (1ULL << (TSqlParser::ROWS - 261))
        | (1ULL << (TSqlParser::SCHEMABINDING - 261))
        | (1ULL << (TSqlParser::SCROLL - 261))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 261))
        | (1ULL << (TSqlParser::SECONDS - 261))
        | (1ULL << (TSqlParser::SELF - 261))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 261))
        | (1ULL << (TSqlParser::SEQUENCE - 261))
        | (1ULL << (TSqlParser::SERIALIZABLE - 261))
        | (1ULL << (TSqlParser::SETERROR - 261))
        | (1ULL << (TSqlParser::SHARE - 261))
        | (1ULL << (TSqlParser::SIMPLE - 261))
        | (1ULL << (TSqlParser::SIZE - 261))
        | (1ULL << (TSqlParser::SMALLINT - 261))
        | (1ULL << (TSqlParser::SNAPSHOT - 261)))) != 0) || ((((_la - 325) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 325)) & ((1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 325))
        | (1ULL << (TSqlParser::STATIC - 325))
        | (1ULL << (TSqlParser::STATUSONLY - 325))
        | (1ULL << (TSqlParser::STDEV - 325))
        | (1ULL << (TSqlParser::STDEVP - 325))
        | (1ULL << (TSqlParser::STRING_AGG - 325))
        | (1ULL << (TSqlParser::STUFF - 325))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 325))
        | (1ULL << (TSqlParser::SUM - 325))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 325))
        | (1ULL << (TSqlParser::THROW - 325))
        | (1ULL << (TSqlParser::TIES - 325))
        | (1ULL << (TSqlParser::TIME - 325))
        | (1ULL << (TSqlParser::TIMEOUT - 325))
        | (1ULL << (TSqlParser::TINYINT - 325))
        | (1ULL << (TSqlParser::TRIPLE_DES - 325))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 325))
        | (1ULL << (TSqlParser::TRY - 325))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 325))
        | (1ULL << (TSqlParser::TYPE - 325))
        | (1ULL << (TSqlParser::TYPE_WARNING - 325))
        | (1ULL << (TSqlParser::UNBOUNDED - 325))
        | (1ULL << (TSqlParser::UNCOMMITTED - 325))
        | (1ULL << (TSqlParser::UNKNOWN - 325))
        | (1ULL << (TSqlParser::UOW - 325))
        | (1ULL << (TSqlParser::USING - 325))
        | (1ULL << (TSqlParser::VAR - 325))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 325))
        | (1ULL << (TSqlParser::VARP - 325))
        | (1ULL << (TSqlParser::WAIT - 325))
        | (1ULL << (TSqlParser::WORK - 325))
        | (1ULL << (TSqlParser::ZONE - 325))
        | (1ULL << (TSqlParser::DOLLAR_ACTION - 325))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 325))
        | (1ULL << (TSqlParser::CACHE - 325))
        | (1ULL << (TSqlParser::CALLED - 325))
        | (1ULL << (TSqlParser::CHANGETABLE - 325))
        | (1ULL << (TSqlParser::CHANGES - 325))
        | (1ULL << (TSqlParser::CYCLE - 325))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 325))
        | (1ULL << (TSqlParser::ERROR - 325))
        | (1ULL << (TSqlParser::FORCESEEK - 325))
        | (1ULL << (TSqlParser::IIF - 325))
        | (1ULL << (TSqlParser::INCREMENT - 325))
        | (1ULL << (TSqlParser::ISNULL - 325))
        | (1ULL << (TSqlParser::LOG - 325))
        | (1ULL << (TSqlParser::MATCHED - 325))
        | (1ULL << (TSqlParser::MAXVALUE - 325))
        | (1ULL << (TSqlParser::MINVALUE - 325))
        | (1ULL << (TSqlParser::NOTIFICATION - 325))
        | (1ULL << (TSqlParser::PERSISTED - 325))
        | (1ULL << (TSqlParser::PREDICATE - 325))
        | (1ULL << (TSqlParser::RESTART - 325))
        | (1ULL << (TSqlParser::RETURNS - 325))
        | (1ULL << (TSqlParser::SOURCE - 325))
        | (1ULL << (TSqlParser::STATE - 325))
        | (1ULL << (TSqlParser::START - 325)))) != 0) || ((((_la - 389) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 389)) & ((1ULL << (TSqlParser::TARGET - 389))
        | (1ULL << (TSqlParser::VARCHAR - 389))
        | (1ULL << (TSqlParser::NVARCHAR - 389))
        | (1ULL << (TSqlParser::SPACE - 389))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 389))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 389))
        | (1ULL << (TSqlParser::LOCAL_ID - 389))
        | (1ULL << (TSqlParser::DECIMAL - 389))
        | (1ULL << (TSqlParser::ID - 389))
        | (1ULL << (TSqlParser::STRING - 389))
        | (1ULL << (TSqlParser::BINARY - 389))
        | (1ULL << (TSqlParser::FLOAT - 389))
        | (1ULL << (TSqlParser::REAL - 389))
        | (1ULL << (TSqlParser::DOT - 389))
        | (1ULL << (TSqlParser::DOLLAR - 389))
        | (1ULL << (TSqlParser::LR_BRACKET - 389))
        | (1ULL << (TSqlParser::PLUS - 389))
        | (1ULL << (TSqlParser::MINUS - 389))
        | (1ULL << (TSqlParser::BIT_NOT - 389)))) != 0)) {
        setState(2987);
        expression_list();
      }
      setState(2990);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      _localctx = dynamic_cast<Function_callContext *>(_tracker.createInstance<TSqlParser::PARTITION_FUNCContext>(_localctx));
      enterOuterAlt(_localctx, 6);
      setState(2992);
      partition_function();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_functionContext ------------------------------------------------------------------

TSqlParser::Partition_functionContext::Partition_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Partition_functionContext::DOLLAR_PARTITION() {
  return getToken(TSqlParser::DOLLAR_PARTITION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Partition_functionContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Partition_functionContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Partition_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Partition_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Partition_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Partition_functionContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Partition_functionContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Partition_functionContext::getRuleIndex() const {
  return TSqlParser::RulePartition_function;
}

void TSqlParser::Partition_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartition_function(this);
}

void TSqlParser::Partition_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartition_function(this);
}

TSqlParser::Partition_functionContext* TSqlParser::partition_function() {
  Partition_functionContext *_localctx = _tracker.createInstance<Partition_functionContext>(_ctx, getState());
  enterRule(_localctx, 320, TSqlParser::RulePartition_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2998);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
      | (1ULL << TSqlParser::NCHAR)
      | (1ULL << TSqlParser::TEXT)
      | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
      | (1ULL << (TSqlParser::ABSOLUTE - 122))
      | (1ULL << (TSqlParser::AT_KEYWORD - 122))
      | (1ULL << (TSqlParser::ACTION - 122))
      | (1ULL << (TSqlParser::AES_128 - 122))
      | (1ULL << (TSqlParser::AES_192 - 122))
      | (1ULL << (TSqlParser::AES_256 - 122))
      | (1ULL << (TSqlParser::ALGORITHM - 122))
      | (1ULL << (TSqlParser::ANSI_NULLS - 122))
      | (1ULL << (TSqlParser::ANSI_PADDING - 122))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
      | (1ULL << (TSqlParser::APPLY - 122))
      | (1ULL << (TSqlParser::ARITHABORT - 122))
      | (1ULL << (TSqlParser::AUTO - 122))
      | (1ULL << (TSqlParser::AVG - 122))
      | (1ULL << (TSqlParser::BIGINT - 122))
      | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
      | (1ULL << (TSqlParser::CALLER - 122))
      | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
      | (1ULL << (TSqlParser::CATCH - 186))
      | (1ULL << (TSqlParser::CHECKSUM - 186))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
      | (1ULL << (TSqlParser::COMMITTED - 186))
      | (1ULL << (TSqlParser::CONCAT - 186))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
      | (1ULL << (TSqlParser::COUNT - 186))
      | (1ULL << (TSqlParser::COUNT_BIG - 186))
      | (1ULL << (TSqlParser::CUME_DIST - 186))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
      | (1ULL << (TSqlParser::DATA - 186))
      | (1ULL << (TSqlParser::DATEADD - 186))
      | (1ULL << (TSqlParser::DATEDIFF - 186))
      | (1ULL << (TSqlParser::DATENAME - 186))
      | (1ULL << (TSqlParser::DATEPART - 186))
      | (1ULL << (TSqlParser::DAYS - 186))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
      | (1ULL << (TSqlParser::DELAY - 186))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
      | (1ULL << (TSqlParser::DELETED - 186))
      | (1ULL << (TSqlParser::DENSE_RANK - 186))
      | (1ULL << (TSqlParser::DES - 186))
      | (1ULL << (TSqlParser::DESCRIPTION - 186))
      | (1ULL << (TSqlParser::DESX - 186))
      | (1ULL << (TSqlParser::DISABLE - 186))
      | (1ULL << (TSqlParser::DYNAMIC - 186))
      | (1ULL << (TSqlParser::ELEMENTS - 186))
      | (1ULL << (TSqlParser::EMPTY - 186))
      | (1ULL << (TSqlParser::ENCRYPTION - 186))
      | (1ULL << (TSqlParser::EXCLUSIVE - 186))
      | (1ULL << (TSqlParser::FAST - 186))
      | (1ULL << (TSqlParser::FAST_FORWARD - 186))
      | (1ULL << (TSqlParser::FIRST - 186))
      | (1ULL << (TSqlParser::FIRST_VALUE - 186))
      | (1ULL << (TSqlParser::FOLLOWING - 186))
      | (1ULL << (TSqlParser::FORCE - 186))
      | (1ULL << (TSqlParser::FORCED - 186))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
      | (1ULL << (TSqlParser::GETDATE - 186))
      | (1ULL << (TSqlParser::GETUTCDATE - 186))
      | (1ULL << (TSqlParser::GLOBAL - 186))
      | (1ULL << (TSqlParser::GO_BATCH - 186))
      | (1ULL << (TSqlParser::GO - 186))
      | (1ULL << (TSqlParser::GROUPING - 186))
      | (1ULL << (TSqlParser::GROUPING_ID - 186))
      | (1ULL << (TSqlParser::HASH - 186))
      | (1ULL << (TSqlParser::HIGH - 186))
      | (1ULL << (TSqlParser::HOURS - 186))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
      | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
      | (1ULL << (TSqlParser::INPUT - 186))
      | (1ULL << (TSqlParser::INSENSITIVE - 186))
      | (1ULL << (TSqlParser::INSERTED - 186))
      | (1ULL << (TSqlParser::INT - 186))
      | (1ULL << (TSqlParser::ISOLATION - 186))
      | (1ULL << (TSqlParser::KEEP - 186))
      | (1ULL << (TSqlParser::KEEPFIXED - 186))
      | (1ULL << (TSqlParser::KEYSET - 186))
      | (1ULL << (TSqlParser::LAG - 186))
      | (1ULL << (TSqlParser::LAST - 186))
      | (1ULL << (TSqlParser::LAST_VALUE - 186))
      | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
      | (1ULL << (TSqlParser::LOCAL - 250))
      | (1ULL << (TSqlParser::LOCATION - 250))
      | (1ULL << (TSqlParser::LOCK - 250))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
      | (1ULL << (TSqlParser::LOOP - 250))
      | (1ULL << (TSqlParser::LOW - 250))
      | (1ULL << (TSqlParser::MANUAL - 250))
      | (1ULL << (TSqlParser::MARK - 250))
      | (1ULL << (TSqlParser::MAX - 250))
      | (1ULL << (TSqlParser::MAXDOP - 250))
      | (1ULL << (TSqlParser::MAXRECURSION - 250))
      | (1ULL << (TSqlParser::MIN - 250))
      | (1ULL << (TSqlParser::MINUTES - 250))
      | (1ULL << (TSqlParser::MODE - 250))
      | (1ULL << (TSqlParser::NEXT - 250))
      | (1ULL << (TSqlParser::NO - 250))
      | (1ULL << (TSqlParser::NOCOUNT - 250))
      | (1ULL << (TSqlParser::NODES - 250))
      | (1ULL << (TSqlParser::NOEXPAND - 250))
      | (1ULL << (TSqlParser::NOWAIT - 250))
      | (1ULL << (TSqlParser::NTILE - 250))
      | (1ULL << (TSqlParser::NUMANODE - 250))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
      | (1ULL << (TSqlParser::OBJECT - 250))
      | (1ULL << (TSqlParser::OFFSET - 250))
      | (1ULL << (TSqlParser::ONLINE - 250))
      | (1ULL << (TSqlParser::ONLY - 250))
      | (1ULL << (TSqlParser::OPTIMISTIC - 250))
      | (1ULL << (TSqlParser::OPTIMIZE - 250))
      | (1ULL << (TSqlParser::OUT - 250))
      | (1ULL << (TSqlParser::OUTPUT - 250))
      | (1ULL << (TSqlParser::OWNER - 250))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
      | (1ULL << (TSqlParser::PARTITION - 250))
      | (1ULL << (TSqlParser::PARTITIONS - 250))
      | (1ULL << (TSqlParser::PERCENT_RANK - 250))
      | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
      | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
      | (1ULL << (TSqlParser::PRECEDING - 250))
      | (1ULL << (TSqlParser::PRIOR - 250))
      | (1ULL << (TSqlParser::QUERY - 250))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
      | (1ULL << (TSqlParser::RANGE - 250))
      | (1ULL << (TSqlParser::RANK - 250))
      | (1ULL << (TSqlParser::RC2 - 250))
      | (1ULL << (TSqlParser::RC4 - 250))
      | (1ULL << (TSqlParser::RC4_128 - 250))
      | (1ULL << (TSqlParser::READ_ONLY - 250))
      | (1ULL << (TSqlParser::READONLY - 250))
      | (1ULL << (TSqlParser::REBUILD - 250))
      | (1ULL << (TSqlParser::RECOMPILE - 250))
      | (1ULL << (TSqlParser::RELATIVE - 250))
      | (1ULL << (TSqlParser::REMOTE - 250))
      | (1ULL << (TSqlParser::REPEATABLE - 250))
      | (1ULL << (TSqlParser::ROBUST - 250))
      | (1ULL << (TSqlParser::ROW - 250))
      | (1ULL << (TSqlParser::ROW_NUMBER - 250))
      | (1ULL << (TSqlParser::ROWGUID - 250))
      | (1ULL << (TSqlParser::ROWS - 250))
      | (1ULL << (TSqlParser::SCHEMABINDING - 250))
      | (1ULL << (TSqlParser::SCROLL - 250))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
      | (1ULL << (TSqlParser::SELF - 314))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
      | (1ULL << (TSqlParser::SEQUENCE - 314))
      | (1ULL << (TSqlParser::SERIALIZABLE - 314))
      | (1ULL << (TSqlParser::SETERROR - 314))
      | (1ULL << (TSqlParser::SHARE - 314))
      | (1ULL << (TSqlParser::SIMPLE - 314))
      | (1ULL << (TSqlParser::SIZE - 314))
      | (1ULL << (TSqlParser::SMALLINT - 314))
      | (1ULL << (TSqlParser::SNAPSHOT - 314))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
      | (1ULL << (TSqlParser::STATIC - 314))
      | (1ULL << (TSqlParser::STATUSONLY - 314))
      | (1ULL << (TSqlParser::STDEV - 314))
      | (1ULL << (TSqlParser::STDEVP - 314))
      | (1ULL << (TSqlParser::STRING_AGG - 314))
      | (1ULL << (TSqlParser::STUFF - 314))
      | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
      | (1ULL << (TSqlParser::SUM - 314))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
      | (1ULL << (TSqlParser::THROW - 314))
      | (1ULL << (TSqlParser::TIES - 314))
      | (1ULL << (TSqlParser::TIME - 314))
      | (1ULL << (TSqlParser::TIMEOUT - 314))
      | (1ULL << (TSqlParser::TINYINT - 314))
      | (1ULL << (TSqlParser::TRIPLE_DES - 314))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
      | (1ULL << (TSqlParser::TRY - 314))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
      | (1ULL << (TSqlParser::TYPE - 314))
      | (1ULL << (TSqlParser::TYPE_WARNING - 314))
      | (1ULL << (TSqlParser::UNBOUNDED - 314))
      | (1ULL << (TSqlParser::UNCOMMITTED - 314))
      | (1ULL << (TSqlParser::UNKNOWN - 314))
      | (1ULL << (TSqlParser::UOW - 314))
      | (1ULL << (TSqlParser::USING - 314))
      | (1ULL << (TSqlParser::VAR - 314))
      | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
      | (1ULL << (TSqlParser::VARP - 314))
      | (1ULL << (TSqlParser::WAIT - 314))
      | (1ULL << (TSqlParser::WORK - 314))
      | (1ULL << (TSqlParser::ZONE - 314))
      | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
      | (1ULL << (TSqlParser::CACHE - 314))
      | (1ULL << (TSqlParser::CALLED - 314))
      | (1ULL << (TSqlParser::CHANGETABLE - 314))
      | (1ULL << (TSqlParser::CHANGES - 314))
      | (1ULL << (TSqlParser::CYCLE - 314))
      | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
      | (1ULL << (TSqlParser::ERROR - 314))
      | (1ULL << (TSqlParser::FORCESEEK - 314))
      | (1ULL << (TSqlParser::IIF - 314))
      | (1ULL << (TSqlParser::INCREMENT - 314))
      | (1ULL << (TSqlParser::ISNULL - 314))
      | (1ULL << (TSqlParser::LOG - 314))
      | (1ULL << (TSqlParser::MATCHED - 314))
      | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
      | (1ULL << (TSqlParser::NOTIFICATION - 378))
      | (1ULL << (TSqlParser::PERSISTED - 378))
      | (1ULL << (TSqlParser::PREDICATE - 378))
      | (1ULL << (TSqlParser::RESTART - 378))
      | (1ULL << (TSqlParser::RETURNS - 378))
      | (1ULL << (TSqlParser::SOURCE - 378))
      | (1ULL << (TSqlParser::STATE - 378))
      | (1ULL << (TSqlParser::START - 378))
      | (1ULL << (TSqlParser::TARGET - 378))
      | (1ULL << (TSqlParser::VARCHAR - 378))
      | (1ULL << (TSqlParser::NVARCHAR - 378))
      | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
      | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
      | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
      setState(2995);
      dynamic_cast<Partition_functionContext *>(_localctx)->database = id_();
      setState(2996);
      match(TSqlParser::DOT);
    }
    setState(3000);
    match(TSqlParser::DOLLAR_PARTITION);
    setState(3001);
    match(TSqlParser::DOT);
    setState(3002);
    dynamic_cast<Partition_functionContext *>(_localctx)->func_name = id_();
    setState(3003);
    match(TSqlParser::LR_BRACKET);
    setState(3004);
    expression(0);
    setState(3005);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Built_in_functionsContext ------------------------------------------------------------------

TSqlParser::Built_in_functionsContext::Built_in_functionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TSqlParser::Built_in_functionsContext::getRuleIndex() const {
  return TSqlParser::RuleBuilt_in_functions;
}

void TSqlParser::Built_in_functionsContext::copyFrom(Built_in_functionsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CASTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CASTContext::CAST() {
  return getToken(TSqlParser::CAST, 0);
}

tree::TerminalNode* TSqlParser::CASTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::CASTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::CASTContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::CASTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::CASTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::CASTContext::CASTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CASTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCAST(this);
}
void TSqlParser::CASTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCAST(this);
}
//----------------- CURRENT_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CURRENT_USERContext::CURRENT_USER() {
  return getToken(TSqlParser::CURRENT_USER, 0);
}

TSqlParser::CURRENT_USERContext::CURRENT_USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CURRENT_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCURRENT_USER(this);
}
void TSqlParser::CURRENT_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCURRENT_USER(this);
}
//----------------- DATEADDContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEADDContext::DATEADD() {
  return getToken(TSqlParser::DATEADD, 0);
}

tree::TerminalNode* TSqlParser::DATEADDContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::DATEADDContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::DATEADDContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::DATEADDContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEADDContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::DATEADDContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::DATEADDContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::DATEADDContext::DATEADDContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEADDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEADD(this);
}
void TSqlParser::DATEADDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEADD(this);
}
//----------------- CHECKSUMContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CHECKSUMContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::CHECKSUMContext::CHECKSUMContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CHECKSUMContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCHECKSUM(this);
}
void TSqlParser::CHECKSUMContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCHECKSUM(this);
}
//----------------- CURRENT_TIMESTAMPContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CURRENT_TIMESTAMPContext::CURRENT_TIMESTAMP() {
  return getToken(TSqlParser::CURRENT_TIMESTAMP, 0);
}

TSqlParser::CURRENT_TIMESTAMPContext::CURRENT_TIMESTAMPContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CURRENT_TIMESTAMPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCURRENT_TIMESTAMP(this);
}
void TSqlParser::CURRENT_TIMESTAMPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCURRENT_TIMESTAMP(this);
}
//----------------- MIN_ACTIVE_ROWVERSIONContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::MIN_ACTIVE_ROWVERSIONContext::MIN_ACTIVE_ROWVERSION() {
  return getToken(TSqlParser::MIN_ACTIVE_ROWVERSION, 0);
}

tree::TerminalNode* TSqlParser::MIN_ACTIVE_ROWVERSIONContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::MIN_ACTIVE_ROWVERSIONContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::MIN_ACTIVE_ROWVERSIONContext::MIN_ACTIVE_ROWVERSIONContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::MIN_ACTIVE_ROWVERSIONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMIN_ACTIVE_ROWVERSION(this);
}
void TSqlParser::MIN_ACTIVE_ROWVERSIONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMIN_ACTIVE_ROWVERSION(this);
}
//----------------- BINARY_CHECKSUMContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::BINARY_CHECKSUMContext::BINARY_CHECKSUMContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::BINARY_CHECKSUMContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBINARY_CHECKSUM(this);
}
void TSqlParser::BINARY_CHECKSUMContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBINARY_CHECKSUM(this);
}
//----------------- IIFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::IIFContext::IIF() {
  return getToken(TSqlParser::IIF, 0);
}

tree::TerminalNode* TSqlParser::IIFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::IIFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::IIFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::IIFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::IIFContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::IIFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::IIFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::IIFContext::IIFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::IIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIIF(this);
}
void TSqlParser::IIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIIF(this);
}
//----------------- DATEPARTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEPARTContext::DATEPART() {
  return getToken(TSqlParser::DATEPART, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

TSqlParser::ExpressionContext* TSqlParser::DATEPARTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::DATEPARTContext::DATEPARTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEPARTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEPART(this);
}
void TSqlParser::DATEPARTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEPART(this);
}
//----------------- USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::USERContext::USER() {
  return getToken(TSqlParser::USER, 0);
}

TSqlParser::USERContext::USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUSER(this);
}
void TSqlParser::USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUSER(this);
}
//----------------- STUFFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::STUFFContext::STUFF() {
  return getToken(TSqlParser::STUFF, 0);
}

tree::TerminalNode* TSqlParser::STUFFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STUFFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::STUFFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::STUFFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::STUFFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::STUFFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::STUFFContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::STUFFContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

TSqlParser::STUFFContext::STUFFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::STUFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSTUFF(this);
}
void TSqlParser::STUFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSTUFF(this);
}
//----------------- SYSTEM_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::SYSTEM_USERContext::SYSTEM_USER() {
  return getToken(TSqlParser::SYSTEM_USER, 0);
}

TSqlParser::SYSTEM_USERContext::SYSTEM_USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::SYSTEM_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSYSTEM_USER(this);
}
void TSqlParser::SYSTEM_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSYSTEM_USER(this);
}
//----------------- NULLIFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::NULLIFContext::NULLIF() {
  return getToken(TSqlParser::NULLIF, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::NULLIFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::NULLIFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::NULLIFContext::NULLIFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::NULLIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNULLIF(this);
}
void TSqlParser::NULLIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNULLIF(this);
}
//----------------- SESSION_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::SESSION_USERContext::SESSION_USER() {
  return getToken(TSqlParser::SESSION_USER, 0);
}

TSqlParser::SESSION_USERContext::SESSION_USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::SESSION_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSESSION_USER(this);
}
void TSqlParser::SESSION_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSESSION_USER(this);
}
//----------------- CONVERTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CONVERTContext::CONVERT() {
  return getToken(TSqlParser::CONVERT, 0);
}

tree::TerminalNode* TSqlParser::CONVERTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::CONVERTContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::CONVERTContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::CONVERTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Data_typeContext* TSqlParser::CONVERTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::CONVERTContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::CONVERTContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::CONVERTContext::CONVERTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CONVERTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCONVERT(this);
}
void TSqlParser::CONVERTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCONVERT(this);
}
//----------------- IDENTITYContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::IDENTITYContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Data_typeContext* TSqlParser::IDENTITYContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::IDENTITYContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::IDENTITYContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

TSqlParser::IDENTITYContext::IDENTITYContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::IDENTITYContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIDENTITY(this);
}
void TSqlParser::IDENTITYContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIDENTITY(this);
}
//----------------- COALESCEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::COALESCEContext::COALESCE() {
  return getToken(TSqlParser::COALESCE, 0);
}

tree::TerminalNode* TSqlParser::COALESCEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::COALESCEContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::COALESCEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::COALESCEContext::COALESCEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::COALESCEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCOALESCE(this);
}
void TSqlParser::COALESCEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCOALESCE(this);
}
//----------------- DATENAMEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATENAMEContext::DATENAME() {
  return getToken(TSqlParser::DATENAME, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

TSqlParser::ExpressionContext* TSqlParser::DATENAMEContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::DATENAMEContext::DATENAMEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATENAMEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATENAME(this);
}
void TSqlParser::DATENAMEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATENAME(this);
}
//----------------- GETUTCDATEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::GETUTCDATEContext::GETUTCDATE() {
  return getToken(TSqlParser::GETUTCDATE, 0);
}

tree::TerminalNode* TSqlParser::GETUTCDATEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::GETUTCDATEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::GETUTCDATEContext::GETUTCDATEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::GETUTCDATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGETUTCDATE(this);
}
void TSqlParser::GETUTCDATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGETUTCDATE(this);
}
//----------------- TRY_CASTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::TRY_CASTContext::TRY_CAST() {
  return getToken(TSqlParser::TRY_CAST, 0);
}

tree::TerminalNode* TSqlParser::TRY_CASTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::TRY_CASTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::TRY_CASTContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::TRY_CASTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::TRY_CASTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::TRY_CASTContext::TRY_CASTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::TRY_CASTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTRY_CAST(this);
}
void TSqlParser::TRY_CASTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTRY_CAST(this);
}
//----------------- ISNULLContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::ISNULLContext::ISNULL() {
  return getToken(TSqlParser::ISNULL, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::ISNULLContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::ISNULLContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::ISNULLContext::ISNULLContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::ISNULLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterISNULL(this);
}
void TSqlParser::ISNULLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitISNULL(this);
}
//----------------- DATEDIFFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEDIFFContext::DATEDIFF() {
  return getToken(TSqlParser::DATEDIFF, 0);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::DATEDIFFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::DATEDIFFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::DATEDIFFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::DATEDIFFContext::DATEDIFFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEDIFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEDIFF(this);
}
void TSqlParser::DATEDIFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEDIFF(this);
}
//----------------- GETDATEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::GETDATEContext::GETDATE() {
  return getToken(TSqlParser::GETDATE, 0);
}

tree::TerminalNode* TSqlParser::GETDATEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::GETDATEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::GETDATEContext::GETDATEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::GETDATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGETDATE(this);
}
void TSqlParser::GETDATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGETDATE(this);
}
//----------------- STRINGAGGContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::STRINGAGGContext::STRING_AGG() {
  return getToken(TSqlParser::STRING_AGG, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STRINGAGGContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STRINGAGGContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::STRINGAGGContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::STRINGAGGContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::WITHIN() {
  return getToken(TSqlParser::WITHIN, 0);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::STRINGAGGContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::STRINGAGGContext::STRINGAGGContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::STRINGAGGContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSTRINGAGG(this);
}
void TSqlParser::STRINGAGGContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSTRINGAGG(this);
}
TSqlParser::Built_in_functionsContext* TSqlParser::built_in_functions() {
  Built_in_functionsContext *_localctx = _tracker.createInstance<Built_in_functionsContext>(_ctx, getState());
  enterRule(_localctx, 322, TSqlParser::RuleBuilt_in_functions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3152);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BINARY_CHECKSUM: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::BINARY_CHECKSUMContext>(_localctx));
        enterOuterAlt(_localctx, 1);
        setState(3007);
        match(TSqlParser::BINARY_CHECKSUM);
        setState(3008);
        match(TSqlParser::LR_BRACKET);
        setState(3009);
        match(TSqlParser::STAR);
        setState(3010);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CAST: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::CASTContext>(_localctx));
        enterOuterAlt(_localctx, 2);
        setState(3011);
        match(TSqlParser::CAST);
        setState(3012);
        match(TSqlParser::LR_BRACKET);
        setState(3013);
        expression(0);
        setState(3014);
        match(TSqlParser::AS);
        setState(3015);
        data_type();
        setState(3016);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::TRY_CAST: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::TRY_CASTContext>(_localctx));
        enterOuterAlt(_localctx, 3);
        setState(3018);
        match(TSqlParser::TRY_CAST);
        setState(3019);
        match(TSqlParser::LR_BRACKET);
        setState(3020);
        expression(0);
        setState(3021);
        match(TSqlParser::AS);
        setState(3022);
        data_type();
        setState(3023);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CONVERT: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::CONVERTContext>(_localctx));
        enterOuterAlt(_localctx, 4);
        setState(3025);
        match(TSqlParser::CONVERT);
        setState(3026);
        match(TSqlParser::LR_BRACKET);
        setState(3027);
        dynamic_cast<CONVERTContext *>(_localctx)->convert_data_type = data_type();
        setState(3028);
        match(TSqlParser::COMMA);
        setState(3029);
        dynamic_cast<CONVERTContext *>(_localctx)->convert_expression = expression(0);
        setState(3032);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(3030);
          match(TSqlParser::COMMA);
          setState(3031);
          dynamic_cast<CONVERTContext *>(_localctx)->style = expression(0);
        }
        setState(3034);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CHECKSUM: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::CHECKSUMContext>(_localctx));
        enterOuterAlt(_localctx, 5);
        setState(3036);
        match(TSqlParser::CHECKSUM);
        setState(3037);
        match(TSqlParser::LR_BRACKET);
        setState(3038);
        match(TSqlParser::STAR);
        setState(3039);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::COALESCE: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::COALESCEContext>(_localctx));
        enterOuterAlt(_localctx, 6);
        setState(3040);
        match(TSqlParser::COALESCE);
        setState(3041);
        match(TSqlParser::LR_BRACKET);
        setState(3042);
        expression_list();
        setState(3043);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CURRENT_TIMESTAMP: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::CURRENT_TIMESTAMPContext>(_localctx));
        enterOuterAlt(_localctx, 7);
        setState(3045);
        match(TSqlParser::CURRENT_TIMESTAMP);
        break;
      }

      case TSqlParser::CURRENT_USER: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::CURRENT_USERContext>(_localctx));
        enterOuterAlt(_localctx, 8);
        setState(3046);
        match(TSqlParser::CURRENT_USER);
        break;
      }

      case TSqlParser::DATEADD: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::DATEADDContext>(_localctx));
        enterOuterAlt(_localctx, 9);
        setState(3047);
        match(TSqlParser::DATEADD);
        setState(3048);
        match(TSqlParser::LR_BRACKET);
        setState(3049);
        dynamic_cast<DATEADDContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3050);
        match(TSqlParser::COMMA);
        setState(3051);
        dynamic_cast<DATEADDContext *>(_localctx)->number = expression(0);
        setState(3052);
        match(TSqlParser::COMMA);
        setState(3053);
        dynamic_cast<DATEADDContext *>(_localctx)->date = expression(0);
        setState(3054);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DATEDIFF: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::DATEDIFFContext>(_localctx));
        enterOuterAlt(_localctx, 10);
        setState(3056);
        match(TSqlParser::DATEDIFF);
        setState(3057);
        match(TSqlParser::LR_BRACKET);
        setState(3058);
        dynamic_cast<DATEDIFFContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3059);
        match(TSqlParser::COMMA);
        setState(3060);
        dynamic_cast<DATEDIFFContext *>(_localctx)->date_first = expression(0);
        setState(3061);
        match(TSqlParser::COMMA);
        setState(3062);
        dynamic_cast<DATEDIFFContext *>(_localctx)->date_second = expression(0);
        setState(3063);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DATENAME: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::DATENAMEContext>(_localctx));
        enterOuterAlt(_localctx, 11);
        setState(3065);
        match(TSqlParser::DATENAME);
        setState(3066);
        match(TSqlParser::LR_BRACKET);
        setState(3067);
        dynamic_cast<DATENAMEContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3068);
        match(TSqlParser::COMMA);
        setState(3069);
        dynamic_cast<DATENAMEContext *>(_localctx)->date = expression(0);
        setState(3070);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DATEPART: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::DATEPARTContext>(_localctx));
        enterOuterAlt(_localctx, 12);
        setState(3072);
        match(TSqlParser::DATEPART);
        setState(3073);
        match(TSqlParser::LR_BRACKET);
        setState(3074);
        dynamic_cast<DATEPARTContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3075);
        match(TSqlParser::COMMA);
        setState(3076);
        dynamic_cast<DATEPARTContext *>(_localctx)->date = expression(0);
        setState(3077);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GETDATE: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::GETDATEContext>(_localctx));
        enterOuterAlt(_localctx, 13);
        setState(3079);
        match(TSqlParser::GETDATE);
        setState(3080);
        match(TSqlParser::LR_BRACKET);
        setState(3081);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GETUTCDATE: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::GETUTCDATEContext>(_localctx));
        enterOuterAlt(_localctx, 14);
        setState(3082);
        match(TSqlParser::GETUTCDATE);
        setState(3083);
        match(TSqlParser::LR_BRACKET);
        setState(3084);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::IDENTITY: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::IDENTITYContext>(_localctx));
        enterOuterAlt(_localctx, 15);
        setState(3085);
        match(TSqlParser::IDENTITY);
        setState(3086);
        match(TSqlParser::LR_BRACKET);
        setState(3087);
        data_type();
        setState(3090);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 454, _ctx)) {
        case 1: {
          setState(3088);
          match(TSqlParser::COMMA);
          setState(3089);
          dynamic_cast<IDENTITYContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
          break;
        }

        default:
          break;
        }
        setState(3094);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(3092);
          match(TSqlParser::COMMA);
          setState(3093);
          dynamic_cast<IDENTITYContext *>(_localctx)->increment = match(TSqlParser::DECIMAL);
        }
        setState(3096);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::MIN_ACTIVE_ROWVERSION: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::MIN_ACTIVE_ROWVERSIONContext>(_localctx));
        enterOuterAlt(_localctx, 16);
        setState(3098);
        match(TSqlParser::MIN_ACTIVE_ROWVERSION);
        setState(3099);
        match(TSqlParser::LR_BRACKET);
        setState(3100);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::NULLIF: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::NULLIFContext>(_localctx));
        enterOuterAlt(_localctx, 17);
        setState(3101);
        match(TSqlParser::NULLIF);
        setState(3102);
        match(TSqlParser::LR_BRACKET);
        setState(3103);
        dynamic_cast<NULLIFContext *>(_localctx)->left = expression(0);
        setState(3104);
        match(TSqlParser::COMMA);
        setState(3105);
        dynamic_cast<NULLIFContext *>(_localctx)->right = expression(0);
        setState(3106);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::STUFF: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::STUFFContext>(_localctx));
        enterOuterAlt(_localctx, 18);
        setState(3108);
        match(TSqlParser::STUFF);
        setState(3109);
        match(TSqlParser::LR_BRACKET);
        setState(3110);
        dynamic_cast<STUFFContext *>(_localctx)->str = expression(0);
        setState(3111);
        match(TSqlParser::COMMA);
        setState(3112);
        dynamic_cast<STUFFContext *>(_localctx)->from = match(TSqlParser::DECIMAL);
        setState(3113);
        match(TSqlParser::COMMA);
        setState(3114);
        dynamic_cast<STUFFContext *>(_localctx)->to = match(TSqlParser::DECIMAL);
        setState(3115);
        match(TSqlParser::COMMA);
        setState(3116);
        dynamic_cast<STUFFContext *>(_localctx)->str_with = expression(0);
        setState(3117);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::SESSION_USER: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::SESSION_USERContext>(_localctx));
        enterOuterAlt(_localctx, 19);
        setState(3119);
        match(TSqlParser::SESSION_USER);
        break;
      }

      case TSqlParser::SYSTEM_USER: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::SYSTEM_USERContext>(_localctx));
        enterOuterAlt(_localctx, 20);
        setState(3120);
        match(TSqlParser::SYSTEM_USER);
        break;
      }

      case TSqlParser::USER: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::USERContext>(_localctx));
        enterOuterAlt(_localctx, 21);
        setState(3121);
        match(TSqlParser::USER);
        break;
      }

      case TSqlParser::ISNULL: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::ISNULLContext>(_localctx));
        enterOuterAlt(_localctx, 22);
        setState(3122);
        match(TSqlParser::ISNULL);
        setState(3123);
        match(TSqlParser::LR_BRACKET);
        setState(3124);
        dynamic_cast<ISNULLContext *>(_localctx)->left = expression(0);
        setState(3125);
        match(TSqlParser::COMMA);
        setState(3126);
        dynamic_cast<ISNULLContext *>(_localctx)->right = expression(0);
        setState(3127);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::IIF: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::IIFContext>(_localctx));
        enterOuterAlt(_localctx, 23);
        setState(3129);
        match(TSqlParser::IIF);
        setState(3130);
        match(TSqlParser::LR_BRACKET);
        setState(3131);
        dynamic_cast<IIFContext *>(_localctx)->cond = search_condition(0);
        setState(3132);
        match(TSqlParser::COMMA);
        setState(3133);
        dynamic_cast<IIFContext *>(_localctx)->left = expression(0);
        setState(3134);
        match(TSqlParser::COMMA);
        setState(3135);
        dynamic_cast<IIFContext *>(_localctx)->right = expression(0);
        setState(3136);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::STRING_AGG: {
        _localctx = dynamic_cast<Built_in_functionsContext *>(_tracker.createInstance<TSqlParser::STRINGAGGContext>(_localctx));
        enterOuterAlt(_localctx, 24);
        setState(3138);
        match(TSqlParser::STRING_AGG);
        setState(3139);
        match(TSqlParser::LR_BRACKET);
        setState(3140);
        dynamic_cast<STRINGAGGContext *>(_localctx)->expr = expression(0);
        setState(3141);
        match(TSqlParser::COMMA);
        setState(3142);
        dynamic_cast<STRINGAGGContext *>(_localctx)->separator = expression(0);
        setState(3143);
        match(TSqlParser::RR_BRACKET);
        setState(3150);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 456, _ctx)) {
        case 1: {
          setState(3144);
          match(TSqlParser::WITHIN);
          setState(3145);
          match(TSqlParser::GROUP);
          setState(3146);
          match(TSqlParser::LR_BRACKET);
          setState(3147);
          order_by_clause();
          setState(3148);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nodes_methodContext ------------------------------------------------------------------

TSqlParser::Nodes_methodContext::Nodes_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::NODES() {
  return getToken(TSqlParser::NODES, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Nodes_methodContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Nodes_methodContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

TSqlParser::SubqueryContext* TSqlParser::Nodes_methodContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Id_Context* TSqlParser::Nodes_methodContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}


size_t TSqlParser::Nodes_methodContext::getRuleIndex() const {
  return TSqlParser::RuleNodes_method;
}

void TSqlParser::Nodes_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodes_method(this);
}

void TSqlParser::Nodes_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodes_method(this);
}

TSqlParser::Nodes_methodContext* TSqlParser::nodes_method() {
  Nodes_methodContext *_localctx = _tracker.createInstance<Nodes_methodContext>(_ctx, getState());
  enterRule(_localctx, 324, TSqlParser::RuleNodes_method);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3160);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LOCAL_ID: {
        setState(3154);
        dynamic_cast<Nodes_methodContext *>(_localctx)->loc_id = match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(3155);
        dynamic_cast<Nodes_methodContext *>(_localctx)->value_id = id_();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        setState(3156);
        match(TSqlParser::LR_BRACKET);
        setState(3157);
        subquery();
        setState(3158);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3162);
    match(TSqlParser::DOT);
    setState(3163);
    match(TSqlParser::NODES);
    setState(3164);
    match(TSqlParser::LR_BRACKET);
    setState(3165);
    dynamic_cast<Nodes_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
    setState(3166);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_sectionContext ------------------------------------------------------------------

TSqlParser::Switch_sectionContext::Switch_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Switch_sectionContext::WHEN() {
  return getToken(TSqlParser::WHEN, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Switch_sectionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Switch_sectionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::Switch_sectionContext::THEN() {
  return getToken(TSqlParser::THEN, 0);
}


size_t TSqlParser::Switch_sectionContext::getRuleIndex() const {
  return TSqlParser::RuleSwitch_section;
}

void TSqlParser::Switch_sectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_section(this);
}

void TSqlParser::Switch_sectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_section(this);
}

TSqlParser::Switch_sectionContext* TSqlParser::switch_section() {
  Switch_sectionContext *_localctx = _tracker.createInstance<Switch_sectionContext>(_ctx, getState());
  enterRule(_localctx, 326, TSqlParser::RuleSwitch_section);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3168);
    match(TSqlParser::WHEN);
    setState(3169);
    expression(0);
    setState(3170);
    match(TSqlParser::THEN);
    setState(3171);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_search_condition_sectionContext ------------------------------------------------------------------

TSqlParser::Switch_search_condition_sectionContext::Switch_search_condition_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Switch_search_condition_sectionContext::WHEN() {
  return getToken(TSqlParser::WHEN, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Switch_search_condition_sectionContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Switch_search_condition_sectionContext::THEN() {
  return getToken(TSqlParser::THEN, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Switch_search_condition_sectionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Switch_search_condition_sectionContext::getRuleIndex() const {
  return TSqlParser::RuleSwitch_search_condition_section;
}

void TSqlParser::Switch_search_condition_sectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_search_condition_section(this);
}

void TSqlParser::Switch_search_condition_sectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_search_condition_section(this);
}

TSqlParser::Switch_search_condition_sectionContext* TSqlParser::switch_search_condition_section() {
  Switch_search_condition_sectionContext *_localctx = _tracker.createInstance<Switch_search_condition_sectionContext>(_ctx, getState());
  enterRule(_localctx, 328, TSqlParser::RuleSwitch_search_condition_section);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3173);
    match(TSqlParser::WHEN);
    setState(3174);
    search_condition(0);
    setState(3175);
    match(TSqlParser::THEN);
    setState(3176);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_column_aliasContext ------------------------------------------------------------------

TSqlParser::As_column_aliasContext::As_column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_aliasContext* TSqlParser::As_column_aliasContext::column_alias() {
  return getRuleContext<TSqlParser::Column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::As_column_aliasContext::AS() {
  return getToken(TSqlParser::AS, 0);
}


size_t TSqlParser::As_column_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleAs_column_alias;
}

void TSqlParser::As_column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAs_column_alias(this);
}

void TSqlParser::As_column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAs_column_alias(this);
}

TSqlParser::As_column_aliasContext* TSqlParser::as_column_alias() {
  As_column_aliasContext *_localctx = _tracker.createInstance<As_column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 330, TSqlParser::RuleAs_column_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3179);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(3178);
      match(TSqlParser::AS);
    }
    setState(3181);
    column_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_table_aliasContext ------------------------------------------------------------------

TSqlParser::As_table_aliasContext::As_table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_aliasContext* TSqlParser::As_table_aliasContext::table_alias() {
  return getRuleContext<TSqlParser::Table_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::As_table_aliasContext::AS() {
  return getToken(TSqlParser::AS, 0);
}


size_t TSqlParser::As_table_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleAs_table_alias;
}

void TSqlParser::As_table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAs_table_alias(this);
}

void TSqlParser::As_table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAs_table_alias(this);
}

TSqlParser::As_table_aliasContext* TSqlParser::as_table_alias() {
  As_table_aliasContext *_localctx = _tracker.createInstance<As_table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 332, TSqlParser::RuleAs_table_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3184);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(3183);
      match(TSqlParser::AS);
    }
    setState(3186);
    table_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_aliasContext ------------------------------------------------------------------

TSqlParser::Table_aliasContext::Table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Table_aliasContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Table_aliasContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}


size_t TSqlParser::Table_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleTable_alias;
}

void TSqlParser::Table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_alias(this);
}

void TSqlParser::Table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_alias(this);
}

TSqlParser::Table_aliasContext* TSqlParser::table_alias() {
  Table_aliasContext *_localctx = _tracker.createInstance<Table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 334, TSqlParser::RuleTable_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3188);
    id_();
    setState(3190);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
    case 1: {
      setState(3189);
      with_table_hints();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_table_hintsContext ------------------------------------------------------------------

TSqlParser::With_table_hintsContext::With_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Table_hintContext *> TSqlParser::With_table_hintsContext::table_hint() {
  return getRuleContexts<TSqlParser::Table_hintContext>();
}

TSqlParser::Table_hintContext* TSqlParser::With_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<TSqlParser::Table_hintContext>(i);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::With_table_hintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::With_table_hintsContext::getRuleIndex() const {
  return TSqlParser::RuleWith_table_hints;
}

void TSqlParser::With_table_hintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_table_hints(this);
}

void TSqlParser::With_table_hintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_table_hints(this);
}

TSqlParser::With_table_hintsContext* TSqlParser::with_table_hints() {
  With_table_hintsContext *_localctx = _tracker.createInstance<With_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 336, TSqlParser::RuleWith_table_hints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3193);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(3192);
      match(TSqlParser::WITH);
    }
    setState(3195);
    match(TSqlParser::LR_BRACKET);
    setState(3196);
    dynamic_cast<With_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
    dynamic_cast<With_table_hintsContext *>(_localctx)->hint.push_back(dynamic_cast<With_table_hintsContext *>(_localctx)->table_hintContext);
    setState(3203);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::HOLDLOCK

    || _la == TSqlParser::INDEX || ((((_la - 270) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 270)) & ((1ULL << (TSqlParser::NOEXPAND - 270))
      | (1ULL << (TSqlParser::SERIALIZABLE - 270))
      | (1ULL << (TSqlParser::SNAPSHOT - 270))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 270)))) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 371)) & ((1ULL << (TSqlParser::FORCESEEK - 371))
      | (1ULL << (TSqlParser::ID - 371))
      | (1ULL << (TSqlParser::COMMA - 371)))) != 0)) {
      setState(3198);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3197);
        match(TSqlParser::COMMA);
      }
      setState(3200);
      dynamic_cast<With_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
      dynamic_cast<With_table_hintsContext *>(_localctx)->hint.push_back(dynamic_cast<With_table_hintsContext *>(_localctx)->table_hintContext);
      setState(3205);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3206);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_with_table_hintsContext ------------------------------------------------------------------

TSqlParser::Insert_with_table_hintsContext::Insert_with_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Table_hintContext *> TSqlParser::Insert_with_table_hintsContext::table_hint() {
  return getRuleContexts<TSqlParser::Table_hintContext>();
}

TSqlParser::Table_hintContext* TSqlParser::Insert_with_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<TSqlParser::Table_hintContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_with_table_hintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Insert_with_table_hintsContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_with_table_hints;
}

void TSqlParser::Insert_with_table_hintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_with_table_hints(this);
}

void TSqlParser::Insert_with_table_hintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_with_table_hints(this);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::insert_with_table_hints() {
  Insert_with_table_hintsContext *_localctx = _tracker.createInstance<Insert_with_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 338, TSqlParser::RuleInsert_with_table_hints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3208);
    match(TSqlParser::WITH);
    setState(3209);
    match(TSqlParser::LR_BRACKET);
    setState(3210);
    dynamic_cast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
    dynamic_cast<Insert_with_table_hintsContext *>(_localctx)->hint.push_back(dynamic_cast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext);
    setState(3217);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::HOLDLOCK

    || _la == TSqlParser::INDEX || ((((_la - 270) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 270)) & ((1ULL << (TSqlParser::NOEXPAND - 270))
      | (1ULL << (TSqlParser::SERIALIZABLE - 270))
      | (1ULL << (TSqlParser::SNAPSHOT - 270))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 270)))) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 371)) & ((1ULL << (TSqlParser::FORCESEEK - 371))
      | (1ULL << (TSqlParser::ID - 371))
      | (1ULL << (TSqlParser::COMMA - 371)))) != 0)) {
      setState(3212);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3211);
        match(TSqlParser::COMMA);
      }
      setState(3214);
      dynamic_cast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
      dynamic_cast<Insert_with_table_hintsContext *>(_localctx)->hint.push_back(dynamic_cast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext);
      setState(3219);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3220);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_hintContext ------------------------------------------------------------------

TSqlParser::Table_hintContext::Table_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_hintContext::INDEX() {
  return getToken(TSqlParser::INDEX, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<TSqlParser::Index_valueContext *> TSqlParser::Table_hintContext::index_value() {
  return getRuleContexts<TSqlParser::Index_valueContext>();
}

TSqlParser::Index_valueContext* TSqlParser::Table_hintContext::index_value(size_t i) {
  return getRuleContext<TSqlParser::Index_valueContext>(i);
}

tree::TerminalNode* TSqlParser::Table_hintContext::FORCESEEK() {
  return getToken(TSqlParser::FORCESEEK, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(TSqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::HOLDLOCK() {
  return getToken(TSqlParser::HOLDLOCK, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::ID() {
  return getTokens(TSqlParser::ID);
}

tree::TerminalNode* TSqlParser::Table_hintContext::ID(size_t i) {
  return getToken(TSqlParser::ID, i);
}

tree::TerminalNode* TSqlParser::Table_hintContext::NOEXPAND() {
  return getToken(TSqlParser::NOEXPAND, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_hintContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_hintContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_hintContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_hintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_hint;
}

void TSqlParser::Table_hintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_hint(this);
}

void TSqlParser::Table_hintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_hint(this);
}

TSqlParser::Table_hintContext* TSqlParser::table_hint() {
  Table_hintContext *_localctx = _tracker.createInstance<Table_hintContext>(_ctx, getState());
  enterRule(_localctx, 340, TSqlParser::RuleTable_hint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::NOEXPAND) {
      setState(3222);
      match(TSqlParser::NOEXPAND);
    }
    setState(3274);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx)) {
    case 1: {
      setState(3225);
      match(TSqlParser::INDEX);
      setState(3245);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::LR_BRACKET: {
          setState(3226);
          match(TSqlParser::LR_BRACKET);
          setState(3227);
          index_value();
          setState(3232);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == TSqlParser::COMMA) {
            setState(3228);
            match(TSqlParser::COMMA);
            setState(3229);
            index_value();
            setState(3234);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(3235);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID: {
          setState(3237);
          index_value();
          setState(3242);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3238);
              match(TSqlParser::COMMA);
              setState(3239);
              index_value(); 
            }
            setState(3244);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(3247);
      match(TSqlParser::INDEX);
      setState(3248);
      match(TSqlParser::EQUAL);
      setState(3249);
      index_value();
      break;
    }

    case 3: {
      setState(3250);
      match(TSqlParser::FORCESEEK);
      setState(3265);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LR_BRACKET) {
        setState(3251);
        match(TSqlParser::LR_BRACKET);
        setState(3252);
        index_value();
        setState(3253);
        match(TSqlParser::LR_BRACKET);
        setState(3254);
        match(TSqlParser::ID);
        setState(3259);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(3255);
          match(TSqlParser::COMMA);
          setState(3256);
          match(TSqlParser::ID);
          setState(3261);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3262);
        match(TSqlParser::RR_BRACKET);
        setState(3263);
        match(TSqlParser::RR_BRACKET);
      }
      break;
    }

    case 4: {
      setState(3267);
      match(TSqlParser::SERIALIZABLE);
      break;
    }

    case 5: {
      setState(3268);
      match(TSqlParser::SNAPSHOT);
      break;
    }

    case 6: {
      setState(3269);
      match(TSqlParser::SPATIAL_WINDOW_MAX_CELLS);
      setState(3270);
      match(TSqlParser::EQUAL);
      setState(3271);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 7: {
      setState(3272);
      match(TSqlParser::HOLDLOCK);
      break;
    }

    case 8: {
      setState(3273);
      match(TSqlParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_valueContext ------------------------------------------------------------------

TSqlParser::Index_valueContext::Index_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Index_valueContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Index_valueContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Index_valueContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_value;
}

void TSqlParser::Index_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_value(this);
}

void TSqlParser::Index_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_value(this);
}

TSqlParser::Index_valueContext* TSqlParser::index_value() {
  Index_valueContext *_localctx = _tracker.createInstance<Index_valueContext>(_ctx, getState());
  enterRule(_localctx, 342, TSqlParser::RuleIndex_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3278);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3276);
        id_();
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3277);
        match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_alias_listContext ------------------------------------------------------------------

TSqlParser::Column_alias_listContext::Column_alias_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Column_aliasContext *> TSqlParser::Column_alias_listContext::column_alias() {
  return getRuleContexts<TSqlParser::Column_aliasContext>();
}

TSqlParser::Column_aliasContext* TSqlParser::Column_alias_listContext::column_alias(size_t i) {
  return getRuleContext<TSqlParser::Column_aliasContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_alias_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_alias_listContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_alias_list;
}

void TSqlParser::Column_alias_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias_list(this);
}

void TSqlParser::Column_alias_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias_list(this);
}

TSqlParser::Column_alias_listContext* TSqlParser::column_alias_list() {
  Column_alias_listContext *_localctx = _tracker.createInstance<Column_alias_listContext>(_ctx, getState());
  enterRule(_localctx, 344, TSqlParser::RuleColumn_alias_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3280);
    match(TSqlParser::LR_BRACKET);
    setState(3281);
    dynamic_cast<Column_alias_listContext *>(_localctx)->column_aliasContext = column_alias();
    dynamic_cast<Column_alias_listContext *>(_localctx)->alias.push_back(dynamic_cast<Column_alias_listContext *>(_localctx)->column_aliasContext);
    setState(3286);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3282);
      match(TSqlParser::COMMA);
      setState(3283);
      dynamic_cast<Column_alias_listContext *>(_localctx)->column_aliasContext = column_alias();
      dynamic_cast<Column_alias_listContext *>(_localctx)->alias.push_back(dynamic_cast<Column_alias_listContext *>(_localctx)->column_aliasContext);
      setState(3288);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3289);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_aliasContext ------------------------------------------------------------------

TSqlParser::Column_aliasContext::Column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Column_aliasContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Column_aliasContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Column_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_alias;
}

void TSqlParser::Column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias(this);
}

void TSqlParser::Column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias(this);
}

TSqlParser::Column_aliasContext* TSqlParser::column_alias() {
  Column_aliasContext *_localctx = _tracker.createInstance<Column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 346, TSqlParser::RuleColumn_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3293);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3291);
        id_();
        break;
      }

      case TSqlParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(3292);
        match(TSqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_value_constructorContext ------------------------------------------------------------------

TSqlParser::Table_value_constructorContext::Table_value_constructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<TSqlParser::Expression_listContext *> TSqlParser::Table_value_constructorContext::expression_list() {
  return getRuleContexts<TSqlParser::Expression_listContext>();
}

TSqlParser::Expression_listContext* TSqlParser::Table_value_constructorContext::expression_list(size_t i) {
  return getRuleContext<TSqlParser::Expression_listContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_value_constructorContext::getRuleIndex() const {
  return TSqlParser::RuleTable_value_constructor;
}

void TSqlParser::Table_value_constructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_value_constructor(this);
}

void TSqlParser::Table_value_constructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_value_constructor(this);
}

TSqlParser::Table_value_constructorContext* TSqlParser::table_value_constructor() {
  Table_value_constructorContext *_localctx = _tracker.createInstance<Table_value_constructorContext>(_ctx, getState());
  enterRule(_localctx, 348, TSqlParser::RuleTable_value_constructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3295);
    match(TSqlParser::VALUES);
    setState(3296);
    match(TSqlParser::LR_BRACKET);
    setState(3297);
    dynamic_cast<Table_value_constructorContext *>(_localctx)->expression_listContext = expression_list();
    dynamic_cast<Table_value_constructorContext *>(_localctx)->exps.push_back(dynamic_cast<Table_value_constructorContext *>(_localctx)->expression_listContext);
    setState(3298);
    match(TSqlParser::RR_BRACKET);
    setState(3306);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3299);
      match(TSqlParser::COMMA);
      setState(3300);
      match(TSqlParser::LR_BRACKET);
      setState(3301);
      dynamic_cast<Table_value_constructorContext *>(_localctx)->expression_listContext = expression_list();
      dynamic_cast<Table_value_constructorContext *>(_localctx)->exps.push_back(dynamic_cast<Table_value_constructorContext *>(_localctx)->expression_listContext);
      setState(3302);
      match(TSqlParser::RR_BRACKET);
      setState(3308);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_listContext ------------------------------------------------------------------

TSqlParser::Expression_listContext::Expression_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Expression_listContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Expression_listContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Expression_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Expression_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Expression_listContext::getRuleIndex() const {
  return TSqlParser::RuleExpression_list;
}

void TSqlParser::Expression_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_list(this);
}

void TSqlParser::Expression_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_list(this);
}

TSqlParser::Expression_listContext* TSqlParser::expression_list() {
  Expression_listContext *_localctx = _tracker.createInstance<Expression_listContext>(_ctx, getState());
  enterRule(_localctx, 350, TSqlParser::RuleExpression_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3309);
    dynamic_cast<Expression_listContext *>(_localctx)->expressionContext = expression(0);
    dynamic_cast<Expression_listContext *>(_localctx)->exp.push_back(dynamic_cast<Expression_listContext *>(_localctx)->expressionContext);
    setState(3314);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3310);
      match(TSqlParser::COMMA);
      setState(3311);
      dynamic_cast<Expression_listContext *>(_localctx)->expressionContext = expression(0);
      dynamic_cast<Expression_listContext *>(_localctx)->exp.push_back(dynamic_cast<Expression_listContext *>(_localctx)->expressionContext);
      setState(3316);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ranking_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Ranking_windowed_functionContext::Ranking_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Over_clauseContext* TSqlParser::Ranking_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::RANK() {
  return getToken(TSqlParser::RANK, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::DENSE_RANK() {
  return getToken(TSqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::ROW_NUMBER() {
  return getToken(TSqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::NTILE() {
  return getToken(TSqlParser::NTILE, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Ranking_windowed_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Ranking_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleRanking_windowed_function;
}

void TSqlParser::Ranking_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRanking_windowed_function(this);
}

void TSqlParser::Ranking_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRanking_windowed_function(this);
}

TSqlParser::Ranking_windowed_functionContext* TSqlParser::ranking_windowed_function() {
  Ranking_windowed_functionContext *_localctx = _tracker.createInstance<Ranking_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 352, TSqlParser::RuleRanking_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3327);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DENSE_RANK:
      case TSqlParser::RANK:
      case TSqlParser::ROW_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(3317);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DENSE_RANK || _la == TSqlParser::RANK

        || _la == TSqlParser::ROW_NUMBER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3318);
        match(TSqlParser::LR_BRACKET);
        setState(3319);
        match(TSqlParser::RR_BRACKET);
        setState(3320);
        over_clause();
        break;
      }

      case TSqlParser::NTILE: {
        enterOuterAlt(_localctx, 2);
        setState(3321);
        match(TSqlParser::NTILE);
        setState(3322);
        match(TSqlParser::LR_BRACKET);
        setState(3323);
        expression(0);
        setState(3324);
        match(TSqlParser::RR_BRACKET);
        setState(3325);
        over_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Aggregate_windowed_functionContext::Aggregate_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::All_distinct_expressionContext* TSqlParser::Aggregate_windowed_functionContext::all_distinct_expression() {
  return getRuleContext<TSqlParser::All_distinct_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::AVG() {
  return getToken(TSqlParser::AVG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::MIN() {
  return getToken(TSqlParser::MIN, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::SUM() {
  return getToken(TSqlParser::SUM, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STDEV() {
  return getToken(TSqlParser::STDEV, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STDEVP() {
  return getToken(TSqlParser::STDEVP, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::VAR() {
  return getToken(TSqlParser::VAR, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::VARP() {
  return getToken(TSqlParser::VARP, 0);
}

TSqlParser::Over_clauseContext* TSqlParser::Aggregate_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::COUNT() {
  return getToken(TSqlParser::COUNT, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::COUNT_BIG() {
  return getToken(TSqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::CHECKSUM_AGG() {
  return getToken(TSqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::GROUPING() {
  return getToken(TSqlParser::GROUPING, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Aggregate_windowed_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::GROUPING_ID() {
  return getToken(TSqlParser::GROUPING_ID, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Aggregate_windowed_functionContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}


size_t TSqlParser::Aggregate_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleAggregate_windowed_function;
}

void TSqlParser::Aggregate_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_windowed_function(this);
}

void TSqlParser::Aggregate_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_windowed_function(this);
}

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::aggregate_windowed_function() {
  Aggregate_windowed_functionContext *_localctx = _tracker.createInstance<Aggregate_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 354, TSqlParser::RuleAggregate_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3361);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::AVG:
      case TSqlParser::MAX:
      case TSqlParser::MIN:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::SUM:
      case TSqlParser::VAR:
      case TSqlParser::VARP: {
        enterOuterAlt(_localctx, 1);
        setState(3329);
        dynamic_cast<Aggregate_windowed_functionContext *>(_localctx)->agg_func = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::AVG || _la == TSqlParser::MAX

        || _la == TSqlParser::MIN || ((((_la - 328) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 328)) & ((1ULL << (TSqlParser::STDEV - 328))
          | (1ULL << (TSqlParser::STDEVP - 328))
          | (1ULL << (TSqlParser::SUM - 328))
          | (1ULL << (TSqlParser::VAR - 328))
          | (1ULL << (TSqlParser::VARP - 328)))) != 0))) {
          dynamic_cast<Aggregate_windowed_functionContext *>(_localctx)->agg_func = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3330);
        match(TSqlParser::LR_BRACKET);
        setState(3331);
        all_distinct_expression();
        setState(3332);
        match(TSqlParser::RR_BRACKET);
        setState(3334);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx)) {
        case 1: {
          setState(3333);
          over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG: {
        enterOuterAlt(_localctx, 2);
        setState(3336);
        dynamic_cast<Aggregate_windowed_functionContext *>(_localctx)->cnt = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::COUNT

        || _la == TSqlParser::COUNT_BIG)) {
          dynamic_cast<Aggregate_windowed_functionContext *>(_localctx)->cnt = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3337);
        match(TSqlParser::LR_BRACKET);
        setState(3340);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::STAR: {
            setState(3338);
            match(TSqlParser::STAR);
            break;
          }

          case TSqlParser::ABS:
          case TSqlParser::ASCII:
          case TSqlParser::CEILING:
          case TSqlParser::CHAR:
          case TSqlParser::CHARINDEX:
          case TSqlParser::DATALENGTH:
          case TSqlParser::DAY:
          case TSqlParser::FLOOR:
          case TSqlParser::ISDATE:
          case TSqlParser::ISNUMERIC:
          case TSqlParser::LEN:
          case TSqlParser::LOWER:
          case TSqlParser::LTRIM:
          case TSqlParser::MONTH:
          case TSqlParser::NCHAR:
          case TSqlParser::PATINDEX:
          case TSqlParser::RAND:
          case TSqlParser::REPLACE:
          case TSqlParser::ROUND:
          case TSqlParser::RTRIM:
          case TSqlParser::SIGN:
          case TSqlParser::STR:
          case TSqlParser::SUBSTRING:
          case TSqlParser::UPPER:
          case TSqlParser::USER_NAME:
          case TSqlParser::YEAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::ALL:
          case TSqlParser::CASE:
          case TSqlParser::COALESCE:
          case TSqlParser::CONVERT:
          case TSqlParser::CURRENT_TIMESTAMP:
          case TSqlParser::CURRENT_USER:
          case TSqlParser::DEFAULT:
          case TSqlParser::DISTINCT:
          case TSqlParser::IDENTITY:
          case TSqlParser::LEFT:
          case TSqlParser::NULL_:
          case TSqlParser::NULLIF:
          case TSqlParser::OVER:
          case TSqlParser::PRECISION:
          case TSqlParser::RIGHT:
          case TSqlParser::SESSION_USER:
          case TSqlParser::SYSTEM_USER:
          case TSqlParser::USER:
          case TSqlParser::DOLLAR_PARTITION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::DOLLAR_ACTION:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::SPACE:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::LOCAL_ID:
          case TSqlParser::DECIMAL:
          case TSqlParser::ID:
          case TSqlParser::STRING:
          case TSqlParser::BINARY:
          case TSqlParser::FLOAT:
          case TSqlParser::REAL:
          case TSqlParser::DOT:
          case TSqlParser::DOLLAR:
          case TSqlParser::LR_BRACKET:
          case TSqlParser::PLUS:
          case TSqlParser::MINUS:
          case TSqlParser::BIT_NOT: {
            setState(3339);
            all_distinct_expression();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(3342);
        match(TSqlParser::RR_BRACKET);
        setState(3344);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 482, _ctx)) {
        case 1: {
          setState(3343);
          over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHECKSUM_AGG: {
        enterOuterAlt(_localctx, 3);
        setState(3346);
        match(TSqlParser::CHECKSUM_AGG);
        setState(3347);
        match(TSqlParser::LR_BRACKET);
        setState(3348);
        all_distinct_expression();
        setState(3349);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GROUPING: {
        enterOuterAlt(_localctx, 4);
        setState(3351);
        match(TSqlParser::GROUPING);
        setState(3352);
        match(TSqlParser::LR_BRACKET);
        setState(3353);
        expression(0);
        setState(3354);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GROUPING_ID: {
        enterOuterAlt(_localctx, 5);
        setState(3356);
        match(TSqlParser::GROUPING_ID);
        setState(3357);
        match(TSqlParser::LR_BRACKET);
        setState(3358);
        expression_list();
        setState(3359);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analytic_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Analytic_windowed_functionContext::Analytic_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Analytic_windowed_functionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Analytic_windowed_functionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::Over_clauseContext* TSqlParser::Analytic_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::FIRST_VALUE() {
  return getToken(TSqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LAST_VALUE() {
  return getToken(TSqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LAG() {
  return getToken(TSqlParser::LAG, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LEAD() {
  return getToken(TSqlParser::LEAD, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::OVER() {
  return getToken(TSqlParser::OVER, 0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Analytic_windowed_functionContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::CUME_DIST() {
  return getToken(TSqlParser::CUME_DIST, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PERCENT_RANK() {
  return getToken(TSqlParser::PERCENT_RANK, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::BY() {
  return getTokens(TSqlParser::BY);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::BY(size_t i) {
  return getToken(TSqlParser::BY, i);
}

TSqlParser::Expression_listContext* TSqlParser::Analytic_windowed_functionContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::WITHIN() {
  return getToken(TSqlParser::WITHIN, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PERCENTILE_CONT() {
  return getToken(TSqlParser::PERCENTILE_CONT, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PERCENTILE_DISC() {
  return getToken(TSqlParser::PERCENTILE_DISC, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::ASC() {
  return getToken(TSqlParser::ASC, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::DESC() {
  return getToken(TSqlParser::DESC, 0);
}


size_t TSqlParser::Analytic_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleAnalytic_windowed_function;
}

void TSqlParser::Analytic_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalytic_windowed_function(this);
}

void TSqlParser::Analytic_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalytic_windowed_function(this);
}

TSqlParser::Analytic_windowed_functionContext* TSqlParser::analytic_windowed_function() {
  Analytic_windowed_functionContext *_localctx = _tracker.createInstance<Analytic_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 356, TSqlParser::RuleAnalytic_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3419);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::LAST_VALUE: {
        enterOuterAlt(_localctx, 1);
        setState(3363);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FIRST_VALUE

        || _la == TSqlParser::LAST_VALUE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3364);
        match(TSqlParser::LR_BRACKET);
        setState(3365);
        expression(0);
        setState(3366);
        match(TSqlParser::RR_BRACKET);
        setState(3367);
        over_clause();
        break;
      }

      case TSqlParser::LAG:
      case TSqlParser::LEAD: {
        enterOuterAlt(_localctx, 2);
        setState(3369);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::LAG

        || _la == TSqlParser::LEAD)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3370);
        match(TSqlParser::LR_BRACKET);
        setState(3371);
        expression(0);
        setState(3378);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(3372);
          match(TSqlParser::COMMA);
          setState(3373);
          expression(0);
          setState(3376);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::COMMA) {
            setState(3374);
            match(TSqlParser::COMMA);
            setState(3375);
            expression(0);
          }
        }
        setState(3380);
        match(TSqlParser::RR_BRACKET);
        setState(3381);
        over_clause();
        break;
      }

      case TSqlParser::CUME_DIST:
      case TSqlParser::PERCENT_RANK: {
        enterOuterAlt(_localctx, 3);
        setState(3383);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::CUME_DIST || _la == TSqlParser::PERCENT_RANK)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3384);
        match(TSqlParser::LR_BRACKET);
        setState(3385);
        match(TSqlParser::RR_BRACKET);
        setState(3386);
        match(TSqlParser::OVER);
        setState(3387);
        match(TSqlParser::LR_BRACKET);
        setState(3391);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::PARTITION) {
          setState(3388);
          match(TSqlParser::PARTITION);
          setState(3389);
          match(TSqlParser::BY);
          setState(3390);
          expression_list();
        }
        setState(3393);
        order_by_clause();
        setState(3394);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC: {
        enterOuterAlt(_localctx, 4);
        setState(3396);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::PERCENTILE_CONT

        || _la == TSqlParser::PERCENTILE_DISC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3397);
        match(TSqlParser::LR_BRACKET);
        setState(3398);
        expression(0);
        setState(3399);
        match(TSqlParser::RR_BRACKET);
        setState(3400);
        match(TSqlParser::WITHIN);
        setState(3401);
        match(TSqlParser::GROUP);
        setState(3402);
        match(TSqlParser::LR_BRACKET);
        setState(3403);
        match(TSqlParser::ORDER);
        setState(3404);
        match(TSqlParser::BY);
        setState(3405);
        expression(0);
        setState(3407);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ASC

        || _la == TSqlParser::DESC) {
          setState(3406);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::ASC

          || _la == TSqlParser::DESC)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3409);
        match(TSqlParser::RR_BRACKET);
        setState(3410);
        match(TSqlParser::OVER);
        setState(3411);
        match(TSqlParser::LR_BRACKET);
        setState(3415);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::PARTITION) {
          setState(3412);
          match(TSqlParser::PARTITION);
          setState(3413);
          match(TSqlParser::BY);
          setState(3414);
          expression_list();
        }
        setState(3417);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_distinct_expressionContext ------------------------------------------------------------------

TSqlParser::All_distinct_expressionContext::All_distinct_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::All_distinct_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::All_distinct_expressionContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::All_distinct_expressionContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}


size_t TSqlParser::All_distinct_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleAll_distinct_expression;
}

void TSqlParser::All_distinct_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAll_distinct_expression(this);
}

void TSqlParser::All_distinct_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAll_distinct_expression(this);
}

TSqlParser::All_distinct_expressionContext* TSqlParser::all_distinct_expression() {
  All_distinct_expressionContext *_localctx = _tracker.createInstance<All_distinct_expressionContext>(_ctx, getState());
  enterRule(_localctx, 358, TSqlParser::RuleAll_distinct_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ALL

    || _la == TSqlParser::DISTINCT) {
      setState(3421);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL

      || _la == TSqlParser::DISTINCT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3424);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

TSqlParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Over_clauseContext::OVER() {
  return getToken(TSqlParser::OVER, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Over_clauseContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Over_clauseContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::Row_or_range_clauseContext* TSqlParser::Over_clauseContext::row_or_range_clause() {
  return getRuleContext<TSqlParser::Row_or_range_clauseContext>(0);
}


size_t TSqlParser::Over_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOver_clause;
}

void TSqlParser::Over_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOver_clause(this);
}

void TSqlParser::Over_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOver_clause(this);
}

TSqlParser::Over_clauseContext* TSqlParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 360, TSqlParser::RuleOver_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3426);
    match(TSqlParser::OVER);
    setState(3427);
    match(TSqlParser::LR_BRACKET);
    setState(3431);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::PARTITION) {
      setState(3428);
      match(TSqlParser::PARTITION);
      setState(3429);
      match(TSqlParser::BY);
      setState(3430);
      expression_list();
    }
    setState(3434);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ORDER) {
      setState(3433);
      order_by_clause();
    }
    setState(3437);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::RANGE

    || _la == TSqlParser::ROWS) {
      setState(3436);
      row_or_range_clause();
    }
    setState(3439);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Row_or_range_clauseContext ------------------------------------------------------------------

TSqlParser::Row_or_range_clauseContext::Row_or_range_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_extentContext* TSqlParser::Row_or_range_clauseContext::window_frame_extent() {
  return getRuleContext<TSqlParser::Window_frame_extentContext>(0);
}

tree::TerminalNode* TSqlParser::Row_or_range_clauseContext::ROWS() {
  return getToken(TSqlParser::ROWS, 0);
}

tree::TerminalNode* TSqlParser::Row_or_range_clauseContext::RANGE() {
  return getToken(TSqlParser::RANGE, 0);
}


size_t TSqlParser::Row_or_range_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleRow_or_range_clause;
}

void TSqlParser::Row_or_range_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRow_or_range_clause(this);
}

void TSqlParser::Row_or_range_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRow_or_range_clause(this);
}

TSqlParser::Row_or_range_clauseContext* TSqlParser::row_or_range_clause() {
  Row_or_range_clauseContext *_localctx = _tracker.createInstance<Row_or_range_clauseContext>(_ctx, getState());
  enterRule(_localctx, 362, TSqlParser::RuleRow_or_range_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3441);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::RANGE

    || _la == TSqlParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3442);
    window_frame_extent();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_extentContext ------------------------------------------------------------------

TSqlParser::Window_frame_extentContext::Window_frame_extentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_precedingContext* TSqlParser::Window_frame_extentContext::window_frame_preceding() {
  return getRuleContext<TSqlParser::Window_frame_precedingContext>(0);
}

tree::TerminalNode* TSqlParser::Window_frame_extentContext::BETWEEN() {
  return getToken(TSqlParser::BETWEEN, 0);
}

std::vector<TSqlParser::Window_frame_boundContext *> TSqlParser::Window_frame_extentContext::window_frame_bound() {
  return getRuleContexts<TSqlParser::Window_frame_boundContext>();
}

TSqlParser::Window_frame_boundContext* TSqlParser::Window_frame_extentContext::window_frame_bound(size_t i) {
  return getRuleContext<TSqlParser::Window_frame_boundContext>(i);
}

tree::TerminalNode* TSqlParser::Window_frame_extentContext::AND() {
  return getToken(TSqlParser::AND, 0);
}


size_t TSqlParser::Window_frame_extentContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_extent;
}

void TSqlParser::Window_frame_extentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_extent(this);
}

void TSqlParser::Window_frame_extentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_extent(this);
}

TSqlParser::Window_frame_extentContext* TSqlParser::window_frame_extent() {
  Window_frame_extentContext *_localctx = _tracker.createInstance<Window_frame_extentContext>(_ctx, getState());
  enterRule(_localctx, 364, TSqlParser::RuleWindow_frame_extent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3450);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CURRENT:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(3444);
        window_frame_preceding();
        break;
      }

      case TSqlParser::BETWEEN: {
        enterOuterAlt(_localctx, 2);
        setState(3445);
        match(TSqlParser::BETWEEN);
        setState(3446);
        window_frame_bound();
        setState(3447);
        match(TSqlParser::AND);
        setState(3448);
        window_frame_bound();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_boundContext ------------------------------------------------------------------

TSqlParser::Window_frame_boundContext::Window_frame_boundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_precedingContext* TSqlParser::Window_frame_boundContext::window_frame_preceding() {
  return getRuleContext<TSqlParser::Window_frame_precedingContext>(0);
}

TSqlParser::Window_frame_followingContext* TSqlParser::Window_frame_boundContext::window_frame_following() {
  return getRuleContext<TSqlParser::Window_frame_followingContext>(0);
}


size_t TSqlParser::Window_frame_boundContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_bound;
}

void TSqlParser::Window_frame_boundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_bound(this);
}

void TSqlParser::Window_frame_boundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_bound(this);
}

TSqlParser::Window_frame_boundContext* TSqlParser::window_frame_bound() {
  Window_frame_boundContext *_localctx = _tracker.createInstance<Window_frame_boundContext>(_ctx, getState());
  enterRule(_localctx, 366, TSqlParser::RuleWindow_frame_bound);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3454);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3452);
      window_frame_preceding();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3453);
      window_frame_following();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_precedingContext ------------------------------------------------------------------

TSqlParser::Window_frame_precedingContext::Window_frame_precedingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::PRECEDING() {
  return getToken(TSqlParser::PRECEDING, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}


size_t TSqlParser::Window_frame_precedingContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_preceding;
}

void TSqlParser::Window_frame_precedingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_preceding(this);
}

void TSqlParser::Window_frame_precedingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_preceding(this);
}

TSqlParser::Window_frame_precedingContext* TSqlParser::window_frame_preceding() {
  Window_frame_precedingContext *_localctx = _tracker.createInstance<Window_frame_precedingContext>(_ctx, getState());
  enterRule(_localctx, 368, TSqlParser::RuleWindow_frame_preceding);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3462);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(3456);
        match(TSqlParser::UNBOUNDED);
        setState(3457);
        match(TSqlParser::PRECEDING);
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3458);
        match(TSqlParser::DECIMAL);
        setState(3459);
        match(TSqlParser::PRECEDING);
        break;
      }

      case TSqlParser::CURRENT: {
        enterOuterAlt(_localctx, 3);
        setState(3460);
        match(TSqlParser::CURRENT);
        setState(3461);
        match(TSqlParser::ROW);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_followingContext ------------------------------------------------------------------

TSqlParser::Window_frame_followingContext::Window_frame_followingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::FOLLOWING() {
  return getToken(TSqlParser::FOLLOWING, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Window_frame_followingContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_following;
}

void TSqlParser::Window_frame_followingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_following(this);
}

void TSqlParser::Window_frame_followingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_following(this);
}

TSqlParser::Window_frame_followingContext* TSqlParser::window_frame_following() {
  Window_frame_followingContext *_localctx = _tracker.createInstance<Window_frame_followingContext>(_ctx, getState());
  enterRule(_localctx, 370, TSqlParser::RuleWindow_frame_following);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3468);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(3464);
        match(TSqlParser::UNBOUNDED);
        setState(3465);
        match(TSqlParser::FOLLOWING);
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3466);
        match(TSqlParser::DECIMAL);
        setState(3467);
        match(TSqlParser::FOLLOWING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_nameContext ------------------------------------------------------------------

TSqlParser::Entity_nameContext::Entity_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Entity_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Entity_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Entity_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Entity_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Entity_nameContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name;
}

void TSqlParser::Entity_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name(this);
}

void TSqlParser::Entity_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name(this);
}

TSqlParser::Entity_nameContext* TSqlParser::entity_name() {
  Entity_nameContext *_localctx = _tracker.createInstance<Entity_nameContext>(_ctx, getState());
  enterRule(_localctx, 372, TSqlParser::RuleEntity_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3487);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 499, _ctx)) {
    case 1: {
      setState(3470);
      dynamic_cast<Entity_nameContext *>(_localctx)->server = id_();
      setState(3471);
      match(TSqlParser::DOT);
      setState(3472);
      dynamic_cast<Entity_nameContext *>(_localctx)->database = id_();
      setState(3473);
      match(TSqlParser::DOT);
      setState(3474);
      dynamic_cast<Entity_nameContext *>(_localctx)->schema = id_();
      setState(3475);
      match(TSqlParser::DOT);
      break;
    }

    case 2: {
      setState(3477);
      dynamic_cast<Entity_nameContext *>(_localctx)->database = id_();
      setState(3478);
      match(TSqlParser::DOT);
      setState(3480);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3479);
        dynamic_cast<Entity_nameContext *>(_localctx)->schema = id_();
      }
      setState(3482);
      match(TSqlParser::DOT);
      break;
    }

    case 3: {
      setState(3484);
      dynamic_cast<Entity_nameContext *>(_localctx)->schema = id_();
      setState(3485);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3489);
    dynamic_cast<Entity_nameContext *>(_localctx)->table = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_name_for_azure_dwContext ------------------------------------------------------------------

TSqlParser::Entity_name_for_azure_dwContext::Entity_name_for_azure_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Entity_name_for_azure_dwContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Entity_name_for_azure_dwContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Entity_name_for_azure_dwContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Entity_name_for_azure_dwContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name_for_azure_dw;
}

void TSqlParser::Entity_name_for_azure_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name_for_azure_dw(this);
}

void TSqlParser::Entity_name_for_azure_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name_for_azure_dw(this);
}

TSqlParser::Entity_name_for_azure_dwContext* TSqlParser::entity_name_for_azure_dw() {
  Entity_name_for_azure_dwContext *_localctx = _tracker.createInstance<Entity_name_for_azure_dwContext>(_ctx, getState());
  enterRule(_localctx, 374, TSqlParser::RuleEntity_name_for_azure_dw);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3496);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3491);
      dynamic_cast<Entity_name_for_azure_dwContext *>(_localctx)->schema = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3492);
      dynamic_cast<Entity_name_for_azure_dwContext *>(_localctx)->schema = id_();
      setState(3493);
      match(TSqlParser::DOT);
      setState(3494);
      dynamic_cast<Entity_name_for_azure_dwContext *>(_localctx)->object_name = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_name_for_parallel_dwContext ------------------------------------------------------------------

TSqlParser::Entity_name_for_parallel_dwContext::Entity_name_for_parallel_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Entity_name_for_parallel_dwContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Entity_name_for_parallel_dwContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Entity_name_for_parallel_dwContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Entity_name_for_parallel_dwContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name_for_parallel_dw;
}

void TSqlParser::Entity_name_for_parallel_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name_for_parallel_dw(this);
}

void TSqlParser::Entity_name_for_parallel_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name_for_parallel_dw(this);
}

TSqlParser::Entity_name_for_parallel_dwContext* TSqlParser::entity_name_for_parallel_dw() {
  Entity_name_for_parallel_dwContext *_localctx = _tracker.createInstance<Entity_name_for_parallel_dwContext>(_ctx, getState());
  enterRule(_localctx, 376, TSqlParser::RuleEntity_name_for_parallel_dw);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3503);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 501, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3498);
      dynamic_cast<Entity_name_for_parallel_dwContext *>(_localctx)->schema_database = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3499);
      dynamic_cast<Entity_name_for_parallel_dwContext *>(_localctx)->schema = id_();
      setState(3500);
      match(TSqlParser::DOT);
      setState(3501);
      dynamic_cast<Entity_name_for_parallel_dwContext *>(_localctx)->object_name = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_table_nameContext ------------------------------------------------------------------

TSqlParser::Full_table_nameContext::Full_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Full_table_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Full_table_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Full_table_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Full_table_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Full_table_nameContext::getRuleIndex() const {
  return TSqlParser::RuleFull_table_name;
}

void TSqlParser::Full_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_table_name(this);
}

void TSqlParser::Full_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_table_name(this);
}

TSqlParser::Full_table_nameContext* TSqlParser::full_table_name() {
  Full_table_nameContext *_localctx = _tracker.createInstance<Full_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 378, TSqlParser::RuleFull_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3522);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 503, _ctx)) {
    case 1: {
      setState(3505);
      dynamic_cast<Full_table_nameContext *>(_localctx)->server = id_();
      setState(3506);
      match(TSqlParser::DOT);
      setState(3507);
      dynamic_cast<Full_table_nameContext *>(_localctx)->database = id_();
      setState(3508);
      match(TSqlParser::DOT);
      setState(3509);
      dynamic_cast<Full_table_nameContext *>(_localctx)->schema = id_();
      setState(3510);
      match(TSqlParser::DOT);
      break;
    }

    case 2: {
      setState(3512);
      dynamic_cast<Full_table_nameContext *>(_localctx)->database = id_();
      setState(3513);
      match(TSqlParser::DOT);
      setState(3515);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3514);
        dynamic_cast<Full_table_nameContext *>(_localctx)->schema = id_();
      }
      setState(3517);
      match(TSqlParser::DOT);
      break;
    }

    case 3: {
      setState(3519);
      dynamic_cast<Full_table_nameContext *>(_localctx)->schema = id_();
      setState(3520);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3524);
    dynamic_cast<Full_table_nameContext *>(_localctx)->table = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

TSqlParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_nameContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Table_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Table_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Table_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Table_nameContext::BLOCKING_HIERARCHY() {
  return getToken(TSqlParser::BLOCKING_HIERARCHY, 0);
}


size_t TSqlParser::Table_nameContext::getRuleIndex() const {
  return TSqlParser::RuleTable_name;
}

void TSqlParser::Table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name(this);
}

void TSqlParser::Table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name(this);
}

TSqlParser::Table_nameContext* TSqlParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 380, TSqlParser::RuleTable_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3553);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 508, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3526);
      dynamic_cast<Table_nameContext *>(_localctx)->loc_id = match(TSqlParser::LOCAL_ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3537);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx)) {
      case 1: {
        setState(3527);
        dynamic_cast<Table_nameContext *>(_localctx)->database = id_();
        setState(3528);
        match(TSqlParser::DOT);
        setState(3530);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
          | (1ULL << TSqlParser::NCHAR)
          | (1ULL << TSqlParser::TEXT)
          | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
          | (1ULL << (TSqlParser::ABSOLUTE - 122))
          | (1ULL << (TSqlParser::AT_KEYWORD - 122))
          | (1ULL << (TSqlParser::ACTION - 122))
          | (1ULL << (TSqlParser::AES_128 - 122))
          | (1ULL << (TSqlParser::AES_192 - 122))
          | (1ULL << (TSqlParser::AES_256 - 122))
          | (1ULL << (TSqlParser::ALGORITHM - 122))
          | (1ULL << (TSqlParser::ANSI_NULLS - 122))
          | (1ULL << (TSqlParser::ANSI_PADDING - 122))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
          | (1ULL << (TSqlParser::APPLY - 122))
          | (1ULL << (TSqlParser::ARITHABORT - 122))
          | (1ULL << (TSqlParser::AUTO - 122))
          | (1ULL << (TSqlParser::AVG - 122))
          | (1ULL << (TSqlParser::BIGINT - 122))
          | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
          | (1ULL << (TSqlParser::CALLER - 122))
          | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
          | (1ULL << (TSqlParser::CATCH - 186))
          | (1ULL << (TSqlParser::CHECKSUM - 186))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
          | (1ULL << (TSqlParser::COMMITTED - 186))
          | (1ULL << (TSqlParser::CONCAT - 186))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
          | (1ULL << (TSqlParser::COUNT - 186))
          | (1ULL << (TSqlParser::COUNT_BIG - 186))
          | (1ULL << (TSqlParser::CUME_DIST - 186))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
          | (1ULL << (TSqlParser::DATA - 186))
          | (1ULL << (TSqlParser::DATEADD - 186))
          | (1ULL << (TSqlParser::DATEDIFF - 186))
          | (1ULL << (TSqlParser::DATENAME - 186))
          | (1ULL << (TSqlParser::DATEPART - 186))
          | (1ULL << (TSqlParser::DAYS - 186))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
          | (1ULL << (TSqlParser::DELAY - 186))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
          | (1ULL << (TSqlParser::DELETED - 186))
          | (1ULL << (TSqlParser::DENSE_RANK - 186))
          | (1ULL << (TSqlParser::DES - 186))
          | (1ULL << (TSqlParser::DESCRIPTION - 186))
          | (1ULL << (TSqlParser::DESX - 186))
          | (1ULL << (TSqlParser::DISABLE - 186))
          | (1ULL << (TSqlParser::DYNAMIC - 186))
          | (1ULL << (TSqlParser::ELEMENTS - 186))
          | (1ULL << (TSqlParser::EMPTY - 186))
          | (1ULL << (TSqlParser::ENCRYPTION - 186))
          | (1ULL << (TSqlParser::EXCLUSIVE - 186))
          | (1ULL << (TSqlParser::FAST - 186))
          | (1ULL << (TSqlParser::FAST_FORWARD - 186))
          | (1ULL << (TSqlParser::FIRST - 186))
          | (1ULL << (TSqlParser::FIRST_VALUE - 186))
          | (1ULL << (TSqlParser::FOLLOWING - 186))
          | (1ULL << (TSqlParser::FORCE - 186))
          | (1ULL << (TSqlParser::FORCED - 186))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
          | (1ULL << (TSqlParser::GETDATE - 186))
          | (1ULL << (TSqlParser::GETUTCDATE - 186))
          | (1ULL << (TSqlParser::GLOBAL - 186))
          | (1ULL << (TSqlParser::GO_BATCH - 186))
          | (1ULL << (TSqlParser::GO - 186))
          | (1ULL << (TSqlParser::GROUPING - 186))
          | (1ULL << (TSqlParser::GROUPING_ID - 186))
          | (1ULL << (TSqlParser::HASH - 186))
          | (1ULL << (TSqlParser::HIGH - 186))
          | (1ULL << (TSqlParser::HOURS - 186))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
          | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
          | (1ULL << (TSqlParser::INPUT - 186))
          | (1ULL << (TSqlParser::INSENSITIVE - 186))
          | (1ULL << (TSqlParser::INSERTED - 186))
          | (1ULL << (TSqlParser::INT - 186))
          | (1ULL << (TSqlParser::ISOLATION - 186))
          | (1ULL << (TSqlParser::KEEP - 186))
          | (1ULL << (TSqlParser::KEEPFIXED - 186))
          | (1ULL << (TSqlParser::KEYSET - 186))
          | (1ULL << (TSqlParser::LAG - 186))
          | (1ULL << (TSqlParser::LAST - 186))
          | (1ULL << (TSqlParser::LAST_VALUE - 186))
          | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
          | (1ULL << (TSqlParser::LOCAL - 250))
          | (1ULL << (TSqlParser::LOCATION - 250))
          | (1ULL << (TSqlParser::LOCK - 250))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
          | (1ULL << (TSqlParser::LOOP - 250))
          | (1ULL << (TSqlParser::LOW - 250))
          | (1ULL << (TSqlParser::MANUAL - 250))
          | (1ULL << (TSqlParser::MARK - 250))
          | (1ULL << (TSqlParser::MAX - 250))
          | (1ULL << (TSqlParser::MAXDOP - 250))
          | (1ULL << (TSqlParser::MAXRECURSION - 250))
          | (1ULL << (TSqlParser::MIN - 250))
          | (1ULL << (TSqlParser::MINUTES - 250))
          | (1ULL << (TSqlParser::MODE - 250))
          | (1ULL << (TSqlParser::NEXT - 250))
          | (1ULL << (TSqlParser::NO - 250))
          | (1ULL << (TSqlParser::NOCOUNT - 250))
          | (1ULL << (TSqlParser::NODES - 250))
          | (1ULL << (TSqlParser::NOEXPAND - 250))
          | (1ULL << (TSqlParser::NOWAIT - 250))
          | (1ULL << (TSqlParser::NTILE - 250))
          | (1ULL << (TSqlParser::NUMANODE - 250))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
          | (1ULL << (TSqlParser::OBJECT - 250))
          | (1ULL << (TSqlParser::OFFSET - 250))
          | (1ULL << (TSqlParser::ONLINE - 250))
          | (1ULL << (TSqlParser::ONLY - 250))
          | (1ULL << (TSqlParser::OPTIMISTIC - 250))
          | (1ULL << (TSqlParser::OPTIMIZE - 250))
          | (1ULL << (TSqlParser::OUT - 250))
          | (1ULL << (TSqlParser::OUTPUT - 250))
          | (1ULL << (TSqlParser::OWNER - 250))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
          | (1ULL << (TSqlParser::PARTITION - 250))
          | (1ULL << (TSqlParser::PARTITIONS - 250))
          | (1ULL << (TSqlParser::PERCENT_RANK - 250))
          | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
          | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
          | (1ULL << (TSqlParser::PRECEDING - 250))
          | (1ULL << (TSqlParser::PRIOR - 250))
          | (1ULL << (TSqlParser::QUERY - 250))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
          | (1ULL << (TSqlParser::RANGE - 250))
          | (1ULL << (TSqlParser::RANK - 250))
          | (1ULL << (TSqlParser::RC2 - 250))
          | (1ULL << (TSqlParser::RC4 - 250))
          | (1ULL << (TSqlParser::RC4_128 - 250))
          | (1ULL << (TSqlParser::READ_ONLY - 250))
          | (1ULL << (TSqlParser::READONLY - 250))
          | (1ULL << (TSqlParser::REBUILD - 250))
          | (1ULL << (TSqlParser::RECOMPILE - 250))
          | (1ULL << (TSqlParser::RELATIVE - 250))
          | (1ULL << (TSqlParser::REMOTE - 250))
          | (1ULL << (TSqlParser::REPEATABLE - 250))
          | (1ULL << (TSqlParser::ROBUST - 250))
          | (1ULL << (TSqlParser::ROW - 250))
          | (1ULL << (TSqlParser::ROW_NUMBER - 250))
          | (1ULL << (TSqlParser::ROWGUID - 250))
          | (1ULL << (TSqlParser::ROWS - 250))
          | (1ULL << (TSqlParser::SCHEMABINDING - 250))
          | (1ULL << (TSqlParser::SCROLL - 250))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
          | (1ULL << (TSqlParser::SELF - 314))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
          | (1ULL << (TSqlParser::SEQUENCE - 314))
          | (1ULL << (TSqlParser::SERIALIZABLE - 314))
          | (1ULL << (TSqlParser::SETERROR - 314))
          | (1ULL << (TSqlParser::SHARE - 314))
          | (1ULL << (TSqlParser::SIMPLE - 314))
          | (1ULL << (TSqlParser::SIZE - 314))
          | (1ULL << (TSqlParser::SMALLINT - 314))
          | (1ULL << (TSqlParser::SNAPSHOT - 314))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
          | (1ULL << (TSqlParser::STATIC - 314))
          | (1ULL << (TSqlParser::STATUSONLY - 314))
          | (1ULL << (TSqlParser::STDEV - 314))
          | (1ULL << (TSqlParser::STDEVP - 314))
          | (1ULL << (TSqlParser::STRING_AGG - 314))
          | (1ULL << (TSqlParser::STUFF - 314))
          | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
          | (1ULL << (TSqlParser::SUM - 314))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
          | (1ULL << (TSqlParser::THROW - 314))
          | (1ULL << (TSqlParser::TIES - 314))
          | (1ULL << (TSqlParser::TIME - 314))
          | (1ULL << (TSqlParser::TIMEOUT - 314))
          | (1ULL << (TSqlParser::TINYINT - 314))
          | (1ULL << (TSqlParser::TRIPLE_DES - 314))
          | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
          | (1ULL << (TSqlParser::TRY - 314))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
          | (1ULL << (TSqlParser::TYPE - 314))
          | (1ULL << (TSqlParser::TYPE_WARNING - 314))
          | (1ULL << (TSqlParser::UNBOUNDED - 314))
          | (1ULL << (TSqlParser::UNCOMMITTED - 314))
          | (1ULL << (TSqlParser::UNKNOWN - 314))
          | (1ULL << (TSqlParser::UOW - 314))
          | (1ULL << (TSqlParser::USING - 314))
          | (1ULL << (TSqlParser::VAR - 314))
          | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
          | (1ULL << (TSqlParser::VARP - 314))
          | (1ULL << (TSqlParser::WAIT - 314))
          | (1ULL << (TSqlParser::WORK - 314))
          | (1ULL << (TSqlParser::ZONE - 314))
          | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
          | (1ULL << (TSqlParser::CACHE - 314))
          | (1ULL << (TSqlParser::CALLED - 314))
          | (1ULL << (TSqlParser::CHANGETABLE - 314))
          | (1ULL << (TSqlParser::CHANGES - 314))
          | (1ULL << (TSqlParser::CYCLE - 314))
          | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
          | (1ULL << (TSqlParser::ERROR - 314))
          | (1ULL << (TSqlParser::FORCESEEK - 314))
          | (1ULL << (TSqlParser::IIF - 314))
          | (1ULL << (TSqlParser::INCREMENT - 314))
          | (1ULL << (TSqlParser::ISNULL - 314))
          | (1ULL << (TSqlParser::LOG - 314))
          | (1ULL << (TSqlParser::MATCHED - 314))
          | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
          | (1ULL << (TSqlParser::NOTIFICATION - 378))
          | (1ULL << (TSqlParser::PERSISTED - 378))
          | (1ULL << (TSqlParser::PREDICATE - 378))
          | (1ULL << (TSqlParser::RESTART - 378))
          | (1ULL << (TSqlParser::RETURNS - 378))
          | (1ULL << (TSqlParser::SOURCE - 378))
          | (1ULL << (TSqlParser::STATE - 378))
          | (1ULL << (TSqlParser::START - 378))
          | (1ULL << (TSqlParser::TARGET - 378))
          | (1ULL << (TSqlParser::VARCHAR - 378))
          | (1ULL << (TSqlParser::NVARCHAR - 378))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
          | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
          setState(3529);
          dynamic_cast<Table_nameContext *>(_localctx)->schema = id_();
        }
        setState(3532);
        match(TSqlParser::DOT);
        break;
      }

      case 2: {
        setState(3534);
        dynamic_cast<Table_nameContext *>(_localctx)->schema = id_();
        setState(3535);
        match(TSqlParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(3539);
      dynamic_cast<Table_nameContext *>(_localctx)->table = id_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3550);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
      case 1: {
        setState(3540);
        dynamic_cast<Table_nameContext *>(_localctx)->database = id_();
        setState(3541);
        match(TSqlParser::DOT);
        setState(3543);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
          | (1ULL << TSqlParser::NCHAR)
          | (1ULL << TSqlParser::TEXT)
          | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
          | (1ULL << (TSqlParser::ABSOLUTE - 122))
          | (1ULL << (TSqlParser::AT_KEYWORD - 122))
          | (1ULL << (TSqlParser::ACTION - 122))
          | (1ULL << (TSqlParser::AES_128 - 122))
          | (1ULL << (TSqlParser::AES_192 - 122))
          | (1ULL << (TSqlParser::AES_256 - 122))
          | (1ULL << (TSqlParser::ALGORITHM - 122))
          | (1ULL << (TSqlParser::ANSI_NULLS - 122))
          | (1ULL << (TSqlParser::ANSI_PADDING - 122))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
          | (1ULL << (TSqlParser::APPLY - 122))
          | (1ULL << (TSqlParser::ARITHABORT - 122))
          | (1ULL << (TSqlParser::AUTO - 122))
          | (1ULL << (TSqlParser::AVG - 122))
          | (1ULL << (TSqlParser::BIGINT - 122))
          | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
          | (1ULL << (TSqlParser::CALLER - 122))
          | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
          | (1ULL << (TSqlParser::CATCH - 186))
          | (1ULL << (TSqlParser::CHECKSUM - 186))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
          | (1ULL << (TSqlParser::COMMITTED - 186))
          | (1ULL << (TSqlParser::CONCAT - 186))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
          | (1ULL << (TSqlParser::COUNT - 186))
          | (1ULL << (TSqlParser::COUNT_BIG - 186))
          | (1ULL << (TSqlParser::CUME_DIST - 186))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
          | (1ULL << (TSqlParser::DATA - 186))
          | (1ULL << (TSqlParser::DATEADD - 186))
          | (1ULL << (TSqlParser::DATEDIFF - 186))
          | (1ULL << (TSqlParser::DATENAME - 186))
          | (1ULL << (TSqlParser::DATEPART - 186))
          | (1ULL << (TSqlParser::DAYS - 186))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
          | (1ULL << (TSqlParser::DELAY - 186))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
          | (1ULL << (TSqlParser::DELETED - 186))
          | (1ULL << (TSqlParser::DENSE_RANK - 186))
          | (1ULL << (TSqlParser::DES - 186))
          | (1ULL << (TSqlParser::DESCRIPTION - 186))
          | (1ULL << (TSqlParser::DESX - 186))
          | (1ULL << (TSqlParser::DISABLE - 186))
          | (1ULL << (TSqlParser::DYNAMIC - 186))
          | (1ULL << (TSqlParser::ELEMENTS - 186))
          | (1ULL << (TSqlParser::EMPTY - 186))
          | (1ULL << (TSqlParser::ENCRYPTION - 186))
          | (1ULL << (TSqlParser::EXCLUSIVE - 186))
          | (1ULL << (TSqlParser::FAST - 186))
          | (1ULL << (TSqlParser::FAST_FORWARD - 186))
          | (1ULL << (TSqlParser::FIRST - 186))
          | (1ULL << (TSqlParser::FIRST_VALUE - 186))
          | (1ULL << (TSqlParser::FOLLOWING - 186))
          | (1ULL << (TSqlParser::FORCE - 186))
          | (1ULL << (TSqlParser::FORCED - 186))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
          | (1ULL << (TSqlParser::GETDATE - 186))
          | (1ULL << (TSqlParser::GETUTCDATE - 186))
          | (1ULL << (TSqlParser::GLOBAL - 186))
          | (1ULL << (TSqlParser::GO_BATCH - 186))
          | (1ULL << (TSqlParser::GO - 186))
          | (1ULL << (TSqlParser::GROUPING - 186))
          | (1ULL << (TSqlParser::GROUPING_ID - 186))
          | (1ULL << (TSqlParser::HASH - 186))
          | (1ULL << (TSqlParser::HIGH - 186))
          | (1ULL << (TSqlParser::HOURS - 186))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
          | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
          | (1ULL << (TSqlParser::INPUT - 186))
          | (1ULL << (TSqlParser::INSENSITIVE - 186))
          | (1ULL << (TSqlParser::INSERTED - 186))
          | (1ULL << (TSqlParser::INT - 186))
          | (1ULL << (TSqlParser::ISOLATION - 186))
          | (1ULL << (TSqlParser::KEEP - 186))
          | (1ULL << (TSqlParser::KEEPFIXED - 186))
          | (1ULL << (TSqlParser::KEYSET - 186))
          | (1ULL << (TSqlParser::LAG - 186))
          | (1ULL << (TSqlParser::LAST - 186))
          | (1ULL << (TSqlParser::LAST_VALUE - 186))
          | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
          | (1ULL << (TSqlParser::LOCAL - 250))
          | (1ULL << (TSqlParser::LOCATION - 250))
          | (1ULL << (TSqlParser::LOCK - 250))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
          | (1ULL << (TSqlParser::LOOP - 250))
          | (1ULL << (TSqlParser::LOW - 250))
          | (1ULL << (TSqlParser::MANUAL - 250))
          | (1ULL << (TSqlParser::MARK - 250))
          | (1ULL << (TSqlParser::MAX - 250))
          | (1ULL << (TSqlParser::MAXDOP - 250))
          | (1ULL << (TSqlParser::MAXRECURSION - 250))
          | (1ULL << (TSqlParser::MIN - 250))
          | (1ULL << (TSqlParser::MINUTES - 250))
          | (1ULL << (TSqlParser::MODE - 250))
          | (1ULL << (TSqlParser::NEXT - 250))
          | (1ULL << (TSqlParser::NO - 250))
          | (1ULL << (TSqlParser::NOCOUNT - 250))
          | (1ULL << (TSqlParser::NODES - 250))
          | (1ULL << (TSqlParser::NOEXPAND - 250))
          | (1ULL << (TSqlParser::NOWAIT - 250))
          | (1ULL << (TSqlParser::NTILE - 250))
          | (1ULL << (TSqlParser::NUMANODE - 250))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
          | (1ULL << (TSqlParser::OBJECT - 250))
          | (1ULL << (TSqlParser::OFFSET - 250))
          | (1ULL << (TSqlParser::ONLINE - 250))
          | (1ULL << (TSqlParser::ONLY - 250))
          | (1ULL << (TSqlParser::OPTIMISTIC - 250))
          | (1ULL << (TSqlParser::OPTIMIZE - 250))
          | (1ULL << (TSqlParser::OUT - 250))
          | (1ULL << (TSqlParser::OUTPUT - 250))
          | (1ULL << (TSqlParser::OWNER - 250))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
          | (1ULL << (TSqlParser::PARTITION - 250))
          | (1ULL << (TSqlParser::PARTITIONS - 250))
          | (1ULL << (TSqlParser::PERCENT_RANK - 250))
          | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
          | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
          | (1ULL << (TSqlParser::PRECEDING - 250))
          | (1ULL << (TSqlParser::PRIOR - 250))
          | (1ULL << (TSqlParser::QUERY - 250))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
          | (1ULL << (TSqlParser::RANGE - 250))
          | (1ULL << (TSqlParser::RANK - 250))
          | (1ULL << (TSqlParser::RC2 - 250))
          | (1ULL << (TSqlParser::RC4 - 250))
          | (1ULL << (TSqlParser::RC4_128 - 250))
          | (1ULL << (TSqlParser::READ_ONLY - 250))
          | (1ULL << (TSqlParser::READONLY - 250))
          | (1ULL << (TSqlParser::REBUILD - 250))
          | (1ULL << (TSqlParser::RECOMPILE - 250))
          | (1ULL << (TSqlParser::RELATIVE - 250))
          | (1ULL << (TSqlParser::REMOTE - 250))
          | (1ULL << (TSqlParser::REPEATABLE - 250))
          | (1ULL << (TSqlParser::ROBUST - 250))
          | (1ULL << (TSqlParser::ROW - 250))
          | (1ULL << (TSqlParser::ROW_NUMBER - 250))
          | (1ULL << (TSqlParser::ROWGUID - 250))
          | (1ULL << (TSqlParser::ROWS - 250))
          | (1ULL << (TSqlParser::SCHEMABINDING - 250))
          | (1ULL << (TSqlParser::SCROLL - 250))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
          | (1ULL << (TSqlParser::SELF - 314))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
          | (1ULL << (TSqlParser::SEQUENCE - 314))
          | (1ULL << (TSqlParser::SERIALIZABLE - 314))
          | (1ULL << (TSqlParser::SETERROR - 314))
          | (1ULL << (TSqlParser::SHARE - 314))
          | (1ULL << (TSqlParser::SIMPLE - 314))
          | (1ULL << (TSqlParser::SIZE - 314))
          | (1ULL << (TSqlParser::SMALLINT - 314))
          | (1ULL << (TSqlParser::SNAPSHOT - 314))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
          | (1ULL << (TSqlParser::STATIC - 314))
          | (1ULL << (TSqlParser::STATUSONLY - 314))
          | (1ULL << (TSqlParser::STDEV - 314))
          | (1ULL << (TSqlParser::STDEVP - 314))
          | (1ULL << (TSqlParser::STRING_AGG - 314))
          | (1ULL << (TSqlParser::STUFF - 314))
          | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
          | (1ULL << (TSqlParser::SUM - 314))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
          | (1ULL << (TSqlParser::THROW - 314))
          | (1ULL << (TSqlParser::TIES - 314))
          | (1ULL << (TSqlParser::TIME - 314))
          | (1ULL << (TSqlParser::TIMEOUT - 314))
          | (1ULL << (TSqlParser::TINYINT - 314))
          | (1ULL << (TSqlParser::TRIPLE_DES - 314))
          | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
          | (1ULL << (TSqlParser::TRY - 314))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
          | (1ULL << (TSqlParser::TYPE - 314))
          | (1ULL << (TSqlParser::TYPE_WARNING - 314))
          | (1ULL << (TSqlParser::UNBOUNDED - 314))
          | (1ULL << (TSqlParser::UNCOMMITTED - 314))
          | (1ULL << (TSqlParser::UNKNOWN - 314))
          | (1ULL << (TSqlParser::UOW - 314))
          | (1ULL << (TSqlParser::USING - 314))
          | (1ULL << (TSqlParser::VAR - 314))
          | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
          | (1ULL << (TSqlParser::VARP - 314))
          | (1ULL << (TSqlParser::WAIT - 314))
          | (1ULL << (TSqlParser::WORK - 314))
          | (1ULL << (TSqlParser::ZONE - 314))
          | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
          | (1ULL << (TSqlParser::CACHE - 314))
          | (1ULL << (TSqlParser::CALLED - 314))
          | (1ULL << (TSqlParser::CHANGETABLE - 314))
          | (1ULL << (TSqlParser::CHANGES - 314))
          | (1ULL << (TSqlParser::CYCLE - 314))
          | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
          | (1ULL << (TSqlParser::ERROR - 314))
          | (1ULL << (TSqlParser::FORCESEEK - 314))
          | (1ULL << (TSqlParser::IIF - 314))
          | (1ULL << (TSqlParser::INCREMENT - 314))
          | (1ULL << (TSqlParser::ISNULL - 314))
          | (1ULL << (TSqlParser::LOG - 314))
          | (1ULL << (TSqlParser::MATCHED - 314))
          | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
          | (1ULL << (TSqlParser::NOTIFICATION - 378))
          | (1ULL << (TSqlParser::PERSISTED - 378))
          | (1ULL << (TSqlParser::PREDICATE - 378))
          | (1ULL << (TSqlParser::RESTART - 378))
          | (1ULL << (TSqlParser::RETURNS - 378))
          | (1ULL << (TSqlParser::SOURCE - 378))
          | (1ULL << (TSqlParser::STATE - 378))
          | (1ULL << (TSqlParser::START - 378))
          | (1ULL << (TSqlParser::TARGET - 378))
          | (1ULL << (TSqlParser::VARCHAR - 378))
          | (1ULL << (TSqlParser::NVARCHAR - 378))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
          | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
          setState(3542);
          dynamic_cast<Table_nameContext *>(_localctx)->schema = id_();
        }
        setState(3545);
        match(TSqlParser::DOT);
        break;
      }

      case 2: {
        setState(3547);
        dynamic_cast<Table_nameContext *>(_localctx)->schema = id_();
        setState(3548);
        match(TSqlParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(3552);
      dynamic_cast<Table_nameContext *>(_localctx)->blocking_hierarchy = match(TSqlParser::BLOCKING_HIERARCHY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_nameContext ------------------------------------------------------------------

TSqlParser::Simple_nameContext::Simple_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Simple_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Simple_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Simple_nameContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Simple_nameContext::getRuleIndex() const {
  return TSqlParser::RuleSimple_name;
}

void TSqlParser::Simple_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_name(this);
}

void TSqlParser::Simple_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_name(this);
}

TSqlParser::Simple_nameContext* TSqlParser::simple_name() {
  Simple_nameContext *_localctx = _tracker.createInstance<Simple_nameContext>(_ctx, getState());
  enterRule(_localctx, 382, TSqlParser::RuleSimple_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3558);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 509, _ctx)) {
    case 1: {
      setState(3555);
      dynamic_cast<Simple_nameContext *>(_localctx)->schema = id_();
      setState(3556);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3560);
    dynamic_cast<Simple_nameContext *>(_localctx)->name = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_schemaContext::Func_proc_name_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Func_proc_name_schemaContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Func_proc_name_schemaContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Func_proc_name_schemaContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Func_proc_name_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_schema;
}

void TSqlParser::Func_proc_name_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_schema(this);
}

void TSqlParser::Func_proc_name_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_schema(this);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::func_proc_name_schema() {
  Func_proc_name_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_schemaContext>(_ctx, getState());
  enterRule(_localctx, 384, TSqlParser::RuleFunc_proc_name_schema);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3565);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx)) {
    case 1: {
      setState(3562);
      dynamic_cast<Func_proc_name_schemaContext *>(_localctx)->schema = id_();
      setState(3563);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3567);
    dynamic_cast<Func_proc_name_schemaContext *>(_localctx)->procedure = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_database_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_database_schemaContext::Func_proc_name_database_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Func_proc_name_database_schemaContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Func_proc_name_database_schemaContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Func_proc_name_database_schemaContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Func_proc_name_database_schemaContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Func_proc_name_database_schemaContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}


size_t TSqlParser::Func_proc_name_database_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_database_schema;
}

void TSqlParser::Func_proc_name_database_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_database_schema(this);
}

void TSqlParser::Func_proc_name_database_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_database_schema(this);
}

TSqlParser::Func_proc_name_database_schemaContext* TSqlParser::func_proc_name_database_schema() {
  Func_proc_name_database_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_database_schemaContext>(_ctx, getState());
  enterRule(_localctx, 386, TSqlParser::RuleFunc_proc_name_database_schema);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3579);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3570);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3569);
        dynamic_cast<Func_proc_name_database_schemaContext *>(_localctx)->database = id_();
      }
      setState(3572);
      match(TSqlParser::DOT);
      setState(3574);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3573);
        dynamic_cast<Func_proc_name_database_schemaContext *>(_localctx)->schema = id_();
      }
      setState(3576);
      match(TSqlParser::DOT);
      setState(3577);
      dynamic_cast<Func_proc_name_database_schemaContext *>(_localctx)->procedure = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3578);
      func_proc_name_schema();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_server_database_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_server_database_schemaContext::Func_proc_name_server_database_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Func_proc_name_server_database_schemaContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Func_proc_name_server_database_schemaContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Func_proc_name_server_database_schemaContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Func_proc_name_server_database_schemaContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Func_proc_name_database_schemaContext* TSqlParser::Func_proc_name_server_database_schemaContext::func_proc_name_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_database_schemaContext>(0);
}


size_t TSqlParser::Func_proc_name_server_database_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_server_database_schema;
}

void TSqlParser::Func_proc_name_server_database_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_server_database_schema(this);
}

void TSqlParser::Func_proc_name_server_database_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_server_database_schema(this);
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::func_proc_name_server_database_schema() {
  Func_proc_name_server_database_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_server_database_schemaContext>(_ctx, getState());
  enterRule(_localctx, 388, TSqlParser::RuleFunc_proc_name_server_database_schema);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3595);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3582);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3581);
        dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->server = id_();
      }
      setState(3584);
      match(TSqlParser::DOT);
      setState(3586);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3585);
        dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->database = id_();
      }
      setState(3588);
      match(TSqlParser::DOT);
      setState(3590);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3589);
        dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->schema = id_();
      }
      setState(3592);
      match(TSqlParser::DOT);
      setState(3593);
      dynamic_cast<Func_proc_name_server_database_schemaContext *>(_localctx)->procedure = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3594);
      func_proc_name_database_schema();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_objectContext ------------------------------------------------------------------

TSqlParser::Ddl_objectContext::Ddl_objectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Full_table_nameContext* TSqlParser::Ddl_objectContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Ddl_objectContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Ddl_objectContext::getRuleIndex() const {
  return TSqlParser::RuleDdl_object;
}

void TSqlParser::Ddl_objectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDdl_object(this);
}

void TSqlParser::Ddl_objectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDdl_object(this);
}

TSqlParser::Ddl_objectContext* TSqlParser::ddl_object() {
  Ddl_objectContext *_localctx = _tracker.createInstance<Ddl_objectContext>(_ctx, getState());
  enterRule(_localctx, 390, TSqlParser::RuleDdl_object);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3599);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3597);
        full_table_name();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3598);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_column_nameContext ------------------------------------------------------------------

TSqlParser::Full_column_nameContext::Full_column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Full_column_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Full_column_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Full_column_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Full_column_nameContext::getRuleIndex() const {
  return TSqlParser::RuleFull_column_name;
}

void TSqlParser::Full_column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_column_name(this);
}

void TSqlParser::Full_column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_column_name(this);
}

TSqlParser::Full_column_nameContext* TSqlParser::full_column_name() {
  Full_column_nameContext *_localctx = _tracker.createInstance<Full_column_nameContext>(_ctx, getState());
  enterRule(_localctx, 392, TSqlParser::RuleFull_column_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3632);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3601);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DELETED

      || _la == TSqlParser::INSERTED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3602);
      match(TSqlParser::DOT);
      setState(3603);
      dynamic_cast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3605);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3604);
        dynamic_cast<Full_column_nameContext *>(_localctx)->server = id_();
      }
      setState(3607);
      match(TSqlParser::DOT);
      setState(3609);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3608);
        dynamic_cast<Full_column_nameContext *>(_localctx)->schema = id_();
      }
      setState(3611);
      match(TSqlParser::DOT);
      setState(3613);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3612);
        dynamic_cast<Full_column_nameContext *>(_localctx)->tablename = id_();
      }
      setState(3615);
      match(TSqlParser::DOT);
      setState(3616);
      dynamic_cast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3618);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3617);
        dynamic_cast<Full_column_nameContext *>(_localctx)->schema = id_();
      }
      setState(3620);
      match(TSqlParser::DOT);
      setState(3622);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3621);
        dynamic_cast<Full_column_nameContext *>(_localctx)->tablename = id_();
      }
      setState(3624);
      match(TSqlParser::DOT);
      setState(3625);
      dynamic_cast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
        | (1ULL << (TSqlParser::ABSOLUTE - 122))
        | (1ULL << (TSqlParser::AT_KEYWORD - 122))
        | (1ULL << (TSqlParser::ACTION - 122))
        | (1ULL << (TSqlParser::AES_128 - 122))
        | (1ULL << (TSqlParser::AES_192 - 122))
        | (1ULL << (TSqlParser::AES_256 - 122))
        | (1ULL << (TSqlParser::ALGORITHM - 122))
        | (1ULL << (TSqlParser::ANSI_NULLS - 122))
        | (1ULL << (TSqlParser::ANSI_PADDING - 122))
        | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
        | (1ULL << (TSqlParser::APPLY - 122))
        | (1ULL << (TSqlParser::ARITHABORT - 122))
        | (1ULL << (TSqlParser::AUTO - 122))
        | (1ULL << (TSqlParser::AVG - 122))
        | (1ULL << (TSqlParser::BIGINT - 122))
        | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
        | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
        | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
        | (1ULL << (TSqlParser::CALLER - 122))
        | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
        | (1ULL << (TSqlParser::CATCH - 186))
        | (1ULL << (TSqlParser::CHECKSUM - 186))
        | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
        | (1ULL << (TSqlParser::COMMITTED - 186))
        | (1ULL << (TSqlParser::CONCAT - 186))
        | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
        | (1ULL << (TSqlParser::COUNT - 186))
        | (1ULL << (TSqlParser::COUNT_BIG - 186))
        | (1ULL << (TSqlParser::CUME_DIST - 186))
        | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
        | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
        | (1ULL << (TSqlParser::DATA - 186))
        | (1ULL << (TSqlParser::DATEADD - 186))
        | (1ULL << (TSqlParser::DATEDIFF - 186))
        | (1ULL << (TSqlParser::DATENAME - 186))
        | (1ULL << (TSqlParser::DATEPART - 186))
        | (1ULL << (TSqlParser::DAYS - 186))
        | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
        | (1ULL << (TSqlParser::DELAY - 186))
        | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
        | (1ULL << (TSqlParser::DELETED - 186))
        | (1ULL << (TSqlParser::DENSE_RANK - 186))
        | (1ULL << (TSqlParser::DES - 186))
        | (1ULL << (TSqlParser::DESCRIPTION - 186))
        | (1ULL << (TSqlParser::DESX - 186))
        | (1ULL << (TSqlParser::DISABLE - 186))
        | (1ULL << (TSqlParser::DYNAMIC - 186))
        | (1ULL << (TSqlParser::ELEMENTS - 186))
        | (1ULL << (TSqlParser::EMPTY - 186))
        | (1ULL << (TSqlParser::ENCRYPTION - 186))
        | (1ULL << (TSqlParser::EXCLUSIVE - 186))
        | (1ULL << (TSqlParser::FAST - 186))
        | (1ULL << (TSqlParser::FAST_FORWARD - 186))
        | (1ULL << (TSqlParser::FIRST - 186))
        | (1ULL << (TSqlParser::FIRST_VALUE - 186))
        | (1ULL << (TSqlParser::FOLLOWING - 186))
        | (1ULL << (TSqlParser::FORCE - 186))
        | (1ULL << (TSqlParser::FORCED - 186))
        | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
        | (1ULL << (TSqlParser::GETDATE - 186))
        | (1ULL << (TSqlParser::GETUTCDATE - 186))
        | (1ULL << (TSqlParser::GLOBAL - 186))
        | (1ULL << (TSqlParser::GO_BATCH - 186))
        | (1ULL << (TSqlParser::GO - 186))
        | (1ULL << (TSqlParser::GROUPING - 186))
        | (1ULL << (TSqlParser::GROUPING_ID - 186))
        | (1ULL << (TSqlParser::HASH - 186))
        | (1ULL << (TSqlParser::HIGH - 186))
        | (1ULL << (TSqlParser::HOURS - 186))
        | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
        | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
        | (1ULL << (TSqlParser::INPUT - 186))
        | (1ULL << (TSqlParser::INSENSITIVE - 186))
        | (1ULL << (TSqlParser::INSERTED - 186))
        | (1ULL << (TSqlParser::INT - 186))
        | (1ULL << (TSqlParser::ISOLATION - 186))
        | (1ULL << (TSqlParser::KEEP - 186))
        | (1ULL << (TSqlParser::KEEPFIXED - 186))
        | (1ULL << (TSqlParser::KEYSET - 186))
        | (1ULL << (TSqlParser::LAG - 186))
        | (1ULL << (TSqlParser::LAST - 186))
        | (1ULL << (TSqlParser::LAST_VALUE - 186))
        | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
        | (1ULL << (TSqlParser::LOCAL - 250))
        | (1ULL << (TSqlParser::LOCATION - 250))
        | (1ULL << (TSqlParser::LOCK - 250))
        | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
        | (1ULL << (TSqlParser::LOOP - 250))
        | (1ULL << (TSqlParser::LOW - 250))
        | (1ULL << (TSqlParser::MANUAL - 250))
        | (1ULL << (TSqlParser::MARK - 250))
        | (1ULL << (TSqlParser::MAX - 250))
        | (1ULL << (TSqlParser::MAXDOP - 250))
        | (1ULL << (TSqlParser::MAXRECURSION - 250))
        | (1ULL << (TSqlParser::MIN - 250))
        | (1ULL << (TSqlParser::MINUTES - 250))
        | (1ULL << (TSqlParser::MODE - 250))
        | (1ULL << (TSqlParser::NEXT - 250))
        | (1ULL << (TSqlParser::NO - 250))
        | (1ULL << (TSqlParser::NOCOUNT - 250))
        | (1ULL << (TSqlParser::NODES - 250))
        | (1ULL << (TSqlParser::NOEXPAND - 250))
        | (1ULL << (TSqlParser::NOWAIT - 250))
        | (1ULL << (TSqlParser::NTILE - 250))
        | (1ULL << (TSqlParser::NUMANODE - 250))
        | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
        | (1ULL << (TSqlParser::OBJECT - 250))
        | (1ULL << (TSqlParser::OFFSET - 250))
        | (1ULL << (TSqlParser::ONLINE - 250))
        | (1ULL << (TSqlParser::ONLY - 250))
        | (1ULL << (TSqlParser::OPTIMISTIC - 250))
        | (1ULL << (TSqlParser::OPTIMIZE - 250))
        | (1ULL << (TSqlParser::OUT - 250))
        | (1ULL << (TSqlParser::OUTPUT - 250))
        | (1ULL << (TSqlParser::OWNER - 250))
        | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
        | (1ULL << (TSqlParser::PARTITION - 250))
        | (1ULL << (TSqlParser::PARTITIONS - 250))
        | (1ULL << (TSqlParser::PERCENT_RANK - 250))
        | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
        | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
        | (1ULL << (TSqlParser::PRECEDING - 250))
        | (1ULL << (TSqlParser::PRIOR - 250))
        | (1ULL << (TSqlParser::QUERY - 250))
        | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
        | (1ULL << (TSqlParser::RANGE - 250))
        | (1ULL << (TSqlParser::RANK - 250))
        | (1ULL << (TSqlParser::RC2 - 250))
        | (1ULL << (TSqlParser::RC4 - 250))
        | (1ULL << (TSqlParser::RC4_128 - 250))
        | (1ULL << (TSqlParser::READ_ONLY - 250))
        | (1ULL << (TSqlParser::READONLY - 250))
        | (1ULL << (TSqlParser::REBUILD - 250))
        | (1ULL << (TSqlParser::RECOMPILE - 250))
        | (1ULL << (TSqlParser::RELATIVE - 250))
        | (1ULL << (TSqlParser::REMOTE - 250))
        | (1ULL << (TSqlParser::REPEATABLE - 250))
        | (1ULL << (TSqlParser::ROBUST - 250))
        | (1ULL << (TSqlParser::ROW - 250))
        | (1ULL << (TSqlParser::ROW_NUMBER - 250))
        | (1ULL << (TSqlParser::ROWGUID - 250))
        | (1ULL << (TSqlParser::ROWS - 250))
        | (1ULL << (TSqlParser::SCHEMABINDING - 250))
        | (1ULL << (TSqlParser::SCROLL - 250))
        | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
        | (1ULL << (TSqlParser::SELF - 314))
        | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
        | (1ULL << (TSqlParser::SEQUENCE - 314))
        | (1ULL << (TSqlParser::SERIALIZABLE - 314))
        | (1ULL << (TSqlParser::SETERROR - 314))
        | (1ULL << (TSqlParser::SHARE - 314))
        | (1ULL << (TSqlParser::SIMPLE - 314))
        | (1ULL << (TSqlParser::SIZE - 314))
        | (1ULL << (TSqlParser::SMALLINT - 314))
        | (1ULL << (TSqlParser::SNAPSHOT - 314))
        | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
        | (1ULL << (TSqlParser::STATIC - 314))
        | (1ULL << (TSqlParser::STATUSONLY - 314))
        | (1ULL << (TSqlParser::STDEV - 314))
        | (1ULL << (TSqlParser::STDEVP - 314))
        | (1ULL << (TSqlParser::STRING_AGG - 314))
        | (1ULL << (TSqlParser::STUFF - 314))
        | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
        | (1ULL << (TSqlParser::SUM - 314))
        | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
        | (1ULL << (TSqlParser::THROW - 314))
        | (1ULL << (TSqlParser::TIES - 314))
        | (1ULL << (TSqlParser::TIME - 314))
        | (1ULL << (TSqlParser::TIMEOUT - 314))
        | (1ULL << (TSqlParser::TINYINT - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES - 314))
        | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
        | (1ULL << (TSqlParser::TRY - 314))
        | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
        | (1ULL << (TSqlParser::TYPE - 314))
        | (1ULL << (TSqlParser::TYPE_WARNING - 314))
        | (1ULL << (TSqlParser::UNBOUNDED - 314))
        | (1ULL << (TSqlParser::UNCOMMITTED - 314))
        | (1ULL << (TSqlParser::UNKNOWN - 314))
        | (1ULL << (TSqlParser::UOW - 314))
        | (1ULL << (TSqlParser::USING - 314))
        | (1ULL << (TSqlParser::VAR - 314))
        | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
        | (1ULL << (TSqlParser::VARP - 314))
        | (1ULL << (TSqlParser::WAIT - 314))
        | (1ULL << (TSqlParser::WORK - 314))
        | (1ULL << (TSqlParser::ZONE - 314))
        | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
        | (1ULL << (TSqlParser::CACHE - 314))
        | (1ULL << (TSqlParser::CALLED - 314))
        | (1ULL << (TSqlParser::CHANGETABLE - 314))
        | (1ULL << (TSqlParser::CHANGES - 314))
        | (1ULL << (TSqlParser::CYCLE - 314))
        | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
        | (1ULL << (TSqlParser::ERROR - 314))
        | (1ULL << (TSqlParser::FORCESEEK - 314))
        | (1ULL << (TSqlParser::IIF - 314))
        | (1ULL << (TSqlParser::INCREMENT - 314))
        | (1ULL << (TSqlParser::ISNULL - 314))
        | (1ULL << (TSqlParser::LOG - 314))
        | (1ULL << (TSqlParser::MATCHED - 314))
        | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
        | (1ULL << (TSqlParser::NOTIFICATION - 378))
        | (1ULL << (TSqlParser::PERSISTED - 378))
        | (1ULL << (TSqlParser::PREDICATE - 378))
        | (1ULL << (TSqlParser::RESTART - 378))
        | (1ULL << (TSqlParser::RETURNS - 378))
        | (1ULL << (TSqlParser::SOURCE - 378))
        | (1ULL << (TSqlParser::STATE - 378))
        | (1ULL << (TSqlParser::START - 378))
        | (1ULL << (TSqlParser::TARGET - 378))
        | (1ULL << (TSqlParser::VARCHAR - 378))
        | (1ULL << (TSqlParser::NVARCHAR - 378))
        | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
        | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
        | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
        setState(3626);
        dynamic_cast<Full_column_nameContext *>(_localctx)->tablename = id_();
      }
      setState(3629);
      match(TSqlParser::DOT);
      setState(3630);
      dynamic_cast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3631);
      dynamic_cast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_list_with_orderContext ------------------------------------------------------------------

TSqlParser::Column_name_list_with_orderContext::Column_name_list_with_orderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Column_name_list_with_orderContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Column_name_list_with_orderContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::ASC() {
  return getTokens(TSqlParser::ASC);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::ASC(size_t i) {
  return getToken(TSqlParser::ASC, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::DESC() {
  return getTokens(TSqlParser::DESC);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::DESC(size_t i) {
  return getToken(TSqlParser::DESC, i);
}


size_t TSqlParser::Column_name_list_with_orderContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_name_list_with_order;
}

void TSqlParser::Column_name_list_with_orderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list_with_order(this);
}

void TSqlParser::Column_name_list_with_orderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list_with_order(this);
}

TSqlParser::Column_name_list_with_orderContext* TSqlParser::column_name_list_with_order() {
  Column_name_list_with_orderContext *_localctx = _tracker.createInstance<Column_name_list_with_orderContext>(_ctx, getState());
  enterRule(_localctx, 394, TSqlParser::RuleColumn_name_list_with_order);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3634);
    id_();
    setState(3636);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ASC

    || _la == TSqlParser::DESC) {
      setState(3635);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ASC

      || _la == TSqlParser::DESC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3645);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3638);
      match(TSqlParser::COMMA);
      setState(3639);
      id_();
      setState(3641);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ASC

      || _la == TSqlParser::DESC) {
        setState(3640);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ASC

        || _la == TSqlParser::DESC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(3647);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_name_listContext ------------------------------------------------------------------

TSqlParser::Insert_column_name_listContext::Insert_column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Insert_column_idContext *> TSqlParser::Insert_column_name_listContext::insert_column_id() {
  return getRuleContexts<TSqlParser::Insert_column_idContext>();
}

TSqlParser::Insert_column_idContext* TSqlParser::Insert_column_name_listContext::insert_column_id(size_t i) {
  return getRuleContext<TSqlParser::Insert_column_idContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Insert_column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Insert_column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_column_name_list;
}

void TSqlParser::Insert_column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_column_name_list(this);
}

void TSqlParser::Insert_column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_column_name_list(this);
}

TSqlParser::Insert_column_name_listContext* TSqlParser::insert_column_name_list() {
  Insert_column_name_listContext *_localctx = _tracker.createInstance<Insert_column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 396, TSqlParser::RuleInsert_column_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3648);
    dynamic_cast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext = insert_column_id();
    dynamic_cast<Insert_column_name_listContext *>(_localctx)->col.push_back(dynamic_cast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext);
    setState(3653);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3649);
      match(TSqlParser::COMMA);
      setState(3650);
      dynamic_cast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext = insert_column_id();
      dynamic_cast<Insert_column_name_listContext *>(_localctx)->col.push_back(dynamic_cast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext);
      setState(3655);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_idContext ------------------------------------------------------------------

TSqlParser::Insert_column_idContext::Insert_column_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Insert_column_idContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Insert_column_idContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_column_idContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Insert_column_idContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Insert_column_idContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_column_id;
}

void TSqlParser::Insert_column_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_column_id(this);
}

void TSqlParser::Insert_column_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_column_id(this);
}

TSqlParser::Insert_column_idContext* TSqlParser::insert_column_id() {
  Insert_column_idContext *_localctx = _tracker.createInstance<Insert_column_idContext>(_ctx, getState());
  enterRule(_localctx, 398, TSqlParser::RuleInsert_column_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3662);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 531, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3657);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
          | (1ULL << TSqlParser::NCHAR)
          | (1ULL << TSqlParser::TEXT)
          | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
          | (1ULL << (TSqlParser::ABSOLUTE - 122))
          | (1ULL << (TSqlParser::AT_KEYWORD - 122))
          | (1ULL << (TSqlParser::ACTION - 122))
          | (1ULL << (TSqlParser::AES_128 - 122))
          | (1ULL << (TSqlParser::AES_192 - 122))
          | (1ULL << (TSqlParser::AES_256 - 122))
          | (1ULL << (TSqlParser::ALGORITHM - 122))
          | (1ULL << (TSqlParser::ANSI_NULLS - 122))
          | (1ULL << (TSqlParser::ANSI_PADDING - 122))
          | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
          | (1ULL << (TSqlParser::APPLY - 122))
          | (1ULL << (TSqlParser::ARITHABORT - 122))
          | (1ULL << (TSqlParser::AUTO - 122))
          | (1ULL << (TSqlParser::AVG - 122))
          | (1ULL << (TSqlParser::BIGINT - 122))
          | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
          | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
          | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
          | (1ULL << (TSqlParser::CALLER - 122))
          | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
          | (1ULL << (TSqlParser::CATCH - 186))
          | (1ULL << (TSqlParser::CHECKSUM - 186))
          | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
          | (1ULL << (TSqlParser::COMMITTED - 186))
          | (1ULL << (TSqlParser::CONCAT - 186))
          | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
          | (1ULL << (TSqlParser::COUNT - 186))
          | (1ULL << (TSqlParser::COUNT_BIG - 186))
          | (1ULL << (TSqlParser::CUME_DIST - 186))
          | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
          | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
          | (1ULL << (TSqlParser::DATA - 186))
          | (1ULL << (TSqlParser::DATEADD - 186))
          | (1ULL << (TSqlParser::DATEDIFF - 186))
          | (1ULL << (TSqlParser::DATENAME - 186))
          | (1ULL << (TSqlParser::DATEPART - 186))
          | (1ULL << (TSqlParser::DAYS - 186))
          | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
          | (1ULL << (TSqlParser::DELAY - 186))
          | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
          | (1ULL << (TSqlParser::DELETED - 186))
          | (1ULL << (TSqlParser::DENSE_RANK - 186))
          | (1ULL << (TSqlParser::DES - 186))
          | (1ULL << (TSqlParser::DESCRIPTION - 186))
          | (1ULL << (TSqlParser::DESX - 186))
          | (1ULL << (TSqlParser::DISABLE - 186))
          | (1ULL << (TSqlParser::DYNAMIC - 186))
          | (1ULL << (TSqlParser::ELEMENTS - 186))
          | (1ULL << (TSqlParser::EMPTY - 186))
          | (1ULL << (TSqlParser::ENCRYPTION - 186))
          | (1ULL << (TSqlParser::EXCLUSIVE - 186))
          | (1ULL << (TSqlParser::FAST - 186))
          | (1ULL << (TSqlParser::FAST_FORWARD - 186))
          | (1ULL << (TSqlParser::FIRST - 186))
          | (1ULL << (TSqlParser::FIRST_VALUE - 186))
          | (1ULL << (TSqlParser::FOLLOWING - 186))
          | (1ULL << (TSqlParser::FORCE - 186))
          | (1ULL << (TSqlParser::FORCED - 186))
          | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
          | (1ULL << (TSqlParser::GETDATE - 186))
          | (1ULL << (TSqlParser::GETUTCDATE - 186))
          | (1ULL << (TSqlParser::GLOBAL - 186))
          | (1ULL << (TSqlParser::GO_BATCH - 186))
          | (1ULL << (TSqlParser::GO - 186))
          | (1ULL << (TSqlParser::GROUPING - 186))
          | (1ULL << (TSqlParser::GROUPING_ID - 186))
          | (1ULL << (TSqlParser::HASH - 186))
          | (1ULL << (TSqlParser::HIGH - 186))
          | (1ULL << (TSqlParser::HOURS - 186))
          | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
          | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
          | (1ULL << (TSqlParser::INPUT - 186))
          | (1ULL << (TSqlParser::INSENSITIVE - 186))
          | (1ULL << (TSqlParser::INSERTED - 186))
          | (1ULL << (TSqlParser::INT - 186))
          | (1ULL << (TSqlParser::ISOLATION - 186))
          | (1ULL << (TSqlParser::KEEP - 186))
          | (1ULL << (TSqlParser::KEEPFIXED - 186))
          | (1ULL << (TSqlParser::KEYSET - 186))
          | (1ULL << (TSqlParser::LAG - 186))
          | (1ULL << (TSqlParser::LAST - 186))
          | (1ULL << (TSqlParser::LAST_VALUE - 186))
          | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
          | (1ULL << (TSqlParser::LOCAL - 250))
          | (1ULL << (TSqlParser::LOCATION - 250))
          | (1ULL << (TSqlParser::LOCK - 250))
          | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
          | (1ULL << (TSqlParser::LOOP - 250))
          | (1ULL << (TSqlParser::LOW - 250))
          | (1ULL << (TSqlParser::MANUAL - 250))
          | (1ULL << (TSqlParser::MARK - 250))
          | (1ULL << (TSqlParser::MAX - 250))
          | (1ULL << (TSqlParser::MAXDOP - 250))
          | (1ULL << (TSqlParser::MAXRECURSION - 250))
          | (1ULL << (TSqlParser::MIN - 250))
          | (1ULL << (TSqlParser::MINUTES - 250))
          | (1ULL << (TSqlParser::MODE - 250))
          | (1ULL << (TSqlParser::NEXT - 250))
          | (1ULL << (TSqlParser::NO - 250))
          | (1ULL << (TSqlParser::NOCOUNT - 250))
          | (1ULL << (TSqlParser::NODES - 250))
          | (1ULL << (TSqlParser::NOEXPAND - 250))
          | (1ULL << (TSqlParser::NOWAIT - 250))
          | (1ULL << (TSqlParser::NTILE - 250))
          | (1ULL << (TSqlParser::NUMANODE - 250))
          | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
          | (1ULL << (TSqlParser::OBJECT - 250))
          | (1ULL << (TSqlParser::OFFSET - 250))
          | (1ULL << (TSqlParser::ONLINE - 250))
          | (1ULL << (TSqlParser::ONLY - 250))
          | (1ULL << (TSqlParser::OPTIMISTIC - 250))
          | (1ULL << (TSqlParser::OPTIMIZE - 250))
          | (1ULL << (TSqlParser::OUT - 250))
          | (1ULL << (TSqlParser::OUTPUT - 250))
          | (1ULL << (TSqlParser::OWNER - 250))
          | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
          | (1ULL << (TSqlParser::PARTITION - 250))
          | (1ULL << (TSqlParser::PARTITIONS - 250))
          | (1ULL << (TSqlParser::PERCENT_RANK - 250))
          | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
          | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
          | (1ULL << (TSqlParser::PRECEDING - 250))
          | (1ULL << (TSqlParser::PRIOR - 250))
          | (1ULL << (TSqlParser::QUERY - 250))
          | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
          | (1ULL << (TSqlParser::RANGE - 250))
          | (1ULL << (TSqlParser::RANK - 250))
          | (1ULL << (TSqlParser::RC2 - 250))
          | (1ULL << (TSqlParser::RC4 - 250))
          | (1ULL << (TSqlParser::RC4_128 - 250))
          | (1ULL << (TSqlParser::READ_ONLY - 250))
          | (1ULL << (TSqlParser::READONLY - 250))
          | (1ULL << (TSqlParser::REBUILD - 250))
          | (1ULL << (TSqlParser::RECOMPILE - 250))
          | (1ULL << (TSqlParser::RELATIVE - 250))
          | (1ULL << (TSqlParser::REMOTE - 250))
          | (1ULL << (TSqlParser::REPEATABLE - 250))
          | (1ULL << (TSqlParser::ROBUST - 250))
          | (1ULL << (TSqlParser::ROW - 250))
          | (1ULL << (TSqlParser::ROW_NUMBER - 250))
          | (1ULL << (TSqlParser::ROWGUID - 250))
          | (1ULL << (TSqlParser::ROWS - 250))
          | (1ULL << (TSqlParser::SCHEMABINDING - 250))
          | (1ULL << (TSqlParser::SCROLL - 250))
          | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
          | (1ULL << (TSqlParser::SELF - 314))
          | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
          | (1ULL << (TSqlParser::SEQUENCE - 314))
          | (1ULL << (TSqlParser::SERIALIZABLE - 314))
          | (1ULL << (TSqlParser::SETERROR - 314))
          | (1ULL << (TSqlParser::SHARE - 314))
          | (1ULL << (TSqlParser::SIMPLE - 314))
          | (1ULL << (TSqlParser::SIZE - 314))
          | (1ULL << (TSqlParser::SMALLINT - 314))
          | (1ULL << (TSqlParser::SNAPSHOT - 314))
          | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
          | (1ULL << (TSqlParser::STATIC - 314))
          | (1ULL << (TSqlParser::STATUSONLY - 314))
          | (1ULL << (TSqlParser::STDEV - 314))
          | (1ULL << (TSqlParser::STDEVP - 314))
          | (1ULL << (TSqlParser::STRING_AGG - 314))
          | (1ULL << (TSqlParser::STUFF - 314))
          | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
          | (1ULL << (TSqlParser::SUM - 314))
          | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
          | (1ULL << (TSqlParser::THROW - 314))
          | (1ULL << (TSqlParser::TIES - 314))
          | (1ULL << (TSqlParser::TIME - 314))
          | (1ULL << (TSqlParser::TIMEOUT - 314))
          | (1ULL << (TSqlParser::TINYINT - 314))
          | (1ULL << (TSqlParser::TRIPLE_DES - 314))
          | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
          | (1ULL << (TSqlParser::TRY - 314))
          | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
          | (1ULL << (TSqlParser::TYPE - 314))
          | (1ULL << (TSqlParser::TYPE_WARNING - 314))
          | (1ULL << (TSqlParser::UNBOUNDED - 314))
          | (1ULL << (TSqlParser::UNCOMMITTED - 314))
          | (1ULL << (TSqlParser::UNKNOWN - 314))
          | (1ULL << (TSqlParser::UOW - 314))
          | (1ULL << (TSqlParser::USING - 314))
          | (1ULL << (TSqlParser::VAR - 314))
          | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
          | (1ULL << (TSqlParser::VARP - 314))
          | (1ULL << (TSqlParser::WAIT - 314))
          | (1ULL << (TSqlParser::WORK - 314))
          | (1ULL << (TSqlParser::ZONE - 314))
          | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
          | (1ULL << (TSqlParser::CACHE - 314))
          | (1ULL << (TSqlParser::CALLED - 314))
          | (1ULL << (TSqlParser::CHANGETABLE - 314))
          | (1ULL << (TSqlParser::CHANGES - 314))
          | (1ULL << (TSqlParser::CYCLE - 314))
          | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
          | (1ULL << (TSqlParser::ERROR - 314))
          | (1ULL << (TSqlParser::FORCESEEK - 314))
          | (1ULL << (TSqlParser::IIF - 314))
          | (1ULL << (TSqlParser::INCREMENT - 314))
          | (1ULL << (TSqlParser::ISNULL - 314))
          | (1ULL << (TSqlParser::LOG - 314))
          | (1ULL << (TSqlParser::MATCHED - 314))
          | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
          | (1ULL << (TSqlParser::NOTIFICATION - 378))
          | (1ULL << (TSqlParser::PERSISTED - 378))
          | (1ULL << (TSqlParser::PREDICATE - 378))
          | (1ULL << (TSqlParser::RESTART - 378))
          | (1ULL << (TSqlParser::RETURNS - 378))
          | (1ULL << (TSqlParser::SOURCE - 378))
          | (1ULL << (TSqlParser::STATE - 378))
          | (1ULL << (TSqlParser::START - 378))
          | (1ULL << (TSqlParser::TARGET - 378))
          | (1ULL << (TSqlParser::VARCHAR - 378))
          | (1ULL << (TSqlParser::NVARCHAR - 378))
          | (1ULL << (TSqlParser::DOUBLE_QUOTE_ID - 378))
          | (1ULL << (TSqlParser::SQUARE_BRACKET_ID - 378))
          | (1ULL << (TSqlParser::ID - 378)))) != 0)) {
          setState(3656);
          dynamic_cast<Insert_column_idContext *>(_localctx)->id_Context = id_();
          dynamic_cast<Insert_column_idContext *>(_localctx)->ignore.push_back(dynamic_cast<Insert_column_idContext *>(_localctx)->id_Context);
        }
        setState(3659);
        match(TSqlParser::DOT); 
      }
      setState(3664);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 531, _ctx);
    }
    setState(3665);
    id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_listContext ------------------------------------------------------------------

TSqlParser::Column_name_listContext::Column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Column_name_listContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Column_name_listContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_name_list;
}

void TSqlParser::Column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list(this);
}

void TSqlParser::Column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list(this);
}

TSqlParser::Column_name_listContext* TSqlParser::column_name_list() {
  Column_name_listContext *_localctx = _tracker.createInstance<Column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 400, TSqlParser::RuleColumn_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3667);
    dynamic_cast<Column_name_listContext *>(_localctx)->id_Context = id_();
    dynamic_cast<Column_name_listContext *>(_localctx)->col.push_back(dynamic_cast<Column_name_listContext *>(_localctx)->id_Context);
    setState(3672);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3668);
      match(TSqlParser::COMMA);
      setState(3669);
      dynamic_cast<Column_name_listContext *>(_localctx)->id_Context = id_();
      dynamic_cast<Column_name_listContext *>(_localctx)->col.push_back(dynamic_cast<Column_name_listContext *>(_localctx)->id_Context);
      setState(3674);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_nameContext ------------------------------------------------------------------

TSqlParser::Cursor_nameContext::Cursor_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Cursor_nameContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Cursor_nameContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Cursor_nameContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_name;
}

void TSqlParser::Cursor_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_name(this);
}

void TSqlParser::Cursor_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_name(this);
}

TSqlParser::Cursor_nameContext* TSqlParser::cursor_name() {
  Cursor_nameContext *_localctx = _tracker.createInstance<Cursor_nameContext>(_ctx, getState());
  enterRule(_localctx, 402, TSqlParser::RuleCursor_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3677);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3675);
        id_();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3676);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_offContext ------------------------------------------------------------------

TSqlParser::On_offContext::On_offContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::On_offContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::On_offContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}


size_t TSqlParser::On_offContext::getRuleIndex() const {
  return TSqlParser::RuleOn_off;
}

void TSqlParser::On_offContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOn_off(this);
}

void TSqlParser::On_offContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOn_off(this);
}

TSqlParser::On_offContext* TSqlParser::on_off() {
  On_offContext *_localctx = _tracker.createInstance<On_offContext>(_ctx, getState());
  enterRule(_localctx, 404, TSqlParser::RuleOn_off);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3679);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::OFF

    || _la == TSqlParser::ON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_notnullContext ------------------------------------------------------------------

TSqlParser::Null_notnullContext::Null_notnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Null_notnullContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Null_notnullContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}


size_t TSqlParser::Null_notnullContext::getRuleIndex() const {
  return TSqlParser::RuleNull_notnull;
}

void TSqlParser::Null_notnullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_notnull(this);
}

void TSqlParser::Null_notnullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_notnull(this);
}

TSqlParser::Null_notnullContext* TSqlParser::null_notnull() {
  Null_notnullContext *_localctx = _tracker.createInstance<Null_notnullContext>(_ctx, getState());
  enterRule(_localctx, 406, TSqlParser::RuleNull_notnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::NOT) {
      setState(3681);
      match(TSqlParser::NOT);
    }
    setState(3684);
    match(TSqlParser::NULL_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_or_defaultContext ------------------------------------------------------------------

TSqlParser::Null_or_defaultContext::Null_or_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Null_notnullContext* TSqlParser::Null_or_defaultContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Null_or_defaultContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::Id_Context* TSqlParser::Null_or_defaultContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}


size_t TSqlParser::Null_or_defaultContext::getRuleIndex() const {
  return TSqlParser::RuleNull_or_default;
}

void TSqlParser::Null_or_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_or_default(this);
}

void TSqlParser::Null_or_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_or_default(this);
}

TSqlParser::Null_or_defaultContext* TSqlParser::null_or_default() {
  Null_or_defaultContext *_localctx = _tracker.createInstance<Null_or_defaultContext>(_ctx, getState());
  enterRule(_localctx, 408, TSqlParser::RuleNull_or_default);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3697);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NOT:
      case TSqlParser::NULL_: {
        setState(3686);
        null_notnull();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(3687);
        match(TSqlParser::DEFAULT);
        setState(3688);
        constant_expression();
        setState(3691);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COLLATE) {
          setState(3689);
          match(TSqlParser::COLLATE);
          setState(3690);
          id_();
        }
        setState(3695);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 536, _ctx)) {
        case 1: {
          setState(3693);
          match(TSqlParser::WITH);
          setState(3694);
          match(TSqlParser::VALUES);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_function_nameContext ------------------------------------------------------------------

TSqlParser::Scalar_function_nameContext::Scalar_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Scalar_function_nameContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RIGHT() {
  return getToken(TSqlParser::RIGHT, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LEFT() {
  return getToken(TSqlParser::LEFT, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ABS() {
  return getToken(TSqlParser::ABS, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ASCII() {
  return getToken(TSqlParser::ASCII, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CEILING() {
  return getToken(TSqlParser::CEILING, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHAR() {
  return getToken(TSqlParser::CHAR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHARINDEX() {
  return getToken(TSqlParser::CHARINDEX, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::DATALENGTH() {
  return getToken(TSqlParser::DATALENGTH, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::DAY() {
  return getToken(TSqlParser::DAY, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::FLOOR() {
  return getToken(TSqlParser::FLOOR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ISDATE() {
  return getToken(TSqlParser::ISDATE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ISNUMERIC() {
  return getToken(TSqlParser::ISNUMERIC, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LEN() {
  return getToken(TSqlParser::LEN, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LOWER() {
  return getToken(TSqlParser::LOWER, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LTRIM() {
  return getToken(TSqlParser::LTRIM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::MONTH() {
  return getToken(TSqlParser::MONTH, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::NCHAR() {
  return getToken(TSqlParser::NCHAR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::PATINDEX() {
  return getToken(TSqlParser::PATINDEX, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RAND() {
  return getToken(TSqlParser::RAND, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::REPLACE() {
  return getToken(TSqlParser::REPLACE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ROUND() {
  return getToken(TSqlParser::ROUND, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RTRIM() {
  return getToken(TSqlParser::RTRIM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SIGN() {
  return getToken(TSqlParser::SIGN, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SPACE() {
  return getToken(TSqlParser::SPACE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::STR() {
  return getToken(TSqlParser::STR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SUBSTRING() {
  return getToken(TSqlParser::SUBSTRING, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::UPPER() {
  return getToken(TSqlParser::UPPER, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::USER_NAME() {
  return getToken(TSqlParser::USER_NAME, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::YEAR() {
  return getToken(TSqlParser::YEAR, 0);
}


size_t TSqlParser::Scalar_function_nameContext::getRuleIndex() const {
  return TSqlParser::RuleScalar_function_name;
}

void TSqlParser::Scalar_function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_function_name(this);
}

void TSqlParser::Scalar_function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_function_name(this);
}

TSqlParser::Scalar_function_nameContext* TSqlParser::scalar_function_name() {
  Scalar_function_nameContext *_localctx = _tracker.createInstance<Scalar_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 410, TSqlParser::RuleScalar_function_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 538, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3699);
      func_proc_name_server_database_schema();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3700);
      match(TSqlParser::RIGHT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3701);
      match(TSqlParser::LEFT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3702);
      match(TSqlParser::BINARY_CHECKSUM);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3703);
      match(TSqlParser::CHECKSUM);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3704);
      match(TSqlParser::ABS);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3705);
      match(TSqlParser::ASCII);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3706);
      match(TSqlParser::CEILING);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3707);
      match(TSqlParser::CHAR);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3708);
      match(TSqlParser::CHARINDEX);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3709);
      match(TSqlParser::DATALENGTH);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3710);
      match(TSqlParser::DAY);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3711);
      match(TSqlParser::FLOOR);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3712);
      match(TSqlParser::ISDATE);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3713);
      match(TSqlParser::ISNUMERIC);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(3714);
      match(TSqlParser::LEN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(3715);
      match(TSqlParser::LOWER);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(3716);
      match(TSqlParser::LTRIM);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(3717);
      match(TSqlParser::MONTH);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(3718);
      match(TSqlParser::NCHAR);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(3719);
      match(TSqlParser::PATINDEX);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(3720);
      match(TSqlParser::RAND);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(3721);
      match(TSqlParser::REPLACE);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(3722);
      match(TSqlParser::ROUND);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(3723);
      match(TSqlParser::RTRIM);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(3724);
      match(TSqlParser::SIGN);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(3725);
      match(TSqlParser::SPACE);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(3726);
      match(TSqlParser::STR);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(3727);
      match(TSqlParser::SUBSTRING);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(3728);
      match(TSqlParser::UPPER);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(3729);
      match(TSqlParser::USER_NAME);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(3730);
      match(TSqlParser::YEAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_typeContext ------------------------------------------------------------------

TSqlParser::Data_typeContext::Data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Data_typeContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::NTEXT() {
  return getToken(TSqlParser::NTEXT, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::TEXT() {
  return getToken(TSqlParser::TEXT, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::NCHAR() {
  return getToken(TSqlParser::NCHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::CHAR() {
  return getToken(TSqlParser::CHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::VARCHAR() {
  return getToken(TSqlParser::VARCHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::NVARCHAR() {
  return getToken(TSqlParser::NVARCHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::BINARY_KEYWORD() {
  return getToken(TSqlParser::BINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::VARBINARY_KEYWORD() {
  return getToken(TSqlParser::VARBINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

TSqlParser::Id_Context* TSqlParser::Data_typeContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Data_typeContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Data_typeContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

tree::TerminalNode* TSqlParser::Data_typeContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::DOUBLE() {
  return getToken(TSqlParser::DOUBLE, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::PRECISION() {
  return getToken(TSqlParser::PRECISION, 0);
}


size_t TSqlParser::Data_typeContext::getRuleIndex() const {
  return TSqlParser::RuleData_type;
}

void TSqlParser::Data_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_type(this);
}

void TSqlParser::Data_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_type(this);
}

TSqlParser::Data_typeContext* TSqlParser::data_type() {
  Data_typeContext *_localctx = _tracker.createInstance<Data_typeContext>(_ctx, getState());
  enterRule(_localctx, 412, TSqlParser::RuleData_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3763);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 541, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3733);
      dynamic_cast<Data_typeContext *>(_localctx)->scaled = _input->LT(1);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
        | (1ULL << TSqlParser::NCHAR)
        | (1ULL << TSqlParser::TEXT)
        | (1ULL << TSqlParser::NTEXT))) != 0) || _la == TSqlParser::BINARY_KEYWORD || ((((_la - 352) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 352)) & ((1ULL << (TSqlParser::VARBINARY_KEYWORD - 352))
        | (1ULL << (TSqlParser::VARCHAR - 352))
        | (1ULL << (TSqlParser::NVARCHAR - 352)))) != 0))) {
        dynamic_cast<Data_typeContext *>(_localctx)->scaled = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3734);
      match(TSqlParser::LR_BRACKET);
      setState(3735);
      match(TSqlParser::MAX);
      setState(3736);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3737);
      dynamic_cast<Data_typeContext *>(_localctx)->ext_type = id_();
      setState(3738);
      match(TSqlParser::LR_BRACKET);
      setState(3739);
      dynamic_cast<Data_typeContext *>(_localctx)->scale = match(TSqlParser::DECIMAL);
      setState(3740);
      match(TSqlParser::COMMA);
      setState(3741);
      dynamic_cast<Data_typeContext *>(_localctx)->prec = match(TSqlParser::DECIMAL);
      setState(3742);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3744);
      dynamic_cast<Data_typeContext *>(_localctx)->ext_type = id_();
      setState(3745);
      match(TSqlParser::LR_BRACKET);
      setState(3746);
      dynamic_cast<Data_typeContext *>(_localctx)->scale = match(TSqlParser::DECIMAL);
      setState(3747);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3749);
      dynamic_cast<Data_typeContext *>(_localctx)->ext_type = id_();
      setState(3750);
      match(TSqlParser::IDENTITY);
      setState(3756);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 539, _ctx)) {
      case 1: {
        setState(3751);
        match(TSqlParser::LR_BRACKET);
        setState(3752);
        dynamic_cast<Data_typeContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
        setState(3753);
        match(TSqlParser::COMMA);
        setState(3754);
        dynamic_cast<Data_typeContext *>(_localctx)->inc = match(TSqlParser::DECIMAL);
        setState(3755);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3758);
      dynamic_cast<Data_typeContext *>(_localctx)->double_prec = match(TSqlParser::DOUBLE);
      setState(3760);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 540, _ctx)) {
      case 1: {
        setState(3759);
        match(TSqlParser::PRECISION);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3762);
      dynamic_cast<Data_typeContext *>(_localctx)->unscaled_type = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_valueContext ------------------------------------------------------------------

TSqlParser::Default_valueContext::Default_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Default_valueContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Default_valueContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

TSqlParser::ConstantContext* TSqlParser::Default_valueContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::Default_valueContext::getRuleIndex() const {
  return TSqlParser::RuleDefault_value;
}

void TSqlParser::Default_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_value(this);
}

void TSqlParser::Default_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_value(this);
}

TSqlParser::Default_valueContext* TSqlParser::default_value() {
  Default_valueContext *_localctx = _tracker.createInstance<Default_valueContext>(_ctx, getState());
  enterRule(_localctx, 414, TSqlParser::RuleDefault_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3768);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(3765);
        match(TSqlParser::NULL_);
        break;
      }

      case TSqlParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(3766);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 3);
        setState(3767);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

TSqlParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::ConstantContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::BINARY() {
  return getToken(TSqlParser::BINARY, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

TSqlParser::SignContext* TSqlParser::ConstantContext::sign() {
  return getRuleContext<TSqlParser::SignContext>(0);
}

tree::TerminalNode* TSqlParser::ConstantContext::REAL() {
  return getToken(TSqlParser::REAL, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::FLOAT() {
  return getToken(TSqlParser::FLOAT, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::DOLLAR() {
  return getToken(TSqlParser::DOLLAR, 0);
}


size_t TSqlParser::ConstantContext::getRuleIndex() const {
  return TSqlParser::RuleConstant;
}

void TSqlParser::ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant(this);
}

void TSqlParser::ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant(this);
}

TSqlParser::ConstantContext* TSqlParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 416, TSqlParser::RuleConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 546, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3770);
      match(TSqlParser::STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3771);
      match(TSqlParser::BINARY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3773);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(3772);
        sign();
      }
      setState(3775);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3777);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(3776);
        sign();
      }
      setState(3779);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::FLOAT

      || _la == TSqlParser::REAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3781);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(3780);
        sign();
      }
      setState(3783);
      dynamic_cast<ConstantContext *>(_localctx)->dollar = match(TSqlParser::DOLLAR);
      setState(3784);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DECIMAL

      || _la == TSqlParser::FLOAT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignContext ------------------------------------------------------------------

TSqlParser::SignContext::SignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::SignContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::SignContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::SignContext::getRuleIndex() const {
  return TSqlParser::RuleSign;
}

void TSqlParser::SignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSign(this);
}

void TSqlParser::SignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSign(this);
}

TSqlParser::SignContext* TSqlParser::sign() {
  SignContext *_localctx = _tracker.createInstance<SignContext>(_ctx, getState());
  enterRule(_localctx, 418, TSqlParser::RuleSign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3787);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PLUS

    || _la == TSqlParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

TSqlParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::KeywordContext::ABSOLUTE() {
  return getToken(TSqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ACTION() {
  return getToken(TSqlParser::ACTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AES_128() {
  return getToken(TSqlParser::AES_128, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AES_192() {
  return getToken(TSqlParser::AES_192, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AES_256() {
  return getToken(TSqlParser::AES_256, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ALGORITHM() {
  return getToken(TSqlParser::ALGORITHM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ANSI_NULLS() {
  return getToken(TSqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ANSI_PADDING() {
  return getToken(TSqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ANSI_WARNINGS() {
  return getToken(TSqlParser::ANSI_WARNINGS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::APPLY() {
  return getToken(TSqlParser::APPLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ARITHABORT() {
  return getToken(TSqlParser::ARITHABORT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AT_KEYWORD() {
  return getToken(TSqlParser::AT_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AUTO() {
  return getToken(TSqlParser::AUTO, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AVG() {
  return getToken(TSqlParser::AVG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BIGINT() {
  return getToken(TSqlParser::BIGINT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BINARY_BASE64() {
  return getToken(TSqlParser::BINARY_BASE64, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CALLER() {
  return getToken(TSqlParser::CALLER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CAST() {
  return getToken(TSqlParser::CAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CATCH() {
  return getToken(TSqlParser::CATCH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHECKSUM_AGG() {
  return getToken(TSqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::COMMITTED() {
  return getToken(TSqlParser::COMMITTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CONCAT() {
  return getToken(TSqlParser::CONCAT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CONCAT_NULL_YIELDS_NULL() {
  return getToken(TSqlParser::CONCAT_NULL_YIELDS_NULL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::COUNT() {
  return getToken(TSqlParser::COUNT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::COUNT_BIG() {
  return getToken(TSqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CURSOR_DEFAULT() {
  return getToken(TSqlParser::CURSOR_DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATA() {
  return getToken(TSqlParser::DATA, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATEADD() {
  return getToken(TSqlParser::DATEADD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATEDIFF() {
  return getToken(TSqlParser::DATEDIFF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATENAME() {
  return getToken(TSqlParser::DATENAME, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATEPART() {
  return getToken(TSqlParser::DATEPART, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DAYS() {
  return getToken(TSqlParser::DAYS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DEFAULT_DOUBLE_QUOTE() {
  return getToken(TSqlParser::DEFAULT_DOUBLE_QUOTE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DELAY() {
  return getToken(TSqlParser::DELAY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DELAYED_DURABILITY() {
  return getToken(TSqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DENSE_RANK() {
  return getToken(TSqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DES() {
  return getToken(TSqlParser::DES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DESCRIPTION() {
  return getToken(TSqlParser::DESCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DESX() {
  return getToken(TSqlParser::DESX, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DISABLE() {
  return getToken(TSqlParser::DISABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DYNAMIC() {
  return getToken(TSqlParser::DYNAMIC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ELEMENTS() {
  return getToken(TSqlParser::ELEMENTS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::EMPTY() {
  return getToken(TSqlParser::EMPTY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::EXCLUSIVE() {
  return getToken(TSqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FAST() {
  return getToken(TSqlParser::FAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FAST_FORWARD() {
  return getToken(TSqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FIRST_VALUE() {
  return getToken(TSqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FOLLOWING() {
  return getToken(TSqlParser::FOLLOWING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORCE() {
  return getToken(TSqlParser::FORCE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORCED() {
  return getToken(TSqlParser::FORCED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORWARD_ONLY() {
  return getToken(TSqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GETDATE() {
  return getToken(TSqlParser::GETDATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GETUTCDATE() {
  return getToken(TSqlParser::GETUTCDATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GO() {
  return getToken(TSqlParser::GO, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GO_BATCH() {
  return getToken(TSqlParser::GO_BATCH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GROUPING() {
  return getToken(TSqlParser::GROUPING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GROUPING_ID() {
  return getToken(TSqlParser::GROUPING_ID, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::HIGH() {
  return getToken(TSqlParser::HIGH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::HOURS() {
  return getToken(TSqlParser::HOURS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::IDENTITY_VALUE() {
  return getToken(TSqlParser::IDENTITY_VALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INCLUDE_NULL_VALUES() {
  return getToken(TSqlParser::INCLUDE_NULL_VALUES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INPUT() {
  return getToken(TSqlParser::INPUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INSENSITIVE() {
  return getToken(TSqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INT() {
  return getToken(TSqlParser::INT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ISOLATION() {
  return getToken(TSqlParser::ISOLATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::KEEP() {
  return getToken(TSqlParser::KEEP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::KEEPFIXED() {
  return getToken(TSqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::KEYSET() {
  return getToken(TSqlParser::KEYSET, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LAG() {
  return getToken(TSqlParser::LAG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LAST() {
  return getToken(TSqlParser::LAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LAST_VALUE() {
  return getToken(TSqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LEAD() {
  return getToken(TSqlParser::LEAD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LEVEL() {
  return getToken(TSqlParser::LEVEL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCATION() {
  return getToken(TSqlParser::LOCATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCK_ESCALATION() {
  return getToken(TSqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOW() {
  return getToken(TSqlParser::LOW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MANUAL() {
  return getToken(TSqlParser::MANUAL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MARK() {
  return getToken(TSqlParser::MARK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAXDOP() {
  return getToken(TSqlParser::MAXDOP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAXRECURSION() {
  return getToken(TSqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MIN() {
  return getToken(TSqlParser::MIN, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MINUTES() {
  return getToken(TSqlParser::MINUTES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MODE() {
  return getToken(TSqlParser::MODE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NO() {
  return getToken(TSqlParser::NO, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOCOUNT() {
  return getToken(TSqlParser::NOCOUNT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NODES() {
  return getToken(TSqlParser::NODES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOEXPAND() {
  return getToken(TSqlParser::NOEXPAND, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NTILE() {
  return getToken(TSqlParser::NTILE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NUMANODE() {
  return getToken(TSqlParser::NUMANODE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NUMERIC_ROUNDABORT() {
  return getToken(TSqlParser::NUMERIC_ROUNDABORT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OFFSET() {
  return getToken(TSqlParser::OFFSET, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ONLINE() {
  return getToken(TSqlParser::ONLINE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OPTIMISTIC() {
  return getToken(TSqlParser::OPTIMISTIC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OPTIMIZE() {
  return getToken(TSqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OWNER() {
  return getToken(TSqlParser::OWNER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PARAMETERIZATION() {
  return getToken(TSqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PARTITIONS() {
  return getToken(TSqlParser::PARTITIONS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PRECEDING() {
  return getToken(TSqlParser::PRECEDING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PRIOR() {
  return getToken(TSqlParser::PRIOR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::QUERY() {
  return getToken(TSqlParser::QUERY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::QUOTED_IDENTIFIER() {
  return getToken(TSqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RANGE() {
  return getToken(TSqlParser::RANGE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RANK() {
  return getToken(TSqlParser::RANK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RC2() {
  return getToken(TSqlParser::RC2, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RC4() {
  return getToken(TSqlParser::RC4, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RC4_128() {
  return getToken(TSqlParser::RC4_128, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::READ_ONLY() {
  return getToken(TSqlParser::READ_ONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::READONLY() {
  return getToken(TSqlParser::READONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::REBUILD() {
  return getToken(TSqlParser::REBUILD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RELATIVE() {
  return getToken(TSqlParser::RELATIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::REMOTE() {
  return getToken(TSqlParser::REMOTE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::REPEATABLE() {
  return getToken(TSqlParser::REPEATABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROBUST() {
  return getToken(TSqlParser::ROBUST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROW_NUMBER() {
  return getToken(TSqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROWGUID() {
  return getToken(TSqlParser::ROWGUID, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROWS() {
  return getToken(TSqlParser::ROWS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SCHEMABINDING() {
  return getToken(TSqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SCROLL_LOCKS() {
  return getToken(TSqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SECONDS() {
  return getToken(TSqlParser::SECONDS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SELF() {
  return getToken(TSqlParser::SELF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SEMI_SENSITIVE() {
  return getToken(TSqlParser::SEMI_SENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SEQUENCE() {
  return getToken(TSqlParser::SEQUENCE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SETERROR() {
  return getToken(TSqlParser::SETERROR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SHARE() {
  return getToken(TSqlParser::SHARE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SIMPLE() {
  return getToken(TSqlParser::SIMPLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SIZE() {
  return getToken(TSqlParser::SIZE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SMALLINT() {
  return getToken(TSqlParser::SMALLINT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(TSqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STATIC() {
  return getToken(TSqlParser::STATIC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STATUSONLY() {
  return getToken(TSqlParser::STATUSONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STDEV() {
  return getToken(TSqlParser::STDEV, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STDEVP() {
  return getToken(TSqlParser::STDEVP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STRING_AGG() {
  return getToken(TSqlParser::STRING_AGG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STUFF() {
  return getToken(TSqlParser::STUFF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SUBSCRIPTION() {
  return getToken(TSqlParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SUM() {
  return getToken(TSqlParser::SUM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TEXTIMAGE_ON() {
  return getToken(TSqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::THROW() {
  return getToken(TSqlParser::THROW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TIES() {
  return getToken(TSqlParser::TIES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TINYINT() {
  return getToken(TSqlParser::TINYINT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRIPLE_DES() {
  return getToken(TSqlParser::TRIPLE_DES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRIPLE_DES_3KEY() {
  return getToken(TSqlParser::TRIPLE_DES_3KEY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRY() {
  return getToken(TSqlParser::TRY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TWO_DIGIT_YEAR_CUTOFF() {
  return getToken(TSqlParser::TWO_DIGIT_YEAR_CUTOFF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TYPE_WARNING() {
  return getToken(TSqlParser::TYPE_WARNING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UNCOMMITTED() {
  return getToken(TSqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UOW() {
  return getToken(TSqlParser::UOW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::USING() {
  return getToken(TSqlParser::USING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VAR() {
  return getToken(TSqlParser::VAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VARP() {
  return getToken(TSqlParser::VARP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::WAIT() {
  return getToken(TSqlParser::WAIT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::WORK() {
  return getToken(TSqlParser::WORK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BLOCKING_HIERARCHY() {
  return getToken(TSqlParser::BLOCKING_HIERARCHY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CACHE() {
  return getToken(TSqlParser::CACHE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CALLED() {
  return getToken(TSqlParser::CALLED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHANGETABLE() {
  return getToken(TSqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHANGES() {
  return getToken(TSqlParser::CHANGES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CUME_DIST() {
  return getToken(TSqlParser::CUME_DIST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CYCLE() {
  return getToken(TSqlParser::CYCLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATA_COMPRESSION() {
  return getToken(TSqlParser::DATA_COMPRESSION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ERROR() {
  return getToken(TSqlParser::ERROR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORCESEEK() {
  return getToken(TSqlParser::FORCESEEK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::IIF() {
  return getToken(TSqlParser::IIF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INCREMENT() {
  return getToken(TSqlParser::INCREMENT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ISNULL() {
  return getToken(TSqlParser::ISNULL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOG() {
  return getToken(TSqlParser::LOG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MATCHED() {
  return getToken(TSqlParser::MATCHED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAXVALUE() {
  return getToken(TSqlParser::MAXVALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MINVALUE() {
  return getToken(TSqlParser::MINVALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOTIFICATION() {
  return getToken(TSqlParser::NOTIFICATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERCENTILE_CONT() {
  return getToken(TSqlParser::PERCENTILE_CONT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERCENTILE_DISC() {
  return getToken(TSqlParser::PERCENTILE_DISC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERCENT_RANK() {
  return getToken(TSqlParser::PERCENT_RANK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERSISTED() {
  return getToken(TSqlParser::PERSISTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PREDICATE() {
  return getToken(TSqlParser::PREDICATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RESTART() {
  return getToken(TSqlParser::RESTART, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SOURCE() {
  return getToken(TSqlParser::SOURCE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STATE() {
  return getToken(TSqlParser::STATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::START() {
  return getToken(TSqlParser::START, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TARGET() {
  return getToken(TSqlParser::TARGET, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRY_CAST() {
  return getToken(TSqlParser::TRY_CAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ZONE() {
  return getToken(TSqlParser::ZONE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TEXT() {
  return getToken(TSqlParser::TEXT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NTEXT() {
  return getToken(TSqlParser::NTEXT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHAR() {
  return getToken(TSqlParser::CHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NCHAR() {
  return getToken(TSqlParser::NCHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VARCHAR() {
  return getToken(TSqlParser::VARCHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NVARCHAR() {
  return getToken(TSqlParser::NVARCHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BINARY_KEYWORD() {
  return getToken(TSqlParser::BINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VARBINARY_KEYWORD() {
  return getToken(TSqlParser::VARBINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PRECISION() {
  return getToken(TSqlParser::PRECISION, 0);
}


size_t TSqlParser::KeywordContext::getRuleIndex() const {
  return TSqlParser::RuleKeyword;
}

void TSqlParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void TSqlParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}

TSqlParser::KeywordContext* TSqlParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 420, TSqlParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3789);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << TSqlParser::CHAR)
      | (1ULL << TSqlParser::NCHAR)
      | (1ULL << TSqlParser::TEXT)
      | (1ULL << TSqlParser::NTEXT))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & ((1ULL << (TSqlParser::PRECISION - 122))
      | (1ULL << (TSqlParser::ABSOLUTE - 122))
      | (1ULL << (TSqlParser::AT_KEYWORD - 122))
      | (1ULL << (TSqlParser::ACTION - 122))
      | (1ULL << (TSqlParser::AES_128 - 122))
      | (1ULL << (TSqlParser::AES_192 - 122))
      | (1ULL << (TSqlParser::AES_256 - 122))
      | (1ULL << (TSqlParser::ALGORITHM - 122))
      | (1ULL << (TSqlParser::ANSI_NULLS - 122))
      | (1ULL << (TSqlParser::ANSI_PADDING - 122))
      | (1ULL << (TSqlParser::ANSI_WARNINGS - 122))
      | (1ULL << (TSqlParser::APPLY - 122))
      | (1ULL << (TSqlParser::ARITHABORT - 122))
      | (1ULL << (TSqlParser::AUTO - 122))
      | (1ULL << (TSqlParser::AVG - 122))
      | (1ULL << (TSqlParser::BIGINT - 122))
      | (1ULL << (TSqlParser::BINARY_KEYWORD - 122))
      | (1ULL << (TSqlParser::BINARY_BASE64 - 122))
      | (1ULL << (TSqlParser::BINARY_CHECKSUM - 122))
      | (1ULL << (TSqlParser::CALLER - 122))
      | (1ULL << (TSqlParser::CAST - 122)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & ((1ULL << (TSqlParser::TRY_CAST - 186))
      | (1ULL << (TSqlParser::CATCH - 186))
      | (1ULL << (TSqlParser::CHECKSUM - 186))
      | (1ULL << (TSqlParser::CHECKSUM_AGG - 186))
      | (1ULL << (TSqlParser::COMMITTED - 186))
      | (1ULL << (TSqlParser::CONCAT - 186))
      | (1ULL << (TSqlParser::CONCAT_NULL_YIELDS_NULL - 186))
      | (1ULL << (TSqlParser::COUNT - 186))
      | (1ULL << (TSqlParser::COUNT_BIG - 186))
      | (1ULL << (TSqlParser::CUME_DIST - 186))
      | (1ULL << (TSqlParser::CURSOR_CLOSE_ON_COMMIT - 186))
      | (1ULL << (TSqlParser::CURSOR_DEFAULT - 186))
      | (1ULL << (TSqlParser::DATA - 186))
      | (1ULL << (TSqlParser::DATEADD - 186))
      | (1ULL << (TSqlParser::DATEDIFF - 186))
      | (1ULL << (TSqlParser::DATENAME - 186))
      | (1ULL << (TSqlParser::DATEPART - 186))
      | (1ULL << (TSqlParser::DAYS - 186))
      | (1ULL << (TSqlParser::DEFAULT_DOUBLE_QUOTE - 186))
      | (1ULL << (TSqlParser::DELAY - 186))
      | (1ULL << (TSqlParser::DELAYED_DURABILITY - 186))
      | (1ULL << (TSqlParser::DELETED - 186))
      | (1ULL << (TSqlParser::DENSE_RANK - 186))
      | (1ULL << (TSqlParser::DES - 186))
      | (1ULL << (TSqlParser::DESCRIPTION - 186))
      | (1ULL << (TSqlParser::DESX - 186))
      | (1ULL << (TSqlParser::DISABLE - 186))
      | (1ULL << (TSqlParser::DYNAMIC - 186))
      | (1ULL << (TSqlParser::ELEMENTS - 186))
      | (1ULL << (TSqlParser::EMPTY - 186))
      | (1ULL << (TSqlParser::ENCRYPTION - 186))
      | (1ULL << (TSqlParser::EXCLUSIVE - 186))
      | (1ULL << (TSqlParser::FAST - 186))
      | (1ULL << (TSqlParser::FAST_FORWARD - 186))
      | (1ULL << (TSqlParser::FIRST - 186))
      | (1ULL << (TSqlParser::FIRST_VALUE - 186))
      | (1ULL << (TSqlParser::FOLLOWING - 186))
      | (1ULL << (TSqlParser::FORCE - 186))
      | (1ULL << (TSqlParser::FORCED - 186))
      | (1ULL << (TSqlParser::FORWARD_ONLY - 186))
      | (1ULL << (TSqlParser::GETDATE - 186))
      | (1ULL << (TSqlParser::GETUTCDATE - 186))
      | (1ULL << (TSqlParser::GLOBAL - 186))
      | (1ULL << (TSqlParser::GO_BATCH - 186))
      | (1ULL << (TSqlParser::GO - 186))
      | (1ULL << (TSqlParser::GROUPING - 186))
      | (1ULL << (TSqlParser::GROUPING_ID - 186))
      | (1ULL << (TSqlParser::HASH - 186))
      | (1ULL << (TSqlParser::HIGH - 186))
      | (1ULL << (TSqlParser::HOURS - 186))
      | (1ULL << (TSqlParser::IDENTITY_VALUE - 186))
      | (1ULL << (TSqlParser::INCLUDE_NULL_VALUES - 186))
      | (1ULL << (TSqlParser::INPUT - 186))
      | (1ULL << (TSqlParser::INSENSITIVE - 186))
      | (1ULL << (TSqlParser::INSERTED - 186))
      | (1ULL << (TSqlParser::INT - 186))
      | (1ULL << (TSqlParser::ISOLATION - 186))
      | (1ULL << (TSqlParser::KEEP - 186))
      | (1ULL << (TSqlParser::KEEPFIXED - 186))
      | (1ULL << (TSqlParser::KEYSET - 186))
      | (1ULL << (TSqlParser::LAG - 186))
      | (1ULL << (TSqlParser::LAST - 186))
      | (1ULL << (TSqlParser::LAST_VALUE - 186))
      | (1ULL << (TSqlParser::LEAD - 186)))) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 250)) & ((1ULL << (TSqlParser::LEVEL - 250))
      | (1ULL << (TSqlParser::LOCAL - 250))
      | (1ULL << (TSqlParser::LOCATION - 250))
      | (1ULL << (TSqlParser::LOCK - 250))
      | (1ULL << (TSqlParser::LOCK_ESCALATION - 250))
      | (1ULL << (TSqlParser::LOOP - 250))
      | (1ULL << (TSqlParser::LOW - 250))
      | (1ULL << (TSqlParser::MANUAL - 250))
      | (1ULL << (TSqlParser::MARK - 250))
      | (1ULL << (TSqlParser::MAX - 250))
      | (1ULL << (TSqlParser::MAXDOP - 250))
      | (1ULL << (TSqlParser::MAXRECURSION - 250))
      | (1ULL << (TSqlParser::MIN - 250))
      | (1ULL << (TSqlParser::MINUTES - 250))
      | (1ULL << (TSqlParser::MODE - 250))
      | (1ULL << (TSqlParser::NEXT - 250))
      | (1ULL << (TSqlParser::NO - 250))
      | (1ULL << (TSqlParser::NOCOUNT - 250))
      | (1ULL << (TSqlParser::NODES - 250))
      | (1ULL << (TSqlParser::NOEXPAND - 250))
      | (1ULL << (TSqlParser::NOWAIT - 250))
      | (1ULL << (TSqlParser::NTILE - 250))
      | (1ULL << (TSqlParser::NUMANODE - 250))
      | (1ULL << (TSqlParser::NUMERIC_ROUNDABORT - 250))
      | (1ULL << (TSqlParser::OBJECT - 250))
      | (1ULL << (TSqlParser::OFFSET - 250))
      | (1ULL << (TSqlParser::ONLINE - 250))
      | (1ULL << (TSqlParser::ONLY - 250))
      | (1ULL << (TSqlParser::OPTIMISTIC - 250))
      | (1ULL << (TSqlParser::OPTIMIZE - 250))
      | (1ULL << (TSqlParser::OUT - 250))
      | (1ULL << (TSqlParser::OUTPUT - 250))
      | (1ULL << (TSqlParser::OWNER - 250))
      | (1ULL << (TSqlParser::PARAMETERIZATION - 250))
      | (1ULL << (TSqlParser::PARTITION - 250))
      | (1ULL << (TSqlParser::PARTITIONS - 250))
      | (1ULL << (TSqlParser::PERCENT_RANK - 250))
      | (1ULL << (TSqlParser::PERCENTILE_CONT - 250))
      | (1ULL << (TSqlParser::PERCENTILE_DISC - 250))
      | (1ULL << (TSqlParser::PRECEDING - 250))
      | (1ULL << (TSqlParser::PRIOR - 250))
      | (1ULL << (TSqlParser::QUERY - 250))
      | (1ULL << (TSqlParser::QUOTED_IDENTIFIER - 250))
      | (1ULL << (TSqlParser::RANGE - 250))
      | (1ULL << (TSqlParser::RANK - 250))
      | (1ULL << (TSqlParser::RC2 - 250))
      | (1ULL << (TSqlParser::RC4 - 250))
      | (1ULL << (TSqlParser::RC4_128 - 250))
      | (1ULL << (TSqlParser::READ_ONLY - 250))
      | (1ULL << (TSqlParser::READONLY - 250))
      | (1ULL << (TSqlParser::REBUILD - 250))
      | (1ULL << (TSqlParser::RECOMPILE - 250))
      | (1ULL << (TSqlParser::RELATIVE - 250))
      | (1ULL << (TSqlParser::REMOTE - 250))
      | (1ULL << (TSqlParser::REPEATABLE - 250))
      | (1ULL << (TSqlParser::ROBUST - 250))
      | (1ULL << (TSqlParser::ROW - 250))
      | (1ULL << (TSqlParser::ROW_NUMBER - 250))
      | (1ULL << (TSqlParser::ROWGUID - 250))
      | (1ULL << (TSqlParser::ROWS - 250))
      | (1ULL << (TSqlParser::SCHEMABINDING - 250))
      | (1ULL << (TSqlParser::SCROLL - 250))
      | (1ULL << (TSqlParser::SCROLL_LOCKS - 250)))) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & ((1ULL << (TSqlParser::SECONDS - 314))
      | (1ULL << (TSqlParser::SELF - 314))
      | (1ULL << (TSqlParser::SEMI_SENSITIVE - 314))
      | (1ULL << (TSqlParser::SEQUENCE - 314))
      | (1ULL << (TSqlParser::SERIALIZABLE - 314))
      | (1ULL << (TSqlParser::SETERROR - 314))
      | (1ULL << (TSqlParser::SHARE - 314))
      | (1ULL << (TSqlParser::SIMPLE - 314))
      | (1ULL << (TSqlParser::SIZE - 314))
      | (1ULL << (TSqlParser::SMALLINT - 314))
      | (1ULL << (TSqlParser::SNAPSHOT - 314))
      | (1ULL << (TSqlParser::SPATIAL_WINDOW_MAX_CELLS - 314))
      | (1ULL << (TSqlParser::STATIC - 314))
      | (1ULL << (TSqlParser::STATUSONLY - 314))
      | (1ULL << (TSqlParser::STDEV - 314))
      | (1ULL << (TSqlParser::STDEVP - 314))
      | (1ULL << (TSqlParser::STRING_AGG - 314))
      | (1ULL << (TSqlParser::STUFF - 314))
      | (1ULL << (TSqlParser::SUBSCRIPTION - 314))
      | (1ULL << (TSqlParser::SUM - 314))
      | (1ULL << (TSqlParser::TEXTIMAGE_ON - 314))
      | (1ULL << (TSqlParser::THROW - 314))
      | (1ULL << (TSqlParser::TIES - 314))
      | (1ULL << (TSqlParser::TIME - 314))
      | (1ULL << (TSqlParser::TIMEOUT - 314))
      | (1ULL << (TSqlParser::TINYINT - 314))
      | (1ULL << (TSqlParser::TRIPLE_DES - 314))
      | (1ULL << (TSqlParser::TRIPLE_DES_3KEY - 314))
      | (1ULL << (TSqlParser::TRY - 314))
      | (1ULL << (TSqlParser::TWO_DIGIT_YEAR_CUTOFF - 314))
      | (1ULL << (TSqlParser::TYPE - 314))
      | (1ULL << (TSqlParser::TYPE_WARNING - 314))
      | (1ULL << (TSqlParser::UNBOUNDED - 314))
      | (1ULL << (TSqlParser::UNCOMMITTED - 314))
      | (1ULL << (TSqlParser::UNKNOWN - 314))
      | (1ULL << (TSqlParser::UOW - 314))
      | (1ULL << (TSqlParser::USING - 314))
      | (1ULL << (TSqlParser::VAR - 314))
      | (1ULL << (TSqlParser::VARBINARY_KEYWORD - 314))
      | (1ULL << (TSqlParser::VARP - 314))
      | (1ULL << (TSqlParser::WAIT - 314))
      | (1ULL << (TSqlParser::WORK - 314))
      | (1ULL << (TSqlParser::ZONE - 314))
      | (1ULL << (TSqlParser::BLOCKING_HIERARCHY - 314))
      | (1ULL << (TSqlParser::CACHE - 314))
      | (1ULL << (TSqlParser::CALLED - 314))
      | (1ULL << (TSqlParser::CHANGETABLE - 314))
      | (1ULL << (TSqlParser::CHANGES - 314))
      | (1ULL << (TSqlParser::CYCLE - 314))
      | (1ULL << (TSqlParser::DATA_COMPRESSION - 314))
      | (1ULL << (TSqlParser::ERROR - 314))
      | (1ULL << (TSqlParser::FORCESEEK - 314))
      | (1ULL << (TSqlParser::IIF - 314))
      | (1ULL << (TSqlParser::INCREMENT - 314))
      | (1ULL << (TSqlParser::ISNULL - 314))
      | (1ULL << (TSqlParser::LOG - 314))
      | (1ULL << (TSqlParser::MATCHED - 314))
      | (1ULL << (TSqlParser::MAXVALUE - 314)))) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 378)) & ((1ULL << (TSqlParser::MINVALUE - 378))
      | (1ULL << (TSqlParser::NOTIFICATION - 378))
      | (1ULL << (TSqlParser::PERSISTED - 378))
      | (1ULL << (TSqlParser::PREDICATE - 378))
      | (1ULL << (TSqlParser::RESTART - 378))
      | (1ULL << (TSqlParser::RETURNS - 378))
      | (1ULL << (TSqlParser::SOURCE - 378))
      | (1ULL << (TSqlParser::STATE - 378))
      | (1ULL << (TSqlParser::START - 378))
      | (1ULL << (TSqlParser::TARGET - 378))
      | (1ULL << (TSqlParser::VARCHAR - 378))
      | (1ULL << (TSqlParser::NVARCHAR - 378)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Id_Context ------------------------------------------------------------------

TSqlParser::Id_Context::Id_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Id_Context::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::Id_Context::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}

tree::TerminalNode* TSqlParser::Id_Context::SQUARE_BRACKET_ID() {
  return getToken(TSqlParser::SQUARE_BRACKET_ID, 0);
}

TSqlParser::KeywordContext* TSqlParser::Id_Context::keyword() {
  return getRuleContext<TSqlParser::KeywordContext>(0);
}


size_t TSqlParser::Id_Context::getRuleIndex() const {
  return TSqlParser::RuleId_;
}

void TSqlParser::Id_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterId_(this);
}

void TSqlParser::Id_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitId_(this);
}

TSqlParser::Id_Context* TSqlParser::id_() {
  Id_Context *_localctx = _tracker.createInstance<Id_Context>(_ctx, getState());
  enterRule(_localctx, 422, TSqlParser::RuleId_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3795);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3791);
        match(TSqlParser::ID);
        break;
      }

      case TSqlParser::DOUBLE_QUOTE_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3792);
        match(TSqlParser::DOUBLE_QUOTE_ID);
        break;
      }

      case TSqlParser::SQUARE_BRACKET_ID: {
        enterOuterAlt(_localctx, 3);
        setState(3793);
        match(TSqlParser::SQUARE_BRACKET_ID);
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        enterOuterAlt(_localctx, 4);
        setState(3794);
        keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_idContext ------------------------------------------------------------------

TSqlParser::Simple_idContext::Simple_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Simple_idContext::ID() {
  return getToken(TSqlParser::ID, 0);
}


size_t TSqlParser::Simple_idContext::getRuleIndex() const {
  return TSqlParser::RuleSimple_id;
}

void TSqlParser::Simple_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_id(this);
}

void TSqlParser::Simple_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_id(this);
}

TSqlParser::Simple_idContext* TSqlParser::simple_id() {
  Simple_idContext *_localctx = _tracker.createInstance<Simple_idContext>(_ctx, getState());
  enterRule(_localctx, 424, TSqlParser::RuleSimple_id);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3797);
    match(TSqlParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Id_or_stringContext ------------------------------------------------------------------

TSqlParser::Id_or_stringContext::Id_or_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Id_or_stringContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Id_or_stringContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Id_or_stringContext::getRuleIndex() const {
  return TSqlParser::RuleId_or_string;
}

void TSqlParser::Id_or_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterId_or_string(this);
}

void TSqlParser::Id_or_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitId_or_string(this);
}

TSqlParser::Id_or_stringContext* TSqlParser::id_or_string() {
  Id_or_stringContext *_localctx = _tracker.createInstance<Id_or_stringContext>(_ctx, getState());
  enterRule(_localctx, 426, TSqlParser::RuleId_or_string);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3801);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3799);
        id_();
        break;
      }

      case TSqlParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(3800);
        match(TSqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comparison_operatorContext ------------------------------------------------------------------

TSqlParser::Comparison_operatorContext::Comparison_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::GREATER() {
  return getToken(TSqlParser::GREATER, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::LESS() {
  return getToken(TSqlParser::LESS, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::EXCLAMATION() {
  return getToken(TSqlParser::EXCLAMATION, 0);
}


size_t TSqlParser::Comparison_operatorContext::getRuleIndex() const {
  return TSqlParser::RuleComparison_operator;
}

void TSqlParser::Comparison_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison_operator(this);
}

void TSqlParser::Comparison_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison_operator(this);
}

TSqlParser::Comparison_operatorContext* TSqlParser::comparison_operator() {
  Comparison_operatorContext *_localctx = _tracker.createInstance<Comparison_operatorContext>(_ctx, getState());
  enterRule(_localctx, 428, TSqlParser::RuleComparison_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3818);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 549, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3803);
      match(TSqlParser::EQUAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3804);
      match(TSqlParser::GREATER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3805);
      match(TSqlParser::LESS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3806);
      match(TSqlParser::LESS);
      setState(3807);
      match(TSqlParser::EQUAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3808);
      match(TSqlParser::GREATER);
      setState(3809);
      match(TSqlParser::EQUAL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3810);
      match(TSqlParser::LESS);
      setState(3811);
      match(TSqlParser::GREATER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3812);
      match(TSqlParser::EXCLAMATION);
      setState(3813);
      match(TSqlParser::EQUAL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3814);
      match(TSqlParser::EXCLAMATION);
      setState(3815);
      match(TSqlParser::GREATER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3816);
      match(TSqlParser::EXCLAMATION);
      setState(3817);
      match(TSqlParser::LESS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_operatorContext ------------------------------------------------------------------

TSqlParser::Assignment_operatorContext::Assignment_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::PLUS_ASSIGN() {
  return getToken(TSqlParser::PLUS_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MINUS_ASSIGN() {
  return getToken(TSqlParser::MINUS_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MULT_ASSIGN() {
  return getToken(TSqlParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::DIV_ASSIGN() {
  return getToken(TSqlParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MOD_ASSIGN() {
  return getToken(TSqlParser::MOD_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::AND_ASSIGN() {
  return getToken(TSqlParser::AND_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::XOR_ASSIGN() {
  return getToken(TSqlParser::XOR_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::OR_ASSIGN() {
  return getToken(TSqlParser::OR_ASSIGN, 0);
}


size_t TSqlParser::Assignment_operatorContext::getRuleIndex() const {
  return TSqlParser::RuleAssignment_operator;
}

void TSqlParser::Assignment_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_operator(this);
}

void TSqlParser::Assignment_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_operator(this);
}

TSqlParser::Assignment_operatorContext* TSqlParser::assignment_operator() {
  Assignment_operatorContext *_localctx = _tracker.createInstance<Assignment_operatorContext>(_ctx, getState());
  enterRule(_localctx, 430, TSqlParser::RuleAssignment_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3820);
    _la = _input->LA(1);
    if (!(((((_la - 410) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 410)) & ((1ULL << (TSqlParser::PLUS_ASSIGN - 410))
      | (1ULL << (TSqlParser::MINUS_ASSIGN - 410))
      | (1ULL << (TSqlParser::MULT_ASSIGN - 410))
      | (1ULL << (TSqlParser::DIV_ASSIGN - 410))
      | (1ULL << (TSqlParser::MOD_ASSIGN - 410))
      | (1ULL << (TSqlParser::AND_ASSIGN - 410))
      | (1ULL << (TSqlParser::XOR_ASSIGN - 410))
      | (1ULL << (TSqlParser::OR_ASSIGN - 410)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool TSqlParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 105: return expressionSempred(dynamic_cast<ExpressionContext *>(context), predicateIndex);
    case 117: return search_conditionSempred(dynamic_cast<Search_conditionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool TSqlParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 5);
    case 1: return precpred(_ctx, 4);
    case 2: return precpred(_ctx, 10);
    case 3: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool TSqlParser::search_conditionSempred(Search_conditionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> TSqlParser::_decisionToDFA;
atn::PredictionContextCache TSqlParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN TSqlParser::_atn;
std::vector<uint16_t> TSqlParser::_serializedATN;

std::vector<std::string> TSqlParser::_ruleNames = {
  "tsql_file", "batch", "batch_level_statement", "sql_clauses", "dml_clause", 
  "ddl_clause", "cfl_statement", "block_statement", "break_statement", "continue_statement", 
  "goto_statement", "return_statement", "if_statement", "throw_statement", 
  "throw_error_number", "throw_message", "throw_state", "try_catch_statement", 
  "waitfor_statement", "while_statement", "print_statement", "raiseerror_statement", 
  "empty_statement", "another_statement", "entity_to", "colon_colon", "class_type", 
  "class_type_for_sql_database", "class_type_for_azure_dw", "class_type_for_parallel_dw", 
  "lock_table", "truncate_table", "alter_sequence", "create_sequence", "merge_statement", 
  "when_matches", "merge_matched", "merge_not_matched", "delete_statement", 
  "delete_statement_from", "insert_statement", "insert_statement_value", 
  "receive_statement", "select_statement_standalone", "select_statement", 
  "time", "update_statement", "output_clause", "output_dml_list_elem", "create_or_alter_procedure", 
  "create_or_alter_function", "func_body_returns_select", "func_body_returns_table", 
  "func_body_returns_scalar", "procedure_param", "procedure_option", "function_option", 
  "create_table", "table_options", "alter_table", "database_optionspec", 
  "cursor_option", "drop_procedure", "drop_function", "drop_table", "declare_statement", 
  "cursor_statement", "kill_statement", "kill_process", "kill_query_notification", 
  "execute_statement", "execute_body_batch", "execute_body", "execute_statement_arg", 
  "execute_statement_arg_named", "execute_statement_arg_unnamed", "execute_parameter", 
  "execute_var_string", "algorithm", "set_statement", "transaction_statement", 
  "go_batch_statement", "go_statement", "use_statement", "shutdown_statement", 
  "dbcc_special", "dbcc_clause", "dbcc_command", "dbcc_options", "execute_clause", 
  "declare_local", "table_type_definition", "column_def_table_constraints", 
  "column_def_table_constraint", "column_definition", "column_constraint", 
  "table_constraint", "index_options", "index_option", "declare_cursor", 
  "declare_set_cursor_common", "declare_set_cursor_common_partial", "fetch_cursor", 
  "set_special", "constant_LOCAL_ID", "expression", "time_zone", "primitive_expression", 
  "case_expression", "unary_operator_expression", "bracket_expression", 
  "constant_expression", "subquery", "with_expression", "common_table_expression", 
  "update_elem", "update_elem_merge", "search_condition", "predicate", "query_expression", 
  "sql_union", "query_specification", "top_clause", "top_percent", "top_count", 
  "order_by_clause", "order_by_expression", "group_by_item", "option_clause", 
  "option", "optimize_for_arg", "select_list", "udt_method_arguments", "asterisk", 
  "column_elem", "udt_elem", "expression_elem", "select_list_elem", "table_sources", 
  "table_source", "table_source_item_joined", "table_source_item", "schema_declaration", 
  "column_declaration", "change_table", "change_table_changes", "change_table_version", 
  "join_part", "join_on", "cross_join", "apply_", "pivot", "unpivot", "pivot_clause", 
  "unpivot_clause", "full_column_name_list", "table_name_with_hint", "bulk_option", 
  "derived_table", "function_call", "partition_function", "built_in_functions", 
  "nodes_method", "switch_section", "switch_search_condition_section", "as_column_alias", 
  "as_table_alias", "table_alias", "with_table_hints", "insert_with_table_hints", 
  "table_hint", "index_value", "column_alias_list", "column_alias", "table_value_constructor", 
  "expression_list", "ranking_windowed_function", "aggregate_windowed_function", 
  "analytic_windowed_function", "all_distinct_expression", "over_clause", 
  "row_or_range_clause", "window_frame_extent", "window_frame_bound", "window_frame_preceding", 
  "window_frame_following", "entity_name", "entity_name_for_azure_dw", "entity_name_for_parallel_dw", 
  "full_table_name", "table_name", "simple_name", "func_proc_name_schema", 
  "func_proc_name_database_schema", "func_proc_name_server_database_schema", 
  "ddl_object", "full_column_name", "column_name_list_with_order", "insert_column_name_list", 
  "insert_column_id", "column_name_list", "cursor_name", "on_off", "null_notnull", 
  "null_or_default", "scalar_function_name", "data_type", "default_value", 
  "constant", "sign", "keyword", "id_", "simple_id", "id_or_string", "comparison_operator", 
  "assignment_operator"
};

std::vector<std::string> TSqlParser::_literalNames = {
  "", "'ABS'", "'ASCII'", "'CEILING'", "'CHAR'", "'CHARINDEX'", "'DATALENGTH'", 
  "'DAY'", "'FLOOR'", "'ISDATE'", "'ISNUMERIC'", "'LEN'", "'LOWER'", "'LTRIM'", 
  "'MONTH'", "'NCHAR'", "'PATINDEX'", "'RAND'", "'REPLACE'", "'ROUND'", 
  "'RTRIM'", "'SIGN'", "'SPACE'", "'STR'", "'SUBSTRING'", "'UPPER'", "'USER_NAME'", 
  "'YEAR'", "'TEXT'", "'NTEXT'", "'ADD'", "'ALL'", "'ALTER'", "'AND'", "'ANY'", 
  "'AS'", "'ASC'", "'AUTHORIZATION'", "'\\'", "'BEGIN'", "'BETWEEN'", "'BREAK'", 
  "'BY'", "'CASE'", "'CHECK'", "'CLOSE'", "'COALESCE'", "'COLLATE'", "'COLUMN'", 
  "'COMMIT'", "'COMPUTE'", "'CONSTRAINT'", "'CONTINUE'", "", "'CREATE'", 
  "'CROSS'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", 
  "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", "'DBCC'", "'DEALLOCATE'", 
  "'DECLARE'", "'DEFAULT'", "'DELETE'", "'DESC'", "'DISTINCT'", "'DISTRIBUTED'", 
  "'DOUBLE'", "'\\\\'", "'//'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", 
  "'EXCEPT'", "", "'EXISTS'", "'FETCH'", "'FOR'", "'FOREIGN'", "'FROM'", 
  "'FULL'", "'FUNCTION'", "'GOTO'", "'GROUP'", "'HAVING'", "'HOLDLOCK'", 
  "'IDENTITY'", "'IDENTITY_INSERT'", "'IF'", "'IN'", "'INDEX'", "'INNER'", 
  "'INSERT'", "'INTERSECT'", "'INTO'", "'IS'", "'JOIN'", "'KEY'", "'KILL'", 
  "'LEFT'", "'LIKE'", "'MERGE'", "'NOT'", "'NULL'", "'NULLIF'", "'OF'", 
  "'OFF'", "'ON'", "'OPEN'", "'OPTION'", "'OR'", "'ORDER'", "'OUTER'", "'OVER'", 
  "'PERCENT'", "'PIVOT'", "'PLAN'", "'PRECISION'", "'PRIMARY'", "'PRINT'", 
  "'PROC'", "'PROCEDURE'", "'RAISERROR'", "'READ'", "'REFERENCES'", "'REPLICATION'", 
  "'RETURN'", "'REVERT'", "'RIGHT'", "'ROLLBACK'", "'ROWCOUNT'", "'ROWGUIDCOL'", 
  "'SAVE'", "'SCHEMA'", "'SELECT'", "'SESSION_USER'", "'SET'", "'SHUTDOWN'", 
  "'SOME'", "'SYSTEM_USER'", "'TABLE'", "'THEN'", "'TO'", "'TOP'", "'TRAN'", 
  "'TRANSACTION'", "'TRUNCATE'", "'UNION'", "'UNIQUE'", "'UNPIVOT'", "'UPDATE'", 
  "'USE'", "'USER'", "'VALUES'", "'VARYING'", "'WHEN'", "'WHERE'", "'WHILE'", 
  "'WITH'", "'WITHIN'", "'$PARTITION'", "'ABSOLUTE'", "'AT'", "'ACTION'", 
  "'AES_128'", "'AES_192'", "'AES_256'", "'ALGORITHM'", "'ANSI_NULLS'", 
  "'ANSI_PADDING'", "'ANSI_WARNINGS'", "'APPLY'", "'ARITHABORT'", "'AUTO'", 
  "'AVG'", "'BIGINT'", "'BINARY'", "'BINARY BASE64'", "'BINARY_CHECKSUM'", 
  "'CALLER'", "'CAST'", "'TRY_CAST'", "'CATCH'", "'CHECKSUM'", "'CHECKSUM_AGG'", 
  "'COMMITTED'", "'CONCAT'", "'CONCAT_NULL_YIELDS_NULL'", "'COUNT'", "'COUNT_BIG'", 
  "'CUME_DIST'", "'CURSOR_CLOSE_ON_COMMIT'", "'CURSOR_DEFAULT'", "'DATA'", 
  "'DATEADD'", "'DATEDIFF'", "'DATENAME'", "'DATEPART'", "'DAYS'", "", "'DELAY'", 
  "'DELAYED_DURABILITY'", "'DELETED'", "'DENSE_RANK'", "'DES'", "'DESCRIPTION'", 
  "'DESX'", "'DISABLE'", "'DYNAMIC'", "'ELEMENTS'", "'EMPTY'", "'ENCRYPTION'", 
  "'EXCLUSIVE'", "'FAST'", "'FAST_FORWARD'", "'FIRST'", "'FIRST_VALUE'", 
  "'FOLLOWING'", "'FORCE'", "'FORCED'", "'FORWARD_ONLY'", "'GETDATE'", "'GETUTCDATE'", 
  "'GLOBAL'", "", "'GO'", "'GROUPING'", "'GROUPING_ID'", "'HASH'", "'HIGH'", 
  "'HOURS'", "'IDENTITY_VALUE'", "'INCLUDE_NULL_VALUES'", "'INPUT'", "'INSENSITIVE'", 
  "'INSERTED'", "'INT'", "'ISOLATION'", "'KEEP'", "'KEEPFIXED'", "'KEYSET'", 
  "'LAG'", "'LAST'", "'LAST_VALUE'", "'LEAD'", "'LEVEL'", "'LOCAL'", "'LOCATION'", 
  "'LOCK'", "'LOCK_ESCALATION'", "'LOOP'", "'LOW'", "'MANUAL'", "'MARK'", 
  "'MAX'", "'MAXDOP'", "'MAXRECURSION'", "'MIN'", "'MIN_ACTIVE_ROWVERSION'", 
  "'MINUTES'", "'MODE'", "'NEXT'", "'NO'", "'NOCOUNT'", "'NODES'", "'NOEXPAND'", 
  "'NOWAIT'", "'NTILE'", "'NUMANODE'", "'NUMERIC_ROUNDABORT'", "'OBJECT'", 
  "'OFFSET'", "'ONLINE'", "'ONLY'", "'OPTIMISTIC'", "'OPTIMIZE'", "'OUT'", 
  "'OUTPUT'", "'OWNER'", "'PARAMETERIZATION'", "'PARTITION'", "'PARTITIONS'", 
  "'PERCENT_RANK'", "'PERCENTILE_CONT'", "'PERCENTILE_DISC'", "'PRECEDING'", 
  "'PRIOR'", "'QUERY'", "'QUOTED_IDENTIFIER'", "'RANGE'", "'RANK'", "'RC2'", 
  "'RC4'", "'RC4_128'", "'READ_ONLY'", "'READONLY'", "'REBUILD'", "'RECOMPILE'", 
  "'RELATIVE'", "'REMOTE'", "'REPEATABLE'", "'ROBUST'", "'ROW'", "'ROW_NUMBER'", 
  "'ROWGUID'", "'ROWS'", "'SCHEMABINDING'", "'SCROLL'", "'SCROLL_LOCKS'", 
  "'SECONDS'", "'SELF'", "'SEMI_SENSITIVE'", "'SEQUENCE'", "'SERIALIZABLE'", 
  "'SETERROR'", "'SHARE'", "'SIMPLE'", "'SIZE'", "'SMALLINT'", "'SNAPSHOT'", 
  "'SPATIAL_WINDOW_MAX_CELLS'", "'STATIC'", "'STATUSONLY'", "'STDEV'", "'STDEVP'", 
  "'STRING_AGG'", "'STUFF'", "'SUBSCRIPTION'", "'SUM'", "'TEXTIMAGE_ON'", 
  "'THROW'", "'TIES'", "'TIME'", "'TIMEOUT'", "'TINYINT'", "'TRIPLE_DES'", 
  "'TRIPLE_DES_3KEY'", "'TRY'", "'TWO_DIGIT_YEAR_CUTOFF'", "'TYPE'", "'TYPE_WARNING'", 
  "'UNBOUNDED'", "'UNCOMMITTED'", "'UNKNOWN'", "'UOW'", "'USING'", "'VAR'", 
  "'VARBINARY'", "'VARP'", "'WAIT'", "'WAITFOR'", "'WORK'", "'ZONE'", "'$ACTION'", 
  "'BLOCKING_HIERARCHY'", "'CACHE'", "'CALLED'", "'CHANGETABLE'", "'CHANGES'", 
  "'CONNECTION'", "'CONTRACT'", "'CYCLE'", "'DATA_COMPRESSION'", "'DDL'", 
  "'ERROR'", "'EVENT'", "'FORCESEEK'", "'IIF'", "'INCREMENT'", "'ISNULL'", 
  "'LOG'", "'MATCHED'", "'MAXVALUE'", "'MINVALUE'", "'NOTIFICATION'", "'PERSISTED'", 
  "'PREDICATE'", "'RESTART'", "'RETURNS'", "'SHRINKLOG'", "'SOURCE'", "'SQL'", 
  "'STATE'", "'START'", "'TARGET'", "'WITHOUT'", "'VARCHAR'", "'NVARCHAR'", 
  "", "", "", "", "'''", "", "", "", "", "", "", "", "", "'='", "'>'", "'<'", 
  "'!'", "'+='", "'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", 
  "'||'", "'.'", "'_'", "'@'", "'#'", "'$'", "'('", "')'", "','", "';'", 
  "':'", "'::'", "'*'", "'/'", "'%'", "'+'", "'-'", "'~'", "'|'", "'&'", 
  "'^'"
};

std::vector<std::string> TSqlParser::_symbolicNames = {
  "", "ABS", "ASCII", "CEILING", "CHAR", "CHARINDEX", "DATALENGTH", "DAY", 
  "FLOOR", "ISDATE", "ISNUMERIC", "LEN", "LOWER", "LTRIM", "MONTH", "NCHAR", 
  "PATINDEX", "RAND", "REPLACE", "ROUND", "RTRIM", "SIGN", "SPACE_fn", "STR", 
  "SUBSTRING", "UPPER", "USER_NAME", "YEAR", "TEXT", "NTEXT", "ADD", "ALL", 
  "ALTER", "AND", "ANY", "AS", "ASC", "AUTHORIZATION", "BACKSLASH", "BEGIN", 
  "BETWEEN", "BREAK", "BY", "CASE", "CHECK", "CLOSE", "COALESCE", "COLLATE", 
  "COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", 
  "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
  "CURRENT_USER", "CURSOR", "DATABASE", "DBCC", "DEALLOCATE", "DECLARE", 
  "DEFAULT", "DELETE", "DESC", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DOUBLE_BACK_SLASH", 
  "DOUBLE_FORWARD_SLASH", "DROP", "ELSE", "END", "ESCAPE", "EXCEPT", "EXECUTE", 
  "EXISTS", "FETCH", "FOR", "FOREIGN", "FROM", "FULL", "FUNCTION", "GOTO", 
  "GROUP", "HAVING", "HOLDLOCK", "IDENTITY", "IDENTITY_INSERT", "IF", "IN", 
  "INDEX", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "KEY", 
  "KILL", "LEFT", "LIKE", "MERGE", "NOT", "NULL_", "NULLIF", "OF", "OFF", 
  "ON", "OPEN", "OPTION", "OR", "ORDER", "OUTER", "OVER", "PERCENT", "PIVOT", 
  "PLAN", "PRECISION", "PRIMARY", "PRINT", "PROC", "PROCEDURE", "RAISERROR", 
  "READ", "REFERENCES", "REPLICATION", "RETURN", "REVERT", "RIGHT", "ROLLBACK", 
  "ROWCOUNT", "ROWGUIDCOL", "SAVE", "SCHEMA", "SELECT", "SESSION_USER", 
  "SET", "SHUTDOWN", "SOME", "SYSTEM_USER", "TABLE", "THEN", "TO", "TOP", 
  "TRAN", "TRANSACTION", "TRUNCATE", "UNION", "UNIQUE", "UNPIVOT", "UPDATE", 
  "USE", "USER", "VALUES", "VARYING", "WHEN", "WHERE", "WHILE", "WITH", 
  "WITHIN", "DOLLAR_PARTITION", "ABSOLUTE", "AT_KEYWORD", "ACTION", "AES_128", 
  "AES_192", "AES_256", "ALGORITHM", "ANSI_NULLS", "ANSI_PADDING", "ANSI_WARNINGS", 
  "APPLY", "ARITHABORT", "AUTO", "AVG", "BIGINT", "BINARY_KEYWORD", "BINARY_BASE64", 
  "BINARY_CHECKSUM", "CALLER", "CAST", "TRY_CAST", "CATCH", "CHECKSUM", 
  "CHECKSUM_AGG", "COMMITTED", "CONCAT", "CONCAT_NULL_YIELDS_NULL", "COUNT", 
  "COUNT_BIG", "CUME_DIST", "CURSOR_CLOSE_ON_COMMIT", "CURSOR_DEFAULT", 
  "DATA", "DATEADD", "DATEDIFF", "DATENAME", "DATEPART", "DAYS", "DEFAULT_DOUBLE_QUOTE", 
  "DELAY", "DELAYED_DURABILITY", "DELETED", "DENSE_RANK", "DES", "DESCRIPTION", 
  "DESX", "DISABLE", "DYNAMIC", "ELEMENTS", "EMPTY", "ENCRYPTION", "EXCLUSIVE", 
  "FAST", "FAST_FORWARD", "FIRST", "FIRST_VALUE", "FOLLOWING", "FORCE", 
  "FORCED", "FORWARD_ONLY", "GETDATE", "GETUTCDATE", "GLOBAL", "GO_BATCH", 
  "GO", "GROUPING", "GROUPING_ID", "HASH", "HIGH", "HOURS", "IDENTITY_VALUE", 
  "INCLUDE_NULL_VALUES", "INPUT", "INSENSITIVE", "INSERTED", "INT", "ISOLATION", 
  "KEEP", "KEEPFIXED", "KEYSET", "LAG", "LAST", "LAST_VALUE", "LEAD", "LEVEL", 
  "LOCAL", "LOCATION", "LOCK", "LOCK_ESCALATION", "LOOP", "LOW", "MANUAL", 
  "MARK", "MAX", "MAXDOP", "MAXRECURSION", "MIN", "MIN_ACTIVE_ROWVERSION", 
  "MINUTES", "MODE", "NEXT", "NO", "NOCOUNT", "NODES", "NOEXPAND", "NOWAIT", 
  "NTILE", "NUMANODE", "NUMERIC_ROUNDABORT", "OBJECT", "OFFSET", "ONLINE", 
  "ONLY", "OPTIMISTIC", "OPTIMIZE", "OUT", "OUTPUT", "OWNER", "PARAMETERIZATION", 
  "PARTITION", "PARTITIONS", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", 
  "PRECEDING", "PRIOR", "QUERY", "QUOTED_IDENTIFIER", "RANGE", "RANK", "RC2", 
  "RC4", "RC4_128", "READ_ONLY", "READONLY", "REBUILD", "RECOMPILE", "RELATIVE", 
  "REMOTE", "REPEATABLE", "ROBUST", "ROW", "ROW_NUMBER", "ROWGUID", "ROWS", 
  "SCHEMABINDING", "SCROLL", "SCROLL_LOCKS", "SECONDS", "SELF", "SEMI_SENSITIVE", 
  "SEQUENCE", "SERIALIZABLE", "SETERROR", "SHARE", "SIMPLE", "SIZE", "SMALLINT", 
  "SNAPSHOT", "SPATIAL_WINDOW_MAX_CELLS", "STATIC", "STATUSONLY", "STDEV", 
  "STDEVP", "STRING_AGG", "STUFF", "SUBSCRIPTION", "SUM", "TEXTIMAGE_ON", 
  "THROW", "TIES", "TIME", "TIMEOUT", "TINYINT", "TRIPLE_DES", "TRIPLE_DES_3KEY", 
  "TRY", "TWO_DIGIT_YEAR_CUTOFF", "TYPE", "TYPE_WARNING", "UNBOUNDED", "UNCOMMITTED", 
  "UNKNOWN", "UOW", "USING", "VAR", "VARBINARY_KEYWORD", "VARP", "WAIT", 
  "WAITFOR", "WORK", "ZONE", "DOLLAR_ACTION", "BLOCKING_HIERARCHY", "CACHE", 
  "CALLED", "CHANGETABLE", "CHANGES", "CONNECTION", "CONTRACT", "CYCLE", 
  "DATA_COMPRESSION", "DDL", "ERROR", "EVENT", "FORCESEEK", "IIF", "INCREMENT", 
  "ISNULL", "LOG", "MATCHED", "MAXVALUE", "MINVALUE", "NOTIFICATION", "PERSISTED", 
  "PREDICATE", "RESTART", "RETURNS", "SHRINKLOG", "SOURCE", "SQL", "STATE", 
  "START", "TARGET", "WITHOUT", "VARCHAR", "NVARCHAR", "SPACE", "COMMENT", 
  "LINE_COMMENT", "DOUBLE_QUOTE_ID", "SINGLE_QUOTE", "SQUARE_BRACKET_ID", 
  "LOCAL_ID", "DECIMAL", "ID", "STRING", "BINARY", "FLOAT", "REAL", "EQUAL", 
  "GREATER", "LESS", "EXCLAMATION", "PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", 
  "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "DOUBLE_BAR", 
  "DOT", "UNDERLINE", "AT", "SHARP", "DOLLAR", "LR_BRACKET", "RR_BRACKET", 
  "COMMA", "SEMI", "COLON", "DOUBLE_COLON", "STAR", "DIVIDE", "MODULE", 
  "PLUS", "MINUS", "BIT_NOT", "BIT_OR", "BIT_AND", "BIT_XOR", "RECEIVE", 
  "ANSI_DEFAULTS", "ANSI_NULL_DFLT_OFF", "ANSI_NULL_DFLT_ON", "ARITHIGNORE", 
  "FMTONLY", "FORCEPLAN", "IMPLICIT_TRANSACTIONS", "NOEXEC", "PARSEONLY", 
  "REMOTE_PROC_TRANSACTIONS", "SHOWPLAN_ALL", "SHOWPLAN_TEXT", "SHOWPLAN_XML", 
  "XACT_ABORT", "VERSION"
};

dfa::Vocabulary TSqlParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> TSqlParser::_tokenNames;

TSqlParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x1c8, 0xef1, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 0x4, 
       0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 0x9, 
       0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 0xa, 
       0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 0x4, 
       0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 0x11, 
       0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 0x14, 
       0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 0x17, 
       0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 0x1a, 
       0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 0x1d, 
       0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 0x20, 
       0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 0x23, 
       0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 0x26, 
       0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 0x29, 
       0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 0x2c, 
       0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 0x2f, 
       0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 0x32, 
       0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 0x35, 
       0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 0x38, 
       0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 0x3b, 
       0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 0x3e, 
       0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 0x41, 
       0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 0x44, 
       0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 0x47, 
       0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 0x4a, 
       0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 0x4d, 
       0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 0x50, 
       0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 0x53, 
       0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 0x56, 
       0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 0x59, 
       0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 0x5c, 
       0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 0x5f, 
       0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 0x62, 
       0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 0x65, 
       0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 0x68, 
       0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 0x6b, 
       0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 0x6e, 
       0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 0x71, 
       0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 0x74, 
       0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 0x77, 
       0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 0x7a, 
       0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 0x7d, 
       0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 0x80, 
       0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 0x83, 
       0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 0x86, 
       0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 0x89, 
       0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 0x8c, 
       0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 0x8f, 
       0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 0x92, 
       0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 0x95, 
       0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 0x98, 
       0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 0x9b, 
       0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 0x9e, 
       0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 0xa1, 
       0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 0xa4, 
       0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 0xa7, 
       0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 0xaa, 
       0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 0xad, 
       0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 0xb0, 
       0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 0xb3, 
       0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 0xb6, 
       0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 0xb9, 
       0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 0xbc, 
       0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 0xbf, 
       0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 0xc2, 
       0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 0xc5, 
       0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 0xc8, 
       0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 0xcb, 
       0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 0xce, 
       0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 0xd1, 
       0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 0xd4, 
       0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 0xd7, 
       0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x3, 0x2, 
       0x7, 0x2, 0x1b4, 0xa, 0x2, 0xc, 0x2, 0xe, 0x2, 0x1b7, 0xb, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x7, 0x2, 0x1bc, 0xa, 0x2, 0xc, 0x2, 0xe, 
       0x2, 0x1bf, 0xb, 0x2, 0x3, 0x2, 0x3, 0x2, 0x5, 0x2, 0x1c3, 0xa, 0x2, 
       0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x1c7, 0xa, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x6, 0x3, 0x1cb, 0xa, 0x3, 0xd, 0x3, 0xe, 0x3, 0x1cc, 0x5, 0x3, 0x1cf, 
       0xa, 0x3, 0x3, 0x3, 0x7, 0x3, 0x1d2, 0xa, 0x3, 0xc, 0x3, 0xe, 0x3, 
       0x1d5, 0xb, 0x3, 0x3, 0x3, 0x3, 0x3, 0x7, 0x3, 0x1d9, 0xa, 0x3, 0xc, 
       0x3, 0xe, 0x3, 0x1dc, 0xb, 0x3, 0x3, 0x3, 0x5, 0x3, 0x1df, 0xa, 0x3, 
       0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x1e3, 0xa, 0x4, 0x3, 0x5, 0x3, 0x5, 
       0x5, 0x5, 0x1e7, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1eb, 0xa, 
       0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1ef, 0xa, 0x5, 0x3, 0x5, 0x3, 
       0x5, 0x5, 0x5, 0x1f3, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1f7, 
       0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1fb, 0xa, 0x5, 0x3, 0x5, 
       0x5, 0x5, 0x1fe, 0xa, 0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 
       0x3, 0x6, 0x5, 0x6, 0x205, 0xa, 0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 
       0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x5, 
       0x7, 0x210, 0xa, 0x7, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x5, 0x8, 0x21e, 0xa, 0x8, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 
       0x222, 0xa, 0x9, 0x3, 0x9, 0x7, 0x9, 0x225, 0xa, 0x9, 0xc, 0x9, 0xe, 
       0x9, 0x228, 0xb, 0x9, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x22c, 0xa, 0x9, 
       0x3, 0xa, 0x3, 0xa, 0x5, 0xa, 0x230, 0xa, 0xa, 0x3, 0xb, 0x3, 0xb, 
       0x5, 0xb, 0x234, 0xa, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 
       0x239, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x23e, 0xa, 
       0xc, 0x5, 0xc, 0x240, 0xa, 0xc, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x244, 
       0xa, 0xd, 0x3, 0xd, 0x5, 0xd, 0x247, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 
       0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x5, 0xe, 0x24e, 0xa, 0xe, 0x3, 0xe, 
       0x5, 0xe, 0x251, 0xa, 0xe, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 
       0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x5, 0xf, 0x25a, 0xa, 0xf, 0x3, 0xf, 
       0x5, 0xf, 0x25d, 0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 0x3, 0x11, 0x3, 
       0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 
       0x13, 0x268, 0xa, 0x13, 0x3, 0x13, 0x6, 0x13, 0x26b, 0xa, 0x13, 0xd, 
       0x13, 0xe, 0x13, 0x26c, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 
       0x272, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x277, 
       0xa, 0x13, 0x3, 0x13, 0x7, 0x13, 0x27a, 0xa, 0x13, 0xc, 0x13, 0xe, 
       0x13, 0x27d, 0xb, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 
       0x282, 0xa, 0x13, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x286, 0xa, 0x14, 
       0x3, 0x14, 0x5, 0x14, 0x289, 0xa, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 
       0x14, 0x28d, 0xa, 0x14, 0x3, 0x14, 0x5, 0x14, 0x290, 0xa, 0x14, 0x3, 
       0x14, 0x5, 0x14, 0x293, 0xa, 0x14, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x29a, 0xa, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x5, 0x15, 0x29e, 0xa, 0x15, 0x5, 0x15, 0x2a0, 0xa, 0x15, 0x3, 
       0x16, 0x3, 0x16, 0x3, 0x16, 0x5, 0x16, 0x2a5, 0xa, 0x16, 0x3, 0x16, 
       0x3, 0x16, 0x7, 0x16, 0x2a9, 0xa, 0x16, 0xc, 0x16, 0xe, 0x16, 0x2ac, 
       0xb, 0x16, 0x3, 0x16, 0x5, 0x16, 0x2af, 0xa, 0x16, 0x3, 0x17, 0x3, 
       0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 
       0x17, 0x3, 0x17, 0x7, 0x17, 0x2ba, 0xa, 0x17, 0xc, 0x17, 0xe, 0x17, 
       0x2bd, 0xb, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x5, 0x17, 0x2c2, 
       0xa, 0x17, 0x3, 0x17, 0x5, 0x17, 0x2c5, 0xa, 0x17, 0x3, 0x17, 0x3, 
       0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x7, 0x17, 0x2cc, 0xa, 0x17, 
       0xc, 0x17, 0xe, 0x17, 0x2cf, 0xb, 0x17, 0x5, 0x17, 0x2d1, 0xa, 0x17, 
       0x3, 0x18, 0x3, 0x18, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 
       0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x5, 0x19, 0x2dd, 0xa, 
       0x19, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1c, 0x3, 
       0x1c, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1f, 0x3, 
       0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 
       0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x2f4, 0xa, 0x20, 
       0x3, 0x20, 0x5, 0x20, 0x2f7, 0xa, 0x20, 0x3, 0x21, 0x3, 0x21, 0x3, 
       0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x5, 
       0x21, 0x301, 0xa, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 
       0x5, 0x21, 0x307, 0xa, 0x21, 0x6, 0x21, 0x309, 0xa, 0x21, 0xd, 0x21, 
       0xe, 0x21, 0x30a, 0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x30f, 0xa, 0x21, 
       0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 
       0x316, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x5, 
       0x22, 0x31c, 0xa, 0x22, 0x5, 0x22, 0x31e, 0xa, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x3, 0x22, 0x5, 0x22, 0x323, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 
       0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x329, 0xa, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x32f, 0xa, 0x22, 0x3, 0x22, 
       0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x334, 0xa, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x33a, 0xa, 0x22, 0x3, 0x23, 
       0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x341, 0xa, 
       0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x346, 0xa, 0x23, 
       0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x34b, 0xa, 0x23, 0x3, 
       0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x350, 0xa, 0x23, 0x3, 0x23, 
       0x5, 0x23, 0x353, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x357, 
       0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x35b, 0xa, 0x23, 0x3, 
       0x23, 0x3, 0x23, 0x5, 0x23, 0x35f, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 
       0x5, 0x23, 0x363, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 
       0x23, 0x368, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x36c, 0xa, 
       0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x370, 0xa, 0x23, 0x3, 0x24, 
       0x5, 0x24, 0x373, 0xa, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x3, 0x24, 0x3, 0x24, 0x5, 0x24, 0x37b, 0xa, 0x24, 0x5, 0x24, 
       0x37d, 0xa, 0x24, 0x3, 0x24, 0x5, 0x24, 0x380, 0xa, 0x24, 0x3, 0x24, 
       0x3, 0x24, 0x5, 0x24, 0x384, 0xa, 0x24, 0x3, 0x24, 0x5, 0x24, 0x387, 
       0xa, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 
       0x6, 0x24, 0x38e, 0xa, 0x24, 0xd, 0x24, 0xe, 0x24, 0x38f, 0x3, 0x24, 
       0x5, 0x24, 0x393, 0xa, 0x24, 0x3, 0x24, 0x5, 0x24, 0x396, 0xa, 0x24, 
       0x3, 0x24, 0x3, 0x24, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 
       0x5, 0x25, 0x39e, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x6, 0x25, 0x3a2, 
       0xa, 0x25, 0xd, 0x25, 0xe, 0x25, 0x3a3, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x3ab, 0xa, 0x25, 0x3, 0x25, 
       0x3, 0x25, 0x5, 0x25, 0x3af, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x5, 0x25, 0x3ba, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x6, 0x25, 
       0x3be, 0xa, 0x25, 0xd, 0x25, 0xe, 0x25, 0x3bf, 0x5, 0x25, 0x3c2, 
       0xa, 0x25, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 
       0x7, 0x26, 0x3c9, 0xa, 0x26, 0xc, 0x26, 0xe, 0x26, 0x3cc, 0xb, 0x26, 
       0x3, 0x26, 0x5, 0x26, 0x3cf, 0xa, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 
       0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 0x3d6, 0xa, 0x27, 0x3, 0x27, 
       0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 0x3db, 0xa, 0x27, 0x3, 0x28, 0x5, 
       0x28, 0x3de, 0xa, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 
       0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x3e6, 0xa, 0x28, 0x3, 0x28, 0x3, 
       0x28, 0x5, 0x28, 0x3ea, 0xa, 0x28, 0x3, 0x28, 0x5, 0x28, 0x3ed, 0xa, 
       0x28, 0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x3f1, 0xa, 0x28, 0x3, 0x28, 
       0x5, 0x28, 0x3f4, 0xa, 0x28, 0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x3f8, 
       0xa, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 
       0x5, 0x28, 0x3ff, 0xa, 0x28, 0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x403, 
       0xa, 0x28, 0x5, 0x28, 0x405, 0xa, 0x28, 0x5, 0x28, 0x407, 0xa, 0x28, 
       0x3, 0x28, 0x5, 0x28, 0x40a, 0xa, 0x28, 0x3, 0x28, 0x5, 0x28, 0x40d, 
       0xa, 0x28, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x5, 0x29, 0x412, 0xa, 
       0x29, 0x3, 0x2a, 0x5, 0x2a, 0x415, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x41d, 0xa, 
       0x2a, 0x5, 0x2a, 0x41f, 0xa, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x422, 0xa, 
       0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x426, 0xa, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x42c, 0xa, 0x2a, 0x3, 
       0x2a, 0x5, 0x2a, 0x42f, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2b, 
       0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x438, 0xa, 
       0x2b, 0x3, 0x2c, 0x5, 0x2c, 0x43b, 0xa, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x442, 0xa, 0x2c, 0x3, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x448, 0xa, 0x2c, 
       0x7, 0x2c, 0x44a, 0xa, 0x2c, 0xc, 0x2c, 0xe, 0x2c, 0x44d, 0xb, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 
       0x3, 0x2c, 0x5, 0x2c, 0x456, 0xa, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x459, 
       0xa, 0x2c, 0x3, 0x2d, 0x5, 0x2d, 0x45c, 0xa, 0x2d, 0x3, 0x2d, 0x3, 
       0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x462, 0xa, 0x2e, 0x3, 0x2e, 
       0x5, 0x2e, 0x465, 0xa, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x468, 0xa, 0x2e, 
       0x3, 0x2f, 0x3, 0x2f, 0x5, 0x2f, 0x46c, 0xa, 0x2f, 0x3, 0x30, 0x5, 
       0x30, 0x46f, 0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 
       0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x477, 0xa, 0x30, 0x5, 0x30, 0x479, 
       0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x47d, 0xa, 0x30, 0x3, 
       0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x7, 0x30, 0x483, 0xa, 0x30, 
       0xc, 0x30, 0xe, 0x30, 0x486, 0xb, 0x30, 0x3, 0x30, 0x5, 0x30, 0x489, 
       0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x48d, 0xa, 0x30, 0x3, 
       0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x494, 
       0xa, 0x30, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x498, 0xa, 0x30, 0x5, 
       0x30, 0x49a, 0xa, 0x30, 0x5, 0x30, 0x49c, 0xa, 0x30, 0x3, 0x30, 0x5, 
       0x30, 0x49f, 0xa, 0x30, 0x3, 0x30, 0x5, 0x30, 0x4a2, 0xa, 0x30, 0x3, 
       0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x7, 0x31, 0x4a8, 0xa, 0x31, 
       0xc, 0x31, 0xe, 0x31, 0x4ab, 0xb, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 
       0x31, 0x5, 0x31, 0x4b0, 0xa, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 
       0x3, 0x31, 0x5, 0x31, 0x4b6, 0xa, 0x31, 0x5, 0x31, 0x4b8, 0xa, 0x31, 
       0x3, 0x32, 0x3, 0x32, 0x5, 0x32, 0x4bc, 0xa, 0x32, 0x3, 0x32, 0x5, 
       0x32, 0x4bf, 0xa, 0x32, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 
       0x4c4, 0xa, 0x33, 0x3, 0x33, 0x5, 0x33, 0x4c7, 0xa, 0x33, 0x3, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x4cd, 0xa, 0x33, 0x3, 
       0x33, 0x5, 0x33, 0x4d0, 0xa, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 
       0x7, 0x33, 0x4d5, 0xa, 0x33, 0xc, 0x33, 0xe, 0x33, 0x4d8, 0xb, 0x33, 
       0x3, 0x33, 0x5, 0x33, 0x4db, 0xa, 0x33, 0x5, 0x33, 0x4dd, 0xa, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x7, 0x33, 0x4e3, 0xa, 
       0x33, 0xc, 0x33, 0xe, 0x33, 0x4e6, 0xb, 0x33, 0x5, 0x33, 0x4e8, 0xa, 
       0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x4ec, 0xa, 0x33, 0x3, 0x33, 
       0x3, 0x33, 0x7, 0x33, 0x4f0, 0xa, 0x33, 0xc, 0x33, 0xe, 0x33, 0x4f3, 
       0xb, 0x33, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x5, 0x34, 0x4f8, 0xa, 
       0x34, 0x3, 0x34, 0x5, 0x34, 0x4fb, 0xa, 0x34, 0x3, 0x34, 0x3, 0x34, 
       0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x7, 0x34, 0x503, 0xa, 
       0x34, 0xc, 0x34, 0xe, 0x34, 0x506, 0xb, 0x34, 0x3, 0x34, 0x3, 0x34, 
       0x3, 0x34, 0x3, 0x34, 0x5, 0x34, 0x50c, 0xa, 0x34, 0x3, 0x34, 0x3, 
       0x34, 0x3, 0x34, 0x5, 0x34, 0x511, 0xa, 0x34, 0x3, 0x34, 0x5, 0x34, 
       0x514, 0xa, 0x34, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 
       0x35, 0x3, 0x35, 0x7, 0x35, 0x51c, 0xa, 0x35, 0xc, 0x35, 0xe, 0x35, 
       0x51f, 0xb, 0x35, 0x5, 0x35, 0x521, 0xa, 0x35, 0x3, 0x35, 0x5, 0x35, 
       0x524, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 
       0x35, 0x3, 0x35, 0x5, 0x35, 0x52c, 0xa, 0x35, 0x3, 0x36, 0x3, 0x36, 
       0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x7, 0x36, 
       0x535, 0xa, 0x36, 0xc, 0x36, 0xe, 0x36, 0x538, 0xb, 0x36, 0x5, 0x36, 
       0x53a, 0xa, 0x36, 0x3, 0x36, 0x5, 0x36, 0x53d, 0xa, 0x36, 0x3, 0x36, 
       0x3, 0x36, 0x7, 0x36, 0x541, 0xa, 0x36, 0xc, 0x36, 0xe, 0x36, 0x544, 
       0xb, 0x36, 0x3, 0x36, 0x3, 0x36, 0x5, 0x36, 0x548, 0xa, 0x36, 0x3, 
       0x36, 0x3, 0x36, 0x5, 0x36, 0x54c, 0xa, 0x36, 0x3, 0x37, 0x3, 0x37, 
       0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x7, 0x37, 0x554, 0xa, 
       0x37, 0xc, 0x37, 0xe, 0x37, 0x557, 0xb, 0x37, 0x5, 0x37, 0x559, 0xa, 
       0x37, 0x3, 0x37, 0x5, 0x37, 0x55c, 0xa, 0x37, 0x3, 0x37, 0x3, 0x37, 
       0x7, 0x37, 0x560, 0xa, 0x37, 0xc, 0x37, 0xe, 0x37, 0x563, 0xb, 0x37, 
       0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 0x568, 0xa, 0x37, 0x3, 
       0x37, 0x3, 0x37, 0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x56e, 0xa, 0x38, 
       0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x573, 0xa, 0x38, 0x3, 
       0x38, 0x3, 0x38, 0x5, 0x38, 0x577, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 
       0x5, 0x38, 0x57b, 0xa, 0x38, 0x3, 0x38, 0x5, 0x38, 0x57e, 0xa, 0x38, 
       0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x5, 0x39, 0x583, 0xa, 0x39, 0x3, 
       0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 
       0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x5, 
       0x3a, 0x591, 0xa, 0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 
       0x3, 0x3b, 0x3, 0x3b, 0x5, 0x3b, 0x599, 0xa, 0x3b, 0x3, 0x3b, 0x3, 
       0x3b, 0x3, 0x3b, 0x5, 0x3b, 0x59e, 0xa, 0x3b, 0x3, 0x3b, 0x7, 0x3b, 
       0x5a1, 0xa, 0x3b, 0xc, 0x3b, 0xe, 0x3b, 0x5a4, 0xb, 0x3b, 0x3, 0x3b, 
       0x3, 0x3b, 0x3, 0x3b, 0x5, 0x3b, 0x5a9, 0xa, 0x3b, 0x3, 0x3b, 0x3, 
       0x3b, 0x3, 0x3b, 0x5, 0x3b, 0x5ae, 0xa, 0x3b, 0x3, 0x3b, 0x5, 0x3b, 
       0x5b1, 0xa, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 
       0x3c, 0x7, 0x3c, 0x5b8, 0xa, 0x3c, 0xc, 0x3c, 0xe, 0x3c, 0x5bb, 0xb, 
       0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x7, 
       0x3c, 0x5c2, 0xa, 0x3c, 0xc, 0x3c, 0xe, 0x3c, 0x5c5, 0xb, 0x3c, 0x5, 
       0x3c, 0x5c7, 0xa, 0x3c, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x7, 0x3d, 0x5dc, 0xa, 0x3d, 0xc, 
       0x3d, 0xe, 0x3d, 0x5df, 0xb, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x5f9, 0xa, 0x3d, 0x3, 
       0x3d, 0x5, 0x3d, 0x5fc, 0xa, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3f, 
       0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x5, 0x3f, 0x604, 0xa, 0x3f, 0x3, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x5, 0x40, 0x60a, 0xa, 0x40, 
       0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x7, 0x40, 0x60f, 0xa, 0x40, 0xc, 
       0x40, 0xe, 0x40, 0x612, 0xb, 0x40, 0x3, 0x40, 0x5, 0x40, 0x615, 0xa, 
       0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 0x41, 0x61b, 
       0xa, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x7, 0x41, 0x620, 0xa, 
       0x41, 0xc, 0x41, 0xe, 0x41, 0x623, 0xb, 0x41, 0x3, 0x41, 0x5, 0x41, 
       0x626, 0xa, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 
       0x42, 0x62c, 0xa, 0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 0x42, 0x630, 0xa, 
       0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x635, 0xa, 0x43, 
       0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x639, 0xa, 0x43, 0x3, 0x43, 0x3, 
       0x43, 0x3, 0x43, 0x3, 0x43, 0x7, 0x43, 0x63f, 0xa, 0x43, 0xc, 0x43, 
       0xe, 0x43, 0x642, 0xb, 0x43, 0x3, 0x43, 0x5, 0x43, 0x645, 0xa, 0x43, 
       0x5, 0x43, 0x647, 0xa, 0x43, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x64b, 
       0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x64f, 0xa, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x5, 0x44, 0x653, 0xa, 0x44, 0x3, 0x44, 0x5, 0x44, 
       0x656, 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x65a, 0xa, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x660, 0xa, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x664, 0xa, 0x44, 0x5, 0x44, 
       0x666, 0xa, 0x44, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x66b, 
       0xa, 0x45, 0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x66f, 0xa, 0x46, 0x3, 
       0x46, 0x3, 0x46, 0x5, 0x46, 0x673, 0xa, 0x46, 0x3, 0x47, 0x3, 0x47, 
       0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x5, 0x47, 0x67a, 0xa, 0x47, 0x3, 
       0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x67f, 0xa, 0x48, 0x3, 0x49, 
       0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x7, 0x49, 0x685, 0xa, 0x49, 0xc, 
       0x49, 0xe, 0x49, 0x688, 0xb, 0x49, 0x5, 0x49, 0x68a, 0xa, 0x49, 0x3, 
       0x49, 0x5, 0x49, 0x68d, 0xa, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 
       0x691, 0xa, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x695, 0xa, 0x4a, 
       0x3, 0x4a, 0x5, 0x4a, 0x698, 0xa, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 
       0x4a, 0x3, 0x4a, 0x7, 0x4a, 0x69e, 0xa, 0x4a, 0xc, 0x4a, 0xe, 0x4a, 
       0x6a1, 0xb, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x6a5, 0xa, 0x4a, 
       0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x7, 0x4b, 0x6aa, 0xa, 0x4b, 0xc, 
       0x4b, 0xe, 0x4b, 0x6ad, 0xb, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 
       0x7, 0x4b, 0x6b2, 0xa, 0x4b, 0xc, 0x4b, 0xe, 0x4b, 0x6b5, 0xb, 0x4b, 
       0x5, 0x4b, 0x6b7, 0xa, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x5, 
       0x4e, 0x6c2, 0xa, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x5, 0x4e, 
       0x6c7, 0xa, 0x4e, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x50, 0x3, 0x50, 0x3, 
       0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x6d1, 0xa, 0x51, 
       0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x6d6, 0xa, 0x51, 0x3, 
       0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x6dd, 
       0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 
       0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 
       0x5, 0x51, 0x6ea, 0xa, 0x51, 0x5, 0x51, 0x6ec, 0xa, 0x51, 0x5, 0x51, 
       0x6ee, 0xa, 0x51, 0x3, 0x51, 0x5, 0x51, 0x6f1, 0xa, 0x51, 0x3, 0x51, 
       0x5, 0x51, 0x6f4, 0xa, 0x51, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 
       0x52, 0x3, 0x52, 0x5, 0x52, 0x6fb, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 
       0x6fe, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 
       0x52, 0x704, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 
       0x709, 0xa, 0x52, 0x5, 0x52, 0x70b, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 
       0x70e, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 
       0x52, 0x714, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 
       0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x71c, 0xa, 0x52, 0x5, 0x52, 0x71e, 
       0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x721, 0xa, 0x52, 0x3, 0x52, 0x3, 
       0x52, 0x5, 0x52, 0x725, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x728, 0xa, 
       0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 
       0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x732, 0xa, 0x52, 0x3, 0x52, 
       0x5, 0x52, 0x735, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x739, 
       0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x73c, 0xa, 0x52, 0x3, 0x52, 0x3, 
       0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x742, 0xa, 0x52, 0x3, 0x52, 
       0x5, 0x52, 0x745, 0xa, 0x52, 0x5, 0x52, 0x747, 0xa, 0x52, 0x3, 0x53, 
       0x3, 0x53, 0x5, 0x53, 0x74b, 0xa, 0x53, 0x3, 0x54, 0x3, 0x54, 0x5, 
       0x54, 0x74f, 0xa, 0x54, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 
       0x754, 0xa, 0x55, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x759, 
       0xa, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 
       0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x763, 0xa, 0x57, 0x3, 
       0x57, 0x5, 0x57, 0x766, 0xa, 0x57, 0x3, 0x57, 0x5, 0x57, 0x769, 0xa, 
       0x57, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 
       0x58, 0x5, 0x58, 0x771, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 
       0x775, 0xa, 0x58, 0x3, 0x58, 0x5, 0x58, 0x778, 0xa, 0x58, 0x3, 0x59, 
       0x3, 0x59, 0x5, 0x59, 0x77c, 0xa, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x3, 
       0x5a, 0x5, 0x5a, 0x781, 0xa, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 
       0x3, 0x5b, 0x3, 0x5c, 0x3, 0x5c, 0x5, 0x5c, 0x789, 0xa, 0x5c, 0x3, 
       0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x5, 0x5c, 0x78e, 0xa, 0x5c, 0x3, 0x5d, 
       0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 
       0x5, 0x5e, 0x797, 0xa, 0x5e, 0x3, 0x5e, 0x7, 0x5e, 0x79a, 0xa, 0x5e, 
       0xc, 0x5e, 0xe, 0x5e, 0x79d, 0xb, 0x5e, 0x3, 0x5f, 0x3, 0x5f, 0x5, 
       0x5f, 0x7a1, 0xa, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 
       0x3, 0x60, 0x5, 0x60, 0x7a8, 0xa, 0x60, 0x5, 0x60, 0x7aa, 0xa, 0x60, 
       0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 0x7ae, 0xa, 0x60, 0x3, 0x60, 0x5, 
       0x60, 0x7b1, 0xa, 0x60, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 0x7b5, 0xa, 
       0x60, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 0x7b9, 0xa, 0x60, 0x3, 0x60, 
       0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 
       0x7c1, 0xa, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, 0x7c6, 
       0xa, 0x60, 0x5, 0x60, 0x7c8, 0xa, 0x60, 0x3, 0x60, 0x5, 0x60, 0x7cb, 
       0xa, 0x60, 0x3, 0x60, 0x7, 0x60, 0x7ce, 0xa, 0x60, 0xc, 0x60, 0xe, 
       0x60, 0x7d1, 0xb, 0x60, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x7d5, 0xa, 
       0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x7da, 0xa, 0x61, 
       0x3, 0x61, 0x5, 0x61, 0x7dd, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 
       0x61, 0x3, 0x61, 0x5, 0x61, 0x7e3, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 
       0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x7eb, 0xa, 
       0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 
       0x61, 0x3, 0x61, 0x5, 0x61, 0x7f4, 0xa, 0x61, 0x3, 0x62, 0x3, 0x62, 
       0x5, 0x62, 0x7f8, 0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x5, 
       0x62, 0x7fd, 0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 
       0x5, 0x62, 0x803, 0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 0x5, 0x62, 0x807, 
       0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x5, 0x62, 
       0x80d, 0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 
       0x62, 0x3, 0x62, 0x5, 0x62, 0x815, 0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 
       0x3, 0x62, 0x3, 0x62, 0x6, 0x62, 0x81b, 0xa, 0x62, 0xd, 0x62, 0xe, 
       0x62, 0x81c, 0x3, 0x62, 0x5, 0x62, 0x820, 0xa, 0x62, 0x3, 0x62, 0x3, 
       0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 
       0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x5, 
       0x62, 0x82f, 0xa, 0x62, 0x5, 0x62, 0x831, 0xa, 0x62, 0x3, 0x63, 0x3, 
       0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x7, 0x63, 0x838, 0xa, 0x63, 
       0xc, 0x63, 0xe, 0x63, 0x83b, 0xb, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 
       0x64, 0x3, 0x64, 0x5, 0x64, 0x841, 0xa, 0x64, 0x3, 0x64, 0x3, 0x64, 
       0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x5, 0x64, 0x848, 0xa, 0x64, 0x3, 
       0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 
       0x65, 0x3, 0x65, 0x5, 0x65, 0x852, 0xa, 0x65, 0x5, 0x65, 0x854, 0xa, 
       0x65, 0x5, 0x65, 0x856, 0xa, 0x65, 0x3, 0x65, 0x5, 0x65, 0x859, 0xa, 
       0x65, 0x3, 0x65, 0x5, 0x65, 0x85c, 0xa, 0x65, 0x3, 0x65, 0x3, 0x65, 
       0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 
       0x3, 0x65, 0x5, 0x65, 0x867, 0xa, 0x65, 0x5, 0x65, 0x869, 0xa, 0x65, 
       0x5, 0x65, 0x86b, 0xa, 0x65, 0x3, 0x65, 0x5, 0x65, 0x86e, 0xa, 0x65, 
       0x3, 0x66, 0x7, 0x66, 0x871, 0xa, 0x66, 0xc, 0x66, 0xe, 0x66, 0x874, 
       0xb, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x87e, 0xa, 0x67, 0x3, 
       0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 
       0x68, 0x5, 0x68, 0x887, 0xa, 0x68, 0x3, 0x68, 0x5, 0x68, 0x88a, 0xa, 
       0x68, 0x3, 0x68, 0x5, 0x68, 0x88d, 0xa, 0x68, 0x3, 0x68, 0x3, 0x68, 
       0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x7, 0x68, 0x894, 0xa, 0x68, 0xc, 
       0x68, 0xe, 0x68, 0x897, 0xb, 0x68, 0x5, 0x68, 0x899, 0xa, 0x68, 0x3, 
       0x68, 0x5, 0x68, 0x89c, 0xa, 0x68, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x8a3, 0xa, 0x69, 0x3, 0x69, 0x5, 
       0x69, 0x8a6, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x5, 0x69, 0x8ac, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x8bb, 0xa, 0x69, 
       0x3, 0x69, 0x5, 0x69, 0x8be, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x8c5, 0xa, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x8ca, 0xa, 0x69, 0x3, 0x6a, 0x3, 
       0x6a, 0x5, 0x6a, 0x8ce, 0xa, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 
       0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 
       0x5, 0x6b, 0x8d9, 0xa, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 
       0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 
       0x6b, 0x3, 0x6b, 0x7, 0x6b, 0x8e6, 0xa, 0x6b, 0xc, 0x6b, 0xe, 0x6b, 
       0x8e9, 0xb, 0x6b, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 
       0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x5, 0x6d, 0x8f4, 
       0xa, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x6, 0x6e, 0x8f9, 0xa, 
       0x6e, 0xd, 0x6e, 0xe, 0x6e, 0x8fa, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 
       0x8ff, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x6, 
       0x6e, 0x905, 0xa, 0x6e, 0xd, 0x6e, 0xe, 0x6e, 0x906, 0x3, 0x6e, 0x3, 
       0x6e, 0x5, 0x6e, 0x90b, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 
       0x90f, 0xa, 0x6e, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x5, 
       0x6f, 0x915, 0xa, 0x6f, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 
       0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 0x91f, 0xa, 
       0x70, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 
       0x71, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 0x929, 0xa, 0x71, 0x3, 0x72, 
       0x3, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x7, 0x73, 
       0x931, 0xa, 0x73, 0xc, 0x73, 0xe, 0x73, 0x934, 0xb, 0x73, 0x3, 0x74, 
       0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x5, 0x74, 0x93b, 0xa, 
       0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 
       0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0x947, 
       0xa, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 
       0x94d, 0xa, 0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0x951, 0xa, 0x75, 
       0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 
       0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0x95b, 0xa, 0x75, 0x3, 0x76, 0x3, 
       0x76, 0x5, 0x76, 0x95f, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 
       0x963, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 
       0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 0x96d, 0xa, 0x76, 
       0x3, 0x77, 0x3, 0x77, 0x7, 0x77, 0x971, 0xa, 0x77, 0xc, 0x77, 0xe, 
       0x77, 0x974, 0xb, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 
       0x3, 0x77, 0x5, 0x77, 0x97b, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 
       0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x7, 0x77, 0x983, 0xa, 0x77, 
       0xc, 0x77, 0xe, 0x77, 0x986, 0xb, 0x77, 0x3, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x7, 0x78, 0x99a, 0xa, 0x78, 
       0xc, 0x78, 0xe, 0x78, 0x99d, 0xb, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x7, 0x78, 0x9a6, 
       0xa, 0x78, 0xc, 0x78, 0xe, 0x78, 0x9a9, 0xb, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x3, 0x78, 0x5, 0x78, 0x9af, 0xa, 0x78, 0x3, 0x78, 
       0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x7, 0x78, 0x9b5, 0xa, 0x78, 0xc, 
       0x78, 0xe, 0x78, 0x9b8, 0xb, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 
       0x3, 0x78, 0x5, 0x78, 0x9be, 0xa, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x5, 0x78, 0x9c4, 0xa, 0x78, 0x3, 0x79, 0x3, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0x9cb, 0xa, 0x79, 0x3, 
       0x79, 0x3, 0x79, 0x5, 0x79, 0x9cf, 0xa, 0x79, 0x3, 0x79, 0x6, 0x79, 
       0x9d2, 0xa, 0x79, 0xd, 0x79, 0xe, 0x79, 0x9d3, 0x5, 0x79, 0x9d6, 
       0xa, 0x79, 0x3, 0x7a, 0x3, 0x7a, 0x5, 0x7a, 0x9da, 0xa, 0x7a, 0x3, 
       0x7a, 0x3, 0x7a, 0x5, 0x7a, 0x9de, 0xa, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 
       0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x5, 0x7a, 0x9e5, 0xa, 0x7a, 0x3, 
       0x7b, 0x3, 0x7b, 0x5, 0x7b, 0x9e9, 0xa, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 
       0x9ec, 0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 0x9f1, 
       0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 0x9f5, 0xa, 0x7b, 0x3, 
       0x7b, 0x3, 0x7b, 0x5, 0x7b, 0x9f9, 0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 
       0x3, 0x7b, 0x5, 0x7b, 0x9fe, 0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 
       0x7b, 0x7, 0x7b, 0xa03, 0xa, 0x7b, 0xc, 0x7b, 0xe, 0x7b, 0xa06, 0xb, 
       0x7b, 0x5, 0x7b, 0xa08, 0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 
       0xa0c, 0xa, 0x7b, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0xa11, 
       0xa, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0xa15, 0xa, 0x7c, 0x3, 
       0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 
       0x7d, 0x5, 0x7d, 0xa1e, 0xa, 0x7d, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 
       0x3, 0x7e, 0x3, 0x7e, 0x5, 0x7e, 0xa25, 0xa, 0x7e, 0x3, 0x7f, 0x3, 
       0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x7, 0x7f, 0xa2c, 0xa, 0x7f, 
       0xc, 0x7f, 0xe, 0x7f, 0xa2f, 0xb, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 
       0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 
       0x7f, 0x5, 0x7f, 0xa3a, 0xa, 0x7f, 0x5, 0x7f, 0xa3c, 0xa, 0x7f, 0x3, 
       0x80, 0x3, 0x80, 0x3, 0x80, 0x5, 0x80, 0xa41, 0xa, 0x80, 0x3, 0x81, 
       0x3, 0x81, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x7, 0x82, 0xa4a, 0xa, 0x82, 0xc, 0x82, 0xe, 0x82, 0xa4d, 0xb, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x7, 0x83, 0xa69, 0xa, 0x83, 0xc, 0x83, 0xe, 
       0x83, 0xa6c, 0xb, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0xa7b, 0xa, 0x83, 0x3, 
       0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x5, 0x84, 0xa82, 
       0xa, 0x84, 0x5, 0x84, 0xa84, 0xa, 0x84, 0x3, 0x85, 0x3, 0x85, 0x3, 
       0x85, 0x7, 0x85, 0xa89, 0xa, 0x85, 0xc, 0x85, 0xe, 0x85, 0xa8c, 0xb, 
       0x85, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x7, 0x86, 0xa92, 
       0xa, 0x86, 0xc, 0x86, 0xe, 0x86, 0xa95, 0xb, 0x86, 0x3, 0x86, 0x3, 
       0x86, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 0xa9c, 0xa, 0x87, 
       0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 0xaa2, 0xa, 
       0x87, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 
       0x88, 0x5, 0x88, 0xaaa, 0xa, 0x88, 0x3, 0x88, 0x5, 0x88, 0xaad, 0xa, 
       0x88, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 
       0x89, 0xab4, 0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x5, 0x89, 0xaba, 0xa, 0x89, 0x3, 0x89, 0x5, 0x89, 0xabd, 0xa, 0x89, 
       0x5, 0x89, 0xabf, 0xa, 0x89, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 
       0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0xac7, 0xa, 0x8a, 0x5, 0x8a, 
       0xac9, 0xa, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 
       0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xad1, 0xa, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 
       0x5, 0x8b, 0xad5, 0xa, 0x8b, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x7, 
       0x8c, 0xada, 0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 0xadd, 0xb, 0x8c, 0x3, 
       0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x5, 0x8d, 0xae4, 
       0xa, 0x8d, 0x3, 0x8e, 0x3, 0x8e, 0x7, 0x8e, 0xae8, 0xa, 0x8e, 0xc, 
       0x8e, 0xe, 0x8e, 0xaeb, 0xb, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 
       0x3, 0x8e, 0x7, 0x8e, 0xaf1, 0xa, 0x8e, 0xc, 0x8e, 0xe, 0x8e, 0xaf4, 
       0xb, 0x8e, 0x5, 0x8e, 0xaf6, 0xa, 0x8e, 0x3, 0x8f, 0x3, 0x8f, 0x5, 
       0x8f, 0xafa, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xafe, 0xa, 
       0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xb02, 0xa, 0x8f, 0x3, 0x8f, 
       0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xb09, 0xa, 
       0x8f, 0x5, 0x8f, 0xb0b, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 
       0xb0f, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xb14, 
       0xa, 0x8f, 0x5, 0x8f, 0xb16, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 
       0x8f, 0x5, 0x8f, 0xb1b, 0xa, 0x8f, 0x5, 0x8f, 0xb1d, 0xa, 0x8f, 0x3, 
       0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xb24, 
       0xa, 0x8f, 0x5, 0x8f, 0xb26, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 
       0x8f, 0x5, 0x8f, 0xb2b, 0xa, 0x8f, 0x5, 0x8f, 0xb2d, 0xa, 0x8f, 0x3, 
       0x90, 0x3, 0x90, 0x3, 0x90, 0x7, 0x90, 0xb32, 0xa, 0x90, 0xc, 0x90, 
       0xe, 0x90, 0xb35, 0xb, 0x90, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 
       0x91, 0xb3a, 0xa, 0x91, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xb3e, 0xa, 
       0x92, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 
       0x95, 0xb57, 0xa, 0x95, 0x3, 0x96, 0x5, 0x96, 0xb5a, 0xa, 0x96, 0x3, 
       0x96, 0x3, 0x96, 0x5, 0x96, 0xb5e, 0xa, 0x96, 0x5, 0x96, 0xb60, 0xa, 
       0x96, 0x3, 0x96, 0x5, 0x96, 0xb63, 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 
       0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 
       0x3, 0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x99, 
       0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 
       0x3, 0x9a, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 
       0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 
       0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 
       0x3, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x7, 0x9d, 0xb8f, 0xa, 
       0x9d, 0xc, 0x9d, 0xe, 0x9d, 0xb92, 0xb, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 
       0x5, 0x9e, 0xb96, 0xa, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 
       0x9f, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 
       0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x5, 0xa0, 0xba6, 
       0xa, 0xa0, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 
       0x3, 0xa1, 0x3, 0xa1, 0x5, 0xa1, 0xbaf, 0xa, 0xa1, 0x3, 0xa1, 0x3, 
       0xa1, 0x3, 0xa1, 0x5, 0xa1, 0xbb4, 0xa, 0xa1, 0x3, 0xa2, 0x3, 0xa2, 
       0x3, 0xa2, 0x5, 0xa2, 0xbb9, 0xa, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 
       0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 
       0xa3, 0xbdb, 0xa, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0xc15, 0xa, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0xc19, 0xa, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 
       0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 
       0xc51, 0xa, 0xa3, 0x5, 0xa3, 0xc53, 0xa, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 
       0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 0xc5b, 0xa, 
       0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 
       0xa4, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 
       0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa7, 0x5, 
       0xa7, 0xc6e, 0xa, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa8, 0x5, 0xa8, 
       0xc73, 0xa, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa9, 0x3, 0xa9, 0x5, 
       0xa9, 0xc79, 0xa, 0xa9, 0x3, 0xaa, 0x5, 0xaa, 0xc7c, 0xa, 0xaa, 0x3, 
       0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x5, 0xaa, 0xc81, 0xa, 0xaa, 0x3, 0xaa, 
       0x7, 0xaa, 0xc84, 0xa, 0xaa, 0xc, 0xaa, 0xe, 0xaa, 0xc87, 0xb, 0xaa, 
       0x3, 0xaa, 0x3, 0xaa, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 
       0x5, 0xab, 0xc8f, 0xa, 0xab, 0x3, 0xab, 0x7, 0xab, 0xc92, 0xa, 0xab, 
       0xc, 0xab, 0xe, 0xab, 0xc95, 0xb, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 
       0xac, 0x5, 0xac, 0xc9a, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x7, 0xac, 0xca1, 0xa, 0xac, 0xc, 0xac, 0xe, 
       0xac, 0xca4, 0xb, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x7, 0xac, 0xcab, 0xa, 0xac, 0xc, 0xac, 0xe, 0xac, 0xcae, 
       0xb, 0xac, 0x5, 0xac, 0xcb0, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 
       0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 
       0xac, 0x3, 0xac, 0x7, 0xac, 0xcbc, 0xa, 0xac, 0xc, 0xac, 0xe, 0xac, 
       0xcbf, 0xb, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 0xcc4, 
       0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 0xccd, 0xa, 0xac, 0x3, 0xad, 0x3, 
       0xad, 0x5, 0xad, 0xcd1, 0xa, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 
       0x3, 0xae, 0x7, 0xae, 0xcd7, 0xa, 0xae, 0xc, 0xae, 0xe, 0xae, 0xcda, 
       0xb, 0xae, 0x3, 0xae, 0x3, 0xae, 0x3, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 
       0xce0, 0xa, 0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 
       0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x7, 0xb0, 0xceb, 
       0xa, 0xb0, 0xc, 0xb0, 0xe, 0xb0, 0xcee, 0xb, 0xb0, 0x3, 0xb1, 0x3, 
       0xb1, 0x3, 0xb1, 0x7, 0xb1, 0xcf3, 0xa, 0xb1, 0xc, 0xb1, 0xe, 0xb1, 
       0xcf6, 0xb, 0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 
       0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x5, 
       0xb2, 0xd02, 0xa, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x5, 0xb3, 0xd09, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xd0f, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x5, 0xb3, 0xd13, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 
       0xb3, 0xd24, 0xa, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 
       0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 
       0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xd33, 0xa, 0xb4, 0x5, 
       0xb4, 0xd35, 0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 
       0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 
       0x3, 0xb4, 0x5, 0xb4, 0xd42, 0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 
       0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 
       0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x5, 
       0xb4, 0xd52, 0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 
       0x3, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xd5a, 0xa, 0xb4, 0x3, 0xb4, 0x3, 
       0xb4, 0x5, 0xb4, 0xd5e, 0xa, 0xb4, 0x3, 0xb5, 0x5, 0xb5, 0xd61, 0xa, 
       0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 
       0xb6, 0x3, 0xb6, 0x5, 0xb6, 0xd6a, 0xa, 0xb6, 0x3, 0xb6, 0x5, 0xb6, 
       0xd6d, 0xa, 0xb6, 0x3, 0xb6, 0x5, 0xb6, 0xd70, 0xa, 0xb6, 0x3, 0xb6, 
       0x3, 0xb6, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xd7d, 0xa, 
       0xb8, 0x3, 0xb9, 0x3, 0xb9, 0x5, 0xb9, 0xd81, 0xa, 0xb9, 0x3, 0xba, 
       0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 
       0xd89, 0xa, 0xba, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x5, 
       0xbb, 0xd8f, 0xa, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 
       0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 
       0x5, 0xbc, 0xd9b, 0xa, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 
       0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xda2, 0xa, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 
       0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x5, 0xbd, 
       0xdab, 0xa, 0xbd, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 
       0xbe, 0x5, 0xbe, 0xdb2, 0xa, 0xbe, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 
       0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 
       0x3, 0xbf, 0x5, 0xbf, 0xdbe, 0xa, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 
       0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x5, 0xbf, 0xdc5, 0xa, 0xbf, 0x3, 0xbf, 
       0x3, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 
       0xdcd, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x5, 0xc0, 0xdd4, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 
       0x3, 0xc0, 0x5, 0xc0, 0xdda, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 0xde1, 0xa, 0xc0, 0x3, 0xc0, 
       0x5, 0xc0, 0xde4, 0xa, 0xc0, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x5, 
       0xc1, 0xde9, 0xa, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc2, 0x3, 0xc2, 
       0x3, 0xc2, 0x5, 0xc2, 0xdf0, 0xa, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 
       0xc3, 0x5, 0xc3, 0xdf5, 0xa, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x5, 0xc3, 
       0xdf9, 0xa, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x5, 0xc3, 0xdfe, 
       0xa, 0xc3, 0x3, 0xc4, 0x5, 0xc4, 0xe01, 0xa, 0xc4, 0x3, 0xc4, 0x3, 
       0xc4, 0x5, 0xc4, 0xe05, 0xa, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x5, 0xc4, 
       0xe09, 0xa, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x5, 0xc4, 0xe0e, 
       0xa, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xe12, 0xa, 0xc5, 0x3, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xe18, 0xa, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xe1c, 0xa, 0xc6, 0x3, 0xc6, 0x3, 
       0xc6, 0x5, 0xc6, 0xe20, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x5, 0xc6, 0xe25, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xe29, 
       0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xe2e, 0xa, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xe33, 0xa, 0xc6, 
       0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xe37, 0xa, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xe3c, 0xa, 0xc7, 0x7, 0xc7, 0xe3e, 0xa, 
       0xc7, 0xc, 0xc7, 0xe, 0xc7, 0xe41, 0xb, 0xc7, 0x3, 0xc8, 0x3, 0xc8, 
       0x3, 0xc8, 0x7, 0xc8, 0xe46, 0xa, 0xc8, 0xc, 0xc8, 0xe, 0xc8, 0xe49, 
       0xb, 0xc8, 0x3, 0xc9, 0x5, 0xc9, 0xe4c, 0xa, 0xc9, 0x3, 0xc9, 0x7, 
       0xc9, 0xe4f, 0xa, 0xc9, 0xc, 0xc9, 0xe, 0xc9, 0xe52, 0xb, 0xc9, 0x3, 
       0xc9, 0x3, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x7, 0xca, 0xe59, 
       0xa, 0xca, 0xc, 0xca, 0xe, 0xca, 0xe5c, 0xb, 0xca, 0x3, 0xcb, 0x3, 
       0xcb, 0x5, 0xcb, 0xe60, 0xa, 0xcb, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcd, 
       0x5, 0xcd, 0xe65, 0xa, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0xe6e, 0xa, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0xe72, 0xa, 0xce, 0x5, 0xce, 0xe74, 
       0xa, 0xce, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xe96, 0xa, 0xcf, 0x3, 
       0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 
       0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 
       0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 
       0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x5, 0xd0, 0xeaf, 
       0xa, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x5, 0xd0, 0xeb3, 0xa, 0xd0, 0x3, 
       0xd0, 0x5, 0xd0, 0xeb6, 0xa, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 
       0x5, 0xd1, 0xebb, 0xa, 0xd1, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x5, 
       0xd2, 0xec0, 0xa, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x5, 0xd2, 0xec4, 0xa, 
       0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x5, 0xd2, 0xec8, 0xa, 0xd2, 0x3, 0xd2, 
       0x3, 0xd2, 0x5, 0xd2, 0xecc, 0xa, 0xd2, 0x3, 0xd3, 0x3, 0xd3, 0x3, 
       0xd4, 0x3, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x5, 
       0xd5, 0xed6, 0xa, 0xd5, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd7, 0x3, 0xd7, 
       0x5, 0xd7, 0xedc, 0xa, 0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 
       0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 
       0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x5, 
       0xd8, 0xeed, 0xa, 0xd8, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x2, 0x4, 
       0xd4, 0xec, 0xda, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 
       0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 
       0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 
       0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 
       0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 
       0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 
       0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 
       0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 
       0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 
       0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 
       0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 
       0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 
       0x106, 0x108, 0x10a, 0x10c, 0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 
       0x11a, 0x11c, 0x11e, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 
       0x12e, 0x130, 0x132, 0x134, 0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 
       0x142, 0x144, 0x146, 0x148, 0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 
       0x156, 0x158, 0x15a, 0x15c, 0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 
       0x16a, 0x16c, 0x16e, 0x170, 0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 
       0x17e, 0x180, 0x182, 0x184, 0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 
       0x192, 0x194, 0x196, 0x198, 0x19a, 0x19c, 0x19e, 0x1a0, 0x1a2, 0x1a4, 
       0x1a6, 0x1a8, 0x1aa, 0x1ac, 0x1ae, 0x1b0, 0x2, 0x3b, 0x3, 0x2, 0x191, 
       0x192, 0x4, 0x2, 0x191, 0x191, 0x194, 0x194, 0x4, 0x2, 0xcf, 0xcf, 
       0x153, 0x154, 0x4, 0x2, 0x191, 0x192, 0x194, 0x194, 0x5, 0x2, 0x111, 
       0x111, 0x141, 0x141, 0x179, 0x179, 0x5, 0x2, 0x18e, 0x18e, 0x191, 
       0x191, 0x194, 0x194, 0x5, 0x2, 0x8c, 0x8c, 0x115, 0x115, 0x15a, 0x15a, 
       0x4, 0x2, 0x8c, 0x8c, 0x115, 0x115, 0x5, 0x2, 0x40, 0x40, 0x8c, 0x8c, 
       0x115, 0x115, 0x4, 0x2, 0xdb, 0xdb, 0x142, 0x142, 0x3, 0x2, 0x7f, 
       0x80, 0x4, 0x2, 0x11b, 0x11c, 0x12e, 0x12e, 0x5, 0x2, 0x93, 0x93, 
       0xb4, 0xb4, 0xd6, 0xd6, 0x4, 0x2, 0xe6, 0xe6, 0xfd, 0xfd, 0x4, 0x2, 
       0x192, 0x192, 0x194, 0x194, 0x3, 0x2, 0x11b, 0x11c, 0x7, 0x2, 0xab, 
       0xad, 0xd3, 0xd3, 0xd5, 0xd5, 0x12a, 0x12c, 0x156, 0x157, 0x3, 0x2, 
       0x97, 0x98, 0x3, 0x2, 0x71, 0x72, 0x6, 0x2, 0xba, 0xba, 0x11d, 0x11d, 
       0x13d, 0x13d, 0x194, 0x194, 0x4, 0x2, 0xf1, 0xf1, 0x13e, 0x13e, 0x4, 
       0x2, 0xe3, 0xe3, 0x13a, 0x13a, 0x6, 0x2, 0xd7, 0xd7, 0xdd, 0xdd, 
       0xf7, 0xf7, 0x148, 0x148, 0x5, 0x2, 0x119, 0x119, 0x12d, 0x12d, 0x13b, 
       0x13b, 0x4, 0x2, 0xa8, 0xa8, 0x131, 0x131, 0xa, 0x2, 0xaf, 0xb1, 
       0xb3, 0xb3, 0xc2, 0xc2, 0xc6, 0xc6, 0x10e, 0x10e, 0x114, 0x114, 0x127, 
       0x127, 0x1ba, 0x1c7, 0x3, 0x2, 0x1b0, 0x1b2, 0x5, 0x2, 0x1a4, 0x1a4, 
       0x1b3, 0x1b4, 0x1b6, 0x1b8, 0x3, 0x2, 0x1b3, 0x1b4, 0x5, 0x2, 0x21, 
       0x21, 0x24, 0x24, 0x91, 0x91, 0x4, 0x2, 0x21, 0x21, 0x47, 0x47, 0x4, 
       0x2, 0x192, 0x192, 0x196, 0x197, 0x4, 0x2, 0x135, 0x135, 0x138, 0x138, 
       0x4, 0x2, 0xde, 0xde, 0x10c, 0x10c, 0x4, 0x2, 0x76, 0x76, 0xeb, 0xeb, 
       0x5, 0x2, 0x6c, 0x6c, 0xc1, 0xc1, 0xeb, 0xeb, 0x5, 0x2, 0x6c, 0x6c, 
       0xeb, 0xeb, 0x101, 0x101, 0x4, 0x2, 0xe2, 0xe2, 0x143, 0x143, 0x4, 
       0x2, 0xd1, 0xd1, 0xf2, 0xf2, 0x4, 0x2, 0x6e, 0x6e, 0x191, 0x192, 
       0x5, 0x2, 0x57, 0x57, 0x6a, 0x6a, 0x87, 0x87, 0x6, 0x2, 0x6c, 0x6c, 
       0xeb, 0xeb, 0x101, 0x101, 0x132, 0x132, 0x4, 0x2, 0x39, 0x39, 0x77, 
       0x77, 0x5, 0x2, 0xd2, 0xd2, 0x129, 0x129, 0x136, 0x136, 0x9, 0x2, 
       0xb5, 0xb5, 0x105, 0x105, 0x108, 0x108, 0x14a, 0x14b, 0x14f, 0x14f, 
       0x161, 0x161, 0x163, 0x163, 0x3, 0x2, 0xc3, 0xc4, 0x4, 0x2, 0xdf, 
       0xdf, 0xfa, 0xfa, 0x4, 0x2, 0xf8, 0xf8, 0xfb, 0xfb, 0x4, 0x2, 0xc5, 
       0xc5, 0x121, 0x121, 0x3, 0x2, 0x122, 0x123, 0x4, 0x2, 0x26, 0x26, 
       0x46, 0x46, 0x4, 0x2, 0x128, 0x128, 0x138, 0x138, 0x8, 0x2, 0x6, 
       0x6, 0x11, 0x11, 0x1e, 0x1f, 0xb7, 0xb7, 0x162, 0x162, 0x189, 0x18a, 
       0x3, 0x2, 0x196, 0x197, 0x4, 0x2, 0x192, 0x192, 0x196, 0x196, 0x10, 
       0x2, 0x6, 0x6, 0x11, 0x11, 0x1e, 0x1f, 0x7c, 0x7c, 0xa8, 0x108, 0x10a, 
       0x164, 0x166, 0x167, 0x169, 0x16d, 0x170, 0x171, 0x173, 0x173, 0x175, 
       0x181, 0x183, 0x183, 0x185, 0x187, 0x189, 0x18a, 0x3, 0x2, 0x19c, 
       0x1a3, 0x2, 0x113c, 0x2, 0x1c2, 0x3, 0x2, 0x2, 0x2, 0x4, 0x1de, 0x3, 
       0x2, 0x2, 0x2, 0x6, 0x1e2, 0x3, 0x2, 0x2, 0x2, 0x8, 0x1fd, 0x3, 0x2, 
       0x2, 0x2, 0xa, 0x204, 0x3, 0x2, 0x2, 0x2, 0xc, 0x20f, 0x3, 0x2, 0x2, 
       0x2, 0xe, 0x21d, 0x3, 0x2, 0x2, 0x2, 0x10, 0x21f, 0x3, 0x2, 0x2, 
       0x2, 0x12, 0x22d, 0x3, 0x2, 0x2, 0x2, 0x14, 0x231, 0x3, 0x2, 0x2, 
       0x2, 0x16, 0x23f, 0x3, 0x2, 0x2, 0x2, 0x18, 0x241, 0x3, 0x2, 0x2, 
       0x2, 0x1a, 0x248, 0x3, 0x2, 0x2, 0x2, 0x1c, 0x252, 0x3, 0x2, 0x2, 
       0x2, 0x1e, 0x25e, 0x3, 0x2, 0x2, 0x2, 0x20, 0x260, 0x3, 0x2, 0x2, 
       0x2, 0x22, 0x262, 0x3, 0x2, 0x2, 0x2, 0x24, 0x264, 0x3, 0x2, 0x2, 
       0x2, 0x26, 0x283, 0x3, 0x2, 0x2, 0x2, 0x28, 0x294, 0x3, 0x2, 0x2, 
       0x2, 0x2a, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x2c, 0x2d0, 0x3, 0x2, 0x2, 
       0x2, 0x2e, 0x2d2, 0x3, 0x2, 0x2, 0x2, 0x30, 0x2dc, 0x3, 0x2, 0x2, 
       0x2, 0x32, 0x2de, 0x3, 0x2, 0x2, 0x2, 0x34, 0x2e0, 0x3, 0x2, 0x2, 
       0x2, 0x36, 0x2e2, 0x3, 0x2, 0x2, 0x2, 0x38, 0x2e4, 0x3, 0x2, 0x2, 
       0x2, 0x3a, 0x2e6, 0x3, 0x2, 0x2, 0x2, 0x3c, 0x2e8, 0x3, 0x2, 0x2, 
       0x2, 0x3e, 0x2ea, 0x3, 0x2, 0x2, 0x2, 0x40, 0x2f8, 0x3, 0x2, 0x2, 
       0x2, 0x42, 0x310, 0x3, 0x2, 0x2, 0x2, 0x44, 0x33b, 0x3, 0x2, 0x2, 
       0x2, 0x46, 0x372, 0x3, 0x2, 0x2, 0x2, 0x48, 0x3c1, 0x3, 0x2, 0x2, 
       0x2, 0x4a, 0x3ce, 0x3, 0x2, 0x2, 0x2, 0x4c, 0x3d0, 0x3, 0x2, 0x2, 
       0x2, 0x4e, 0x3dd, 0x3, 0x2, 0x2, 0x2, 0x50, 0x411, 0x3, 0x2, 0x2, 
       0x2, 0x52, 0x414, 0x3, 0x2, 0x2, 0x2, 0x54, 0x437, 0x3, 0x2, 0x2, 
       0x2, 0x56, 0x43a, 0x3, 0x2, 0x2, 0x2, 0x58, 0x45b, 0x3, 0x2, 0x2, 
       0x2, 0x5a, 0x45f, 0x3, 0x2, 0x2, 0x2, 0x5c, 0x46b, 0x3, 0x2, 0x2, 
       0x2, 0x5e, 0x46e, 0x3, 0x2, 0x2, 0x2, 0x60, 0x4a3, 0x3, 0x2, 0x2, 
       0x2, 0x62, 0x4bb, 0x3, 0x2, 0x2, 0x2, 0x64, 0x4c6, 0x3, 0x2, 0x2, 
       0x2, 0x66, 0x4fa, 0x3, 0x2, 0x2, 0x2, 0x68, 0x515, 0x3, 0x2, 0x2, 
       0x2, 0x6a, 0x52d, 0x3, 0x2, 0x2, 0x2, 0x6c, 0x54d, 0x3, 0x2, 0x2, 
       0x2, 0x6e, 0x56b, 0x3, 0x2, 0x2, 0x2, 0x70, 0x582, 0x3, 0x2, 0x2, 
       0x2, 0x72, 0x590, 0x3, 0x2, 0x2, 0x2, 0x74, 0x592, 0x3, 0x2, 0x2, 
       0x2, 0x76, 0x5b2, 0x3, 0x2, 0x2, 0x2, 0x78, 0x5c8, 0x3, 0x2, 0x2, 
       0x2, 0x7a, 0x5fd, 0x3, 0x2, 0x2, 0x2, 0x7c, 0x603, 0x3, 0x2, 0x2, 
       0x2, 0x7e, 0x605, 0x3, 0x2, 0x2, 0x2, 0x80, 0x616, 0x3, 0x2, 0x2, 
       0x2, 0x82, 0x627, 0x3, 0x2, 0x2, 0x2, 0x84, 0x646, 0x3, 0x2, 0x2, 
       0x2, 0x86, 0x665, 0x3, 0x2, 0x2, 0x2, 0x88, 0x667, 0x3, 0x2, 0x2, 
       0x2, 0x8a, 0x66e, 0x3, 0x2, 0x2, 0x2, 0x8c, 0x674, 0x3, 0x2, 0x2, 
       0x2, 0x8e, 0x67b, 0x3, 0x2, 0x2, 0x2, 0x90, 0x680, 0x3, 0x2, 0x2, 
       0x2, 0x92, 0x6a4, 0x3, 0x2, 0x2, 0x2, 0x94, 0x6b6, 0x3, 0x2, 0x2, 
       0x2, 0x96, 0x6b8, 0x3, 0x2, 0x2, 0x2, 0x98, 0x6bc, 0x3, 0x2, 0x2, 
       0x2, 0x9a, 0x6c6, 0x3, 0x2, 0x2, 0x2, 0x9c, 0x6c8, 0x3, 0x2, 0x2, 
       0x2, 0x9e, 0x6ca, 0x3, 0x2, 0x2, 0x2, 0xa0, 0x6f3, 0x3, 0x2, 0x2, 
       0x2, 0xa2, 0x746, 0x3, 0x2, 0x2, 0x2, 0xa4, 0x748, 0x3, 0x2, 0x2, 
       0x2, 0xa6, 0x74c, 0x3, 0x2, 0x2, 0x2, 0xa8, 0x750, 0x3, 0x2, 0x2, 
       0x2, 0xaa, 0x755, 0x3, 0x2, 0x2, 0x2, 0xac, 0x75a, 0x3, 0x2, 0x2, 
       0x2, 0xae, 0x76a, 0x3, 0x2, 0x2, 0x2, 0xb0, 0x77b, 0x3, 0x2, 0x2, 
       0x2, 0xb2, 0x77d, 0x3, 0x2, 0x2, 0x2, 0xb4, 0x782, 0x3, 0x2, 0x2, 
       0x2, 0xb6, 0x786, 0x3, 0x2, 0x2, 0x2, 0xb8, 0x78f, 0x3, 0x2, 0x2, 
       0x2, 0xba, 0x794, 0x3, 0x2, 0x2, 0x2, 0xbc, 0x7a0, 0x3, 0x2, 0x2, 
       0x2, 0xbe, 0x7a2, 0x3, 0x2, 0x2, 0x2, 0xc0, 0x7d4, 0x3, 0x2, 0x2, 
       0x2, 0xc2, 0x7f7, 0x3, 0x2, 0x2, 0x2, 0xc4, 0x832, 0x3, 0x2, 0x2, 
       0x2, 0xc6, 0x840, 0x3, 0x2, 0x2, 0x2, 0xc8, 0x849, 0x3, 0x2, 0x2, 
       0x2, 0xca, 0x872, 0x3, 0x2, 0x2, 0x2, 0xcc, 0x87d, 0x3, 0x2, 0x2, 
       0x2, 0xce, 0x87f, 0x3, 0x2, 0x2, 0x2, 0xd0, 0x8c9, 0x3, 0x2, 0x2, 
       0x2, 0xd2, 0x8cd, 0x3, 0x2, 0x2, 0x2, 0xd4, 0x8d8, 0x3, 0x2, 0x2, 
       0x2, 0xd6, 0x8ea, 0x3, 0x2, 0x2, 0x2, 0xd8, 0x8f3, 0x3, 0x2, 0x2, 
       0x2, 0xda, 0x90e, 0x3, 0x2, 0x2, 0x2, 0xdc, 0x914, 0x3, 0x2, 0x2, 
       0x2, 0xde, 0x91e, 0x3, 0x2, 0x2, 0x2, 0xe0, 0x928, 0x3, 0x2, 0x2, 
       0x2, 0xe2, 0x92a, 0x3, 0x2, 0x2, 0x2, 0xe4, 0x92c, 0x3, 0x2, 0x2, 
       0x2, 0xe6, 0x935, 0x3, 0x2, 0x2, 0x2, 0xe8, 0x95a, 0x3, 0x2, 0x2, 
       0x2, 0xea, 0x96c, 0x3, 0x2, 0x2, 0x2, 0xec, 0x96e, 0x3, 0x2, 0x2, 
       0x2, 0xee, 0x9c3, 0x3, 0x2, 0x2, 0x2, 0xf0, 0x9d5, 0x3, 0x2, 0x2, 
       0x2, 0xf2, 0x9dd, 0x3, 0x2, 0x2, 0x2, 0xf4, 0x9e6, 0x3, 0x2, 0x2, 
       0x2, 0xf6, 0xa0d, 0x3, 0x2, 0x2, 0x2, 0xf8, 0xa1d, 0x3, 0x2, 0x2, 
       0x2, 0xfa, 0xa24, 0x3, 0x2, 0x2, 0x2, 0xfc, 0xa26, 0x3, 0x2, 0x2, 
       0x2, 0xfe, 0xa3d, 0x3, 0x2, 0x2, 0x2, 0x100, 0xa42, 0x3, 0x2, 0x2, 
       0x2, 0x102, 0xa44, 0x3, 0x2, 0x2, 0x2, 0x104, 0xa7a, 0x3, 0x2, 0x2, 
       0x2, 0x106, 0xa7c, 0x3, 0x2, 0x2, 0x2, 0x108, 0xa85, 0x3, 0x2, 0x2, 
       0x2, 0x10a, 0xa8d, 0x3, 0x2, 0x2, 0x2, 0x10c, 0xaa1, 0x3, 0x2, 0x2, 
       0x2, 0x10e, 0xaa9, 0x3, 0x2, 0x2, 0x2, 0x110, 0xabe, 0x3, 0x2, 0x2, 
       0x2, 0x112, 0xac8, 0x3, 0x2, 0x2, 0x2, 0x114, 0xad4, 0x3, 0x2, 0x2, 
       0x2, 0x116, 0xad6, 0x3, 0x2, 0x2, 0x2, 0x118, 0xae3, 0x3, 0x2, 0x2, 
       0x2, 0x11a, 0xaf5, 0x3, 0x2, 0x2, 0x2, 0x11c, 0xb2c, 0x3, 0x2, 0x2, 
       0x2, 0x11e, 0xb2e, 0x3, 0x2, 0x2, 0x2, 0x120, 0xb36, 0x3, 0x2, 0x2, 
       0x2, 0x122, 0xb3d, 0x3, 0x2, 0x2, 0x2, 0x124, 0xb3f, 0x3, 0x2, 0x2, 
       0x2, 0x126, 0xb47, 0x3, 0x2, 0x2, 0x2, 0x128, 0xb56, 0x3, 0x2, 0x2, 
       0x2, 0x12a, 0xb5f, 0x3, 0x2, 0x2, 0x2, 0x12c, 0xb69, 0x3, 0x2, 0x2, 
       0x2, 0x12e, 0xb6d, 0x3, 0x2, 0x2, 0x2, 0x130, 0xb71, 0x3, 0x2, 0x2, 
       0x2, 0x132, 0xb75, 0x3, 0x2, 0x2, 0x2, 0x134, 0xb79, 0x3, 0x2, 0x2, 
       0x2, 0x136, 0xb81, 0x3, 0x2, 0x2, 0x2, 0x138, 0xb8b, 0x3, 0x2, 0x2, 
       0x2, 0x13a, 0xb93, 0x3, 0x2, 0x2, 0x2, 0x13c, 0xb97, 0x3, 0x2, 0x2, 
       0x2, 0x13e, 0xba5, 0x3, 0x2, 0x2, 0x2, 0x140, 0xbb3, 0x3, 0x2, 0x2, 
       0x2, 0x142, 0xbb8, 0x3, 0x2, 0x2, 0x2, 0x144, 0xc52, 0x3, 0x2, 0x2, 
       0x2, 0x146, 0xc5a, 0x3, 0x2, 0x2, 0x2, 0x148, 0xc62, 0x3, 0x2, 0x2, 
       0x2, 0x14a, 0xc67, 0x3, 0x2, 0x2, 0x2, 0x14c, 0xc6d, 0x3, 0x2, 0x2, 
       0x2, 0x14e, 0xc72, 0x3, 0x2, 0x2, 0x2, 0x150, 0xc76, 0x3, 0x2, 0x2, 
       0x2, 0x152, 0xc7b, 0x3, 0x2, 0x2, 0x2, 0x154, 0xc8a, 0x3, 0x2, 0x2, 
       0x2, 0x156, 0xc99, 0x3, 0x2, 0x2, 0x2, 0x158, 0xcd0, 0x3, 0x2, 0x2, 
       0x2, 0x15a, 0xcd2, 0x3, 0x2, 0x2, 0x2, 0x15c, 0xcdf, 0x3, 0x2, 0x2, 
       0x2, 0x15e, 0xce1, 0x3, 0x2, 0x2, 0x2, 0x160, 0xcef, 0x3, 0x2, 0x2, 
       0x2, 0x162, 0xd01, 0x3, 0x2, 0x2, 0x2, 0x164, 0xd23, 0x3, 0x2, 0x2, 
       0x2, 0x166, 0xd5d, 0x3, 0x2, 0x2, 0x2, 0x168, 0xd60, 0x3, 0x2, 0x2, 
       0x2, 0x16a, 0xd64, 0x3, 0x2, 0x2, 0x2, 0x16c, 0xd73, 0x3, 0x2, 0x2, 
       0x2, 0x16e, 0xd7c, 0x3, 0x2, 0x2, 0x2, 0x170, 0xd80, 0x3, 0x2, 0x2, 
       0x2, 0x172, 0xd88, 0x3, 0x2, 0x2, 0x2, 0x174, 0xd8e, 0x3, 0x2, 0x2, 
       0x2, 0x176, 0xda1, 0x3, 0x2, 0x2, 0x2, 0x178, 0xdaa, 0x3, 0x2, 0x2, 
       0x2, 0x17a, 0xdb1, 0x3, 0x2, 0x2, 0x2, 0x17c, 0xdc4, 0x3, 0x2, 0x2, 
       0x2, 0x17e, 0xde3, 0x3, 0x2, 0x2, 0x2, 0x180, 0xde8, 0x3, 0x2, 0x2, 
       0x2, 0x182, 0xdef, 0x3, 0x2, 0x2, 0x2, 0x184, 0xdfd, 0x3, 0x2, 0x2, 
       0x2, 0x186, 0xe0d, 0x3, 0x2, 0x2, 0x2, 0x188, 0xe11, 0x3, 0x2, 0x2, 
       0x2, 0x18a, 0xe32, 0x3, 0x2, 0x2, 0x2, 0x18c, 0xe34, 0x3, 0x2, 0x2, 
       0x2, 0x18e, 0xe42, 0x3, 0x2, 0x2, 0x2, 0x190, 0xe50, 0x3, 0x2, 0x2, 
       0x2, 0x192, 0xe55, 0x3, 0x2, 0x2, 0x2, 0x194, 0xe5f, 0x3, 0x2, 0x2, 
       0x2, 0x196, 0xe61, 0x3, 0x2, 0x2, 0x2, 0x198, 0xe64, 0x3, 0x2, 0x2, 
       0x2, 0x19a, 0xe73, 0x3, 0x2, 0x2, 0x2, 0x19c, 0xe95, 0x3, 0x2, 0x2, 
       0x2, 0x19e, 0xeb5, 0x3, 0x2, 0x2, 0x2, 0x1a0, 0xeba, 0x3, 0x2, 0x2, 
       0x2, 0x1a2, 0xecb, 0x3, 0x2, 0x2, 0x2, 0x1a4, 0xecd, 0x3, 0x2, 0x2, 
       0x2, 0x1a6, 0xecf, 0x3, 0x2, 0x2, 0x2, 0x1a8, 0xed5, 0x3, 0x2, 0x2, 
       0x2, 0x1aa, 0xed7, 0x3, 0x2, 0x2, 0x2, 0x1ac, 0xedb, 0x3, 0x2, 0x2, 
       0x2, 0x1ae, 0xeec, 0x3, 0x2, 0x2, 0x2, 0x1b0, 0xeee, 0x3, 0x2, 0x2, 
       0x2, 0x1b2, 0x1b4, 0x5, 0x4, 0x3, 0x2, 0x1b3, 0x1b2, 0x3, 0x2, 0x2, 
       0x2, 0x1b4, 0x1b7, 0x3, 0x2, 0x2, 0x2, 0x1b5, 0x1b3, 0x3, 0x2, 0x2, 
       0x2, 0x1b5, 0x1b6, 0x3, 0x2, 0x2, 0x2, 0x1b6, 0x1b8, 0x3, 0x2, 0x2, 
       0x2, 0x1b7, 0x1b5, 0x3, 0x2, 0x2, 0x2, 0x1b8, 0x1c3, 0x7, 0x2, 0x2, 
       0x3, 0x1b9, 0x1bd, 0x5, 0x90, 0x49, 0x2, 0x1ba, 0x1bc, 0x5, 0xa4, 
       0x53, 0x2, 0x1bb, 0x1ba, 0x3, 0x2, 0x2, 0x2, 0x1bc, 0x1bf, 0x3, 0x2, 
       0x2, 0x2, 0x1bd, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0x1bd, 0x1be, 0x3, 0x2, 
       0x2, 0x2, 0x1be, 0x1c0, 0x3, 0x2, 0x2, 0x2, 0x1bf, 0x1bd, 0x3, 0x2, 
       0x2, 0x2, 0x1c0, 0x1c1, 0x7, 0x2, 0x2, 0x3, 0x1c1, 0x1c3, 0x3, 0x2, 
       0x2, 0x2, 0x1c2, 0x1b5, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0x1b9, 0x3, 0x2, 
       0x2, 0x2, 0x1c3, 0x3, 0x3, 0x2, 0x2, 0x2, 0x1c4, 0x1df, 0x5, 0xa4, 
       0x53, 0x2, 0x1c5, 0x1c7, 0x5, 0x90, 0x49, 0x2, 0x1c6, 0x1c5, 0x3, 
       0x2, 0x2, 0x2, 0x1c6, 0x1c7, 0x3, 0x2, 0x2, 0x2, 0x1c7, 0x1ce, 0x3, 
       0x2, 0x2, 0x2, 0x1c8, 0x1cf, 0x5, 0xa4, 0x53, 0x2, 0x1c9, 0x1cb, 
       0x5, 0x8, 0x5, 0x2, 0x1ca, 0x1c9, 0x3, 0x2, 0x2, 0x2, 0x1cb, 0x1cc, 
       0x3, 0x2, 0x2, 0x2, 0x1cc, 0x1ca, 0x3, 0x2, 0x2, 0x2, 0x1cc, 0x1cd, 
       0x3, 0x2, 0x2, 0x2, 0x1cd, 0x1cf, 0x3, 0x2, 0x2, 0x2, 0x1ce, 0x1c8, 
       0x3, 0x2, 0x2, 0x2, 0x1ce, 0x1ca, 0x3, 0x2, 0x2, 0x2, 0x1cf, 0x1d3, 
       0x3, 0x2, 0x2, 0x2, 0x1d0, 0x1d2, 0x5, 0xa6, 0x54, 0x2, 0x1d1, 0x1d0, 
       0x3, 0x2, 0x2, 0x2, 0x1d2, 0x1d5, 0x3, 0x2, 0x2, 0x2, 0x1d3, 0x1d1, 
       0x3, 0x2, 0x2, 0x2, 0x1d3, 0x1d4, 0x3, 0x2, 0x2, 0x2, 0x1d4, 0x1df, 
       0x3, 0x2, 0x2, 0x2, 0x1d5, 0x1d3, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0x1da, 
       0x5, 0x6, 0x4, 0x2, 0x1d7, 0x1d9, 0x5, 0xa6, 0x54, 0x2, 0x1d8, 0x1d7, 
       0x3, 0x2, 0x2, 0x2, 0x1d9, 0x1dc, 0x3, 0x2, 0x2, 0x2, 0x1da, 0x1d8, 
       0x3, 0x2, 0x2, 0x2, 0x1da, 0x1db, 0x3, 0x2, 0x2, 0x2, 0x1db, 0x1df, 
       0x3, 0x2, 0x2, 0x2, 0x1dc, 0x1da, 0x3, 0x2, 0x2, 0x2, 0x1dd, 0x1df, 
       0x5, 0xa6, 0x54, 0x2, 0x1de, 0x1c4, 0x3, 0x2, 0x2, 0x2, 0x1de, 0x1c6, 
       0x3, 0x2, 0x2, 0x2, 0x1de, 0x1d6, 0x3, 0x2, 0x2, 0x2, 0x1de, 0x1dd, 
       0x3, 0x2, 0x2, 0x2, 0x1df, 0x5, 0x3, 0x2, 0x2, 0x2, 0x1e0, 0x1e3, 
       0x5, 0x66, 0x34, 0x2, 0x1e1, 0x1e3, 0x5, 0x64, 0x33, 0x2, 0x1e2, 
       0x1e0, 0x3, 0x2, 0x2, 0x2, 0x1e2, 0x1e1, 0x3, 0x2, 0x2, 0x2, 0x1e3, 
       0x7, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1e6, 0x5, 0xa, 0x6, 0x2, 0x1e5, 
       0x1e7, 0x7, 0x1ad, 0x2, 0x2, 0x1e6, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1e6, 
       0x1e7, 0x3, 0x2, 0x2, 0x2, 0x1e7, 0x1fe, 0x3, 0x2, 0x2, 0x2, 0x1e8, 
       0x1ea, 0x5, 0xe, 0x8, 0x2, 0x1e9, 0x1eb, 0x7, 0x1ad, 0x2, 0x2, 0x1ea, 
       0x1e9, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0x1eb, 
       0x1fe, 0x3, 0x2, 0x2, 0x2, 0x1ec, 0x1ee, 0x5, 0x30, 0x19, 0x2, 0x1ed, 
       0x1ef, 0x7, 0x1ad, 0x2, 0x2, 0x1ee, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x1ee, 
       0x1ef, 0x3, 0x2, 0x2, 0x2, 0x1ef, 0x1fe, 0x3, 0x2, 0x2, 0x2, 0x1f0, 
       0x1f2, 0x5, 0xc, 0x7, 0x2, 0x1f1, 0x1f3, 0x7, 0x1ad, 0x2, 0x2, 0x1f2, 
       0x1f1, 0x3, 0x2, 0x2, 0x2, 0x1f2, 0x1f3, 0x3, 0x2, 0x2, 0x2, 0x1f3, 
       0x1fe, 0x3, 0x2, 0x2, 0x2, 0x1f4, 0x1f6, 0x5, 0xac, 0x57, 0x2, 0x1f5, 
       0x1f7, 0x7, 0x1ad, 0x2, 0x2, 0x1f6, 0x1f5, 0x3, 0x2, 0x2, 0x2, 0x1f6, 
       0x1f7, 0x3, 0x2, 0x2, 0x2, 0x1f7, 0x1fe, 0x3, 0x2, 0x2, 0x2, 0x1f8, 
       0x1fa, 0x5, 0xae, 0x58, 0x2, 0x1f9, 0x1fb, 0x7, 0x1ad, 0x2, 0x2, 
       0x1fa, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0x1fa, 0x1fb, 0x3, 0x2, 0x2, 0x2, 
       0x1fb, 0x1fe, 0x3, 0x2, 0x2, 0x2, 0x1fc, 0x1fe, 0x7, 0x1ad, 0x2, 
       0x2, 0x1fd, 0x1e4, 0x3, 0x2, 0x2, 0x2, 0x1fd, 0x1e8, 0x3, 0x2, 0x2, 
       0x2, 0x1fd, 0x1ec, 0x3, 0x2, 0x2, 0x2, 0x1fd, 0x1f0, 0x3, 0x2, 0x2, 
       0x2, 0x1fd, 0x1f4, 0x3, 0x2, 0x2, 0x2, 0x1fd, 0x1f8, 0x3, 0x2, 0x2, 
       0x2, 0x1fd, 0x1fc, 0x3, 0x2, 0x2, 0x2, 0x1fe, 0x9, 0x3, 0x2, 0x2, 
       0x2, 0x1ff, 0x205, 0x5, 0x46, 0x24, 0x2, 0x200, 0x205, 0x5, 0x4e, 
       0x28, 0x2, 0x201, 0x205, 0x5, 0x52, 0x2a, 0x2, 0x202, 0x205, 0x5, 
       0x58, 0x2d, 0x2, 0x203, 0x205, 0x5, 0x5e, 0x30, 0x2, 0x204, 0x1ff, 
       0x3, 0x2, 0x2, 0x2, 0x204, 0x200, 0x3, 0x2, 0x2, 0x2, 0x204, 0x201, 
       0x3, 0x2, 0x2, 0x2, 0x204, 0x202, 0x3, 0x2, 0x2, 0x2, 0x204, 0x203, 
       0x3, 0x2, 0x2, 0x2, 0x205, 0xb, 0x3, 0x2, 0x2, 0x2, 0x206, 0x210, 
       0x5, 0x42, 0x22, 0x2, 0x207, 0x210, 0x5, 0x78, 0x3d, 0x2, 0x208, 
       0x210, 0x5, 0x44, 0x23, 0x2, 0x209, 0x210, 0x5, 0x74, 0x3b, 0x2, 
       0x20a, 0x210, 0x5, 0x80, 0x41, 0x2, 0x20b, 0x210, 0x5, 0x7e, 0x40, 
       0x2, 0x20c, 0x210, 0x5, 0x82, 0x42, 0x2, 0x20d, 0x210, 0x5, 0x3e, 
       0x20, 0x2, 0x20e, 0x210, 0x5, 0x40, 0x21, 0x2, 0x20f, 0x206, 0x3, 
       0x2, 0x2, 0x2, 0x20f, 0x207, 0x3, 0x2, 0x2, 0x2, 0x20f, 0x208, 0x3, 
       0x2, 0x2, 0x2, 0x20f, 0x209, 0x3, 0x2, 0x2, 0x2, 0x20f, 0x20a, 0x3, 
       0x2, 0x2, 0x2, 0x20f, 0x20b, 0x3, 0x2, 0x2, 0x2, 0x20f, 0x20c, 0x3, 
       0x2, 0x2, 0x2, 0x20f, 0x20d, 0x3, 0x2, 0x2, 0x2, 0x20f, 0x20e, 0x3, 
       0x2, 0x2, 0x2, 0x210, 0xd, 0x3, 0x2, 0x2, 0x2, 0x211, 0x21e, 0x5, 
       0x10, 0x9, 0x2, 0x212, 0x21e, 0x5, 0x12, 0xa, 0x2, 0x213, 0x21e, 
       0x5, 0x14, 0xb, 0x2, 0x214, 0x21e, 0x5, 0x16, 0xc, 0x2, 0x215, 0x21e, 
       0x5, 0x1a, 0xe, 0x2, 0x216, 0x21e, 0x5, 0x18, 0xd, 0x2, 0x217, 0x21e, 
       0x5, 0x1c, 0xf, 0x2, 0x218, 0x21e, 0x5, 0x24, 0x13, 0x2, 0x219, 0x21e, 
       0x5, 0x26, 0x14, 0x2, 0x21a, 0x21e, 0x5, 0x28, 0x15, 0x2, 0x21b, 
       0x21e, 0x5, 0x2a, 0x16, 0x2, 0x21c, 0x21e, 0x5, 0x2c, 0x17, 0x2, 
       0x21d, 0x211, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x212, 0x3, 0x2, 0x2, 0x2, 
       0x21d, 0x213, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x214, 0x3, 0x2, 0x2, 0x2, 
       0x21d, 0x215, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x216, 0x3, 0x2, 0x2, 0x2, 
       0x21d, 0x217, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x218, 0x3, 0x2, 0x2, 0x2, 
       0x21d, 0x219, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x21a, 0x3, 0x2, 0x2, 0x2, 
       0x21d, 0x21b, 0x3, 0x2, 0x2, 0x2, 0x21d, 0x21c, 0x3, 0x2, 0x2, 0x2, 
       0x21e, 0xf, 0x3, 0x2, 0x2, 0x2, 0x21f, 0x221, 0x7, 0x29, 0x2, 0x2, 
       0x220, 0x222, 0x7, 0x1ad, 0x2, 0x2, 0x221, 0x220, 0x3, 0x2, 0x2, 
       0x2, 0x221, 0x222, 0x3, 0x2, 0x2, 0x2, 0x222, 0x226, 0x3, 0x2, 0x2, 
       0x2, 0x223, 0x225, 0x5, 0x8, 0x5, 0x2, 0x224, 0x223, 0x3, 0x2, 0x2, 
       0x2, 0x225, 0x228, 0x3, 0x2, 0x2, 0x2, 0x226, 0x224, 0x3, 0x2, 0x2, 
       0x2, 0x226, 0x227, 0x3, 0x2, 0x2, 0x2, 0x227, 0x229, 0x3, 0x2, 0x2, 
       0x2, 0x228, 0x226, 0x3, 0x2, 0x2, 0x2, 0x229, 0x22b, 0x7, 0x4e, 0x2, 
       0x2, 0x22a, 0x22c, 0x7, 0x1ad, 0x2, 0x2, 0x22b, 0x22a, 0x3, 0x2, 
       0x2, 0x2, 0x22b, 0x22c, 0x3, 0x2, 0x2, 0x2, 0x22c, 0x11, 0x3, 0x2, 
       0x2, 0x2, 0x22d, 0x22f, 0x7, 0x2b, 0x2, 0x2, 0x22e, 0x230, 0x7, 0x1ad, 
       0x2, 0x2, 0x22f, 0x22e, 0x3, 0x2, 0x2, 0x2, 0x22f, 0x230, 0x3, 0x2, 
       0x2, 0x2, 0x230, 0x13, 0x3, 0x2, 0x2, 0x2, 0x231, 0x233, 0x7, 0x36, 
       0x2, 0x2, 0x232, 0x234, 0x7, 0x1ad, 0x2, 0x2, 0x233, 0x232, 0x3, 
       0x2, 0x2, 0x2, 0x233, 0x234, 0x3, 0x2, 0x2, 0x2, 0x234, 0x15, 0x3, 
       0x2, 0x2, 0x2, 0x235, 0x236, 0x7, 0x59, 0x2, 0x2, 0x236, 0x238, 0x5, 
       0x1a8, 0xd5, 0x2, 0x237, 0x239, 0x7, 0x1ad, 0x2, 0x2, 0x238, 0x237, 
       0x3, 0x2, 0x2, 0x2, 0x238, 0x239, 0x3, 0x2, 0x2, 0x2, 0x239, 0x240, 
       0x3, 0x2, 0x2, 0x2, 0x23a, 0x23b, 0x5, 0x1a8, 0xd5, 0x2, 0x23b, 0x23d, 
       0x7, 0x1ae, 0x2, 0x2, 0x23c, 0x23e, 0x7, 0x1ad, 0x2, 0x2, 0x23d, 
       0x23c, 0x3, 0x2, 0x2, 0x2, 0x23d, 0x23e, 0x3, 0x2, 0x2, 0x2, 0x23e, 
       0x240, 0x3, 0x2, 0x2, 0x2, 0x23f, 0x235, 0x3, 0x2, 0x2, 0x2, 0x23f, 
       0x23a, 0x3, 0x2, 0x2, 0x2, 0x240, 0x17, 0x3, 0x2, 0x2, 0x2, 0x241, 
       0x243, 0x7, 0x85, 0x2, 0x2, 0x242, 0x244, 0x5, 0xd4, 0x6b, 0x2, 0x243, 
       0x242, 0x3, 0x2, 0x2, 0x2, 0x243, 0x244, 0x3, 0x2, 0x2, 0x2, 0x244, 
       0x246, 0x3, 0x2, 0x2, 0x2, 0x245, 0x247, 0x7, 0x1ad, 0x2, 0x2, 0x246, 
       0x245, 0x3, 0x2, 0x2, 0x2, 0x246, 0x247, 0x3, 0x2, 0x2, 0x2, 0x247, 
       0x19, 0x3, 0x2, 0x2, 0x2, 0x248, 0x249, 0x7, 0x5f, 0x2, 0x2, 0x249, 
       0x24a, 0x5, 0xec, 0x77, 0x2, 0x24a, 0x24d, 0x5, 0x8, 0x5, 0x2, 0x24b, 
       0x24c, 0x7, 0x4d, 0x2, 0x2, 0x24c, 0x24e, 0x5, 0x8, 0x5, 0x2, 0x24d, 
       0x24b, 0x3, 0x2, 0x2, 0x2, 0x24d, 0x24e, 0x3, 0x2, 0x2, 0x2, 0x24e, 
       0x250, 0x3, 0x2, 0x2, 0x2, 0x24f, 0x251, 0x7, 0x1ad, 0x2, 0x2, 0x250, 
       0x24f, 0x3, 0x2, 0x2, 0x2, 0x250, 0x251, 0x3, 0x2, 0x2, 0x2, 0x251, 
       0x1b, 0x3, 0x2, 0x2, 0x2, 0x252, 0x259, 0x7, 0x151, 0x2, 0x2, 0x253, 
       0x254, 0x5, 0x1e, 0x10, 0x2, 0x254, 0x255, 0x7, 0x1ac, 0x2, 0x2, 
       0x255, 0x256, 0x5, 0x20, 0x11, 0x2, 0x256, 0x257, 0x7, 0x1ac, 0x2, 
       0x2, 0x257, 0x258, 0x5, 0x22, 0x12, 0x2, 0x258, 0x25a, 0x3, 0x2, 
       0x2, 0x2, 0x259, 0x253, 0x3, 0x2, 0x2, 0x2, 0x259, 0x25a, 0x3, 0x2, 
       0x2, 0x2, 0x25a, 0x25c, 0x3, 0x2, 0x2, 0x2, 0x25b, 0x25d, 0x7, 0x1ad, 
       0x2, 0x2, 0x25c, 0x25b, 0x3, 0x2, 0x2, 0x2, 0x25c, 0x25d, 0x3, 0x2, 
       0x2, 0x2, 0x25d, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x25f, 0x9, 0x2, 
       0x2, 0x2, 0x25f, 0x1f, 0x3, 0x2, 0x2, 0x2, 0x260, 0x261, 0x9, 0x3, 
       0x2, 0x2, 0x261, 0x21, 0x3, 0x2, 0x2, 0x2, 0x262, 0x263, 0x9, 0x2, 
       0x2, 0x2, 0x263, 0x23, 0x3, 0x2, 0x2, 0x2, 0x264, 0x265, 0x7, 0x29, 
       0x2, 0x2, 0x265, 0x267, 0x7, 0x158, 0x2, 0x2, 0x266, 0x268, 0x7, 
       0x1ad, 0x2, 0x2, 0x267, 0x266, 0x3, 0x2, 0x2, 0x2, 0x267, 0x268, 
       0x3, 0x2, 0x2, 0x2, 0x268, 0x26a, 0x3, 0x2, 0x2, 0x2, 0x269, 0x26b, 
       0x5, 0x8, 0x5, 0x2, 0x26a, 0x269, 0x3, 0x2, 0x2, 0x2, 0x26b, 0x26c, 
       0x3, 0x2, 0x2, 0x2, 0x26c, 0x26a, 0x3, 0x2, 0x2, 0x2, 0x26c, 0x26d, 
       0x3, 0x2, 0x2, 0x2, 0x26d, 0x26e, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x26f, 
       0x7, 0x4e, 0x2, 0x2, 0x26f, 0x271, 0x7, 0x158, 0x2, 0x2, 0x270, 0x272, 
       0x7, 0x1ad, 0x2, 0x2, 0x271, 0x270, 0x3, 0x2, 0x2, 0x2, 0x271, 0x272, 
       0x3, 0x2, 0x2, 0x2, 0x272, 0x273, 0x3, 0x2, 0x2, 0x2, 0x273, 0x274, 
       0x7, 0x29, 0x2, 0x2, 0x274, 0x276, 0x7, 0xbd, 0x2, 0x2, 0x275, 0x277, 
       0x7, 0x1ad, 0x2, 0x2, 0x276, 0x275, 0x3, 0x2, 0x2, 0x2, 0x276, 0x277, 
       0x3, 0x2, 0x2, 0x2, 0x277, 0x27b, 0x3, 0x2, 0x2, 0x2, 0x278, 0x27a, 
       0x5, 0x8, 0x5, 0x2, 0x279, 0x278, 0x3, 0x2, 0x2, 0x2, 0x27a, 0x27d, 
       0x3, 0x2, 0x2, 0x2, 0x27b, 0x279, 0x3, 0x2, 0x2, 0x2, 0x27b, 0x27c, 
       0x3, 0x2, 0x2, 0x2, 0x27c, 0x27e, 0x3, 0x2, 0x2, 0x2, 0x27d, 0x27b, 
       0x3, 0x2, 0x2, 0x2, 0x27e, 0x27f, 0x7, 0x4e, 0x2, 0x2, 0x27f, 0x281, 
       0x7, 0xbd, 0x2, 0x2, 0x280, 0x282, 0x7, 0x1ad, 0x2, 0x2, 0x281, 0x280, 
       0x3, 0x2, 0x2, 0x2, 0x281, 0x282, 0x3, 0x2, 0x2, 0x2, 0x282, 0x25, 
       0x3, 0x2, 0x2, 0x2, 0x283, 0x285, 0x7, 0x165, 0x2, 0x2, 0x284, 0x286, 
       0x5, 0x56, 0x2c, 0x2, 0x285, 0x284, 0x3, 0x2, 0x2, 0x2, 0x285, 0x286, 
       0x3, 0x2, 0x2, 0x2, 0x286, 0x288, 0x3, 0x2, 0x2, 0x2, 0x287, 0x289, 
       0x7, 0x1ac, 0x2, 0x2, 0x288, 0x287, 0x3, 0x2, 0x2, 0x2, 0x288, 0x289, 
       0x3, 0x2, 0x2, 0x2, 0x289, 0x28c, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x28b, 
       0x9, 0x4, 0x2, 0x2, 0x28b, 0x28d, 0x5, 0x5c, 0x2f, 0x2, 0x28c, 0x28a, 
       0x3, 0x2, 0x2, 0x2, 0x28c, 0x28d, 0x3, 0x2, 0x2, 0x2, 0x28d, 0x28f, 
       0x3, 0x2, 0x2, 0x2, 0x28e, 0x290, 0x5, 0xd4, 0x6b, 0x2, 0x28f, 0x28e, 
       0x3, 0x2, 0x2, 0x2, 0x28f, 0x290, 0x3, 0x2, 0x2, 0x2, 0x290, 0x292, 
       0x3, 0x2, 0x2, 0x2, 0x291, 0x293, 0x7, 0x1ad, 0x2, 0x2, 0x292, 0x291, 
       0x3, 0x2, 0x2, 0x2, 0x292, 0x293, 0x3, 0x2, 0x2, 0x2, 0x293, 0x27, 
       0x3, 0x2, 0x2, 0x2, 0x294, 0x295, 0x7, 0xa4, 0x2, 0x2, 0x295, 0x29f, 
       0x5, 0xec, 0x77, 0x2, 0x296, 0x2a0, 0x5, 0x8, 0x5, 0x2, 0x297, 0x299, 
       0x7, 0x2b, 0x2, 0x2, 0x298, 0x29a, 0x7, 0x1ad, 0x2, 0x2, 0x299, 0x298, 
       0x3, 0x2, 0x2, 0x2, 0x299, 0x29a, 0x3, 0x2, 0x2, 0x2, 0x29a, 0x2a0, 
       0x3, 0x2, 0x2, 0x2, 0x29b, 0x29d, 0x7, 0x36, 0x2, 0x2, 0x29c, 0x29e, 
       0x7, 0x1ad, 0x2, 0x2, 0x29d, 0x29c, 0x3, 0x2, 0x2, 0x2, 0x29d, 0x29e, 
       0x3, 0x2, 0x2, 0x2, 0x29e, 0x2a0, 0x3, 0x2, 0x2, 0x2, 0x29f, 0x296, 
       0x3, 0x2, 0x2, 0x2, 0x29f, 0x297, 0x3, 0x2, 0x2, 0x2, 0x29f, 0x29b, 
       0x3, 0x2, 0x2, 0x2, 0x2a0, 0x29, 0x3, 0x2, 0x2, 0x2, 0x2a1, 0x2a4, 
       0x7, 0x7e, 0x2, 0x2, 0x2a2, 0x2a5, 0x5, 0xd4, 0x6b, 0x2, 0x2a3, 0x2a5, 
       0x7, 0x18e, 0x2, 0x2, 0x2a4, 0x2a2, 0x3, 0x2, 0x2, 0x2, 0x2a4, 0x2a3, 
       0x3, 0x2, 0x2, 0x2, 0x2a5, 0x2aa, 0x3, 0x2, 0x2, 0x2, 0x2a6, 0x2a7, 
       0x7, 0x1ac, 0x2, 0x2, 0x2a7, 0x2a9, 0x7, 0x191, 0x2, 0x2, 0x2a8, 
       0x2a6, 0x3, 0x2, 0x2, 0x2, 0x2a9, 0x2ac, 0x3, 0x2, 0x2, 0x2, 0x2aa, 
       0x2a8, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x2ab, 0x3, 0x2, 0x2, 0x2, 0x2ab, 
       0x2ae, 0x3, 0x2, 0x2, 0x2, 0x2ac, 0x2aa, 0x3, 0x2, 0x2, 0x2, 0x2ad, 
       0x2af, 0x7, 0x1ad, 0x2, 0x2, 0x2ae, 0x2ad, 0x3, 0x2, 0x2, 0x2, 0x2ae, 
       0x2af, 0x3, 0x2, 0x2, 0x2, 0x2af, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x2b0, 
       0x2b1, 0x7, 0x81, 0x2, 0x2, 0x2b1, 0x2b2, 0x7, 0x1aa, 0x2, 0x2, 0x2b2, 
       0x2b3, 0x9, 0x5, 0x2, 0x2, 0x2b3, 0x2b4, 0x7, 0x1ac, 0x2, 0x2, 0x2b4, 
       0x2b5, 0x5, 0xd2, 0x6a, 0x2, 0x2b5, 0x2b6, 0x7, 0x1ac, 0x2, 0x2, 
       0x2b6, 0x2bb, 0x5, 0xd2, 0x6a, 0x2, 0x2b7, 0x2b8, 0x7, 0x1ac, 0x2, 
       0x2, 0x2b8, 0x2ba, 0x5, 0xd2, 0x6a, 0x2, 0x2b9, 0x2b7, 0x3, 0x2, 
       0x2, 0x2, 0x2ba, 0x2bd, 0x3, 0x2, 0x2, 0x2, 0x2bb, 0x2b9, 0x3, 0x2, 
       0x2, 0x2, 0x2bb, 0x2bc, 0x3, 0x2, 0x2, 0x2, 0x2bc, 0x2be, 0x3, 0x2, 
       0x2, 0x2, 0x2bd, 0x2bb, 0x3, 0x2, 0x2, 0x2, 0x2be, 0x2c1, 0x7, 0x1ab, 
       0x2, 0x2, 0x2bf, 0x2c0, 0x7, 0xa5, 0x2, 0x2, 0x2c0, 0x2c2, 0x9, 0x6, 
       0x2, 0x2, 0x2c1, 0x2bf, 0x3, 0x2, 0x2, 0x2, 0x2c1, 0x2c2, 0x3, 0x2, 
       0x2, 0x2, 0x2c2, 0x2c4, 0x3, 0x2, 0x2, 0x2, 0x2c3, 0x2c5, 0x7, 0x1ad, 
       0x2, 0x2, 0x2c4, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0x2c4, 0x2c5, 0x3, 0x2, 
       0x2, 0x2, 0x2c5, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x2c7, 0x7, 0x81, 
       0x2, 0x2, 0x2c7, 0x2c8, 0x7, 0x192, 0x2, 0x2, 0x2c8, 0x2cd, 0x9, 
       0x7, 0x2, 0x2, 0x2c9, 0x2ca, 0x7, 0x1ac, 0x2, 0x2, 0x2ca, 0x2cc, 
       0x9, 0x5, 0x2, 0x2, 0x2cb, 0x2c9, 0x3, 0x2, 0x2, 0x2, 0x2cc, 0x2cf, 
       0x3, 0x2, 0x2, 0x2, 0x2cd, 0x2cb, 0x3, 0x2, 0x2, 0x2, 0x2cd, 0x2ce, 
       0x3, 0x2, 0x2, 0x2, 0x2ce, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x2cf, 0x2cd, 
       0x3, 0x2, 0x2, 0x2, 0x2d0, 0x2b0, 0x3, 0x2, 0x2, 0x2, 0x2d0, 0x2c6, 
       0x3, 0x2, 0x2, 0x2, 0x2d1, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x2d3, 
       0x7, 0x1ad, 0x2, 0x2, 0x2d3, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x2d4, 0x2dd, 
       0x5, 0x84, 0x43, 0x2, 0x2d5, 0x2dd, 0x5, 0x8e, 0x48, 0x2, 0x2d6, 
       0x2dd, 0x5, 0x86, 0x44, 0x2, 0x2d7, 0x2dd, 0x5, 0x88, 0x45, 0x2, 
       0x2d8, 0x2dd, 0x5, 0xa0, 0x51, 0x2, 0x2d9, 0x2dd, 0x5, 0xa2, 0x52, 
       0x2, 0x2da, 0x2dd, 0x5, 0xa8, 0x55, 0x2, 0x2db, 0x2dd, 0x5, 0xaa, 
       0x56, 0x2, 0x2dc, 0x2d4, 0x3, 0x2, 0x2, 0x2, 0x2dc, 0x2d5, 0x3, 0x2, 
       0x2, 0x2, 0x2dc, 0x2d6, 0x3, 0x2, 0x2, 0x2, 0x2dc, 0x2d7, 0x3, 0x2, 
       0x2, 0x2, 0x2dc, 0x2d8, 0x3, 0x2, 0x2, 0x2, 0x2dc, 0x2d9, 0x3, 0x2, 
       0x2, 0x2, 0x2dc, 0x2da, 0x3, 0x2, 0x2, 0x2, 0x2dc, 0x2db, 0x3, 0x2, 
       0x2, 0x2, 0x2dd, 0x31, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x2df, 0x7, 0x95, 
       0x2, 0x2, 0x2df, 0x33, 0x3, 0x2, 0x2, 0x2, 0x2e0, 0x2e1, 0x7, 0x1af, 
       0x2, 0x2, 0x2e1, 0x35, 0x3, 0x2, 0x2, 0x2, 0x2e2, 0x2e3, 0x9, 0x8, 
       0x2, 0x2, 0x2e3, 0x37, 0x3, 0x2, 0x2, 0x2, 0x2e4, 0x2e5, 0x9, 0x8, 
       0x2, 0x2, 0x2e5, 0x39, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x2e7, 0x9, 0x9, 
       0x2, 0x2, 0x2e7, 0x3b, 0x3, 0x2, 0x2, 0x2, 0x2e8, 0x2e9, 0x9, 0xa, 
       0x2, 0x2, 0x2e9, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x2ea, 0x2eb, 0x7, 0xff, 
       0x2, 0x2, 0x2eb, 0x2ec, 0x7, 0x93, 0x2, 0x2, 0x2ec, 0x2ed, 0x5, 0x17e, 
       0xc0, 0x2, 0x2ed, 0x2ee, 0x7, 0x60, 0x2, 0x2, 0x2ee, 0x2ef, 0x9, 
       0xb, 0x2, 0x2, 0x2ef, 0x2f3, 0x7, 0x10b, 0x2, 0x2, 0x2f0, 0x2f1, 
       0x7, 0x164, 0x2, 0x2, 0x2f1, 0x2f4, 0x7, 0x192, 0x2, 0x2, 0x2f2, 
       0x2f4, 0x7, 0x111, 0x2, 0x2, 0x2f3, 0x2f0, 0x3, 0x2, 0x2, 0x2, 0x2f3, 
       0x2f2, 0x3, 0x2, 0x2, 0x2, 0x2f3, 0x2f4, 0x3, 0x2, 0x2, 0x2, 0x2f4, 
       0x2f6, 0x3, 0x2, 0x2, 0x2, 0x2f5, 0x2f7, 0x7, 0x1ad, 0x2, 0x2, 0x2f6, 
       0x2f5, 0x3, 0x2, 0x2, 0x2, 0x2f6, 0x2f7, 0x3, 0x2, 0x2, 0x2, 0x2f7, 
       0x3f, 0x3, 0x2, 0x2, 0x2, 0x2f8, 0x2f9, 0x7, 0x99, 0x2, 0x2, 0x2f9, 
       0x2fa, 0x7, 0x93, 0x2, 0x2, 0x2fa, 0x30e, 0x5, 0x17e, 0xc0, 0x2, 
       0x2fb, 0x2fc, 0x7, 0xa5, 0x2, 0x2, 0x2fc, 0x2fd, 0x7, 0x1aa, 0x2, 
       0x2, 0x2fd, 0x2fe, 0x7, 0x120, 0x2, 0x2, 0x2fe, 0x308, 0x7, 0x1aa, 
       0x2, 0x2, 0x2ff, 0x301, 0x7, 0x1ac, 0x2, 0x2, 0x300, 0x2ff, 0x3, 
       0x2, 0x2, 0x2, 0x300, 0x301, 0x3, 0x2, 0x2, 0x2, 0x301, 0x306, 0x3, 
       0x2, 0x2, 0x2, 0x302, 0x307, 0x7, 0x192, 0x2, 0x2, 0x303, 0x304, 
       0x7, 0x192, 0x2, 0x2, 0x304, 0x305, 0x7, 0x95, 0x2, 0x2, 0x305, 0x307, 
       0x7, 0x192, 0x2, 0x2, 0x306, 0x302, 0x3, 0x2, 0x2, 0x2, 0x306, 0x303, 
       0x3, 0x2, 0x2, 0x2, 0x307, 0x309, 0x3, 0x2, 0x2, 0x2, 0x308, 0x300, 
       0x3, 0x2, 0x2, 0x2, 0x309, 0x30a, 0x3, 0x2, 0x2, 0x2, 0x30a, 0x308, 
       0x3, 0x2, 0x2, 0x2, 0x30a, 0x30b, 0x3, 0x2, 0x2, 0x2, 0x30b, 0x30c, 
       0x3, 0x2, 0x2, 0x2, 0x30c, 0x30d, 0x7, 0x1ab, 0x2, 0x2, 0x30d, 0x30f, 
       0x7, 0x1ab, 0x2, 0x2, 0x30e, 0x2fb, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x30f, 
       0x3, 0x2, 0x2, 0x2, 0x30f, 0x41, 0x3, 0x2, 0x2, 0x2, 0x310, 0x311, 
       0x7, 0x22, 0x2, 0x2, 0x311, 0x315, 0x7, 0x13f, 0x2, 0x2, 0x312, 0x313, 
       0x5, 0x1a8, 0xd5, 0x2, 0x313, 0x314, 0x7, 0x1a5, 0x2, 0x2, 0x314, 
       0x316, 0x3, 0x2, 0x2, 0x2, 0x315, 0x312, 0x3, 0x2, 0x2, 0x2, 0x315, 
       0x316, 0x3, 0x2, 0x2, 0x2, 0x316, 0x317, 0x3, 0x2, 0x2, 0x2, 0x317, 
       0x31d, 0x5, 0x1a8, 0xd5, 0x2, 0x318, 0x31b, 0x7, 0x180, 0x2, 0x2, 
       0x319, 0x31a, 0x7, 0xa5, 0x2, 0x2, 0x31a, 0x31c, 0x7, 0x192, 0x2, 
       0x2, 0x31b, 0x319, 0x3, 0x2, 0x2, 0x2, 0x31b, 0x31c, 0x3, 0x2, 0x2, 
       0x2, 0x31c, 0x31e, 0x3, 0x2, 0x2, 0x2, 0x31d, 0x318, 0x3, 0x2, 0x2, 
       0x2, 0x31d, 0x31e, 0x3, 0x2, 0x2, 0x2, 0x31e, 0x322, 0x3, 0x2, 0x2, 
       0x2, 0x31f, 0x320, 0x7, 0x177, 0x2, 0x2, 0x320, 0x321, 0x7, 0x2c, 
       0x2, 0x2, 0x321, 0x323, 0x7, 0x192, 0x2, 0x2, 0x322, 0x31f, 0x3, 
       0x2, 0x2, 0x2, 0x322, 0x323, 0x3, 0x2, 0x2, 0x2, 0x323, 0x328, 0x3, 
       0x2, 0x2, 0x2, 0x324, 0x325, 0x7, 0x17c, 0x2, 0x2, 0x325, 0x329, 
       0x7, 0x192, 0x2, 0x2, 0x326, 0x327, 0x7, 0x10d, 0x2, 0x2, 0x327, 
       0x329, 0x7, 0x17c, 0x2, 0x2, 0x328, 0x324, 0x3, 0x2, 0x2, 0x2, 0x328, 
       0x326, 0x3, 0x2, 0x2, 0x2, 0x328, 0x329, 0x3, 0x2, 0x2, 0x2, 0x329, 
       0x32e, 0x3, 0x2, 0x2, 0x2, 0x32a, 0x32b, 0x7, 0x17b, 0x2, 0x2, 0x32b, 
       0x32f, 0x7, 0x192, 0x2, 0x2, 0x32c, 0x32d, 0x7, 0x10d, 0x2, 0x2, 
       0x32d, 0x32f, 0x7, 0x17b, 0x2, 0x2, 0x32e, 0x32a, 0x3, 0x2, 0x2, 
       0x2, 0x32e, 0x32c, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x32f, 0x3, 0x2, 0x2, 
       0x2, 0x32f, 0x333, 0x3, 0x2, 0x2, 0x2, 0x330, 0x334, 0x7, 0x170, 
       0x2, 0x2, 0x331, 0x332, 0x7, 0x10d, 0x2, 0x2, 0x332, 0x334, 0x7, 
       0x170, 0x2, 0x2, 0x333, 0x330, 0x3, 0x2, 0x2, 0x2, 0x333, 0x331, 
       0x3, 0x2, 0x2, 0x2, 0x333, 0x334, 0x3, 0x2, 0x2, 0x2, 0x334, 0x339, 
       0x3, 0x2, 0x2, 0x2, 0x335, 0x336, 0x7, 0x16a, 0x2, 0x2, 0x336, 0x33a, 
       0x7, 0x192, 0x2, 0x2, 0x337, 0x338, 0x7, 0x10d, 0x2, 0x2, 0x338, 
       0x33a, 0x7, 0x16a, 0x2, 0x2, 0x339, 0x335, 0x3, 0x2, 0x2, 0x2, 0x339, 
       0x337, 0x3, 0x2, 0x2, 0x2, 0x339, 0x33a, 0x3, 0x2, 0x2, 0x2, 0x33a, 
       0x43, 0x3, 0x2, 0x2, 0x2, 0x33b, 0x33c, 0x7, 0x38, 0x2, 0x2, 0x33c, 
       0x340, 0x7, 0x13f, 0x2, 0x2, 0x33d, 0x33e, 0x5, 0x1a8, 0xd5, 0x2, 
       0x33e, 0x33f, 0x7, 0x1a5, 0x2, 0x2, 0x33f, 0x341, 0x3, 0x2, 0x2, 
       0x2, 0x340, 0x33d, 0x3, 0x2, 0x2, 0x2, 0x340, 0x341, 0x3, 0x2, 0x2, 
       0x2, 0x341, 0x342, 0x3, 0x2, 0x2, 0x2, 0x342, 0x345, 0x5, 0x1a8, 
       0xd5, 0x2, 0x343, 0x344, 0x7, 0x25, 0x2, 0x2, 0x344, 0x346, 0x5, 
       0x19e, 0xd0, 0x2, 0x345, 0x343, 0x3, 0x2, 0x2, 0x2, 0x345, 0x346, 
       0x3, 0x2, 0x2, 0x2, 0x346, 0x34a, 0x3, 0x2, 0x2, 0x2, 0x347, 0x348, 
       0x7, 0x186, 0x2, 0x2, 0x348, 0x349, 0x7, 0xa5, 0x2, 0x2, 0x349, 0x34b, 
       0x7, 0x192, 0x2, 0x2, 0x34a, 0x347, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x34b, 
       0x3, 0x2, 0x2, 0x2, 0x34b, 0x352, 0x3, 0x2, 0x2, 0x2, 0x34c, 0x34d, 
       0x7, 0x177, 0x2, 0x2, 0x34d, 0x34f, 0x7, 0x2c, 0x2, 0x2, 0x34e, 0x350, 
       0x7, 0x1b4, 0x2, 0x2, 0x34f, 0x34e, 0x3, 0x2, 0x2, 0x2, 0x34f, 0x350, 
       0x3, 0x2, 0x2, 0x2, 0x350, 0x351, 0x3, 0x2, 0x2, 0x2, 0x351, 0x353, 
       0x7, 0x192, 0x2, 0x2, 0x352, 0x34c, 0x3, 0x2, 0x2, 0x2, 0x352, 0x353, 
       0x3, 0x2, 0x2, 0x2, 0x353, 0x35a, 0x3, 0x2, 0x2, 0x2, 0x354, 0x356, 
       0x7, 0x17c, 0x2, 0x2, 0x355, 0x357, 0x7, 0x192, 0x2, 0x2, 0x356, 
       0x355, 0x3, 0x2, 0x2, 0x2, 0x356, 0x357, 0x3, 0x2, 0x2, 0x2, 0x357, 
       0x35b, 0x3, 0x2, 0x2, 0x2, 0x358, 0x359, 0x7, 0x10d, 0x2, 0x2, 0x359, 
       0x35b, 0x7, 0x17c, 0x2, 0x2, 0x35a, 0x354, 0x3, 0x2, 0x2, 0x2, 0x35a, 
       0x358, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x35b, 0x3, 0x2, 0x2, 0x2, 0x35b, 
       0x362, 0x3, 0x2, 0x2, 0x2, 0x35c, 0x35e, 0x7, 0x17b, 0x2, 0x2, 0x35d, 
       0x35f, 0x7, 0x192, 0x2, 0x2, 0x35e, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x35e, 
       0x35f, 0x3, 0x2, 0x2, 0x2, 0x35f, 0x363, 0x3, 0x2, 0x2, 0x2, 0x360, 
       0x361, 0x7, 0x10d, 0x2, 0x2, 0x361, 0x363, 0x7, 0x17b, 0x2, 0x2, 
       0x362, 0x35c, 0x3, 0x2, 0x2, 0x2, 0x362, 0x360, 0x3, 0x2, 0x2, 0x2, 
       0x362, 0x363, 0x3, 0x2, 0x2, 0x2, 0x363, 0x367, 0x3, 0x2, 0x2, 0x2, 
       0x364, 0x368, 0x7, 0x170, 0x2, 0x2, 0x365, 0x366, 0x7, 0x10d, 0x2, 
       0x2, 0x366, 0x368, 0x7, 0x170, 0x2, 0x2, 0x367, 0x364, 0x3, 0x2, 
       0x2, 0x2, 0x367, 0x365, 0x3, 0x2, 0x2, 0x2, 0x367, 0x368, 0x3, 0x2, 
       0x2, 0x2, 0x368, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x369, 0x36b, 0x7, 0x16a, 
       0x2, 0x2, 0x36a, 0x36c, 0x7, 0x192, 0x2, 0x2, 0x36b, 0x36a, 0x3, 
       0x2, 0x2, 0x2, 0x36b, 0x36c, 0x3, 0x2, 0x2, 0x2, 0x36c, 0x370, 0x3, 
       0x2, 0x2, 0x2, 0x36d, 0x36e, 0x7, 0x10d, 0x2, 0x2, 0x36e, 0x370, 
       0x7, 0x16a, 0x2, 0x2, 0x36f, 0x369, 0x3, 0x2, 0x2, 0x2, 0x36f, 0x36d, 
       0x3, 0x2, 0x2, 0x2, 0x36f, 0x370, 0x3, 0x2, 0x2, 0x2, 0x370, 0x45, 
       0x3, 0x2, 0x2, 0x2, 0x371, 0x373, 0x5, 0xe4, 0x73, 0x2, 0x372, 0x371, 
       0x3, 0x2, 0x2, 0x2, 0x372, 0x373, 0x3, 0x2, 0x2, 0x2, 0x373, 0x374, 
       0x3, 0x2, 0x2, 0x2, 0x374, 0x37c, 0x7, 0x6c, 0x2, 0x2, 0x375, 0x376, 
       0x7, 0x96, 0x2, 0x2, 0x376, 0x377, 0x7, 0x1aa, 0x2, 0x2, 0x377, 0x378, 
       0x5, 0xd4, 0x6b, 0x2, 0x378, 0x37a, 0x7, 0x1ab, 0x2, 0x2, 0x379, 
       0x37b, 0x7, 0x79, 0x2, 0x2, 0x37a, 0x379, 0x3, 0x2, 0x2, 0x2, 0x37a, 
       0x37b, 0x3, 0x2, 0x2, 0x2, 0x37b, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x37c, 
       0x375, 0x3, 0x2, 0x2, 0x2, 0x37c, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x37d, 
       0x37f, 0x3, 0x2, 0x2, 0x2, 0x37e, 0x380, 0x7, 0x65, 0x2, 0x2, 0x37f, 
       0x37e, 0x3, 0x2, 0x2, 0x2, 0x37f, 0x380, 0x3, 0x2, 0x2, 0x2, 0x380, 
       0x381, 0x3, 0x2, 0x2, 0x2, 0x381, 0x383, 0x5, 0x188, 0xc5, 0x2, 0x382, 
       0x384, 0x5, 0x154, 0xab, 0x2, 0x383, 0x382, 0x3, 0x2, 0x2, 0x2, 0x383, 
       0x384, 0x3, 0x2, 0x2, 0x2, 0x384, 0x386, 0x3, 0x2, 0x2, 0x2, 0x385, 
       0x387, 0x5, 0x14e, 0xa8, 0x2, 0x386, 0x385, 0x3, 0x2, 0x2, 0x2, 0x386, 
       0x387, 0x3, 0x2, 0x2, 0x2, 0x387, 0x388, 0x3, 0x2, 0x2, 0x2, 0x388, 
       0x389, 0x7, 0x160, 0x2, 0x2, 0x389, 0x38a, 0x5, 0x116, 0x8c, 0x2, 
       0x38a, 0x38b, 0x7, 0x72, 0x2, 0x2, 0x38b, 0x38d, 0x5, 0xec, 0x77, 
       0x2, 0x38c, 0x38e, 0x5, 0x48, 0x25, 0x2, 0x38d, 0x38c, 0x3, 0x2, 
       0x2, 0x2, 0x38e, 0x38f, 0x3, 0x2, 0x2, 0x2, 0x38f, 0x38d, 0x3, 0x2, 
       0x2, 0x2, 0x38f, 0x390, 0x3, 0x2, 0x2, 0x2, 0x390, 0x392, 0x3, 0x2, 
       0x2, 0x2, 0x391, 0x393, 0x5, 0x60, 0x31, 0x2, 0x392, 0x391, 0x3, 
       0x2, 0x2, 0x2, 0x392, 0x393, 0x3, 0x2, 0x2, 0x2, 0x393, 0x395, 0x3, 
       0x2, 0x2, 0x2, 0x394, 0x396, 0x5, 0x102, 0x82, 0x2, 0x395, 0x394, 
       0x3, 0x2, 0x2, 0x2, 0x395, 0x396, 0x3, 0x2, 0x2, 0x2, 0x396, 0x397, 
       0x3, 0x2, 0x2, 0x2, 0x397, 0x398, 0x7, 0x1ad, 0x2, 0x2, 0x398, 0x47, 
       0x3, 0x2, 0x2, 0x2, 0x399, 0x39a, 0x7, 0xa2, 0x2, 0x2, 0x39a, 0x39d, 
       0x7, 0x17a, 0x2, 0x2, 0x39b, 0x39c, 0x7, 0x23, 0x2, 0x2, 0x39c, 0x39e, 
       0x5, 0xec, 0x77, 0x2, 0x39d, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x39d, 0x39e, 
       0x3, 0x2, 0x2, 0x2, 0x39e, 0x39f, 0x3, 0x2, 0x2, 0x2, 0x39f, 0x3a0, 
       0x7, 0x94, 0x2, 0x2, 0x3a0, 0x3a2, 0x5, 0x4a, 0x26, 0x2, 0x3a1, 0x399, 
       0x3, 0x2, 0x2, 0x2, 0x3a2, 0x3a3, 0x3, 0x2, 0x2, 0x2, 0x3a3, 0x3a1, 
       0x3, 0x2, 0x2, 0x2, 0x3a3, 0x3a4, 0x3, 0x2, 0x2, 0x2, 0x3a4, 0x3c2, 
       0x3, 0x2, 0x2, 0x2, 0x3a5, 0x3a6, 0x7, 0xa2, 0x2, 0x2, 0x3a6, 0x3a7, 
       0x7, 0x6d, 0x2, 0x2, 0x3a7, 0x3aa, 0x7, 0x17a, 0x2, 0x2, 0x3a8, 0x3a9, 
       0x7, 0x2c, 0x2, 0x2, 0x3a9, 0x3ab, 0x7, 0x187, 0x2, 0x2, 0x3aa, 0x3a8, 
       0x3, 0x2, 0x2, 0x2, 0x3aa, 0x3ab, 0x3, 0x2, 0x2, 0x2, 0x3ab, 0x3ae, 
       0x3, 0x2, 0x2, 0x2, 0x3ac, 0x3ad, 0x7, 0x23, 0x2, 0x2, 0x3ad, 0x3af, 
       0x5, 0xec, 0x77, 0x2, 0x3ae, 0x3ac, 0x3, 0x2, 0x2, 0x2, 0x3ae, 0x3af, 
       0x3, 0x2, 0x2, 0x2, 0x3af, 0x3b0, 0x3, 0x2, 0x2, 0x2, 0x3b0, 0x3b1, 
       0x7, 0x94, 0x2, 0x2, 0x3b1, 0x3c2, 0x5, 0x4c, 0x27, 0x2, 0x3b2, 0x3b3, 
       0x7, 0xa2, 0x2, 0x2, 0x3b3, 0x3b4, 0x7, 0x6d, 0x2, 0x2, 0x3b4, 0x3b5, 
       0x7, 0x17a, 0x2, 0x2, 0x3b5, 0x3b6, 0x7, 0x2c, 0x2, 0x2, 0x3b6, 0x3b9, 
       0x7, 0x183, 0x2, 0x2, 0x3b7, 0x3b8, 0x7, 0x23, 0x2, 0x2, 0x3b8, 0x3ba, 
       0x5, 0xec, 0x77, 0x2, 0x3b9, 0x3b7, 0x3, 0x2, 0x2, 0x2, 0x3b9, 0x3ba, 
       0x3, 0x2, 0x2, 0x2, 0x3ba, 0x3bb, 0x3, 0x2, 0x2, 0x2, 0x3bb, 0x3bc, 
       0x7, 0x94, 0x2, 0x2, 0x3bc, 0x3be, 0x5, 0x4a, 0x26, 0x2, 0x3bd, 0x3b2, 
       0x3, 0x2, 0x2, 0x2, 0x3be, 0x3bf, 0x3, 0x2, 0x2, 0x2, 0x3bf, 0x3bd, 
       0x3, 0x2, 0x2, 0x2, 0x3bf, 0x3c0, 0x3, 0x2, 0x2, 0x2, 0x3c0, 0x3c2, 
       0x3, 0x2, 0x2, 0x2, 0x3c1, 0x3a1, 0x3, 0x2, 0x2, 0x2, 0x3c1, 0x3a5, 
       0x3, 0x2, 0x2, 0x2, 0x3c1, 0x3bd, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x49, 
       0x3, 0x2, 0x2, 0x2, 0x3c3, 0x3c4, 0x7, 0x9d, 0x2, 0x2, 0x3c4, 0x3c5, 
       0x7, 0x8f, 0x2, 0x2, 0x3c5, 0x3ca, 0x5, 0xea, 0x76, 0x2, 0x3c6, 0x3c7, 
       0x7, 0x1ac, 0x2, 0x2, 0x3c7, 0x3c9, 0x5, 0xea, 0x76, 0x2, 0x3c8, 
       0x3c6, 0x3, 0x2, 0x2, 0x2, 0x3c9, 0x3cc, 0x3, 0x2, 0x2, 0x2, 0x3ca, 
       0x3c8, 0x3, 0x2, 0x2, 0x2, 0x3ca, 0x3cb, 0x3, 0x2, 0x2, 0x2, 0x3cb, 
       0x3cf, 0x3, 0x2, 0x2, 0x2, 0x3cc, 0x3ca, 0x3, 0x2, 0x2, 0x2, 0x3cd, 
       0x3cf, 0x7, 0x45, 0x2, 0x2, 0x3ce, 0x3c3, 0x3, 0x2, 0x2, 0x2, 0x3ce, 
       0x3cd, 0x3, 0x2, 0x2, 0x2, 0x3cf, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x3d0, 
       0x3d5, 0x7, 0x63, 0x2, 0x2, 0x3d1, 0x3d2, 0x7, 0x1aa, 0x2, 0x2, 0x3d2, 
       0x3d3, 0x5, 0x192, 0xca, 0x2, 0x3d3, 0x3d4, 0x7, 0x1ab, 0x2, 0x2, 
       0x3d4, 0x3d6, 0x3, 0x2, 0x2, 0x2, 0x3d5, 0x3d1, 0x3, 0x2, 0x2, 0x2, 
       0x3d5, 0x3d6, 0x3, 0x2, 0x2, 0x2, 0x3d6, 0x3da, 0x3, 0x2, 0x2, 0x2, 
       0x3d7, 0x3db, 0x5, 0x15e, 0xb0, 0x2, 0x3d8, 0x3d9, 0x7, 0x44, 0x2, 
       0x2, 0x3d9, 0x3db, 0x7, 0xa0, 0x2, 0x2, 0x3da, 0x3d7, 0x3, 0x2, 0x2, 
       0x2, 0x3da, 0x3d8, 0x3, 0x2, 0x2, 0x2, 0x3db, 0x4d, 0x3, 0x2, 0x2, 
       0x2, 0x3dc, 0x3de, 0x5, 0xe4, 0x73, 0x2, 0x3dd, 0x3dc, 0x3, 0x2, 
       0x2, 0x2, 0x3dd, 0x3de, 0x3, 0x2, 0x2, 0x2, 0x3de, 0x3df, 0x3, 0x2, 
       0x2, 0x2, 0x3df, 0x3e9, 0x7, 0x45, 0x2, 0x2, 0x3e0, 0x3e1, 0x7, 0x96, 
       0x2, 0x2, 0x3e1, 0x3e2, 0x7, 0x1aa, 0x2, 0x2, 0x3e2, 0x3e3, 0x5, 
       0xd4, 0x6b, 0x2, 0x3e3, 0x3e5, 0x7, 0x1ab, 0x2, 0x2, 0x3e4, 0x3e6, 
       0x7, 0x79, 0x2, 0x2, 0x3e5, 0x3e4, 0x3, 0x2, 0x2, 0x2, 0x3e5, 0x3e6, 
       0x3, 0x2, 0x2, 0x2, 0x3e6, 0x3ea, 0x3, 0x2, 0x2, 0x2, 0x3e7, 0x3e8, 
       0x7, 0x96, 0x2, 0x2, 0x3e8, 0x3ea, 0x7, 0x192, 0x2, 0x2, 0x3e9, 0x3e0, 
       0x3, 0x2, 0x2, 0x2, 0x3e9, 0x3e7, 0x3, 0x2, 0x2, 0x2, 0x3e9, 0x3ea, 
       0x3, 0x2, 0x2, 0x2, 0x3ea, 0x3ec, 0x3, 0x2, 0x2, 0x2, 0x3eb, 0x3ed, 
       0x7, 0x56, 0x2, 0x2, 0x3ec, 0x3eb, 0x3, 0x2, 0x2, 0x2, 0x3ec, 0x3ed, 
       0x3, 0x2, 0x2, 0x2, 0x3ed, 0x3ee, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x3f0, 
       0x5, 0x50, 0x29, 0x2, 0x3ef, 0x3f1, 0x5, 0x154, 0xab, 0x2, 0x3f0, 
       0x3ef, 0x3, 0x2, 0x2, 0x2, 0x3f0, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x3f1, 
       0x3f3, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x3f4, 0x5, 0x60, 0x31, 0x2, 0x3f3, 
       0x3f2, 0x3, 0x2, 0x2, 0x2, 0x3f3, 0x3f4, 0x3, 0x2, 0x2, 0x2, 0x3f4, 
       0x3f7, 0x3, 0x2, 0x2, 0x2, 0x3f5, 0x3f6, 0x7, 0x56, 0x2, 0x2, 0x3f6, 
       0x3f8, 0x5, 0x116, 0x8c, 0x2, 0x3f7, 0x3f5, 0x3, 0x2, 0x2, 0x2, 0x3f7, 
       0x3f8, 0x3, 0x2, 0x2, 0x2, 0x3f8, 0x406, 0x3, 0x2, 0x2, 0x2, 0x3f9, 
       0x404, 0x7, 0xa3, 0x2, 0x2, 0x3fa, 0x405, 0x5, 0xec, 0x77, 0x2, 0x3fb, 
       0x3fc, 0x7, 0x3a, 0x2, 0x2, 0x3fc, 0x402, 0x7, 0x70, 0x2, 0x2, 0x3fd, 
       0x3ff, 0x7, 0xe6, 0x2, 0x2, 0x3fe, 0x3fd, 0x3, 0x2, 0x2, 0x2, 0x3fe, 
       0x3ff, 0x3, 0x2, 0x2, 0x2, 0x3ff, 0x400, 0x3, 0x2, 0x2, 0x2, 0x400, 
       0x403, 0x5, 0x194, 0xcb, 0x2, 0x401, 0x403, 0x7, 0x191, 0x2, 0x2, 
       0x402, 0x3fe, 0x3, 0x2, 0x2, 0x2, 0x402, 0x401, 0x3, 0x2, 0x2, 0x2, 
       0x403, 0x405, 0x3, 0x2, 0x2, 0x2, 0x404, 0x3fa, 0x3, 0x2, 0x2, 0x2, 
       0x404, 0x3fb, 0x3, 0x2, 0x2, 0x2, 0x405, 0x407, 0x3, 0x2, 0x2, 0x2, 
       0x406, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x406, 0x407, 0x3, 0x2, 0x2, 0x2, 
       0x407, 0x409, 0x3, 0x2, 0x2, 0x2, 0x408, 0x40a, 0x5, 0x102, 0x82, 
       0x2, 0x409, 0x408, 0x3, 0x2, 0x2, 0x2, 0x409, 0x40a, 0x3, 0x2, 0x2, 
       0x2, 0x40a, 0x40c, 0x3, 0x2, 0x2, 0x2, 0x40b, 0x40d, 0x7, 0x1ad, 
       0x2, 0x2, 0x40c, 0x40b, 0x3, 0x2, 0x2, 0x2, 0x40c, 0x40d, 0x3, 0x2, 
       0x2, 0x2, 0x40d, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x412, 0x5, 0x188, 
       0xc5, 0x2, 0x40f, 0x412, 0x5, 0x150, 0xa9, 0x2, 0x410, 0x412, 0x7, 
       0x191, 0x2, 0x2, 0x411, 0x40e, 0x3, 0x2, 0x2, 0x2, 0x411, 0x40f, 
       0x3, 0x2, 0x2, 0x2, 0x411, 0x410, 0x3, 0x2, 0x2, 0x2, 0x412, 0x51, 
       0x3, 0x2, 0x2, 0x2, 0x413, 0x415, 0x5, 0xe4, 0x73, 0x2, 0x414, 0x413, 
       0x3, 0x2, 0x2, 0x2, 0x414, 0x415, 0x3, 0x2, 0x2, 0x2, 0x415, 0x416, 
       0x3, 0x2, 0x2, 0x2, 0x416, 0x41e, 0x7, 0x63, 0x2, 0x2, 0x417, 0x418, 
       0x7, 0x96, 0x2, 0x2, 0x418, 0x419, 0x7, 0x1aa, 0x2, 0x2, 0x419, 0x41a, 
       0x5, 0xd4, 0x6b, 0x2, 0x41a, 0x41c, 0x7, 0x1ab, 0x2, 0x2, 0x41b, 
       0x41d, 0x7, 0x79, 0x2, 0x2, 0x41c, 0x41b, 0x3, 0x2, 0x2, 0x2, 0x41c, 
       0x41d, 0x3, 0x2, 0x2, 0x2, 0x41d, 0x41f, 0x3, 0x2, 0x2, 0x2, 0x41e, 
       0x417, 0x3, 0x2, 0x2, 0x2, 0x41e, 0x41f, 0x3, 0x2, 0x2, 0x2, 0x41f, 
       0x421, 0x3, 0x2, 0x2, 0x2, 0x420, 0x422, 0x7, 0x65, 0x2, 0x2, 0x421, 
       0x420, 0x3, 0x2, 0x2, 0x2, 0x421, 0x422, 0x3, 0x2, 0x2, 0x2, 0x422, 
       0x423, 0x3, 0x2, 0x2, 0x2, 0x423, 0x425, 0x5, 0x188, 0xc5, 0x2, 0x424, 
       0x426, 0x5, 0x154, 0xab, 0x2, 0x425, 0x424, 0x3, 0x2, 0x2, 0x2, 0x425, 
       0x426, 0x3, 0x2, 0x2, 0x2, 0x426, 0x42b, 0x3, 0x2, 0x2, 0x2, 0x427, 
       0x428, 0x7, 0x1aa, 0x2, 0x2, 0x428, 0x429, 0x5, 0x18e, 0xc8, 0x2, 
       0x429, 0x42a, 0x7, 0x1ab, 0x2, 0x2, 0x42a, 0x42c, 0x3, 0x2, 0x2, 
       0x2, 0x42b, 0x427, 0x3, 0x2, 0x2, 0x2, 0x42b, 0x42c, 0x3, 0x2, 0x2, 
       0x2, 0x42c, 0x42e, 0x3, 0x2, 0x2, 0x2, 0x42d, 0x42f, 0x5, 0x60, 0x31, 
       0x2, 0x42e, 0x42d, 0x3, 0x2, 0x2, 0x2, 0x42e, 0x42f, 0x3, 0x2, 0x2, 
       0x2, 0x42f, 0x430, 0x3, 0x2, 0x2, 0x2, 0x430, 0x431, 0x5, 0x54, 0x2b, 
       0x2, 0x431, 0x53, 0x3, 0x2, 0x2, 0x2, 0x432, 0x438, 0x5, 0x15e, 0xb0, 
       0x2, 0x433, 0x438, 0x5, 0x13e, 0xa0, 0x2, 0x434, 0x438, 0x5, 0x8e, 
       0x48, 0x2, 0x435, 0x436, 0x7, 0x44, 0x2, 0x2, 0x436, 0x438, 0x7, 
       0xa0, 0x2, 0x2, 0x437, 0x432, 0x3, 0x2, 0x2, 0x2, 0x437, 0x433, 0x3, 
       0x2, 0x2, 0x2, 0x437, 0x434, 0x3, 0x2, 0x2, 0x2, 0x437, 0x435, 0x3, 
       0x2, 0x2, 0x2, 0x438, 0x55, 0x3, 0x2, 0x2, 0x2, 0x439, 0x43b, 0x7, 
       0x1aa, 0x2, 0x2, 0x43a, 0x439, 0x3, 0x2, 0x2, 0x2, 0x43a, 0x43b, 
       0x3, 0x2, 0x2, 0x2, 0x43b, 0x43c, 0x3, 0x2, 0x2, 0x2, 0x43c, 0x441, 
       0x7, 0x1b9, 0x2, 0x2, 0x43d, 0x442, 0x7, 0x21, 0x2, 0x2, 0x43e, 0x442, 
       0x7, 0x47, 0x2, 0x2, 0x43f, 0x442, 0x5, 0xf6, 0x7c, 0x2, 0x440, 0x442, 
       0x7, 0x1b0, 0x2, 0x2, 0x441, 0x43d, 0x3, 0x2, 0x2, 0x2, 0x441, 0x43e, 
       0x3, 0x2, 0x2, 0x2, 0x441, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x441, 0x440, 
       0x3, 0x2, 0x2, 0x2, 0x442, 0x44b, 0x3, 0x2, 0x2, 0x2, 0x443, 0x444, 
       0x7, 0x191, 0x2, 0x2, 0x444, 0x445, 0x7, 0x198, 0x2, 0x2, 0x445, 
       0x447, 0x5, 0xd4, 0x6b, 0x2, 0x446, 0x448, 0x7, 0x1ac, 0x2, 0x2, 
       0x447, 0x446, 0x3, 0x2, 0x2, 0x2, 0x447, 0x448, 0x3, 0x2, 0x2, 0x2, 
       0x448, 0x44a, 0x3, 0x2, 0x2, 0x2, 0x449, 0x443, 0x3, 0x2, 0x2, 0x2, 
       0x44a, 0x44d, 0x3, 0x2, 0x2, 0x2, 0x44b, 0x449, 0x3, 0x2, 0x2, 0x2, 
       0x44b, 0x44c, 0x3, 0x2, 0x2, 0x2, 0x44c, 0x44e, 0x3, 0x2, 0x2, 0x2, 
       0x44d, 0x44b, 0x3, 0x2, 0x2, 0x2, 0x44e, 0x44f, 0x7, 0x56, 0x2, 0x2, 
       0x44f, 0x455, 0x5, 0x17c, 0xbf, 0x2, 0x450, 0x451, 0x7, 0x65, 0x2, 
       0x2, 0x451, 0x452, 0x5, 0x1a8, 0xd5, 0x2, 0x452, 0x453, 0x7, 0xa3, 
       0x2, 0x2, 0x453, 0x454, 0x5, 0xec, 0x77, 0x2, 0x454, 0x456, 0x3, 
       0x2, 0x2, 0x2, 0x455, 0x450, 0x3, 0x2, 0x2, 0x2, 0x455, 0x456, 0x3, 
       0x2, 0x2, 0x2, 0x456, 0x458, 0x3, 0x2, 0x2, 0x2, 0x457, 0x459, 0x7, 
       0x1ab, 0x2, 0x2, 0x458, 0x457, 0x3, 0x2, 0x2, 0x2, 0x458, 0x459, 
       0x3, 0x2, 0x2, 0x2, 0x459, 0x57, 0x3, 0x2, 0x2, 0x2, 0x45a, 0x45c, 
       0x5, 0xe4, 0x73, 0x2, 0x45b, 0x45a, 0x3, 0x2, 0x2, 0x2, 0x45b, 0x45c, 
       0x3, 0x2, 0x2, 0x2, 0x45c, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x45e, 
       0x5, 0x5a, 0x2e, 0x2, 0x45e, 0x59, 0x3, 0x2, 0x2, 0x2, 0x45f, 0x461, 
       0x5, 0xf0, 0x79, 0x2, 0x460, 0x462, 0x5, 0xfc, 0x7f, 0x2, 0x461, 
       0x460, 0x3, 0x2, 0x2, 0x2, 0x461, 0x462, 0x3, 0x2, 0x2, 0x2, 0x462, 
       0x464, 0x3, 0x2, 0x2, 0x2, 0x463, 0x465, 0x5, 0x102, 0x82, 0x2, 0x464, 
       0x463, 0x3, 0x2, 0x2, 0x2, 0x464, 0x465, 0x3, 0x2, 0x2, 0x2, 0x465, 
       0x467, 0x3, 0x2, 0x2, 0x2, 0x466, 0x468, 0x7, 0x1ad, 0x2, 0x2, 0x467, 
       0x466, 0x3, 0x2, 0x2, 0x2, 0x467, 0x468, 0x3, 0x2, 0x2, 0x2, 0x468, 
       0x5b, 0x3, 0x2, 0x2, 0x2, 0x469, 0x46c, 0x7, 0x191, 0x2, 0x2, 0x46a, 
       0x46c, 0x5, 0x1a2, 0xd2, 0x2, 0x46b, 0x469, 0x3, 0x2, 0x2, 0x2, 0x46b, 
       0x46a, 0x3, 0x2, 0x2, 0x2, 0x46c, 0x5d, 0x3, 0x2, 0x2, 0x2, 0x46d, 
       0x46f, 0x5, 0xe4, 0x73, 0x2, 0x46e, 0x46d, 0x3, 0x2, 0x2, 0x2, 0x46e, 
       0x46f, 0x3, 0x2, 0x2, 0x2, 0x46f, 0x470, 0x3, 0x2, 0x2, 0x2, 0x470, 
       0x478, 0x7, 0x9d, 0x2, 0x2, 0x471, 0x472, 0x7, 0x96, 0x2, 0x2, 0x472, 
       0x473, 0x7, 0x1aa, 0x2, 0x2, 0x473, 0x474, 0x5, 0xd4, 0x6b, 0x2, 
       0x474, 0x476, 0x7, 0x1ab, 0x2, 0x2, 0x475, 0x477, 0x7, 0x79, 0x2, 
       0x2, 0x476, 0x475, 0x3, 0x2, 0x2, 0x2, 0x476, 0x477, 0x3, 0x2, 0x2, 
       0x2, 0x477, 0x479, 0x3, 0x2, 0x2, 0x2, 0x478, 0x471, 0x3, 0x2, 0x2, 
       0x2, 0x478, 0x479, 0x3, 0x2, 0x2, 0x2, 0x479, 0x47a, 0x3, 0x2, 0x2, 
       0x2, 0x47a, 0x47c, 0x5, 0x188, 0xc5, 0x2, 0x47b, 0x47d, 0x5, 0x152, 
       0xaa, 0x2, 0x47c, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x47c, 0x47d, 0x3, 0x2, 
       0x2, 0x2, 0x47d, 0x47e, 0x3, 0x2, 0x2, 0x2, 0x47e, 0x47f, 0x7, 0x8f, 
       0x2, 0x2, 0x47f, 0x484, 0x5, 0xe8, 0x75, 0x2, 0x480, 0x481, 0x7, 
       0x1ac, 0x2, 0x2, 0x481, 0x483, 0x5, 0xe8, 0x75, 0x2, 0x482, 0x480, 
       0x3, 0x2, 0x2, 0x2, 0x483, 0x486, 0x3, 0x2, 0x2, 0x2, 0x484, 0x482, 
       0x3, 0x2, 0x2, 0x2, 0x484, 0x485, 0x3, 0x2, 0x2, 0x2, 0x485, 0x488, 
       0x3, 0x2, 0x2, 0x2, 0x486, 0x484, 0x3, 0x2, 0x2, 0x2, 0x487, 0x489, 
       0x5, 0x60, 0x31, 0x2, 0x488, 0x487, 0x3, 0x2, 0x2, 0x2, 0x488, 0x489, 
       0x3, 0x2, 0x2, 0x2, 0x489, 0x48c, 0x3, 0x2, 0x2, 0x2, 0x48a, 0x48b, 
       0x7, 0x56, 0x2, 0x2, 0x48b, 0x48d, 0x5, 0x116, 0x8c, 0x2, 0x48c, 
       0x48a, 0x3, 0x2, 0x2, 0x2, 0x48c, 0x48d, 0x3, 0x2, 0x2, 0x2, 0x48d, 
       0x49b, 0x3, 0x2, 0x2, 0x2, 0x48e, 0x499, 0x7, 0xa3, 0x2, 0x2, 0x48f, 
       0x49a, 0x5, 0xec, 0x77, 0x2, 0x490, 0x491, 0x7, 0x3a, 0x2, 0x2, 0x491, 
       0x497, 0x7, 0x70, 0x2, 0x2, 0x492, 0x494, 0x7, 0xe6, 0x2, 0x2, 0x493, 
       0x492, 0x3, 0x2, 0x2, 0x2, 0x493, 0x494, 0x3, 0x2, 0x2, 0x2, 0x494, 
       0x495, 0x3, 0x2, 0x2, 0x2, 0x495, 0x498, 0x5, 0x194, 0xcb, 0x2, 0x496, 
       0x498, 0x7, 0x191, 0x2, 0x2, 0x497, 0x493, 0x3, 0x2, 0x2, 0x2, 0x497, 
       0x496, 0x3, 0x2, 0x2, 0x2, 0x498, 0x49a, 0x3, 0x2, 0x2, 0x2, 0x499, 
       0x48f, 0x3, 0x2, 0x2, 0x2, 0x499, 0x490, 0x3, 0x2, 0x2, 0x2, 0x49a, 
       0x49c, 0x3, 0x2, 0x2, 0x2, 0x49b, 0x48e, 0x3, 0x2, 0x2, 0x2, 0x49b, 
       0x49c, 0x3, 0x2, 0x2, 0x2, 0x49c, 0x49e, 0x3, 0x2, 0x2, 0x2, 0x49d, 
       0x49f, 0x5, 0x102, 0x82, 0x2, 0x49e, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x49e, 
       0x49f, 0x3, 0x2, 0x2, 0x2, 0x49f, 0x4a1, 0x3, 0x2, 0x2, 0x2, 0x4a0, 
       0x4a2, 0x7, 0x1ad, 0x2, 0x2, 0x4a1, 0x4a0, 0x3, 0x2, 0x2, 0x2, 0x4a1, 
       0x4a2, 0x3, 0x2, 0x2, 0x2, 0x4a2, 0x5f, 0x3, 0x2, 0x2, 0x2, 0x4a3, 
       0x4a4, 0x7, 0x11c, 0x2, 0x2, 0x4a4, 0x4a9, 0x5, 0x62, 0x32, 0x2, 
       0x4a5, 0x4a6, 0x7, 0x1ac, 0x2, 0x2, 0x4a6, 0x4a8, 0x5, 0x62, 0x32, 
       0x2, 0x4a7, 0x4a5, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4ab, 0x3, 0x2, 0x2, 
       0x2, 0x4a9, 0x4a7, 0x3, 0x2, 0x2, 0x2, 0x4a9, 0x4aa, 0x3, 0x2, 0x2, 
       0x2, 0x4aa, 0x4b7, 0x3, 0x2, 0x2, 0x2, 0x4ab, 0x4a9, 0x3, 0x2, 0x2, 
       0x2, 0x4ac, 0x4af, 0x7, 0x65, 0x2, 0x2, 0x4ad, 0x4b0, 0x7, 0x191, 
       0x2, 0x2, 0x4ae, 0x4b0, 0x5, 0x17e, 0xc0, 0x2, 0x4af, 0x4ad, 0x3, 
       0x2, 0x2, 0x2, 0x4af, 0x4ae, 0x3, 0x2, 0x2, 0x2, 0x4b0, 0x4b5, 0x3, 
       0x2, 0x2, 0x2, 0x4b1, 0x4b2, 0x7, 0x1aa, 0x2, 0x2, 0x4b2, 0x4b3, 
       0x5, 0x192, 0xca, 0x2, 0x4b3, 0x4b4, 0x7, 0x1ab, 0x2, 0x2, 0x4b4, 
       0x4b6, 0x3, 0x2, 0x2, 0x2, 0x4b5, 0x4b1, 0x3, 0x2, 0x2, 0x2, 0x4b5, 
       0x4b6, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0x4b7, 
       0x4ac, 0x3, 0x2, 0x2, 0x2, 0x4b7, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0x4b8, 
       0x61, 0x3, 0x2, 0x2, 0x2, 0x4b9, 0x4bc, 0x5, 0xd4, 0x6b, 0x2, 0x4ba, 
       0x4bc, 0x5, 0x10c, 0x87, 0x2, 0x4bb, 0x4b9, 0x3, 0x2, 0x2, 0x2, 0x4bb, 
       0x4ba, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4be, 0x3, 0x2, 0x2, 0x2, 0x4bd, 
       0x4bf, 0x5, 0x14c, 0xa7, 0x2, 0x4be, 0x4bd, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4bf, 0x3, 0x2, 0x2, 0x2, 0x4bf, 0x63, 0x3, 0x2, 0x2, 0x2, 0x4c0, 
       0x4c3, 0x7, 0x38, 0x2, 0x2, 0x4c1, 0x4c2, 0x7, 0x75, 0x2, 0x2, 0x4c2, 
       0x4c4, 0x7, 0x22, 0x2, 0x2, 0x4c3, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4c4, 0x3, 0x2, 0x2, 0x2, 0x4c4, 0x4c7, 0x3, 0x2, 0x2, 0x2, 0x4c5, 
       0x4c7, 0x7, 0x22, 0x2, 0x2, 0x4c6, 0x4c0, 0x3, 0x2, 0x2, 0x2, 0x4c6, 
       0x4c5, 0x3, 0x2, 0x2, 0x2, 0x4c7, 0x4c8, 0x3, 0x2, 0x2, 0x2, 0x4c8, 
       0x4c9, 0x9, 0xc, 0x2, 0x2, 0x4c9, 0x4cc, 0x5, 0x182, 0xc2, 0x2, 0x4ca, 
       0x4cb, 0x7, 0x1ad, 0x2, 0x2, 0x4cb, 0x4cd, 0x7, 0x192, 0x2, 0x2, 
       0x4cc, 0x4ca, 0x3, 0x2, 0x2, 0x2, 0x4cc, 0x4cd, 0x3, 0x2, 0x2, 0x2, 
       0x4cd, 0x4dc, 0x3, 0x2, 0x2, 0x2, 0x4ce, 0x4d0, 0x7, 0x1aa, 0x2, 
       0x2, 0x4cf, 0x4ce, 0x3, 0x2, 0x2, 0x2, 0x4cf, 0x4d0, 0x3, 0x2, 0x2, 
       0x2, 0x4d0, 0x4d1, 0x3, 0x2, 0x2, 0x2, 0x4d1, 0x4d6, 0x5, 0x6e, 0x38, 
       0x2, 0x4d2, 0x4d3, 0x7, 0x1ac, 0x2, 0x2, 0x4d3, 0x4d5, 0x5, 0x6e, 
       0x38, 0x2, 0x4d4, 0x4d2, 0x3, 0x2, 0x2, 0x2, 0x4d5, 0x4d8, 0x3, 0x2, 
       0x2, 0x2, 0x4d6, 0x4d4, 0x3, 0x2, 0x2, 0x2, 0x4d6, 0x4d7, 0x3, 0x2, 
       0x2, 0x2, 0x4d7, 0x4da, 0x3, 0x2, 0x2, 0x2, 0x4d8, 0x4d6, 0x3, 0x2, 
       0x2, 0x2, 0x4d9, 0x4db, 0x7, 0x1ab, 0x2, 0x2, 0x4da, 0x4d9, 0x3, 
       0x2, 0x2, 0x2, 0x4da, 0x4db, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4dd, 0x3, 
       0x2, 0x2, 0x2, 0x4dc, 0x4cf, 0x3, 0x2, 0x2, 0x2, 0x4dc, 0x4dd, 0x3, 
       0x2, 0x2, 0x2, 0x4dd, 0x4e7, 0x3, 0x2, 0x2, 0x2, 0x4de, 0x4df, 0x7, 
       0xa5, 0x2, 0x2, 0x4df, 0x4e4, 0x5, 0x70, 0x39, 0x2, 0x4e0, 0x4e1, 
       0x7, 0x1ac, 0x2, 0x2, 0x4e1, 0x4e3, 0x5, 0x70, 0x39, 0x2, 0x4e2, 
       0x4e0, 0x3, 0x2, 0x2, 0x2, 0x4e3, 0x4e6, 0x3, 0x2, 0x2, 0x2, 0x4e4, 
       0x4e2, 0x3, 0x2, 0x2, 0x2, 0x4e4, 0x4e5, 0x3, 0x2, 0x2, 0x2, 0x4e5, 
       0x4e8, 0x3, 0x2, 0x2, 0x2, 0x4e6, 0x4e4, 0x3, 0x2, 0x2, 0x2, 0x4e7, 
       0x4de, 0x3, 0x2, 0x2, 0x2, 0x4e7, 0x4e8, 0x3, 0x2, 0x2, 0x2, 0x4e8, 
       0x4eb, 0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4ea, 0x7, 0x54, 0x2, 0x2, 0x4ea, 
       0x4ec, 0x7, 0x84, 0x2, 0x2, 0x4eb, 0x4e9, 0x3, 0x2, 0x2, 0x2, 0x4eb, 
       0x4ec, 0x3, 0x2, 0x2, 0x2, 0x4ec, 0x4ed, 0x3, 0x2, 0x2, 0x2, 0x4ed, 
       0x4f1, 0x7, 0x25, 0x2, 0x2, 0x4ee, 0x4f0, 0x5, 0x8, 0x5, 0x2, 0x4ef, 
       0x4ee, 0x3, 0x2, 0x2, 0x2, 0x4f0, 0x4f3, 0x3, 0x2, 0x2, 0x2, 0x4f1, 
       0x4ef, 0x3, 0x2, 0x2, 0x2, 0x4f1, 0x4f2, 0x3, 0x2, 0x2, 0x2, 0x4f2, 
       0x65, 0x3, 0x2, 0x2, 0x2, 0x4f3, 0x4f1, 0x3, 0x2, 0x2, 0x2, 0x4f4, 
       0x4f7, 0x7, 0x38, 0x2, 0x2, 0x4f5, 0x4f6, 0x7, 0x75, 0x2, 0x2, 0x4f6, 
       0x4f8, 0x7, 0x22, 0x2, 0x2, 0x4f7, 0x4f5, 0x3, 0x2, 0x2, 0x2, 0x4f7, 
       0x4f8, 0x3, 0x2, 0x2, 0x2, 0x4f8, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x4f9, 
       0x4fb, 0x7, 0x22, 0x2, 0x2, 0x4fa, 0x4f4, 0x3, 0x2, 0x2, 0x2, 0x4fa, 
       0x4f9, 0x3, 0x2, 0x2, 0x2, 0x4fb, 0x4fc, 0x3, 0x2, 0x2, 0x2, 0x4fc, 
       0x4fd, 0x7, 0x58, 0x2, 0x2, 0x4fd, 0x50b, 0x5, 0x182, 0xc2, 0x2, 
       0x4fe, 0x4ff, 0x7, 0x1aa, 0x2, 0x2, 0x4ff, 0x504, 0x5, 0x6e, 0x38, 
       0x2, 0x500, 0x501, 0x7, 0x1ac, 0x2, 0x2, 0x501, 0x503, 0x5, 0x6e, 
       0x38, 0x2, 0x502, 0x500, 0x3, 0x2, 0x2, 0x2, 0x503, 0x506, 0x3, 0x2, 
       0x2, 0x2, 0x504, 0x502, 0x3, 0x2, 0x2, 0x2, 0x504, 0x505, 0x3, 0x2, 
       0x2, 0x2, 0x505, 0x507, 0x3, 0x2, 0x2, 0x2, 0x506, 0x504, 0x3, 0x2, 
       0x2, 0x2, 0x507, 0x508, 0x7, 0x1ab, 0x2, 0x2, 0x508, 0x50c, 0x3, 
       0x2, 0x2, 0x2, 0x509, 0x50a, 0x7, 0x1aa, 0x2, 0x2, 0x50a, 0x50c, 
       0x7, 0x1ab, 0x2, 0x2, 0x50b, 0x4fe, 0x3, 0x2, 0x2, 0x2, 0x50b, 0x509, 
       0x3, 0x2, 0x2, 0x2, 0x50c, 0x510, 0x3, 0x2, 0x2, 0x2, 0x50d, 0x511, 
       0x5, 0x68, 0x35, 0x2, 0x50e, 0x511, 0x5, 0x6a, 0x36, 0x2, 0x50f, 
       0x511, 0x5, 0x6c, 0x37, 0x2, 0x510, 0x50d, 0x3, 0x2, 0x2, 0x2, 0x510, 
       0x50e, 0x3, 0x2, 0x2, 0x2, 0x510, 0x50f, 0x3, 0x2, 0x2, 0x2, 0x511, 
       0x513, 0x3, 0x2, 0x2, 0x2, 0x512, 0x514, 0x7, 0x1ad, 0x2, 0x2, 0x513, 
       0x512, 0x3, 0x2, 0x2, 0x2, 0x513, 0x514, 0x3, 0x2, 0x2, 0x2, 0x514, 
       0x67, 0x3, 0x2, 0x2, 0x2, 0x515, 0x516, 0x7, 0x181, 0x2, 0x2, 0x516, 
       0x520, 0x7, 0x93, 0x2, 0x2, 0x517, 0x518, 0x7, 0xa5, 0x2, 0x2, 0x518, 
       0x51d, 0x5, 0x72, 0x3a, 0x2, 0x519, 0x51a, 0x7, 0x1ac, 0x2, 0x2, 
       0x51a, 0x51c, 0x5, 0x72, 0x3a, 0x2, 0x51b, 0x519, 0x3, 0x2, 0x2, 
       0x2, 0x51c, 0x51f, 0x3, 0x2, 0x2, 0x2, 0x51d, 0x51b, 0x3, 0x2, 0x2, 
       0x2, 0x51d, 0x51e, 0x3, 0x2, 0x2, 0x2, 0x51e, 0x521, 0x3, 0x2, 0x2, 
       0x2, 0x51f, 0x51d, 0x3, 0x2, 0x2, 0x2, 0x520, 0x517, 0x3, 0x2, 0x2, 
       0x2, 0x520, 0x521, 0x3, 0x2, 0x2, 0x2, 0x521, 0x523, 0x3, 0x2, 0x2, 
       0x2, 0x522, 0x524, 0x7, 0x25, 0x2, 0x2, 0x523, 0x522, 0x3, 0x2, 0x2, 
       0x2, 0x523, 0x524, 0x3, 0x2, 0x2, 0x2, 0x524, 0x525, 0x3, 0x2, 0x2, 
       0x2, 0x525, 0x52b, 0x7, 0x85, 0x2, 0x2, 0x526, 0x527, 0x7, 0x1aa, 
       0x2, 0x2, 0x527, 0x528, 0x5, 0x58, 0x2d, 0x2, 0x528, 0x529, 0x7, 
       0x1ab, 0x2, 0x2, 0x529, 0x52c, 0x3, 0x2, 0x2, 0x2, 0x52a, 0x52c, 
       0x5, 0x58, 0x2d, 0x2, 0x52b, 0x526, 0x3, 0x2, 0x2, 0x2, 0x52b, 0x52a, 
       0x3, 0x2, 0x2, 0x2, 0x52c, 0x69, 0x3, 0x2, 0x2, 0x2, 0x52d, 0x52e, 
       0x7, 0x181, 0x2, 0x2, 0x52e, 0x52f, 0x7, 0x191, 0x2, 0x2, 0x52f, 
       0x539, 0x5, 0xb8, 0x5d, 0x2, 0x530, 0x531, 0x7, 0xa5, 0x2, 0x2, 0x531, 
       0x536, 0x5, 0x72, 0x3a, 0x2, 0x532, 0x533, 0x7, 0x1ac, 0x2, 0x2, 
       0x533, 0x535, 0x5, 0x72, 0x3a, 0x2, 0x534, 0x532, 0x3, 0x2, 0x2, 
       0x2, 0x535, 0x538, 0x3, 0x2, 0x2, 0x2, 0x536, 0x534, 0x3, 0x2, 0x2, 
       0x2, 0x536, 0x537, 0x3, 0x2, 0x2, 0x2, 0x537, 0x53a, 0x3, 0x2, 0x2, 
       0x2, 0x538, 0x536, 0x3, 0x2, 0x2, 0x2, 0x539, 0x530, 0x3, 0x2, 0x2, 
       0x2, 0x539, 0x53a, 0x3, 0x2, 0x2, 0x2, 0x53a, 0x53c, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x53d, 0x7, 0x25, 0x2, 0x2, 0x53c, 0x53b, 0x3, 0x2, 0x2, 
       0x2, 0x53c, 0x53d, 0x3, 0x2, 0x2, 0x2, 0x53d, 0x53e, 0x3, 0x2, 0x2, 
       0x2, 0x53e, 0x542, 0x7, 0x29, 0x2, 0x2, 0x53f, 0x541, 0x5, 0x8, 0x5, 
       0x2, 0x540, 0x53f, 0x3, 0x2, 0x2, 0x2, 0x541, 0x544, 0x3, 0x2, 0x2, 
       0x2, 0x542, 0x540, 0x3, 0x2, 0x2, 0x2, 0x542, 0x543, 0x3, 0x2, 0x2, 
       0x2, 0x543, 0x545, 0x3, 0x2, 0x2, 0x2, 0x544, 0x542, 0x3, 0x2, 0x2, 
       0x2, 0x545, 0x547, 0x7, 0x85, 0x2, 0x2, 0x546, 0x548, 0x7, 0x1ad, 
       0x2, 0x2, 0x547, 0x546, 0x3, 0x2, 0x2, 0x2, 0x547, 0x548, 0x3, 0x2, 
       0x2, 0x2, 0x548, 0x549, 0x3, 0x2, 0x2, 0x2, 0x549, 0x54b, 0x7, 0x4e, 
       0x2, 0x2, 0x54a, 0x54c, 0x7, 0x1ad, 0x2, 0x2, 0x54b, 0x54a, 0x3, 
       0x2, 0x2, 0x2, 0x54b, 0x54c, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x6b, 0x3, 
       0x2, 0x2, 0x2, 0x54d, 0x54e, 0x7, 0x181, 0x2, 0x2, 0x54e, 0x558, 
       0x5, 0x19e, 0xd0, 0x2, 0x54f, 0x550, 0x7, 0xa5, 0x2, 0x2, 0x550, 
       0x555, 0x5, 0x72, 0x3a, 0x2, 0x551, 0x552, 0x7, 0x1ac, 0x2, 0x2, 
       0x552, 0x554, 0x5, 0x72, 0x3a, 0x2, 0x553, 0x551, 0x3, 0x2, 0x2, 
       0x2, 0x554, 0x557, 0x3, 0x2, 0x2, 0x2, 0x555, 0x553, 0x3, 0x2, 0x2, 
       0x2, 0x555, 0x556, 0x3, 0x2, 0x2, 0x2, 0x556, 0x559, 0x3, 0x2, 0x2, 
       0x2, 0x557, 0x555, 0x3, 0x2, 0x2, 0x2, 0x558, 0x54f, 0x3, 0x2, 0x2, 
       0x2, 0x558, 0x559, 0x3, 0x2, 0x2, 0x2, 0x559, 0x55b, 0x3, 0x2, 0x2, 
       0x2, 0x55a, 0x55c, 0x7, 0x25, 0x2, 0x2, 0x55b, 0x55a, 0x3, 0x2, 0x2, 
       0x2, 0x55b, 0x55c, 0x3, 0x2, 0x2, 0x2, 0x55c, 0x55d, 0x3, 0x2, 0x2, 
       0x2, 0x55d, 0x561, 0x7, 0x29, 0x2, 0x2, 0x55e, 0x560, 0x5, 0x8, 0x5, 
       0x2, 0x55f, 0x55e, 0x3, 0x2, 0x2, 0x2, 0x560, 0x563, 0x3, 0x2, 0x2, 
       0x2, 0x561, 0x55f, 0x3, 0x2, 0x2, 0x2, 0x561, 0x562, 0x3, 0x2, 0x2, 
       0x2, 0x562, 0x564, 0x3, 0x2, 0x2, 0x2, 0x563, 0x561, 0x3, 0x2, 0x2, 
       0x2, 0x564, 0x565, 0x7, 0x85, 0x2, 0x2, 0x565, 0x567, 0x5, 0xd4, 
       0x6b, 0x2, 0x566, 0x568, 0x7, 0x1ad, 0x2, 0x2, 0x567, 0x566, 0x3, 
       0x2, 0x2, 0x2, 0x567, 0x568, 0x3, 0x2, 0x2, 0x2, 0x568, 0x569, 0x3, 
       0x2, 0x2, 0x2, 0x569, 0x56a, 0x7, 0x4e, 0x2, 0x2, 0x56a, 0x6d, 0x3, 
       0x2, 0x2, 0x2, 0x56b, 0x56d, 0x7, 0x191, 0x2, 0x2, 0x56c, 0x56e, 
       0x7, 0x25, 0x2, 0x2, 0x56d, 0x56c, 0x3, 0x2, 0x2, 0x2, 0x56d, 0x56e, 
       0x3, 0x2, 0x2, 0x2, 0x56e, 0x572, 0x3, 0x2, 0x2, 0x2, 0x56f, 0x570, 
       0x5, 0x1a8, 0xd5, 0x2, 0x570, 0x571, 0x7, 0x1a5, 0x2, 0x2, 0x571, 
       0x573, 0x3, 0x2, 0x2, 0x2, 0x572, 0x56f, 0x3, 0x2, 0x2, 0x2, 0x572, 
       0x573, 0x3, 0x2, 0x2, 0x2, 0x573, 0x574, 0x3, 0x2, 0x2, 0x2, 0x574, 
       0x576, 0x5, 0x19e, 0xd0, 0x2, 0x575, 0x577, 0x7, 0xa1, 0x2, 0x2, 
       0x576, 0x575, 0x3, 0x2, 0x2, 0x2, 0x576, 0x577, 0x3, 0x2, 0x2, 0x2, 
       0x577, 0x57a, 0x3, 0x2, 0x2, 0x2, 0x578, 0x579, 0x7, 0x198, 0x2, 
       0x2, 0x579, 0x57b, 0x5, 0x1a0, 0xd1, 0x2, 0x57a, 0x578, 0x3, 0x2, 
       0x2, 0x2, 0x57a, 0x57b, 0x3, 0x2, 0x2, 0x2, 0x57b, 0x57d, 0x3, 0x2, 
       0x2, 0x2, 0x57c, 0x57e, 0x9, 0xd, 0x2, 0x2, 0x57d, 0x57c, 0x3, 0x2, 
       0x2, 0x2, 0x57d, 0x57e, 0x3, 0x2, 0x2, 0x2, 0x57e, 0x6f, 0x3, 0x2, 
       0x2, 0x2, 0x57f, 0x583, 0x7, 0xda, 0x2, 0x2, 0x580, 0x583, 0x7, 0x130, 
       0x2, 0x2, 0x581, 0x583, 0x5, 0xb4, 0x5b, 0x2, 0x582, 0x57f, 0x3, 
       0x2, 0x2, 0x2, 0x582, 0x580, 0x3, 0x2, 0x2, 0x2, 0x582, 0x581, 0x3, 
       0x2, 0x2, 0x2, 0x583, 0x71, 0x3, 0x2, 0x2, 0x2, 0x584, 0x591, 0x7, 
       0xda, 0x2, 0x2, 0x585, 0x591, 0x7, 0x139, 0x2, 0x2, 0x586, 0x587, 
       0x7, 0x181, 0x2, 0x2, 0x587, 0x588, 0x7, 0x6e, 0x2, 0x2, 0x588, 0x589, 
       0x7, 0x72, 0x2, 0x2, 0x589, 0x58a, 0x7, 0x6e, 0x2, 0x2, 0x58a, 0x591, 
       0x7, 0xf0, 0x2, 0x2, 0x58b, 0x58c, 0x7, 0x16b, 0x2, 0x2, 0x58c, 0x58d, 
       0x7, 0x72, 0x2, 0x2, 0x58d, 0x58e, 0x7, 0x6e, 0x2, 0x2, 0x58e, 0x591, 
       0x7, 0xf0, 0x2, 0x2, 0x58f, 0x591, 0x5, 0xb4, 0x5b, 0x2, 0x590, 0x584, 
       0x3, 0x2, 0x2, 0x2, 0x590, 0x585, 0x3, 0x2, 0x2, 0x2, 0x590, 0x586, 
       0x3, 0x2, 0x2, 0x2, 0x590, 0x58b, 0x3, 0x2, 0x2, 0x2, 0x590, 0x58f, 
       0x3, 0x2, 0x2, 0x2, 0x591, 0x73, 0x3, 0x2, 0x2, 0x2, 0x592, 0x593, 
       0x7, 0x38, 0x2, 0x2, 0x593, 0x594, 0x7, 0x93, 0x2, 0x2, 0x594, 0x595, 
       0x5, 0x17e, 0xc0, 0x2, 0x595, 0x596, 0x7, 0x1aa, 0x2, 0x2, 0x596, 
       0x598, 0x5, 0xba, 0x5e, 0x2, 0x597, 0x599, 0x7, 0x1ac, 0x2, 0x2, 
       0x598, 0x597, 0x3, 0x2, 0x2, 0x2, 0x598, 0x599, 0x3, 0x2, 0x2, 0x2, 
       0x599, 0x59a, 0x3, 0x2, 0x2, 0x2, 0x59a, 0x59d, 0x7, 0x1ab, 0x2, 
       0x2, 0x59b, 0x59c, 0x7, 0xff, 0x2, 0x2, 0x59c, 0x59e, 0x5, 0x1aa, 
       0xd6, 0x2, 0x59d, 0x59b, 0x3, 0x2, 0x2, 0x2, 0x59d, 0x59e, 0x3, 0x2, 
       0x2, 0x2, 0x59e, 0x5a2, 0x3, 0x2, 0x2, 0x2, 0x59f, 0x5a1, 0x5, 0x76, 
       0x3c, 0x2, 0x5a0, 0x59f, 0x3, 0x2, 0x2, 0x2, 0x5a1, 0x5a4, 0x3, 0x2, 
       0x2, 0x2, 0x5a2, 0x5a0, 0x3, 0x2, 0x2, 0x2, 0x5a2, 0x5a3, 0x3, 0x2, 
       0x2, 0x2, 0x5a3, 0x5a8, 0x3, 0x2, 0x2, 0x2, 0x5a4, 0x5a2, 0x3, 0x2, 
       0x2, 0x2, 0x5a5, 0x5a6, 0x7, 0x72, 0x2, 0x2, 0x5a6, 0x5a9, 0x5, 0x1a8, 
       0xd5, 0x2, 0x5a7, 0x5a9, 0x7, 0x44, 0x2, 0x2, 0x5a8, 0x5a5, 0x3, 
       0x2, 0x2, 0x2, 0x5a8, 0x5a7, 0x3, 0x2, 0x2, 0x2, 0x5a8, 0x5a9, 0x3, 
       0x2, 0x2, 0x2, 0x5a9, 0x5ad, 0x3, 0x2, 0x2, 0x2, 0x5aa, 0x5ab, 0x7, 
       0x150, 0x2, 0x2, 0x5ab, 0x5ae, 0x5, 0x1a8, 0xd5, 0x2, 0x5ac, 0x5ae, 
       0x7, 0x44, 0x2, 0x2, 0x5ad, 0x5aa, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5ac, 
       0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5ae, 0x3, 0x2, 0x2, 0x2, 0x5ae, 0x5b0, 
       0x3, 0x2, 0x2, 0x2, 0x5af, 0x5b1, 0x7, 0x1ad, 0x2, 0x2, 0x5b0, 0x5af, 
       0x3, 0x2, 0x2, 0x2, 0x5b0, 0x5b1, 0x3, 0x2, 0x2, 0x2, 0x5b1, 0x75, 
       0x3, 0x2, 0x2, 0x2, 0x5b2, 0x5c6, 0x7, 0xa5, 0x2, 0x2, 0x5b3, 0x5b4, 
       0x7, 0x1aa, 0x2, 0x2, 0x5b4, 0x5b9, 0x5, 0xc6, 0x64, 0x2, 0x5b5, 
       0x5b6, 0x7, 0x1ac, 0x2, 0x2, 0x5b6, 0x5b8, 0x5, 0xc6, 0x64, 0x2, 
       0x5b7, 0x5b5, 0x3, 0x2, 0x2, 0x2, 0x5b8, 0x5bb, 0x3, 0x2, 0x2, 0x2, 
       0x5b9, 0x5b7, 0x3, 0x2, 0x2, 0x2, 0x5b9, 0x5ba, 0x3, 0x2, 0x2, 0x2, 
       0x5ba, 0x5bc, 0x3, 0x2, 0x2, 0x2, 0x5bb, 0x5b9, 0x3, 0x2, 0x2, 0x2, 
       0x5bc, 0x5bd, 0x7, 0x1ab, 0x2, 0x2, 0x5bd, 0x5c7, 0x3, 0x2, 0x2, 
       0x2, 0x5be, 0x5c3, 0x5, 0xc6, 0x64, 0x2, 0x5bf, 0x5c0, 0x7, 0x1ac, 
       0x2, 0x2, 0x5c0, 0x5c2, 0x5, 0xc6, 0x64, 0x2, 0x5c1, 0x5bf, 0x3, 
       0x2, 0x2, 0x2, 0x5c2, 0x5c5, 0x3, 0x2, 0x2, 0x2, 0x5c3, 0x5c1, 0x3, 
       0x2, 0x2, 0x2, 0x5c3, 0x5c4, 0x3, 0x2, 0x2, 0x2, 0x5c4, 0x5c7, 0x3, 
       0x2, 0x2, 0x2, 0x5c5, 0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5c6, 0x5b3, 0x3, 
       0x2, 0x2, 0x2, 0x5c6, 0x5be, 0x3, 0x2, 0x2, 0x2, 0x5c7, 0x77, 0x3, 
       0x2, 0x2, 0x2, 0x5c8, 0x5c9, 0x7, 0x22, 0x2, 0x2, 0x5c9, 0x5ca, 0x7, 
       0x93, 0x2, 0x2, 0x5ca, 0x5f8, 0x5, 0x17e, 0xc0, 0x2, 0x5cb, 0x5cc, 
       0x7, 0x8f, 0x2, 0x2, 0x5cc, 0x5cd, 0x7, 0x1aa, 0x2, 0x2, 0x5cd, 0x5ce, 
       0x7, 0x100, 0x2, 0x2, 0x5ce, 0x5cf, 0x7, 0x198, 0x2, 0x2, 0x5cf, 
       0x5d0, 0x9, 0xe, 0x2, 0x2, 0x5d0, 0x5f9, 0x7, 0x1ab, 0x2, 0x2, 0x5d1, 
       0x5d2, 0x7, 0x20, 0x2, 0x2, 0x5d2, 0x5f9, 0x5, 0xba, 0x5e, 0x2, 0x5d3, 
       0x5d4, 0x7, 0x22, 0x2, 0x2, 0x5d4, 0x5d5, 0x7, 0x32, 0x2, 0x2, 0x5d5, 
       0x5f9, 0x5, 0xbe, 0x60, 0x2, 0x5d6, 0x5d7, 0x7, 0x4c, 0x2, 0x2, 0x5d7, 
       0x5d8, 0x7, 0x32, 0x2, 0x2, 0x5d8, 0x5dd, 0x5, 0x1a8, 0xd5, 0x2, 
       0x5d9, 0x5da, 0x7, 0x1ac, 0x2, 0x2, 0x5da, 0x5dc, 0x5, 0x1a8, 0xd5, 
       0x2, 0x5db, 0x5d9, 0x3, 0x2, 0x2, 0x2, 0x5dc, 0x5df, 0x3, 0x2, 0x2, 
       0x2, 0x5dd, 0x5db, 0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5de, 0x3, 0x2, 0x2, 
       0x2, 0x5de, 0x5f9, 0x3, 0x2, 0x2, 0x2, 0x5df, 0x5dd, 0x3, 0x2, 0x2, 
       0x2, 0x5e0, 0x5e1, 0x7, 0x4c, 0x2, 0x2, 0x5e1, 0x5e2, 0x7, 0x35, 
       0x2, 0x2, 0x5e2, 0x5f9, 0x5, 0x1a8, 0xd5, 0x2, 0x5e3, 0x5e4, 0x7, 
       0xa5, 0x2, 0x2, 0x5e4, 0x5e5, 0x7, 0x2e, 0x2, 0x2, 0x5e5, 0x5e6, 
       0x7, 0x20, 0x2, 0x2, 0x5e6, 0x5e7, 0x7, 0x35, 0x2, 0x2, 0x5e7, 0x5e8, 
       0x5, 0x1a8, 0xd5, 0x2, 0x5e8, 0x5e9, 0x7, 0x55, 0x2, 0x2, 0x5e9, 
       0x5ea, 0x7, 0x68, 0x2, 0x2, 0x5ea, 0x5eb, 0x7, 0x1aa, 0x2, 0x2, 0x5eb, 
       0x5ec, 0x5, 0x192, 0xca, 0x2, 0x5ec, 0x5ed, 0x7, 0x1ab, 0x2, 0x2, 
       0x5ed, 0x5ee, 0x7, 0x83, 0x2, 0x2, 0x5ee, 0x5ef, 0x5, 0x17e, 0xc0, 
       0x2, 0x5ef, 0x5f0, 0x7, 0x1aa, 0x2, 0x2, 0x5f0, 0x5f1, 0x5, 0x192, 
       0xca, 0x2, 0x5f1, 0x5f2, 0x7, 0x1ab, 0x2, 0x2, 0x5f2, 0x5f9, 0x3, 
       0x2, 0x2, 0x2, 0x5f3, 0x5f4, 0x7, 0x2e, 0x2, 0x2, 0x5f4, 0x5f5, 0x7, 
       0x35, 0x2, 0x2, 0x5f5, 0x5f9, 0x5, 0x1a8, 0xd5, 0x2, 0x5f6, 0x5f7, 
       0x7, 0x12f, 0x2, 0x2, 0x5f7, 0x5f9, 0x5, 0x76, 0x3c, 0x2, 0x5f8, 
       0x5cb, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x5d1, 0x3, 0x2, 0x2, 0x2, 0x5f8, 
       0x5d3, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x5d6, 0x3, 0x2, 0x2, 0x2, 0x5f8, 
       0x5e0, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x5e3, 0x3, 0x2, 0x2, 0x2, 0x5f8, 
       0x5f3, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x5f6, 0x3, 0x2, 0x2, 0x2, 0x5f9, 
       0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5fc, 0x7, 0x1ad, 0x2, 0x2, 0x5fb, 
       0x5fa, 0x3, 0x2, 0x2, 0x2, 0x5fb, 0x5fc, 0x3, 0x2, 0x2, 0x2, 0x5fc, 
       0x79, 0x3, 0x2, 0x2, 0x2, 0x5fd, 0x5fe, 0x5, 0x7c, 0x3f, 0x2, 0x5fe, 
       0x7b, 0x3, 0x2, 0x2, 0x2, 0x5ff, 0x600, 0x7, 0xc6, 0x2, 0x2, 0x600, 
       0x604, 0x5, 0x196, 0xcc, 0x2, 0x601, 0x602, 0x7, 0xc7, 0x2, 0x2, 
       0x602, 0x604, 0x9, 0xf, 0x2, 0x2, 0x603, 0x5ff, 0x3, 0x2, 0x2, 0x2, 
       0x603, 0x601, 0x3, 0x2, 0x2, 0x2, 0x604, 0x7d, 0x3, 0x2, 0x2, 0x2, 
       0x605, 0x606, 0x7, 0x4c, 0x2, 0x2, 0x606, 0x609, 0x9, 0xc, 0x2, 0x2, 
       0x607, 0x608, 0x7, 0x5f, 0x2, 0x2, 0x608, 0x60a, 0x7, 0x52, 0x2, 
       0x2, 0x609, 0x607, 0x3, 0x2, 0x2, 0x2, 0x609, 0x60a, 0x3, 0x2, 0x2, 
       0x2, 0x60a, 0x60b, 0x3, 0x2, 0x2, 0x2, 0x60b, 0x610, 0x5, 0x182, 
       0xc2, 0x2, 0x60c, 0x60d, 0x7, 0x1ac, 0x2, 0x2, 0x60d, 0x60f, 0x5, 
       0x182, 0xc2, 0x2, 0x60e, 0x60c, 0x3, 0x2, 0x2, 0x2, 0x60f, 0x612, 
       0x3, 0x2, 0x2, 0x2, 0x610, 0x60e, 0x3, 0x2, 0x2, 0x2, 0x610, 0x611, 
       0x3, 0x2, 0x2, 0x2, 0x611, 0x614, 0x3, 0x2, 0x2, 0x2, 0x612, 0x610, 
       0x3, 0x2, 0x2, 0x2, 0x613, 0x615, 0x7, 0x1ad, 0x2, 0x2, 0x614, 0x613, 
       0x3, 0x2, 0x2, 0x2, 0x614, 0x615, 0x3, 0x2, 0x2, 0x2, 0x615, 0x7f, 
       0x3, 0x2, 0x2, 0x2, 0x616, 0x617, 0x7, 0x4c, 0x2, 0x2, 0x617, 0x61a, 
       0x7, 0x58, 0x2, 0x2, 0x618, 0x619, 0x7, 0x5f, 0x2, 0x2, 0x619, 0x61b, 
       0x7, 0x52, 0x2, 0x2, 0x61a, 0x618, 0x3, 0x2, 0x2, 0x2, 0x61a, 0x61b, 
       0x3, 0x2, 0x2, 0x2, 0x61b, 0x61c, 0x3, 0x2, 0x2, 0x2, 0x61c, 0x621, 
       0x5, 0x182, 0xc2, 0x2, 0x61d, 0x61e, 0x7, 0x1ac, 0x2, 0x2, 0x61e, 
       0x620, 0x5, 0x182, 0xc2, 0x2, 0x61f, 0x61d, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x623, 0x3, 0x2, 0x2, 0x2, 0x621, 0x61f, 0x3, 0x2, 0x2, 0x2, 0x621, 
       0x622, 0x3, 0x2, 0x2, 0x2, 0x622, 0x625, 0x3, 0x2, 0x2, 0x2, 0x623, 
       0x621, 0x3, 0x2, 0x2, 0x2, 0x624, 0x626, 0x7, 0x1ad, 0x2, 0x2, 0x625, 
       0x624, 0x3, 0x2, 0x2, 0x2, 0x625, 0x626, 0x3, 0x2, 0x2, 0x2, 0x626, 
       0x81, 0x3, 0x2, 0x2, 0x2, 0x627, 0x628, 0x7, 0x4c, 0x2, 0x2, 0x628, 
       0x62b, 0x7, 0x93, 0x2, 0x2, 0x629, 0x62a, 0x7, 0x5f, 0x2, 0x2, 0x62a, 
       0x62c, 0x7, 0x52, 0x2, 0x2, 0x62b, 0x629, 0x3, 0x2, 0x2, 0x2, 0x62b, 
       0x62c, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x62d, 0x3, 0x2, 0x2, 0x2, 0x62d, 
       0x62f, 0x5, 0x17e, 0xc0, 0x2, 0x62e, 0x630, 0x7, 0x1ad, 0x2, 0x2, 
       0x62f, 0x62e, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x630, 0x3, 0x2, 0x2, 0x2, 
       0x630, 0x83, 0x3, 0x2, 0x2, 0x2, 0x631, 0x632, 0x7, 0x43, 0x2, 0x2, 
       0x632, 0x634, 0x7, 0x191, 0x2, 0x2, 0x633, 0x635, 0x7, 0x25, 0x2, 
       0x2, 0x634, 0x633, 0x3, 0x2, 0x2, 0x2, 0x634, 0x635, 0x3, 0x2, 0x2, 
       0x2, 0x635, 0x636, 0x3, 0x2, 0x2, 0x2, 0x636, 0x638, 0x5, 0xb8, 0x5d, 
       0x2, 0x637, 0x639, 0x7, 0x1ad, 0x2, 0x2, 0x638, 0x637, 0x3, 0x2, 
       0x2, 0x2, 0x638, 0x639, 0x3, 0x2, 0x2, 0x2, 0x639, 0x647, 0x3, 0x2, 
       0x2, 0x2, 0x63a, 0x63b, 0x7, 0x43, 0x2, 0x2, 0x63b, 0x640, 0x5, 0xb6, 
       0x5c, 0x2, 0x63c, 0x63d, 0x7, 0x1ac, 0x2, 0x2, 0x63d, 0x63f, 0x5, 
       0xb6, 0x5c, 0x2, 0x63e, 0x63c, 0x3, 0x2, 0x2, 0x2, 0x63f, 0x642, 
       0x3, 0x2, 0x2, 0x2, 0x640, 0x63e, 0x3, 0x2, 0x2, 0x2, 0x640, 0x641, 
       0x3, 0x2, 0x2, 0x2, 0x641, 0x644, 0x3, 0x2, 0x2, 0x2, 0x642, 0x640, 
       0x3, 0x2, 0x2, 0x2, 0x643, 0x645, 0x7, 0x1ad, 0x2, 0x2, 0x644, 0x643, 
       0x3, 0x2, 0x2, 0x2, 0x644, 0x645, 0x3, 0x2, 0x2, 0x2, 0x645, 0x647, 
       0x3, 0x2, 0x2, 0x2, 0x646, 0x631, 0x3, 0x2, 0x2, 0x2, 0x646, 0x63a, 
       0x3, 0x2, 0x2, 0x2, 0x647, 0x85, 0x3, 0x2, 0x2, 0x2, 0x648, 0x64a, 
       0x7, 0x2f, 0x2, 0x2, 0x649, 0x64b, 0x7, 0xe6, 0x2, 0x2, 0x64a, 0x649, 
       0x3, 0x2, 0x2, 0x2, 0x64a, 0x64b, 0x3, 0x2, 0x2, 0x2, 0x64b, 0x64c, 
       0x3, 0x2, 0x2, 0x2, 0x64c, 0x64e, 0x5, 0x194, 0xcb, 0x2, 0x64d, 0x64f, 
       0x7, 0x1ad, 0x2, 0x2, 0x64e, 0x64d, 0x3, 0x2, 0x2, 0x2, 0x64e, 0x64f, 
       0x3, 0x2, 0x2, 0x2, 0x64f, 0x666, 0x3, 0x2, 0x2, 0x2, 0x650, 0x652, 
       0x7, 0x42, 0x2, 0x2, 0x651, 0x653, 0x7, 0xe6, 0x2, 0x2, 0x652, 0x651, 
       0x3, 0x2, 0x2, 0x2, 0x652, 0x653, 0x3, 0x2, 0x2, 0x2, 0x653, 0x655, 
       0x3, 0x2, 0x2, 0x2, 0x654, 0x656, 0x7, 0x3f, 0x2, 0x2, 0x655, 0x654, 
       0x3, 0x2, 0x2, 0x2, 0x655, 0x656, 0x3, 0x2, 0x2, 0x2, 0x656, 0x657, 
       0x3, 0x2, 0x2, 0x2, 0x657, 0x659, 0x5, 0x194, 0xcb, 0x2, 0x658, 0x65a, 
       0x7, 0x1ad, 0x2, 0x2, 0x659, 0x658, 0x3, 0x2, 0x2, 0x2, 0x659, 0x65a, 
       0x3, 0x2, 0x2, 0x2, 0x65a, 0x666, 0x3, 0x2, 0x2, 0x2, 0x65b, 0x666, 
       0x5, 0xc8, 0x65, 0x2, 0x65c, 0x666, 0x5, 0xce, 0x68, 0x2, 0x65d, 
       0x65f, 0x7, 0x73, 0x2, 0x2, 0x65e, 0x660, 0x7, 0xe6, 0x2, 0x2, 0x65f, 
       0x65e, 0x3, 0x2, 0x2, 0x2, 0x65f, 0x660, 0x3, 0x2, 0x2, 0x2, 0x660, 
       0x661, 0x3, 0x2, 0x2, 0x2, 0x661, 0x663, 0x5, 0x194, 0xcb, 0x2, 0x662, 
       0x664, 0x7, 0x1ad, 0x2, 0x2, 0x663, 0x662, 0x3, 0x2, 0x2, 0x2, 0x663, 
       0x664, 0x3, 0x2, 0x2, 0x2, 0x664, 0x666, 0x3, 0x2, 0x2, 0x2, 0x665, 
       0x648, 0x3, 0x2, 0x2, 0x2, 0x665, 0x650, 0x3, 0x2, 0x2, 0x2, 0x665, 
       0x65b, 0x3, 0x2, 0x2, 0x2, 0x665, 0x65c, 0x3, 0x2, 0x2, 0x2, 0x665, 
       0x65d, 0x3, 0x2, 0x2, 0x2, 0x666, 0x87, 0x3, 0x2, 0x2, 0x2, 0x667, 
       0x66a, 0x7, 0x69, 0x2, 0x2, 0x668, 0x66b, 0x5, 0x8a, 0x46, 0x2, 0x669, 
       0x66b, 0x5, 0x8c, 0x47, 0x2, 0x66a, 0x668, 0x3, 0x2, 0x2, 0x2, 0x66a, 
       0x669, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x89, 0x3, 0x2, 0x2, 0x2, 0x66c, 
       0x66f, 0x9, 0x10, 0x2, 0x2, 0x66d, 0x66f, 0x7, 0x15f, 0x2, 0x2, 0x66e, 
       0x66c, 0x3, 0x2, 0x2, 0x2, 0x66e, 0x66d, 0x3, 0x2, 0x2, 0x2, 0x66f, 
       0x672, 0x3, 0x2, 0x2, 0x2, 0x670, 0x671, 0x7, 0xa5, 0x2, 0x2, 0x671, 
       0x673, 0x7, 0x149, 0x2, 0x2, 0x672, 0x670, 0x3, 0x2, 0x2, 0x2, 0x672, 
       0x673, 0x3, 0x2, 0x2, 0x2, 0x673, 0x8b, 0x3, 0x2, 0x2, 0x2, 0x674, 
       0x675, 0x7, 0x126, 0x2, 0x2, 0x675, 0x676, 0x7, 0x17d, 0x2, 0x2, 
       0x676, 0x679, 0x7, 0x14e, 0x2, 0x2, 0x677, 0x67a, 0x7, 0x21, 0x2, 
       0x2, 0x678, 0x67a, 0x7, 0x192, 0x2, 0x2, 0x679, 0x677, 0x3, 0x2, 
       0x2, 0x2, 0x679, 0x678, 0x3, 0x2, 0x2, 0x2, 0x67a, 0x8d, 0x3, 0x2, 
       0x2, 0x2, 0x67b, 0x67c, 0x7, 0x51, 0x2, 0x2, 0x67c, 0x67e, 0x5, 0x92, 
       0x4a, 0x2, 0x67d, 0x67f, 0x7, 0x1ad, 0x2, 0x2, 0x67e, 0x67d, 0x3, 
       0x2, 0x2, 0x2, 0x67e, 0x67f, 0x3, 0x2, 0x2, 0x2, 0x67f, 0x8f, 0x3, 
       0x2, 0x2, 0x2, 0x680, 0x689, 0x5, 0x186, 0xc4, 0x2, 0x681, 0x686, 
       0x5, 0x94, 0x4b, 0x2, 0x682, 0x683, 0x7, 0x1ac, 0x2, 0x2, 0x683, 
       0x685, 0x5, 0x94, 0x4b, 0x2, 0x684, 0x682, 0x3, 0x2, 0x2, 0x2, 0x685, 
       0x688, 0x3, 0x2, 0x2, 0x2, 0x686, 0x684, 0x3, 0x2, 0x2, 0x2, 0x686, 
       0x687, 0x3, 0x2, 0x2, 0x2, 0x687, 0x68a, 0x3, 0x2, 0x2, 0x2, 0x688, 
       0x686, 0x3, 0x2, 0x2, 0x2, 0x689, 0x681, 0x3, 0x2, 0x2, 0x2, 0x689, 
       0x68a, 0x3, 0x2, 0x2, 0x2, 0x68a, 0x68c, 0x3, 0x2, 0x2, 0x2, 0x68b, 
       0x68d, 0x7, 0x1ad, 0x2, 0x2, 0x68c, 0x68b, 0x3, 0x2, 0x2, 0x2, 0x68c, 
       0x68d, 0x3, 0x2, 0x2, 0x2, 0x68d, 0x91, 0x3, 0x2, 0x2, 0x2, 0x68e, 
       0x68f, 0x7, 0x191, 0x2, 0x2, 0x68f, 0x691, 0x7, 0x198, 0x2, 0x2, 
       0x690, 0x68e, 0x3, 0x2, 0x2, 0x2, 0x690, 0x691, 0x3, 0x2, 0x2, 0x2, 
       0x691, 0x694, 0x3, 0x2, 0x2, 0x2, 0x692, 0x695, 0x5, 0x186, 0xc4, 
       0x2, 0x693, 0x695, 0x5, 0x9c, 0x4f, 0x2, 0x694, 0x692, 0x3, 0x2, 
       0x2, 0x2, 0x694, 0x693, 0x3, 0x2, 0x2, 0x2, 0x695, 0x697, 0x3, 0x2, 
       0x2, 0x2, 0x696, 0x698, 0x5, 0x94, 0x4b, 0x2, 0x697, 0x696, 0x3, 
       0x2, 0x2, 0x2, 0x697, 0x698, 0x3, 0x2, 0x2, 0x2, 0x698, 0x6a5, 0x3, 
       0x2, 0x2, 0x2, 0x699, 0x69a, 0x7, 0x1aa, 0x2, 0x2, 0x69a, 0x69f, 
       0x5, 0x9c, 0x4f, 0x2, 0x69b, 0x69c, 0x7, 0x1b3, 0x2, 0x2, 0x69c, 
       0x69e, 0x5, 0x9c, 0x4f, 0x2, 0x69d, 0x69b, 0x3, 0x2, 0x2, 0x2, 0x69e, 
       0x6a1, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x69d, 0x3, 0x2, 0x2, 0x2, 0x69f, 
       0x6a0, 0x3, 0x2, 0x2, 0x2, 0x6a0, 0x6a2, 0x3, 0x2, 0x2, 0x2, 0x6a1, 
       0x69f, 0x3, 0x2, 0x2, 0x2, 0x6a2, 0x6a3, 0x7, 0x1ab, 0x2, 0x2, 0x6a3, 
       0x6a5, 0x3, 0x2, 0x2, 0x2, 0x6a4, 0x690, 0x3, 0x2, 0x2, 0x2, 0x6a4, 
       0x699, 0x3, 0x2, 0x2, 0x2, 0x6a5, 0x93, 0x3, 0x2, 0x2, 0x2, 0x6a6, 
       0x6ab, 0x5, 0x98, 0x4d, 0x2, 0x6a7, 0x6a8, 0x7, 0x1ac, 0x2, 0x2, 
       0x6a8, 0x6aa, 0x5, 0x94, 0x4b, 0x2, 0x6a9, 0x6a7, 0x3, 0x2, 0x2, 
       0x2, 0x6aa, 0x6ad, 0x3, 0x2, 0x2, 0x2, 0x6ab, 0x6a9, 0x3, 0x2, 0x2, 
       0x2, 0x6ab, 0x6ac, 0x3, 0x2, 0x2, 0x2, 0x6ac, 0x6b7, 0x3, 0x2, 0x2, 
       0x2, 0x6ad, 0x6ab, 0x3, 0x2, 0x2, 0x2, 0x6ae, 0x6b3, 0x5, 0x96, 0x4c, 
       0x2, 0x6af, 0x6b0, 0x7, 0x1ac, 0x2, 0x2, 0x6b0, 0x6b2, 0x5, 0x96, 
       0x4c, 0x2, 0x6b1, 0x6af, 0x3, 0x2, 0x2, 0x2, 0x6b2, 0x6b5, 0x3, 0x2, 
       0x2, 0x2, 0x6b3, 0x6b1, 0x3, 0x2, 0x2, 0x2, 0x6b3, 0x6b4, 0x3, 0x2, 
       0x2, 0x2, 0x6b4, 0x6b7, 0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6b3, 0x3, 0x2, 
       0x2, 0x2, 0x6b6, 0x6a6, 0x3, 0x2, 0x2, 0x2, 0x6b6, 0x6ae, 0x3, 0x2, 
       0x2, 0x2, 0x6b7, 0x95, 0x3, 0x2, 0x2, 0x2, 0x6b8, 0x6b9, 0x7, 0x191, 
       0x2, 0x2, 0x6b9, 0x6ba, 0x7, 0x198, 0x2, 0x2, 0x6ba, 0x6bb, 0x5, 
       0x9a, 0x4e, 0x2, 0x6bb, 0x97, 0x3, 0x2, 0x2, 0x2, 0x6bc, 0x6bd, 0x5, 
       0x9a, 0x4e, 0x2, 0x6bd, 0x99, 0x3, 0x2, 0x2, 0x2, 0x6be, 0x6c7, 0x5, 
       0x1a2, 0xd2, 0x2, 0x6bf, 0x6c1, 0x7, 0x191, 0x2, 0x2, 0x6c0, 0x6c2, 
       0x9, 0x11, 0x2, 0x2, 0x6c1, 0x6c0, 0x3, 0x2, 0x2, 0x2, 0x6c1, 0x6c2, 
       0x3, 0x2, 0x2, 0x2, 0x6c2, 0x6c7, 0x3, 0x2, 0x2, 0x2, 0x6c3, 0x6c7, 
       0x5, 0x1a8, 0xd5, 0x2, 0x6c4, 0x6c7, 0x7, 0x44, 0x2, 0x2, 0x6c5, 
       0x6c7, 0x7, 0x6e, 0x2, 0x2, 0x6c6, 0x6be, 0x3, 0x2, 0x2, 0x2, 0x6c6, 
       0x6bf, 0x3, 0x2, 0x2, 0x2, 0x6c6, 0x6c3, 0x3, 0x2, 0x2, 0x2, 0x6c6, 
       0x6c4, 0x3, 0x2, 0x2, 0x2, 0x6c6, 0x6c5, 0x3, 0x2, 0x2, 0x2, 0x6c7, 
       0x9b, 0x3, 0x2, 0x2, 0x2, 0x6c8, 0x6c9, 0x9, 0x3, 0x2, 0x2, 0x6c9, 
       0x9d, 0x3, 0x2, 0x2, 0x2, 0x6ca, 0x6cb, 0x9, 0x12, 0x2, 0x2, 0x6cb, 
       0x9f, 0x3, 0x2, 0x2, 0x2, 0x6cc, 0x6cd, 0x7, 0x8f, 0x2, 0x2, 0x6cd, 
       0x6d0, 0x7, 0x191, 0x2, 0x2, 0x6ce, 0x6cf, 0x7, 0x1a5, 0x2, 0x2, 
       0x6cf, 0x6d1, 0x5, 0x1a8, 0xd5, 0x2, 0x6d0, 0x6ce, 0x3, 0x2, 0x2, 
       0x2, 0x6d0, 0x6d1, 0x3, 0x2, 0x2, 0x2, 0x6d1, 0x6d2, 0x3, 0x2, 0x2, 
       0x2, 0x6d2, 0x6d3, 0x7, 0x198, 0x2, 0x2, 0x6d3, 0x6d5, 0x5, 0xd4, 
       0x6b, 0x2, 0x6d4, 0x6d6, 0x7, 0x1ad, 0x2, 0x2, 0x6d5, 0x6d4, 0x3, 
       0x2, 0x2, 0x2, 0x6d5, 0x6d6, 0x3, 0x2, 0x2, 0x2, 0x6d6, 0x6f4, 0x3, 
       0x2, 0x2, 0x2, 0x6d7, 0x6d8, 0x7, 0x8f, 0x2, 0x2, 0x6d8, 0x6d9, 0x7, 
       0x191, 0x2, 0x2, 0x6d9, 0x6da, 0x5, 0x1b0, 0xd9, 0x2, 0x6da, 0x6dc, 
       0x5, 0xd4, 0x6b, 0x2, 0x6db, 0x6dd, 0x7, 0x1ad, 0x2, 0x2, 0x6dc, 
       0x6db, 0x3, 0x2, 0x2, 0x2, 0x6dc, 0x6dd, 0x3, 0x2, 0x2, 0x2, 0x6dd, 
       0x6f4, 0x3, 0x2, 0x2, 0x2, 0x6de, 0x6df, 0x7, 0x8f, 0x2, 0x2, 0x6df, 
       0x6e0, 0x7, 0x191, 0x2, 0x2, 0x6e0, 0x6e1, 0x7, 0x198, 0x2, 0x2, 
       0x6e1, 0x6e2, 0x7, 0x3f, 0x2, 0x2, 0x6e2, 0x6ed, 0x5, 0xca, 0x66, 
       0x2, 0x6e3, 0x6eb, 0x7, 0x54, 0x2, 0x2, 0x6e4, 0x6e5, 0x7, 0x82, 
       0x2, 0x2, 0x6e5, 0x6ec, 0x7, 0x118, 0x2, 0x2, 0x6e6, 0x6e9, 0x7, 
       0x9d, 0x2, 0x2, 0x6e7, 0x6e8, 0x7, 0x70, 0x2, 0x2, 0x6e8, 0x6ea, 
       0x5, 0x192, 0xca, 0x2, 0x6e9, 0x6e7, 0x3, 0x2, 0x2, 0x2, 0x6e9, 0x6ea, 
       0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6ec, 0x3, 0x2, 0x2, 0x2, 0x6eb, 0x6e4, 
       0x3, 0x2, 0x2, 0x2, 0x6eb, 0x6e6, 0x3, 0x2, 0x2, 0x2, 0x6ec, 0x6ee, 
       0x3, 0x2, 0x2, 0x2, 0x6ed, 0x6e3, 0x3, 0x2, 0x2, 0x2, 0x6ed, 0x6ee, 
       0x3, 0x2, 0x2, 0x2, 0x6ee, 0x6f0, 0x3, 0x2, 0x2, 0x2, 0x6ef, 0x6f1, 
       0x7, 0x1ad, 0x2, 0x2, 0x6f0, 0x6ef, 0x3, 0x2, 0x2, 0x2, 0x6f0, 0x6f1, 
       0x3, 0x2, 0x2, 0x2, 0x6f1, 0x6f4, 0x3, 0x2, 0x2, 0x2, 0x6f2, 0x6f4, 
       0x5, 0xd0, 0x69, 0x2, 0x6f3, 0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6d7, 
       0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6de, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f2, 
       0x3, 0x2, 0x2, 0x2, 0x6f4, 0xa1, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f6, 
       0x7, 0x29, 0x2, 0x2, 0x6f6, 0x6f7, 0x7, 0x48, 0x2, 0x2, 0x6f7, 0x6fa, 
       0x9, 0x13, 0x2, 0x2, 0x6f8, 0x6fb, 0x5, 0x1a8, 0xd5, 0x2, 0x6f9, 
       0x6fb, 0x7, 0x191, 0x2, 0x2, 0x6fa, 0x6f8, 0x3, 0x2, 0x2, 0x2, 0x6fa, 
       0x6f9, 0x3, 0x2, 0x2, 0x2, 0x6fa, 0x6fb, 0x3, 0x2, 0x2, 0x2, 0x6fb, 
       0x6fd, 0x3, 0x2, 0x2, 0x2, 0x6fc, 0x6fe, 0x7, 0x1ad, 0x2, 0x2, 0x6fd, 
       0x6fc, 0x3, 0x2, 0x2, 0x2, 0x6fd, 0x6fe, 0x3, 0x2, 0x2, 0x2, 0x6fe, 
       0x747, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x700, 0x7, 0x29, 0x2, 0x2, 0x700, 
       0x70a, 0x9, 0x13, 0x2, 0x2, 0x701, 0x704, 0x5, 0x1a8, 0xd5, 0x2, 
       0x702, 0x704, 0x7, 0x191, 0x2, 0x2, 0x703, 0x701, 0x3, 0x2, 0x2, 
       0x2, 0x703, 0x702, 0x3, 0x2, 0x2, 0x2, 0x704, 0x708, 0x3, 0x2, 0x2, 
       0x2, 0x705, 0x706, 0x7, 0xa5, 0x2, 0x2, 0x706, 0x707, 0x7, 0x104, 
       0x2, 0x2, 0x707, 0x709, 0x7, 0x194, 0x2, 0x2, 0x708, 0x705, 0x3, 
       0x2, 0x2, 0x2, 0x708, 0x709, 0x3, 0x2, 0x2, 0x2, 0x709, 0x70b, 0x3, 
       0x2, 0x2, 0x2, 0x70a, 0x703, 0x3, 0x2, 0x2, 0x2, 0x70a, 0x70b, 0x3, 
       0x2, 0x2, 0x2, 0x70b, 0x70d, 0x3, 0x2, 0x2, 0x2, 0x70c, 0x70e, 0x7, 
       0x1ad, 0x2, 0x2, 0x70d, 0x70c, 0x3, 0x2, 0x2, 0x2, 0x70d, 0x70e, 
       0x3, 0x2, 0x2, 0x2, 0x70e, 0x747, 0x3, 0x2, 0x2, 0x2, 0x70f, 0x710, 
       0x7, 0x33, 0x2, 0x2, 0x710, 0x71d, 0x9, 0x13, 0x2, 0x2, 0x711, 0x714, 
       0x5, 0x1a8, 0xd5, 0x2, 0x712, 0x714, 0x7, 0x191, 0x2, 0x2, 0x713, 
       0x711, 0x3, 0x2, 0x2, 0x2, 0x713, 0x712, 0x3, 0x2, 0x2, 0x2, 0x714, 
       0x71b, 0x3, 0x2, 0x2, 0x2, 0x715, 0x716, 0x7, 0xa5, 0x2, 0x2, 0x716, 
       0x717, 0x7, 0x1aa, 0x2, 0x2, 0x717, 0x718, 0x7, 0xd0, 0x2, 0x2, 0x718, 
       0x719, 0x7, 0x198, 0x2, 0x2, 0x719, 0x71a, 0x9, 0x14, 0x2, 0x2, 0x71a, 
       0x71c, 0x7, 0x1ab, 0x2, 0x2, 0x71b, 0x715, 0x3, 0x2, 0x2, 0x2, 0x71b, 
       0x71c, 0x3, 0x2, 0x2, 0x2, 0x71c, 0x71e, 0x3, 0x2, 0x2, 0x2, 0x71d, 
       0x713, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x71e, 0x3, 0x2, 0x2, 0x2, 0x71e, 
       0x720, 0x3, 0x2, 0x2, 0x2, 0x71f, 0x721, 0x7, 0x1ad, 0x2, 0x2, 0x720, 
       0x71f, 0x3, 0x2, 0x2, 0x2, 0x720, 0x721, 0x3, 0x2, 0x2, 0x2, 0x721, 
       0x747, 0x3, 0x2, 0x2, 0x2, 0x722, 0x724, 0x7, 0x33, 0x2, 0x2, 0x723, 
       0x725, 0x7, 0x166, 0x2, 0x2, 0x724, 0x723, 0x3, 0x2, 0x2, 0x2, 0x724, 
       0x725, 0x3, 0x2, 0x2, 0x2, 0x725, 0x727, 0x3, 0x2, 0x2, 0x2, 0x726, 
       0x728, 0x7, 0x1ad, 0x2, 0x2, 0x727, 0x726, 0x3, 0x2, 0x2, 0x2, 0x727, 
       0x728, 0x3, 0x2, 0x2, 0x2, 0x728, 0x747, 0x3, 0x2, 0x2, 0x2, 0x729, 
       0x72a, 0x7, 0x33, 0x2, 0x2, 0x72a, 0x747, 0x5, 0x1a8, 0xd5, 0x2, 
       0x72b, 0x72c, 0x7, 0x88, 0x2, 0x2, 0x72c, 0x747, 0x5, 0x1a8, 0xd5, 
       0x2, 0x72d, 0x72e, 0x7, 0x88, 0x2, 0x2, 0x72e, 0x731, 0x9, 0x13, 
       0x2, 0x2, 0x72f, 0x732, 0x5, 0x1a8, 0xd5, 0x2, 0x730, 0x732, 0x7, 
       0x191, 0x2, 0x2, 0x731, 0x72f, 0x3, 0x2, 0x2, 0x2, 0x731, 0x730, 
       0x3, 0x2, 0x2, 0x2, 0x731, 0x732, 0x3, 0x2, 0x2, 0x2, 0x732, 0x734, 
       0x3, 0x2, 0x2, 0x2, 0x733, 0x735, 0x7, 0x1ad, 0x2, 0x2, 0x734, 0x733, 
       0x3, 0x2, 0x2, 0x2, 0x734, 0x735, 0x3, 0x2, 0x2, 0x2, 0x735, 0x747, 
       0x3, 0x2, 0x2, 0x2, 0x736, 0x738, 0x7, 0x88, 0x2, 0x2, 0x737, 0x739, 
       0x7, 0x166, 0x2, 0x2, 0x738, 0x737, 0x3, 0x2, 0x2, 0x2, 0x738, 0x739, 
       0x3, 0x2, 0x2, 0x2, 0x739, 0x73b, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x73c, 
       0x7, 0x1ad, 0x2, 0x2, 0x73b, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73b, 0x73c, 
       0x3, 0x2, 0x2, 0x2, 0x73c, 0x747, 0x3, 0x2, 0x2, 0x2, 0x73d, 0x73e, 
       0x7, 0x8b, 0x2, 0x2, 0x73e, 0x741, 0x9, 0x13, 0x2, 0x2, 0x73f, 0x742, 
       0x5, 0x1a8, 0xd5, 0x2, 0x740, 0x742, 0x7, 0x191, 0x2, 0x2, 0x741, 
       0x73f, 0x3, 0x2, 0x2, 0x2, 0x741, 0x740, 0x3, 0x2, 0x2, 0x2, 0x741, 
       0x742, 0x3, 0x2, 0x2, 0x2, 0x742, 0x744, 0x3, 0x2, 0x2, 0x2, 0x743, 
       0x745, 0x7, 0x1ad, 0x2, 0x2, 0x744, 0x743, 0x3, 0x2, 0x2, 0x2, 0x744, 
       0x745, 0x3, 0x2, 0x2, 0x2, 0x745, 0x747, 0x3, 0x2, 0x2, 0x2, 0x746, 
       0x6f5, 0x3, 0x2, 0x2, 0x2, 0x746, 0x6ff, 0x3, 0x2, 0x2, 0x2, 0x746, 
       0x70f, 0x3, 0x2, 0x2, 0x2, 0x746, 0x722, 0x3, 0x2, 0x2, 0x2, 0x746, 
       0x729, 0x3, 0x2, 0x2, 0x2, 0x746, 0x72b, 0x3, 0x2, 0x2, 0x2, 0x746, 
       0x72d, 0x3, 0x2, 0x2, 0x2, 0x746, 0x736, 0x3, 0x2, 0x2, 0x2, 0x746, 
       0x73d, 0x3, 0x2, 0x2, 0x2, 0x747, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x748, 
       0x74a, 0x7, 0xe7, 0x2, 0x2, 0x749, 0x74b, 0x7, 0x192, 0x2, 0x2, 0x74a, 
       0x749, 0x3, 0x2, 0x2, 0x2, 0x74a, 0x74b, 0x3, 0x2, 0x2, 0x2, 0x74b, 
       0xa5, 0x3, 0x2, 0x2, 0x2, 0x74c, 0x74e, 0x7, 0xe8, 0x2, 0x2, 0x74d, 
       0x74f, 0x7, 0x192, 0x2, 0x2, 0x74e, 0x74d, 0x3, 0x2, 0x2, 0x2, 0x74e, 
       0x74f, 0x3, 0x2, 0x2, 0x2, 0x74f, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x750, 
       0x751, 0x7, 0x9e, 0x2, 0x2, 0x751, 0x753, 0x5, 0x1a8, 0xd5, 0x2, 
       0x752, 0x754, 0x7, 0x1ad, 0x2, 0x2, 0x753, 0x752, 0x3, 0x2, 0x2, 
       0x2, 0x753, 0x754, 0x3, 0x2, 0x2, 0x2, 0x754, 0xa9, 0x3, 0x2, 0x2, 
       0x2, 0x755, 0x758, 0x7, 0x90, 0x2, 0x2, 0x756, 0x757, 0x7, 0xa5, 
       0x2, 0x2, 0x757, 0x759, 0x7, 0x111, 0x2, 0x2, 0x758, 0x756, 0x3, 
       0x2, 0x2, 0x2, 0x758, 0x759, 0x3, 0x2, 0x2, 0x2, 0x759, 0xab, 0x3, 
       0x2, 0x2, 0x2, 0x75a, 0x75b, 0x7, 0x41, 0x2, 0x2, 0x75b, 0x765, 0x7, 
       0x182, 0x2, 0x2, 0x75c, 0x75d, 0x7, 0x1aa, 0x2, 0x2, 0x75d, 0x75e, 
       0x7, 0x144, 0x2, 0x2, 0x75e, 0x762, 0x7, 0x198, 0x2, 0x2, 0x75f, 
       0x763, 0x5, 0xe0, 0x71, 0x2, 0x760, 0x763, 0x5, 0x1a8, 0xd5, 0x2, 
       0x761, 0x763, 0x7, 0x44, 0x2, 0x2, 0x762, 0x75f, 0x3, 0x2, 0x2, 0x2, 
       0x762, 0x760, 0x3, 0x2, 0x2, 0x2, 0x762, 0x761, 0x3, 0x2, 0x2, 0x2, 
       0x763, 0x764, 0x3, 0x2, 0x2, 0x2, 0x764, 0x766, 0x7, 0x1ab, 0x2, 
       0x2, 0x765, 0x75c, 0x3, 0x2, 0x2, 0x2, 0x765, 0x766, 0x3, 0x2, 0x2, 
       0x2, 0x766, 0x768, 0x3, 0x2, 0x2, 0x2, 0x767, 0x769, 0x7, 0x1ad, 
       0x2, 0x2, 0x768, 0x767, 0x3, 0x2, 0x2, 0x2, 0x768, 0x769, 0x3, 0x2, 
       0x2, 0x2, 0x769, 0xad, 0x3, 0x2, 0x2, 0x2, 0x76a, 0x76b, 0x7, 0x41, 
       0x2, 0x2, 0x76b, 0x770, 0x5, 0xb0, 0x59, 0x2, 0x76c, 0x76d, 0x7, 
       0x1aa, 0x2, 0x2, 0x76d, 0x76e, 0x5, 0x160, 0xb1, 0x2, 0x76e, 0x76f, 
       0x7, 0x1ab, 0x2, 0x2, 0x76f, 0x771, 0x3, 0x2, 0x2, 0x2, 0x770, 0x76c, 
       0x3, 0x2, 0x2, 0x2, 0x770, 0x771, 0x3, 0x2, 0x2, 0x2, 0x771, 0x774, 
       0x3, 0x2, 0x2, 0x2, 0x772, 0x773, 0x7, 0xa5, 0x2, 0x2, 0x773, 0x775, 
       0x5, 0xb2, 0x5a, 0x2, 0x774, 0x772, 0x3, 0x2, 0x2, 0x2, 0x774, 0x775, 
       0x3, 0x2, 0x2, 0x2, 0x775, 0x777, 0x3, 0x2, 0x2, 0x2, 0x776, 0x778, 
       0x7, 0x1ad, 0x2, 0x2, 0x777, 0x776, 0x3, 0x2, 0x2, 0x2, 0x777, 0x778, 
       0x3, 0x2, 0x2, 0x2, 0x778, 0xaf, 0x3, 0x2, 0x2, 0x2, 0x779, 0x77c, 
       0x5, 0x1aa, 0xd6, 0x2, 0x77a, 0x77c, 0x5, 0x1a6, 0xd4, 0x2, 0x77b, 
       0x779, 0x3, 0x2, 0x2, 0x2, 0x77b, 0x77a, 0x3, 0x2, 0x2, 0x2, 0x77c, 
       0xb1, 0x3, 0x2, 0x2, 0x2, 0x77d, 0x780, 0x5, 0x1aa, 0xd6, 0x2, 0x77e, 
       0x77f, 0x7, 0x1ac, 0x2, 0x2, 0x77f, 0x781, 0x5, 0x1aa, 0xd6, 0x2, 
       0x780, 0x77e, 0x3, 0x2, 0x2, 0x2, 0x780, 0x781, 0x3, 0x2, 0x2, 0x2, 
       0x781, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x782, 0x783, 0x7, 0x51, 0x2, 0x2, 
       0x783, 0x784, 0x7, 0x25, 0x2, 0x2, 0x784, 0x785, 0x9, 0x15, 0x2, 
       0x2, 0x785, 0xb5, 0x3, 0x2, 0x2, 0x2, 0x786, 0x788, 0x7, 0x191, 0x2, 
       0x2, 0x787, 0x789, 0x7, 0x25, 0x2, 0x2, 0x788, 0x787, 0x3, 0x2, 0x2, 
       0x2, 0x788, 0x789, 0x3, 0x2, 0x2, 0x2, 0x789, 0x78a, 0x3, 0x2, 0x2, 
       0x2, 0x78a, 0x78d, 0x5, 0x19e, 0xd0, 0x2, 0x78b, 0x78c, 0x7, 0x198, 
       0x2, 0x2, 0x78c, 0x78e, 0x5, 0xd4, 0x6b, 0x2, 0x78d, 0x78b, 0x3, 
       0x2, 0x2, 0x2, 0x78d, 0x78e, 0x3, 0x2, 0x2, 0x2, 0x78e, 0xb7, 0x3, 
       0x2, 0x2, 0x2, 0x78f, 0x790, 0x7, 0x93, 0x2, 0x2, 0x790, 0x791, 0x7, 
       0x1aa, 0x2, 0x2, 0x791, 0x792, 0x5, 0xba, 0x5e, 0x2, 0x792, 0x793, 
       0x7, 0x1ab, 0x2, 0x2, 0x793, 0xb9, 0x3, 0x2, 0x2, 0x2, 0x794, 0x79b, 
       0x5, 0xbc, 0x5f, 0x2, 0x795, 0x797, 0x7, 0x1ac, 0x2, 0x2, 0x796, 
       0x795, 0x3, 0x2, 0x2, 0x2, 0x796, 0x797, 0x3, 0x2, 0x2, 0x2, 0x797, 
       0x798, 0x3, 0x2, 0x2, 0x2, 0x798, 0x79a, 0x5, 0xbc, 0x5f, 0x2, 0x799, 
       0x796, 0x3, 0x2, 0x2, 0x2, 0x79a, 0x79d, 0x3, 0x2, 0x2, 0x2, 0x79b, 
       0x799, 0x3, 0x2, 0x2, 0x2, 0x79b, 0x79c, 0x3, 0x2, 0x2, 0x2, 0x79c, 
       0xbb, 0x3, 0x2, 0x2, 0x2, 0x79d, 0x79b, 0x3, 0x2, 0x2, 0x2, 0x79e, 
       0x7a1, 0x5, 0xbe, 0x60, 0x2, 0x79f, 0x7a1, 0x5, 0xc2, 0x62, 0x2, 
       0x7a0, 0x79e, 0x3, 0x2, 0x2, 0x2, 0x7a0, 0x79f, 0x3, 0x2, 0x2, 0x2, 
       0x7a1, 0xbd, 0x3, 0x2, 0x2, 0x2, 0x7a2, 0x7a9, 0x5, 0x1a8, 0xd5, 
       0x2, 0x7a3, 0x7aa, 0x5, 0x19e, 0xd0, 0x2, 0x7a4, 0x7a5, 0x7, 0x25, 
       0x2, 0x2, 0x7a5, 0x7a7, 0x5, 0xd4, 0x6b, 0x2, 0x7a6, 0x7a8, 0x7, 
       0x17e, 0x2, 0x2, 0x7a7, 0x7a6, 0x3, 0x2, 0x2, 0x2, 0x7a7, 0x7a8, 
       0x3, 0x2, 0x2, 0x2, 0x7a8, 0x7aa, 0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7a3, 
       0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7a4, 0x3, 0x2, 0x2, 0x2, 0x7aa, 0x7ad, 
       0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ac, 0x7, 0x31, 0x2, 0x2, 0x7ac, 0x7ae, 
       0x5, 0x1a8, 0xd5, 0x2, 0x7ad, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x7ad, 0x7ae, 
       0x3, 0x2, 0x2, 0x2, 0x7ae, 0x7b0, 0x3, 0x2, 0x2, 0x2, 0x7af, 0x7b1, 
       0x5, 0x198, 0xcd, 0x2, 0x7b0, 0x7af, 0x3, 0x2, 0x2, 0x2, 0x7b0, 0x7b1, 
       0x3, 0x2, 0x2, 0x2, 0x7b1, 0x7c7, 0x3, 0x2, 0x2, 0x2, 0x7b2, 0x7b3, 
       0x7, 0x35, 0x2, 0x2, 0x7b3, 0x7b5, 0x5, 0x1a8, 0xd5, 0x2, 0x7b4, 
       0x7b2, 0x3, 0x2, 0x2, 0x2, 0x7b4, 0x7b5, 0x3, 0x2, 0x2, 0x2, 0x7b5, 
       0x7b6, 0x3, 0x2, 0x2, 0x2, 0x7b6, 0x7b8, 0x5, 0x19a, 0xce, 0x2, 0x7b7, 
       0x7b9, 0x5, 0x19a, 0xce, 0x2, 0x7b8, 0x7b7, 0x3, 0x2, 0x2, 0x2, 0x7b8, 
       0x7b9, 0x3, 0x2, 0x2, 0x2, 0x7b9, 0x7c8, 0x3, 0x2, 0x2, 0x2, 0x7ba, 
       0x7c0, 0x7, 0x5d, 0x2, 0x2, 0x7bb, 0x7bc, 0x7, 0x1aa, 0x2, 0x2, 0x7bc, 
       0x7bd, 0x7, 0x192, 0x2, 0x2, 0x7bd, 0x7be, 0x7, 0x1ac, 0x2, 0x2, 
       0x7be, 0x7bf, 0x7, 0x192, 0x2, 0x2, 0x7bf, 0x7c1, 0x7, 0x1ab, 0x2, 
       0x2, 0x7c0, 0x7bb, 0x3, 0x2, 0x2, 0x2, 0x7c0, 0x7c1, 0x3, 0x2, 0x2, 
       0x2, 0x7c1, 0x7c5, 0x3, 0x2, 0x2, 0x2, 0x7c2, 0x7c3, 0x7, 0x6d, 0x2, 
       0x2, 0x7c3, 0x7c4, 0x7, 0x54, 0x2, 0x2, 0x7c4, 0x7c6, 0x7, 0x84, 
       0x2, 0x2, 0x7c5, 0x7c2, 0x3, 0x2, 0x2, 0x2, 0x7c5, 0x7c6, 0x3, 0x2, 
       0x2, 0x2, 0x7c6, 0x7c8, 0x3, 0x2, 0x2, 0x2, 0x7c7, 0x7b4, 0x3, 
  };
  static uint16_t serializedATNSegment1[] = {
    0x2, 0x2, 0x2, 0x7c7, 0x7ba, 0x3, 0x2, 0x2, 0x2, 0x7c7, 0x7c8, 0x3, 
       0x2, 0x2, 0x2, 0x7c8, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7c9, 0x7cb, 0x7, 
       0x8a, 0x2, 0x2, 0x7ca, 0x7c9, 0x3, 0x2, 0x2, 0x2, 0x7ca, 0x7cb, 0x3, 
       0x2, 0x2, 0x2, 0x7cb, 0x7cf, 0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7ce, 0x5, 
       0xc0, 0x61, 0x2, 0x7cd, 0x7cc, 0x3, 0x2, 0x2, 0x2, 0x7ce, 0x7d1, 
       0x3, 0x2, 0x2, 0x2, 0x7cf, 0x7cd, 0x3, 0x2, 0x2, 0x2, 0x7cf, 0x7d0, 
       0x3, 0x2, 0x2, 0x2, 0x7d0, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x7d1, 0x7cf, 
       0x3, 0x2, 0x2, 0x2, 0x7d2, 0x7d3, 0x7, 0x35, 0x2, 0x2, 0x7d3, 0x7d5, 
       0x5, 0x1a8, 0xd5, 0x2, 0x7d4, 0x7d2, 0x3, 0x2, 0x2, 0x2, 0x7d4, 0x7d5, 
       0x3, 0x2, 0x2, 0x2, 0x7d5, 0x7f3, 0x3, 0x2, 0x2, 0x2, 0x7d6, 0x7d7, 
       0x7, 0x7d, 0x2, 0x2, 0x7d7, 0x7da, 0x7, 0x68, 0x2, 0x2, 0x7d8, 0x7da, 
       0x7, 0x9b, 0x2, 0x2, 0x7d9, 0x7d6, 0x3, 0x2, 0x2, 0x2, 0x7d9, 0x7d8, 
       0x3, 0x2, 0x2, 0x2, 0x7da, 0x7dc, 0x3, 0x2, 0x2, 0x2, 0x7db, 0x7dd, 
       0x5, 0xc4, 0x63, 0x2, 0x7dc, 0x7db, 0x3, 0x2, 0x2, 0x2, 0x7dc, 0x7dd, 
       0x3, 0x2, 0x2, 0x2, 0x7dd, 0x7f4, 0x3, 0x2, 0x2, 0x2, 0x7de, 0x7e2, 
       0x7, 0x2e, 0x2, 0x2, 0x7df, 0x7e0, 0x7, 0x6d, 0x2, 0x2, 0x7e0, 0x7e1, 
       0x7, 0x54, 0x2, 0x2, 0x7e1, 0x7e3, 0x7, 0x84, 0x2, 0x2, 0x7e2, 0x7df, 
       0x3, 0x2, 0x2, 0x2, 0x7e2, 0x7e3, 0x3, 0x2, 0x2, 0x2, 0x7e3, 0x7e4, 
       0x3, 0x2, 0x2, 0x2, 0x7e4, 0x7e5, 0x7, 0x1aa, 0x2, 0x2, 0x7e5, 0x7e6, 
       0x5, 0xec, 0x77, 0x2, 0x7e6, 0x7e7, 0x7, 0x1ab, 0x2, 0x2, 0x7e7, 
       0x7f4, 0x3, 0x2, 0x2, 0x2, 0x7e8, 0x7e9, 0x7, 0x55, 0x2, 0x2, 0x7e9, 
       0x7eb, 0x7, 0x68, 0x2, 0x2, 0x7ea, 0x7e8, 0x3, 0x2, 0x2, 0x2, 0x7ea, 
       0x7eb, 0x3, 0x2, 0x2, 0x2, 0x7eb, 0x7ec, 0x3, 0x2, 0x2, 0x2, 0x7ec, 
       0x7ed, 0x7, 0x83, 0x2, 0x2, 0x7ed, 0x7ee, 0x5, 0x17e, 0xc0, 0x2, 
       0x7ee, 0x7ef, 0x7, 0x1aa, 0x2, 0x2, 0x7ef, 0x7f0, 0x5, 0x192, 0xca, 
       0x2, 0x7f0, 0x7f1, 0x7, 0x1ab, 0x2, 0x2, 0x7f1, 0x7f4, 0x3, 0x2, 
       0x2, 0x2, 0x7f2, 0x7f4, 0x5, 0x198, 0xcd, 0x2, 0x7f3, 0x7d9, 0x3, 
       0x2, 0x2, 0x2, 0x7f3, 0x7de, 0x3, 0x2, 0x2, 0x2, 0x7f3, 0x7ea, 0x3, 
       0x2, 0x2, 0x2, 0x7f3, 0x7f2, 0x3, 0x2, 0x2, 0x2, 0x7f4, 0xc1, 0x3, 
       0x2, 0x2, 0x2, 0x7f5, 0x7f6, 0x7, 0x35, 0x2, 0x2, 0x7f6, 0x7f8, 0x5, 
       0x1a8, 0xd5, 0x2, 0x7f7, 0x7f5, 0x3, 0x2, 0x2, 0x2, 0x7f7, 0x7f8, 
       0x3, 0x2, 0x2, 0x2, 0x7f8, 0x830, 0x3, 0x2, 0x2, 0x2, 0x7f9, 0x7fa, 
       0x7, 0x7d, 0x2, 0x2, 0x7fa, 0x7fd, 0x7, 0x68, 0x2, 0x2, 0x7fb, 0x7fd, 
       0x7, 0x9b, 0x2, 0x2, 0x7fc, 0x7f9, 0x3, 0x2, 0x2, 0x2, 0x7fc, 0x7fb, 
       0x3, 0x2, 0x2, 0x2, 0x7fd, 0x7fe, 0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7ff, 
       0x7, 0x1aa, 0x2, 0x2, 0x7ff, 0x800, 0x5, 0x18c, 0xc7, 0x2, 0x800, 
       0x802, 0x7, 0x1ab, 0x2, 0x2, 0x801, 0x803, 0x5, 0xc4, 0x63, 0x2, 
       0x802, 0x801, 0x3, 0x2, 0x2, 0x2, 0x802, 0x803, 0x3, 0x2, 0x2, 0x2, 
       0x803, 0x806, 0x3, 0x2, 0x2, 0x2, 0x804, 0x805, 0x7, 0x72, 0x2, 0x2, 
       0x805, 0x807, 0x5, 0x1a8, 0xd5, 0x2, 0x806, 0x804, 0x3, 0x2, 0x2, 
       0x2, 0x806, 0x807, 0x3, 0x2, 0x2, 0x2, 0x807, 0x831, 0x3, 0x2, 0x2, 
       0x2, 0x808, 0x80c, 0x7, 0x2e, 0x2, 0x2, 0x809, 0x80a, 0x7, 0x6d, 
       0x2, 0x2, 0x80a, 0x80b, 0x7, 0x54, 0x2, 0x2, 0x80b, 0x80d, 0x7, 0x84, 
       0x2, 0x2, 0x80c, 0x809, 0x3, 0x2, 0x2, 0x2, 0x80c, 0x80d, 0x3, 0x2, 
       0x2, 0x2, 0x80d, 0x80e, 0x3, 0x2, 0x2, 0x2, 0x80e, 0x80f, 0x7, 0x1aa, 
       0x2, 0x2, 0x80f, 0x810, 0x5, 0xec, 0x77, 0x2, 0x810, 0x811, 0x7, 
       0x1ab, 0x2, 0x2, 0x811, 0x831, 0x3, 0x2, 0x2, 0x2, 0x812, 0x814, 
       0x7, 0x44, 0x2, 0x2, 0x813, 0x815, 0x7, 0x1aa, 0x2, 0x2, 0x814, 0x813, 
       0x3, 0x2, 0x2, 0x2, 0x814, 0x815, 0x3, 0x2, 0x2, 0x2, 0x815, 0x81a, 
       0x3, 0x2, 0x2, 0x2, 0x816, 0x81b, 0x7, 0x194, 0x2, 0x2, 0x817, 0x81b, 
       0x7, 0x1b3, 0x2, 0x2, 0x818, 0x81b, 0x5, 0x140, 0xa1, 0x2, 0x819, 
       0x81b, 0x7, 0x192, 0x2, 0x2, 0x81a, 0x816, 0x3, 0x2, 0x2, 0x2, 0x81a, 
       0x817, 0x3, 0x2, 0x2, 0x2, 0x81a, 0x818, 0x3, 0x2, 0x2, 0x2, 0x81a, 
       0x819, 0x3, 0x2, 0x2, 0x2, 0x81b, 0x81c, 0x3, 0x2, 0x2, 0x2, 0x81c, 
       0x81a, 0x3, 0x2, 0x2, 0x2, 0x81c, 0x81d, 0x3, 0x2, 0x2, 0x2, 0x81d, 
       0x81f, 0x3, 0x2, 0x2, 0x2, 0x81e, 0x820, 0x7, 0x1ab, 0x2, 0x2, 0x81f, 
       0x81e, 0x3, 0x2, 0x2, 0x2, 0x81f, 0x820, 0x3, 0x2, 0x2, 0x2, 0x820, 
       0x821, 0x3, 0x2, 0x2, 0x2, 0x821, 0x822, 0x7, 0x54, 0x2, 0x2, 0x822, 
       0x831, 0x5, 0x1a8, 0xd5, 0x2, 0x823, 0x824, 0x7, 0x55, 0x2, 0x2, 
       0x824, 0x825, 0x7, 0x68, 0x2, 0x2, 0x825, 0x826, 0x7, 0x1aa, 0x2, 
       0x2, 0x826, 0x827, 0x5, 0x192, 0xca, 0x2, 0x827, 0x828, 0x7, 0x1ab, 
       0x2, 0x2, 0x828, 0x829, 0x7, 0x83, 0x2, 0x2, 0x829, 0x82e, 0x5, 0x17e, 
       0xc0, 0x2, 0x82a, 0x82b, 0x7, 0x1aa, 0x2, 0x2, 0x82b, 0x82c, 0x5, 
       0x192, 0xca, 0x2, 0x82c, 0x82d, 0x7, 0x1ab, 0x2, 0x2, 0x82d, 0x82f, 
       0x3, 0x2, 0x2, 0x2, 0x82e, 0x82a, 0x3, 0x2, 0x2, 0x2, 0x82e, 0x82f, 
       0x3, 0x2, 0x2, 0x2, 0x82f, 0x831, 0x3, 0x2, 0x2, 0x2, 0x830, 0x7fc, 
       0x3, 0x2, 0x2, 0x2, 0x830, 0x808, 0x3, 0x2, 0x2, 0x2, 0x830, 0x812, 
       0x3, 0x2, 0x2, 0x2, 0x830, 0x823, 0x3, 0x2, 0x2, 0x2, 0x831, 0xc3, 
       0x3, 0x2, 0x2, 0x2, 0x832, 0x833, 0x7, 0xa5, 0x2, 0x2, 0x833, 0x834, 
       0x7, 0x1aa, 0x2, 0x2, 0x834, 0x839, 0x5, 0xc6, 0x64, 0x2, 0x835, 
       0x836, 0x7, 0x1ac, 0x2, 0x2, 0x836, 0x838, 0x5, 0xc6, 0x64, 0x2, 
       0x837, 0x835, 0x3, 0x2, 0x2, 0x2, 0x838, 0x83b, 0x3, 0x2, 0x2, 0x2, 
       0x839, 0x837, 0x3, 0x2, 0x2, 0x2, 0x839, 0x83a, 0x3, 0x2, 0x2, 0x2, 
       0x83a, 0x83c, 0x3, 0x2, 0x2, 0x2, 0x83b, 0x839, 0x3, 0x2, 0x2, 0x2, 
       0x83c, 0x83d, 0x7, 0x1ab, 0x2, 0x2, 0x83d, 0xc5, 0x3, 0x2, 0x2, 0x2, 
       0x83e, 0x841, 0x5, 0x1aa, 0xd6, 0x2, 0x83f, 0x841, 0x5, 0x1a6, 0xd4, 
       0x2, 0x840, 0x83e, 0x3, 0x2, 0x2, 0x2, 0x840, 0x83f, 0x3, 0x2, 0x2, 
       0x2, 0x841, 0x842, 0x3, 0x2, 0x2, 0x2, 0x842, 0x847, 0x7, 0x198, 
       0x2, 0x2, 0x843, 0x848, 0x5, 0x1aa, 0xd6, 0x2, 0x844, 0x848, 0x5, 
       0x1a6, 0xd4, 0x2, 0x845, 0x848, 0x5, 0x196, 0xcc, 0x2, 0x846, 0x848, 
       0x7, 0x192, 0x2, 0x2, 0x847, 0x843, 0x3, 0x2, 0x2, 0x2, 0x847, 0x844, 
       0x3, 0x2, 0x2, 0x2, 0x847, 0x845, 0x3, 0x2, 0x2, 0x2, 0x847, 0x846, 
       0x3, 0x2, 0x2, 0x2, 0x848, 0xc7, 0x3, 0x2, 0x2, 0x2, 0x849, 0x84a, 
       0x7, 0x43, 0x2, 0x2, 0x84a, 0x86a, 0x5, 0x194, 0xcb, 0x2, 0x84b, 
       0x855, 0x7, 0x3f, 0x2, 0x2, 0x84c, 0x853, 0x5, 0xca, 0x66, 0x2, 0x84d, 
       0x84e, 0x7, 0x54, 0x2, 0x2, 0x84e, 0x851, 0x7, 0x9d, 0x2, 0x2, 0x84f, 
       0x850, 0x7, 0x70, 0x2, 0x2, 0x850, 0x852, 0x5, 0x192, 0xca, 0x2, 
       0x851, 0x84f, 0x3, 0x2, 0x2, 0x2, 0x851, 0x852, 0x3, 0x2, 0x2, 0x2, 
       0x852, 0x854, 0x3, 0x2, 0x2, 0x2, 0x853, 0x84d, 0x3, 0x2, 0x2, 0x2, 
       0x853, 0x854, 0x3, 0x2, 0x2, 0x2, 0x854, 0x856, 0x3, 0x2, 0x2, 0x2, 
       0x855, 0x84c, 0x3, 0x2, 0x2, 0x2, 0x855, 0x856, 0x3, 0x2, 0x2, 0x2, 
       0x856, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x857, 0x859, 0x9, 0x16, 0x2, 0x2, 
       0x858, 0x857, 0x3, 0x2, 0x2, 0x2, 0x858, 0x859, 0x3, 0x2, 0x2, 0x2, 
       0x859, 0x85b, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x85c, 0x7, 0x13a, 0x2, 
       0x2, 0x85b, 0x85a, 0x3, 0x2, 0x2, 0x2, 0x85b, 0x85c, 0x3, 0x2, 0x2, 
       0x2, 0x85c, 0x85d, 0x3, 0x2, 0x2, 0x2, 0x85d, 0x85e, 0x7, 0x3f, 0x2, 
       0x2, 0x85e, 0x85f, 0x7, 0x54, 0x2, 0x2, 0x85f, 0x868, 0x5, 0x58, 
       0x2d, 0x2, 0x860, 0x866, 0x7, 0x54, 0x2, 0x2, 0x861, 0x862, 0x7, 
       0x82, 0x2, 0x2, 0x862, 0x867, 0x7, 0x118, 0x2, 0x2, 0x863, 0x867, 
       0x7, 0x9d, 0x2, 0x2, 0x864, 0x865, 0x7, 0x70, 0x2, 0x2, 0x865, 0x867, 
       0x5, 0x192, 0xca, 0x2, 0x866, 0x861, 0x3, 0x2, 0x2, 0x2, 0x866, 0x863, 
       0x3, 0x2, 0x2, 0x2, 0x866, 0x864, 0x3, 0x2, 0x2, 0x2, 0x867, 0x869, 
       0x3, 0x2, 0x2, 0x2, 0x868, 0x860, 0x3, 0x2, 0x2, 0x2, 0x868, 0x869, 
       0x3, 0x2, 0x2, 0x2, 0x869, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x86a, 0x84b, 
       0x3, 0x2, 0x2, 0x2, 0x86a, 0x858, 0x3, 0x2, 0x2, 0x2, 0x86b, 0x86d, 
       0x3, 0x2, 0x2, 0x2, 0x86c, 0x86e, 0x7, 0x1ad, 0x2, 0x2, 0x86d, 0x86c, 
       0x3, 0x2, 0x2, 0x2, 0x86d, 0x86e, 0x3, 0x2, 0x2, 0x2, 0x86e, 0xc9, 
       0x3, 0x2, 0x2, 0x2, 0x86f, 0x871, 0x5, 0xcc, 0x67, 0x2, 0x870, 0x86f, 
       0x3, 0x2, 0x2, 0x2, 0x871, 0x874, 0x3, 0x2, 0x2, 0x2, 0x872, 0x870, 
       0x3, 0x2, 0x2, 0x2, 0x872, 0x873, 0x3, 0x2, 0x2, 0x2, 0x873, 0x875, 
       0x3, 0x2, 0x2, 0x2, 0x874, 0x872, 0x3, 0x2, 0x2, 0x2, 0x875, 0x876, 
       0x7, 0x54, 0x2, 0x2, 0x876, 0x877, 0x5, 0x58, 0x2d, 0x2, 0x877, 0xcb, 
       0x3, 0x2, 0x2, 0x2, 0x878, 0x87e, 0x9, 0xf, 0x2, 0x2, 0x879, 0x87e, 
       0x9, 0x17, 0x2, 0x2, 0x87a, 0x87e, 0x9, 0x18, 0x2, 0x2, 0x87b, 0x87e, 
       0x9, 0x19, 0x2, 0x2, 0x87c, 0x87e, 0x7, 0x15b, 0x2, 0x2, 0x87d, 0x878, 
       0x3, 0x2, 0x2, 0x2, 0x87d, 0x879, 0x3, 0x2, 0x2, 0x2, 0x87d, 0x87a, 
       0x3, 0x2, 0x2, 0x2, 0x87d, 0x87b, 0x3, 0x2, 0x2, 0x2, 0x87d, 0x87c, 
       0x3, 0x2, 0x2, 0x2, 0x87e, 0xcd, 0x3, 0x2, 0x2, 0x2, 0x87f, 0x889, 
       0x7, 0x53, 0x2, 0x2, 0x880, 0x887, 0x7, 0x10c, 0x2, 0x2, 0x881, 0x887, 
       0x7, 0x125, 0x2, 0x2, 0x882, 0x887, 0x7, 0xde, 0x2, 0x2, 0x883, 0x887, 
       0x7, 0xf9, 0x2, 0x2, 0x884, 0x885, 0x9, 0x1a, 0x2, 0x2, 0x885, 0x887, 
       0x5, 0xd4, 0x6b, 0x2, 0x886, 0x880, 0x3, 0x2, 0x2, 0x2, 0x886, 0x881, 
       0x3, 0x2, 0x2, 0x2, 0x886, 0x882, 0x3, 0x2, 0x2, 0x2, 0x886, 0x883, 
       0x3, 0x2, 0x2, 0x2, 0x886, 0x884, 0x3, 0x2, 0x2, 0x2, 0x886, 0x887, 
       0x3, 0x2, 0x2, 0x2, 0x887, 0x888, 0x3, 0x2, 0x2, 0x2, 0x888, 0x88a, 
       0x7, 0x56, 0x2, 0x2, 0x889, 0x886, 0x3, 0x2, 0x2, 0x2, 0x889, 0x88a, 
       0x3, 0x2, 0x2, 0x2, 0x88a, 0x88c, 0x3, 0x2, 0x2, 0x2, 0x88b, 0x88d, 
       0x7, 0xe6, 0x2, 0x2, 0x88c, 0x88b, 0x3, 0x2, 0x2, 0x2, 0x88c, 0x88d, 
       0x3, 0x2, 0x2, 0x2, 0x88d, 0x88e, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x898, 
       0x5, 0x194, 0xcb, 0x2, 0x88f, 0x890, 0x7, 0x65, 0x2, 0x2, 0x890, 
       0x895, 0x7, 0x191, 0x2, 0x2, 0x891, 0x892, 0x7, 0x1ac, 0x2, 0x2, 
       0x892, 0x894, 0x7, 0x191, 0x2, 0x2, 0x893, 0x891, 0x3, 0x2, 0x2, 
       0x2, 0x894, 0x897, 0x3, 0x2, 0x2, 0x2, 0x895, 0x893, 0x3, 0x2, 0x2, 
       0x2, 0x895, 0x896, 0x3, 0x2, 0x2, 0x2, 0x896, 0x899, 0x3, 0x2, 0x2, 
       0x2, 0x897, 0x895, 0x3, 0x2, 0x2, 0x2, 0x898, 0x88f, 0x3, 0x2, 0x2, 
       0x2, 0x898, 0x899, 0x3, 0x2, 0x2, 0x2, 0x899, 0x89b, 0x3, 0x2, 0x2, 
       0x2, 0x89a, 0x89c, 0x7, 0x1ad, 0x2, 0x2, 0x89b, 0x89a, 0x3, 0x2, 
       0x2, 0x2, 0x89b, 0x89c, 0x3, 0x2, 0x2, 0x2, 0x89c, 0xcf, 0x3, 0x2, 
       0x2, 0x2, 0x89d, 0x89e, 0x7, 0x8f, 0x2, 0x2, 0x89e, 0x8a2, 0x5, 0x1a8, 
       0xd5, 0x2, 0x89f, 0x8a3, 0x5, 0x1a8, 0xd5, 0x2, 0x8a0, 0x8a3, 0x5, 
       0xd2, 0x6a, 0x2, 0x8a1, 0x8a3, 0x5, 0x196, 0xcc, 0x2, 0x8a2, 0x89f, 
       0x3, 0x2, 0x2, 0x2, 0x8a2, 0x8a0, 0x3, 0x2, 0x2, 0x2, 0x8a2, 0x8a1, 
       0x3, 0x2, 0x2, 0x2, 0x8a3, 0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a4, 0x8a6, 
       0x7, 0x1ad, 0x2, 0x2, 0x8a5, 0x8a4, 0x3, 0x2, 0x2, 0x2, 0x8a5, 0x8a6, 
       0x3, 0x2, 0x2, 0x2, 0x8a6, 0x8ca, 0x3, 0x2, 0x2, 0x2, 0x8a7, 0x8a8, 
       0x7, 0x8f, 0x2, 0x2, 0x8a8, 0x8a9, 0x7, 0x89, 0x2, 0x2, 0x8a9, 0x8ab, 
       0x9, 0x2, 0x2, 0x2, 0x8aa, 0x8ac, 0x7, 0x1ad, 0x2, 0x2, 0x8ab, 0x8aa, 
       0x3, 0x2, 0x2, 0x2, 0x8ab, 0x8ac, 0x3, 0x2, 0x2, 0x2, 0x8ac, 0x8ca, 
       0x3, 0x2, 0x2, 0x2, 0x8ad, 0x8ae, 0x7, 0x8f, 0x2, 0x2, 0x8ae, 0x8af, 
       0x7, 0x98, 0x2, 0x2, 0x8af, 0x8b0, 0x7, 0xf4, 0x2, 0x2, 0x8b0, 0x8ba, 
       0x7, 0xfc, 0x2, 0x2, 0x8b1, 0x8b2, 0x7, 0x82, 0x2, 0x2, 0x8b2, 0x8bb, 
       0x7, 0x15d, 0x2, 0x2, 0x8b3, 0x8b4, 0x7, 0x82, 0x2, 0x2, 0x8b4, 0x8bb, 
       0x7, 0xc0, 0x2, 0x2, 0x8b5, 0x8b6, 0x7, 0x133, 0x2, 0x2, 0x8b6, 0x8bb, 
       0x7, 0x82, 0x2, 0x2, 0x8b7, 0x8bb, 0x7, 0x146, 0x2, 0x2, 0x8b8, 0x8bb, 
       0x7, 0x140, 0x2, 0x2, 0x8b9, 0x8bb, 0x7, 0x192, 0x2, 0x2, 0x8ba, 
       0x8b1, 0x3, 0x2, 0x2, 0x2, 0x8ba, 0x8b3, 0x3, 0x2, 0x2, 0x2, 0x8ba, 
       0x8b5, 0x3, 0x2, 0x2, 0x2, 0x8ba, 0x8b7, 0x3, 0x2, 0x2, 0x2, 0x8ba, 
       0x8b8, 0x3, 0x2, 0x2, 0x2, 0x8ba, 0x8b9, 0x3, 0x2, 0x2, 0x2, 0x8bb, 
       0x8bd, 0x3, 0x2, 0x2, 0x2, 0x8bc, 0x8be, 0x7, 0x1ad, 0x2, 0x2, 0x8bd, 
       0x8bc, 0x3, 0x2, 0x2, 0x2, 0x8bd, 0x8be, 0x3, 0x2, 0x2, 0x2, 0x8be, 
       0x8ca, 0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8c0, 0x7, 0x8f, 0x2, 0x2, 0x8c0, 
       0x8c1, 0x7, 0x5e, 0x2, 0x2, 0x8c1, 0x8c2, 0x5, 0x17e, 0xc0, 0x2, 
       0x8c2, 0x8c4, 0x5, 0x196, 0xcc, 0x2, 0x8c3, 0x8c5, 0x7, 0x1ad, 0x2, 
       0x2, 0x8c4, 0x8c3, 0x3, 0x2, 0x2, 0x2, 0x8c4, 0x8c5, 0x3, 0x2, 0x2, 
       0x2, 0x8c5, 0x8ca, 0x3, 0x2, 0x2, 0x2, 0x8c6, 0x8c7, 0x7, 0x8f, 0x2, 
       0x2, 0x8c7, 0x8c8, 0x9, 0x1b, 0x2, 0x2, 0x8c8, 0x8ca, 0x5, 0x196, 
       0xcc, 0x2, 0x8c9, 0x89d, 0x3, 0x2, 0x2, 0x2, 0x8c9, 0x8a7, 0x3, 0x2, 
       0x2, 0x2, 0x8c9, 0x8ad, 0x3, 0x2, 0x2, 0x2, 0x8c9, 0x8bf, 0x3, 0x2, 
       0x2, 0x2, 0x8c9, 0x8c6, 0x3, 0x2, 0x2, 0x2, 0x8ca, 0xd1, 0x3, 0x2, 
       0x2, 0x2, 0x8cb, 0x8ce, 0x5, 0x1a2, 0xd2, 0x2, 0x8cc, 0x8ce, 0x7, 
       0x191, 0x2, 0x2, 0x8cd, 0x8cb, 0x3, 0x2, 0x2, 0x2, 0x8cd, 0x8cc, 
       0x3, 0x2, 0x2, 0x2, 0x8ce, 0xd3, 0x3, 0x2, 0x2, 0x2, 0x8cf, 0x8d0, 
       0x8, 0x6b, 0x1, 0x2, 0x8d0, 0x8d9, 0x5, 0xd8, 0x6d, 0x2, 0x8d1, 0x8d9, 
       0x5, 0x140, 0xa1, 0x2, 0x8d2, 0x8d9, 0x5, 0xda, 0x6e, 0x2, 0x8d3, 
       0x8d9, 0x5, 0x18a, 0xc6, 0x2, 0x8d4, 0x8d9, 0x5, 0xde, 0x70, 0x2, 
       0x8d5, 0x8d9, 0x5, 0xdc, 0x6f, 0x2, 0x8d6, 0x8d9, 0x5, 0x16a, 0xb6, 
       0x2, 0x8d7, 0x8d9, 0x7, 0x168, 0x2, 0x2, 0x8d8, 0x8cf, 0x3, 0x2, 
       0x2, 0x2, 0x8d8, 0x8d1, 0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d2, 0x3, 0x2, 
       0x2, 0x2, 0x8d8, 0x8d3, 0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d4, 0x3, 0x2, 
       0x2, 0x2, 0x8d8, 0x8d5, 0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d6, 0x3, 0x2, 
       0x2, 0x2, 0x8d8, 0x8d7, 0x3, 0x2, 0x2, 0x2, 0x8d9, 0x8e7, 0x3, 0x2, 
       0x2, 0x2, 0x8da, 0x8db, 0xc, 0x7, 0x2, 0x2, 0x8db, 0x8dc, 0x9, 0x1c, 
       0x2, 0x2, 0x8dc, 0x8e6, 0x5, 0xd4, 0x6b, 0x8, 0x8dd, 0x8de, 0xc, 
       0x6, 0x2, 0x2, 0x8de, 0x8df, 0x9, 0x1d, 0x2, 0x2, 0x8df, 0x8e6, 0x5, 
       0xd4, 0x6b, 0x7, 0x8e0, 0x8e1, 0xc, 0xc, 0x2, 0x2, 0x8e1, 0x8e2, 
       0x7, 0x31, 0x2, 0x2, 0x8e2, 0x8e6, 0x5, 0x1a8, 0xd5, 0x2, 0x8e3, 
       0x8e4, 0xc, 0x5, 0x2, 0x2, 0x8e4, 0x8e6, 0x5, 0xd6, 0x6c, 0x2, 0x8e5, 
       0x8da, 0x3, 0x2, 0x2, 0x2, 0x8e5, 0x8dd, 0x3, 0x2, 0x2, 0x2, 0x8e5, 
       0x8e0, 0x3, 0x2, 0x2, 0x2, 0x8e5, 0x8e3, 0x3, 0x2, 0x2, 0x2, 0x8e6, 
       0x8e9, 0x3, 0x2, 0x2, 0x2, 0x8e7, 0x8e5, 0x3, 0x2, 0x2, 0x2, 0x8e7, 
       0x8e8, 0x3, 0x2, 0x2, 0x2, 0x8e8, 0xd5, 0x3, 0x2, 0x2, 0x2, 0x8e9, 
       0x8e7, 0x3, 0x2, 0x2, 0x2, 0x8ea, 0x8eb, 0x7, 0xa9, 0x2, 0x2, 0x8eb, 
       0x8ec, 0x7, 0x153, 0x2, 0x2, 0x8ec, 0x8ed, 0x7, 0x167, 0x2, 0x2, 
       0x8ed, 0x8ee, 0x5, 0xd4, 0x6b, 0x2, 0x8ee, 0xd7, 0x3, 0x2, 0x2, 0x2, 
       0x8ef, 0x8f4, 0x7, 0x44, 0x2, 0x2, 0x8f0, 0x8f4, 0x7, 0x6e, 0x2, 
       0x2, 0x8f1, 0x8f4, 0x7, 0x191, 0x2, 0x2, 0x8f2, 0x8f4, 0x5, 0x1a2, 
       0xd2, 0x2, 0x8f3, 0x8ef, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0x8f0, 0x3, 0x2, 
       0x2, 0x2, 0x8f3, 0x8f1, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0x8f2, 0x3, 0x2, 
       0x2, 0x2, 0x8f4, 0xd9, 0x3, 0x2, 0x2, 0x2, 0x8f5, 0x8f6, 0x7, 0x2d, 
       0x2, 0x2, 0x8f6, 0x8f8, 0x5, 0xd4, 0x6b, 0x2, 0x8f7, 0x8f9, 0x5, 
       0x148, 0xa5, 0x2, 0x8f8, 0x8f7, 0x3, 0x2, 0x2, 0x2, 0x8f9, 0x8fa, 
       0x3, 0x2, 0x2, 0x2, 0x8fa, 0x8f8, 0x3, 0x2, 0x2, 0x2, 0x8fa, 0x8fb, 
       0x3, 0x2, 0x2, 0x2, 0x8fb, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x8fc, 0x8fd, 
       0x7, 0x4d, 0x2, 0x2, 0x8fd, 0x8ff, 0x5, 0xd4, 0x6b, 0x2, 0x8fe, 0x8fc, 
       0x3, 0x2, 0x2, 0x2, 0x8fe, 0x8ff, 0x3, 0x2, 0x2, 0x2, 0x8ff, 0x900, 
       0x3, 0x2, 0x2, 0x2, 0x900, 0x901, 0x7, 0x4e, 0x2, 0x2, 0x901, 0x90f, 
       0x3, 0x2, 0x2, 0x2, 0x902, 0x904, 0x7, 0x2d, 0x2, 0x2, 0x903, 0x905, 
       0x5, 0x14a, 0xa6, 0x2, 0x904, 0x903, 0x3, 0x2, 0x2, 0x2, 0x905, 0x906, 
       0x3, 0x2, 0x2, 0x2, 0x906, 0x904, 0x3, 0x2, 0x2, 0x2, 0x906, 0x907, 
       0x3, 0x2, 0x2, 0x2, 0x907, 0x90a, 0x3, 0x2, 0x2, 0x2, 0x908, 0x909, 
       0x7, 0x4d, 0x2, 0x2, 0x909, 0x90b, 0x5, 0xd4, 0x6b, 0x2, 0x90a, 0x908, 
       0x3, 0x2, 0x2, 0x2, 0x90a, 0x90b, 0x3, 0x2, 0x2, 0x2, 0x90b, 0x90c, 
       0x3, 0x2, 0x2, 0x2, 0x90c, 0x90d, 0x7, 0x4e, 0x2, 0x2, 0x90d, 0x90f, 
       0x3, 0x2, 0x2, 0x2, 0x90e, 0x8f5, 0x3, 0x2, 0x2, 0x2, 0x90e, 0x902, 
       0x3, 0x2, 0x2, 0x2, 0x90f, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x910, 0x911, 
       0x7, 0x1b5, 0x2, 0x2, 0x911, 0x915, 0x5, 0xd4, 0x6b, 0x2, 0x912, 
       0x913, 0x9, 0x1e, 0x2, 0x2, 0x913, 0x915, 0x5, 0xd4, 0x6b, 0x2, 0x914, 
       0x910, 0x3, 0x2, 0x2, 0x2, 0x914, 0x912, 0x3, 0x2, 0x2, 0x2, 0x915, 
       0xdd, 0x3, 0x2, 0x2, 0x2, 0x916, 0x917, 0x7, 0x1aa, 0x2, 0x2, 0x917, 
       0x918, 0x5, 0xd4, 0x6b, 0x2, 0x918, 0x919, 0x7, 0x1ab, 0x2, 0x2, 
       0x919, 0x91f, 0x3, 0x2, 0x2, 0x2, 0x91a, 0x91b, 0x7, 0x1aa, 0x2, 
       0x2, 0x91b, 0x91c, 0x5, 0xe2, 0x72, 0x2, 0x91c, 0x91d, 0x7, 0x1ab, 
       0x2, 0x2, 0x91d, 0x91f, 0x3, 0x2, 0x2, 0x2, 0x91e, 0x916, 0x3, 0x2, 
       0x2, 0x2, 0x91e, 0x91a, 0x3, 0x2, 0x2, 0x2, 0x91f, 0xdf, 0x3, 0x2, 
       0x2, 0x2, 0x920, 0x929, 0x7, 0x6e, 0x2, 0x2, 0x921, 0x929, 0x5, 0x1a2, 
       0xd2, 0x2, 0x922, 0x929, 0x5, 0x140, 0xa1, 0x2, 0x923, 0x929, 0x7, 
       0x191, 0x2, 0x2, 0x924, 0x925, 0x7, 0x1aa, 0x2, 0x2, 0x925, 0x926, 
       0x5, 0xe0, 0x71, 0x2, 0x926, 0x927, 0x7, 0x1ab, 0x2, 0x2, 0x927, 
       0x929, 0x3, 0x2, 0x2, 0x2, 0x928, 0x920, 0x3, 0x2, 0x2, 0x2, 0x928, 
       0x921, 0x3, 0x2, 0x2, 0x2, 0x928, 0x922, 0x3, 0x2, 0x2, 0x2, 0x928, 
       0x923, 0x3, 0x2, 0x2, 0x2, 0x928, 0x924, 0x3, 0x2, 0x2, 0x2, 0x929, 
       0xe1, 0x3, 0x2, 0x2, 0x2, 0x92a, 0x92b, 0x5, 0x5a, 0x2e, 0x2, 0x92b, 
       0xe3, 0x3, 0x2, 0x2, 0x2, 0x92c, 0x92d, 0x7, 0xa5, 0x2, 0x2, 0x92d, 
       0x932, 0x5, 0xe6, 0x74, 0x2, 0x92e, 0x92f, 0x7, 0x1ac, 0x2, 0x2, 
       0x92f, 0x931, 0x5, 0xe6, 0x74, 0x2, 0x930, 0x92e, 0x3, 0x2, 0x2, 
       0x2, 0x931, 0x934, 0x3, 0x2, 0x2, 0x2, 0x932, 0x930, 0x3, 0x2, 0x2, 
       0x2, 0x932, 0x933, 0x3, 0x2, 0x2, 0x2, 0x933, 0xe5, 0x3, 0x2, 0x2, 
       0x2, 0x934, 0x932, 0x3, 0x2, 0x2, 0x2, 0x935, 0x93a, 0x5, 0x1a8, 
       0xd5, 0x2, 0x936, 0x937, 0x7, 0x1aa, 0x2, 0x2, 0x937, 0x938, 0x5, 
       0x192, 0xca, 0x2, 0x938, 0x939, 0x7, 0x1ab, 0x2, 0x2, 0x939, 0x93b, 
       0x3, 0x2, 0x2, 0x2, 0x93a, 0x936, 0x3, 0x2, 0x2, 0x2, 0x93a, 0x93b, 
       0x3, 0x2, 0x2, 0x2, 0x93b, 0x93c, 0x3, 0x2, 0x2, 0x2, 0x93c, 0x93d, 
       0x7, 0x25, 0x2, 0x2, 0x93d, 0x93e, 0x7, 0x1aa, 0x2, 0x2, 0x93e, 0x93f, 
       0x5, 0x5a, 0x2e, 0x2, 0x93f, 0x940, 0x7, 0x1ab, 0x2, 0x2, 0x940, 
       0xe7, 0x3, 0x2, 0x2, 0x2, 0x941, 0x942, 0x7, 0x191, 0x2, 0x2, 0x942, 
       0x943, 0x7, 0x198, 0x2, 0x2, 0x943, 0x946, 0x5, 0x18a, 0xc6, 0x2, 
       0x944, 0x947, 0x7, 0x198, 0x2, 0x2, 0x945, 0x947, 0x5, 0x1b0, 0xd9, 
       0x2, 0x946, 0x944, 0x3, 0x2, 0x2, 0x2, 0x946, 0x945, 0x3, 0x2, 0x2, 
       0x2, 0x947, 0x948, 0x3, 0x2, 0x2, 0x2, 0x948, 0x949, 0x5, 0xd4, 0x6b, 
       0x2, 0x949, 0x95b, 0x3, 0x2, 0x2, 0x2, 0x94a, 0x94d, 0x5, 0x18a, 
       0xc6, 0x2, 0x94b, 0x94d, 0x7, 0x191, 0x2, 0x2, 0x94c, 0x94a, 0x3, 
       0x2, 0x2, 0x2, 0x94c, 0x94b, 0x3, 0x2, 0x2, 0x2, 0x94d, 0x950, 0x3, 
       0x2, 0x2, 0x2, 0x94e, 0x951, 0x7, 0x198, 0x2, 0x2, 0x94f, 0x951, 
       0x5, 0x1b0, 0xd9, 0x2, 0x950, 0x94e, 0x3, 0x2, 0x2, 0x2, 0x950, 0x94f, 
       0x3, 0x2, 0x2, 0x2, 0x951, 0x952, 0x3, 0x2, 0x2, 0x2, 0x952, 0x95b, 
       0x5, 0xd4, 0x6b, 0x2, 0x953, 0x954, 0x5, 0x1a8, 0xd5, 0x2, 0x954, 
       0x955, 0x7, 0x1a5, 0x2, 0x2, 0x955, 0x956, 0x5, 0x1a8, 0xd5, 0x2, 
       0x956, 0x957, 0x7, 0x1aa, 0x2, 0x2, 0x957, 0x958, 0x5, 0x160, 0xb1, 
       0x2, 0x958, 0x959, 0x7, 0x1ab, 0x2, 0x2, 0x959, 0x95b, 0x3, 0x2, 
       0x2, 0x2, 0x95a, 0x941, 0x3, 0x2, 0x2, 0x2, 0x95a, 0x94c, 0x3, 0x2, 
       0x2, 0x2, 0x95a, 0x953, 0x3, 0x2, 0x2, 0x2, 0x95b, 0xe9, 0x3, 0x2, 
       0x2, 0x2, 0x95c, 0x95f, 0x5, 0x18a, 0xc6, 0x2, 0x95d, 0x95f, 0x7, 
       0x191, 0x2, 0x2, 0x95e, 0x95c, 0x3, 0x2, 0x2, 0x2, 0x95e, 0x95d, 
       0x3, 0x2, 0x2, 0x2, 0x95f, 0x962, 0x3, 0x2, 0x2, 0x2, 0x960, 0x963, 
       0x7, 0x198, 0x2, 0x2, 0x961, 0x963, 0x5, 0x1b0, 0xd9, 0x2, 0x962, 
       0x960, 0x3, 0x2, 0x2, 0x2, 0x962, 0x961, 0x3, 0x2, 0x2, 0x2, 0x963, 
       0x964, 0x3, 0x2, 0x2, 0x2, 0x964, 0x96d, 0x5, 0xd4, 0x6b, 0x2, 0x965, 
       0x966, 0x5, 0x1a8, 0xd5, 0x2, 0x966, 0x967, 0x7, 0x1a5, 0x2, 0x2, 
       0x967, 0x968, 0x5, 0x1a8, 0xd5, 0x2, 0x968, 0x969, 0x7, 0x1aa, 0x2, 
       0x2, 0x969, 0x96a, 0x5, 0x160, 0xb1, 0x2, 0x96a, 0x96b, 0x7, 0x1ab, 
       0x2, 0x2, 0x96b, 0x96d, 0x3, 0x2, 0x2, 0x2, 0x96c, 0x95e, 0x3, 0x2, 
       0x2, 0x2, 0x96c, 0x965, 0x3, 0x2, 0x2, 0x2, 0x96d, 0xeb, 0x3, 0x2, 
       0x2, 0x2, 0x96e, 0x972, 0x8, 0x77, 0x1, 0x2, 0x96f, 0x971, 0x7, 0x6d, 
       0x2, 0x2, 0x970, 0x96f, 0x3, 0x2, 0x2, 0x2, 0x971, 0x974, 0x3, 0x2, 
       0x2, 0x2, 0x972, 0x970, 0x3, 0x2, 0x2, 0x2, 0x972, 0x973, 0x3, 0x2, 
       0x2, 0x2, 0x973, 0x97a, 0x3, 0x2, 0x2, 0x2, 0x974, 0x972, 0x3, 0x2, 
       0x2, 0x2, 0x975, 0x97b, 0x5, 0xee, 0x78, 0x2, 0x976, 0x977, 0x7, 
       0x1aa, 0x2, 0x2, 0x977, 0x978, 0x5, 0xec, 0x77, 0x2, 0x978, 0x979, 
       0x7, 0x1ab, 0x2, 0x2, 0x979, 0x97b, 0x3, 0x2, 0x2, 0x2, 0x97a, 0x975, 
       0x3, 0x2, 0x2, 0x2, 0x97a, 0x976, 0x3, 0x2, 0x2, 0x2, 0x97b, 0x984, 
       0x3, 0x2, 0x2, 0x2, 0x97c, 0x97d, 0xc, 0x4, 0x2, 0x2, 0x97d, 0x97e, 
       0x7, 0x23, 0x2, 0x2, 0x97e, 0x983, 0x5, 0xec, 0x77, 0x5, 0x97f, 0x980, 
       0xc, 0x3, 0x2, 0x2, 0x980, 0x981, 0x7, 0x75, 0x2, 0x2, 0x981, 0x983, 
       0x5, 0xec, 0x77, 0x4, 0x982, 0x97c, 0x3, 0x2, 0x2, 0x2, 0x982, 0x97f, 
       0x3, 0x2, 0x2, 0x2, 0x983, 0x986, 0x3, 0x2, 0x2, 0x2, 0x984, 0x982, 
       0x3, 0x2, 0x2, 0x2, 0x984, 0x985, 0x3, 0x2, 0x2, 0x2, 0x985, 0xed, 
       0x3, 0x2, 0x2, 0x2, 0x986, 0x984, 0x3, 0x2, 0x2, 0x2, 0x987, 0x988, 
       0x7, 0x52, 0x2, 0x2, 0x988, 0x989, 0x7, 0x1aa, 0x2, 0x2, 0x989, 0x98a, 
       0x5, 0xe2, 0x72, 0x2, 0x98a, 0x98b, 0x7, 0x1ab, 0x2, 0x2, 0x98b, 
       0x9c4, 0x3, 0x2, 0x2, 0x2, 0x98c, 0x98d, 0x5, 0xd4, 0x6b, 0x2, 0x98d, 
       0x98e, 0x5, 0x1ae, 0xd8, 0x2, 0x98e, 0x98f, 0x5, 0xd4, 0x6b, 0x2, 
       0x98f, 0x9c4, 0x3, 0x2, 0x2, 0x2, 0x990, 0x991, 0x5, 0xd4, 0x6b, 
       0x2, 0x991, 0x992, 0x5, 0x1ae, 0xd8, 0x2, 0x992, 0x993, 0x9, 0x1f, 
       0x2, 0x2, 0x993, 0x994, 0x7, 0x1aa, 0x2, 0x2, 0x994, 0x995, 0x5, 
       0xe2, 0x72, 0x2, 0x995, 0x996, 0x7, 0x1ab, 0x2, 0x2, 0x996, 0x9c4, 
       0x3, 0x2, 0x2, 0x2, 0x997, 0x99b, 0x5, 0xd4, 0x6b, 0x2, 0x998, 0x99a, 
       0x7, 0x6d, 0x2, 0x2, 0x999, 0x998, 0x3, 0x2, 0x2, 0x2, 0x99a, 0x99d, 
       0x3, 0x2, 0x2, 0x2, 0x99b, 0x999, 0x3, 0x2, 0x2, 0x2, 0x99b, 0x99c, 
       0x3, 0x2, 0x2, 0x2, 0x99c, 0x99e, 0x3, 0x2, 0x2, 0x2, 0x99d, 0x99b, 
       0x3, 0x2, 0x2, 0x2, 0x99e, 0x99f, 0x7, 0x2a, 0x2, 0x2, 0x99f, 0x9a0, 
       0x5, 0xd4, 0x6b, 0x2, 0x9a0, 0x9a1, 0x7, 0x23, 0x2, 0x2, 0x9a1, 0x9a2, 
       0x5, 0xd4, 0x6b, 0x2, 0x9a2, 0x9c4, 0x3, 0x2, 0x2, 0x2, 0x9a3, 0x9a7, 
       0x5, 0xd4, 0x6b, 0x2, 0x9a4, 0x9a6, 0x7, 0x6d, 0x2, 0x2, 0x9a5, 0x9a4, 
       0x3, 0x2, 0x2, 0x2, 0x9a6, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0x9a7, 0x9a5, 
       0x3, 0x2, 0x2, 0x2, 0x9a7, 0x9a8, 0x3, 0x2, 0x2, 0x2, 0x9a8, 0x9aa, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x9a7, 0x3, 0x2, 0x2, 0x2, 0x9aa, 0x9ab, 
       0x7, 0x60, 0x2, 0x2, 0x9ab, 0x9ae, 0x7, 0x1aa, 0x2, 0x2, 0x9ac, 0x9af, 
       0x5, 0xe2, 0x72, 0x2, 0x9ad, 0x9af, 0x5, 0x160, 0xb1, 0x2, 0x9ae, 
       0x9ac, 0x3, 0x2, 0x2, 0x2, 0x9ae, 0x9ad, 0x3, 0x2, 0x2, 0x2, 0x9af, 
       0x9b0, 0x3, 0x2, 0x2, 0x2, 0x9b0, 0x9b1, 0x7, 0x1ab, 0x2, 0x2, 0x9b1, 
       0x9c4, 0x3, 0x2, 0x2, 0x2, 0x9b2, 0x9b6, 0x5, 0xd4, 0x6b, 0x2, 0x9b3, 
       0x9b5, 0x7, 0x6d, 0x2, 0x2, 0x9b4, 0x9b3, 0x3, 0x2, 0x2, 0x2, 0x9b5, 
       0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9b6, 0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b6, 
       0x9b7, 0x3, 0x2, 0x2, 0x2, 0x9b7, 0x9b9, 0x3, 0x2, 0x2, 0x2, 0x9b8, 
       0x9b6, 0x3, 0x2, 0x2, 0x2, 0x9b9, 0x9ba, 0x7, 0x6b, 0x2, 0x2, 0x9ba, 
       0x9bd, 0x5, 0xd4, 0x6b, 0x2, 0x9bb, 0x9bc, 0x7, 0x4f, 0x2, 0x2, 0x9bc, 
       0x9be, 0x5, 0xd4, 0x6b, 0x2, 0x9bd, 0x9bb, 0x3, 0x2, 0x2, 0x2, 0x9bd, 
       0x9be, 0x3, 0x2, 0x2, 0x2, 0x9be, 0x9c4, 0x3, 0x2, 0x2, 0x2, 0x9bf, 
       0x9c0, 0x5, 0xd4, 0x6b, 0x2, 0x9c0, 0x9c1, 0x7, 0x66, 0x2, 0x2, 0x9c1, 
       0x9c2, 0x5, 0x198, 0xcd, 0x2, 0x9c2, 0x9c4, 0x3, 0x2, 0x2, 0x2, 0x9c3, 
       0x987, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x98c, 0x3, 0x2, 0x2, 0x2, 0x9c3, 
       0x990, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x997, 0x3, 0x2, 0x2, 0x2, 0x9c3, 
       0x9a3, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x9b2, 0x3, 0x2, 0x2, 0x2, 0x9c3, 
       0x9bf, 0x3, 0x2, 0x2, 0x2, 0x9c4, 0xef, 0x3, 0x2, 0x2, 0x2, 0x9c5, 
       0x9cb, 0x5, 0xf4, 0x7b, 0x2, 0x9c6, 0x9c7, 0x7, 0x1aa, 0x2, 0x2, 
       0x9c7, 0x9c8, 0x5, 0xf0, 0x79, 0x2, 0x9c8, 0x9c9, 0x7, 0x1ab, 0x2, 
       0x2, 0x9c9, 0x9cb, 0x3, 0x2, 0x2, 0x2, 0x9ca, 0x9c5, 0x3, 0x2, 0x2, 
       0x2, 0x9ca, 0x9c6, 0x3, 0x2, 0x2, 0x2, 0x9cb, 0x9d6, 0x3, 0x2, 0x2, 
       0x2, 0x9cc, 0x9ce, 0x5, 0xf4, 0x7b, 0x2, 0x9cd, 0x9cf, 0x5, 0xfc, 
       0x7f, 0x2, 0x9ce, 0x9cd, 0x3, 0x2, 0x2, 0x2, 0x9ce, 0x9cf, 0x3, 0x2, 
       0x2, 0x2, 0x9cf, 0x9d1, 0x3, 0x2, 0x2, 0x2, 0x9d0, 0x9d2, 0x5, 0xf2, 
       0x7a, 0x2, 0x9d1, 0x9d0, 0x3, 0x2, 0x2, 0x2, 0x9d2, 0x9d3, 0x3, 0x2, 
       0x2, 0x2, 0x9d3, 0x9d1, 0x3, 0x2, 0x2, 0x2, 0x9d3, 0x9d4, 0x3, 0x2, 
       0x2, 0x2, 0x9d4, 0x9d6, 0x3, 0x2, 0x2, 0x2, 0x9d5, 0x9ca, 0x3, 0x2, 
       0x2, 0x2, 0x9d5, 0x9cc, 0x3, 0x2, 0x2, 0x2, 0x9d6, 0xf1, 0x3, 0x2, 
       0x2, 0x2, 0x9d7, 0x9d9, 0x7, 0x9a, 0x2, 0x2, 0x9d8, 0x9da, 0x7, 0x21, 
       0x2, 0x2, 0x9d9, 0x9d8, 0x3, 0x2, 0x2, 0x2, 0x9d9, 0x9da, 0x3, 0x2, 
       0x2, 0x2, 0x9da, 0x9de, 0x3, 0x2, 0x2, 0x2, 0x9db, 0x9de, 0x7, 0x50, 
       0x2, 0x2, 0x9dc, 0x9de, 0x7, 0x64, 0x2, 0x2, 0x9dd, 0x9d7, 0x3, 0x2, 
       0x2, 0x2, 0x9dd, 0x9db, 0x3, 0x2, 0x2, 0x2, 0x9dd, 0x9dc, 0x3, 0x2, 
       0x2, 0x2, 0x9de, 0x9e4, 0x3, 0x2, 0x2, 0x2, 0x9df, 0x9e5, 0x5, 0xf4, 
       0x7b, 0x2, 0x9e0, 0x9e1, 0x7, 0x1aa, 0x2, 0x2, 0x9e1, 0x9e2, 0x5, 
       0xf0, 0x79, 0x2, 0x9e2, 0x9e3, 0x7, 0x1ab, 0x2, 0x2, 0x9e3, 0x9e5, 
       0x3, 0x2, 0x2, 0x2, 0x9e4, 0x9df, 0x3, 0x2, 0x2, 0x2, 0x9e4, 0x9e0, 
       0x3, 0x2, 0x2, 0x2, 0x9e5, 0xf3, 0x3, 0x2, 0x2, 0x2, 0x9e6, 0x9e8, 
       0x7, 0x8d, 0x2, 0x2, 0x9e7, 0x9e9, 0x9, 0x20, 0x2, 0x2, 0x9e8, 0x9e7, 
       0x3, 0x2, 0x2, 0x2, 0x9e8, 0x9e9, 0x3, 0x2, 0x2, 0x2, 0x9e9, 0x9eb, 
       0x3, 0x2, 0x2, 0x2, 0x9ea, 0x9ec, 0x5, 0xf6, 0x7c, 0x2, 0x9eb, 0x9ea, 
       0x3, 0x2, 0x2, 0x2, 0x9eb, 0x9ec, 0x3, 0x2, 0x2, 0x2, 0x9ec, 0x9ed, 
       0x3, 0x2, 0x2, 0x2, 0x9ed, 0x9f0, 0x5, 0x108, 0x85, 0x2, 0x9ee, 0x9ef, 
       0x7, 0x65, 0x2, 0x2, 0x9ef, 0x9f1, 0x5, 0x17e, 0xc0, 0x2, 0x9f0, 
       0x9ee, 0x3, 0x2, 0x2, 0x2, 0x9f0, 0x9f1, 0x3, 0x2, 0x2, 0x2, 0x9f1, 
       0x9f4, 0x3, 0x2, 0x2, 0x2, 0x9f2, 0x9f3, 0x7, 0x56, 0x2, 0x2, 0x9f3, 
       0x9f5, 0x5, 0x116, 0x8c, 0x2, 0x9f4, 0x9f2, 0x3, 0x2, 0x2, 0x2, 0x9f4, 
       0x9f5, 0x3, 0x2, 0x2, 0x2, 0x9f5, 0x9f8, 0x3, 0x2, 0x2, 0x2, 0x9f6, 
       0x9f7, 0x7, 0xa3, 0x2, 0x2, 0x9f7, 0x9f9, 0x5, 0xec, 0x77, 0x2, 0x9f8, 
       0x9f6, 0x3, 0x2, 0x2, 0x2, 0x9f8, 0x9f9, 0x3, 0x2, 0x2, 0x2, 0x9f9, 
       0xa07, 0x3, 0x2, 0x2, 0x2, 0x9fa, 0x9fb, 0x7, 0x5a, 0x2, 0x2, 0x9fb, 
       0x9fd, 0x7, 0x2c, 0x2, 0x2, 0x9fc, 0x9fe, 0x7, 0x21, 0x2, 0x2, 0x9fd, 
       0x9fc, 0x3, 0x2, 0x2, 0x2, 0x9fd, 0x9fe, 0x3, 0x2, 0x2, 0x2, 0x9fe, 
       0x9ff, 0x3, 0x2, 0x2, 0x2, 0x9ff, 0xa04, 0x5, 0x100, 0x81, 0x2, 0xa00, 
       0xa01, 0x7, 0x1ac, 0x2, 0x2, 0xa01, 0xa03, 0x5, 0x100, 0x81, 0x2, 
       0xa02, 0xa00, 0x3, 0x2, 0x2, 0x2, 0xa03, 0xa06, 0x3, 0x2, 0x2, 0x2, 
       0xa04, 0xa02, 0x3, 0x2, 0x2, 0x2, 0xa04, 0xa05, 0x3, 0x2, 0x2, 0x2, 
       0xa05, 0xa08, 0x3, 0x2, 0x2, 0x2, 0xa06, 0xa04, 0x3, 0x2, 0x2, 0x2, 
       0xa07, 0x9fa, 0x3, 0x2, 0x2, 0x2, 0xa07, 0xa08, 0x3, 0x2, 0x2, 0x2, 
       0xa08, 0xa0b, 0x3, 0x2, 0x2, 0x2, 0xa09, 0xa0a, 0x7, 0x5b, 0x2, 0x2, 
       0xa0a, 0xa0c, 0x5, 0xec, 0x77, 0x2, 0xa0b, 0xa09, 0x3, 0x2, 0x2, 
       0x2, 0xa0b, 0xa0c, 0x3, 0x2, 0x2, 0x2, 0xa0c, 0xf5, 0x3, 0x2, 0x2, 
       0x2, 0xa0d, 0xa10, 0x7, 0x96, 0x2, 0x2, 0xa0e, 0xa11, 0x5, 0xf8, 
       0x7d, 0x2, 0xa0f, 0xa11, 0x5, 0xfa, 0x7e, 0x2, 0xa10, 0xa0e, 0x3, 
       0x2, 0x2, 0x2, 0xa10, 0xa0f, 0x3, 0x2, 0x2, 0x2, 0xa11, 0xa14, 0x3, 
       0x2, 0x2, 0x2, 0xa12, 0xa13, 0x7, 0xa5, 0x2, 0x2, 0xa13, 0xa15, 0x7, 
       0x152, 0x2, 0x2, 0xa14, 0xa12, 0x3, 0x2, 0x2, 0x2, 0xa14, 0xa15, 
       0x3, 0x2, 0x2, 0x2, 0xa15, 0xf7, 0x3, 0x2, 0x2, 0x2, 0xa16, 0xa17, 
       0x9, 0x21, 0x2, 0x2, 0xa17, 0xa1e, 0x7, 0x79, 0x2, 0x2, 0xa18, 0xa19, 
       0x7, 0x1aa, 0x2, 0x2, 0xa19, 0xa1a, 0x5, 0xd4, 0x6b, 0x2, 0xa1a, 
       0xa1b, 0x7, 0x1ab, 0x2, 0x2, 0xa1b, 0xa1c, 0x7, 0x79, 0x2, 0x2, 0xa1c, 
       0xa1e, 0x3, 0x2, 0x2, 0x2, 0xa1d, 0xa16, 0x3, 0x2, 0x2, 0x2, 0xa1d, 
       0xa18, 0x3, 0x2, 0x2, 0x2, 0xa1e, 0xf9, 0x3, 0x2, 0x2, 0x2, 0xa1f, 
       0xa25, 0x7, 0x192, 0x2, 0x2, 0xa20, 0xa21, 0x7, 0x1aa, 0x2, 0x2, 
       0xa21, 0xa22, 0x5, 0xd4, 0x6b, 0x2, 0xa22, 0xa23, 0x7, 0x1ab, 0x2, 
       0x2, 0xa23, 0xa25, 0x3, 0x2, 0x2, 0x2, 0xa24, 0xa1f, 0x3, 0x2, 0x2, 
       0x2, 0xa24, 0xa20, 0x3, 0x2, 0x2, 0x2, 0xa25, 0xfb, 0x3, 0x2, 0x2, 
       0x2, 0xa26, 0xa27, 0x7, 0x76, 0x2, 0x2, 0xa27, 0xa28, 0x7, 0x2c, 
       0x2, 0x2, 0xa28, 0xa2d, 0x5, 0xfe, 0x80, 0x2, 0xa29, 0xa2a, 0x7, 
       0x1ac, 0x2, 0x2, 0xa2a, 0xa2c, 0x5, 0xfe, 0x80, 0x2, 0xa2b, 0xa29, 
       0x3, 0x2, 0x2, 0x2, 0xa2c, 0xa2f, 0x3, 0x2, 0x2, 0x2, 0xa2d, 0xa2b, 
       0x3, 0x2, 0x2, 0x2, 0xa2d, 0xa2e, 0x3, 0x2, 0x2, 0x2, 0xa2e, 0xa3b, 
       0x3, 0x2, 0x2, 0x2, 0xa2f, 0xa2d, 0x3, 0x2, 0x2, 0x2, 0xa30, 0xa31, 
       0x7, 0x116, 0x2, 0x2, 0xa31, 0xa32, 0x5, 0xd4, 0x6b, 0x2, 0xa32, 
       0xa39, 0x9, 0x22, 0x2, 0x2, 0xa33, 0xa34, 0x7, 0x53, 0x2, 0x2, 0xa34, 
       0xa35, 0x9, 0x23, 0x2, 0x2, 0xa35, 0xa36, 0x5, 0xd4, 0x6b, 0x2, 0xa36, 
       0xa37, 0x9, 0x22, 0x2, 0x2, 0xa37, 0xa38, 0x7, 0x118, 0x2, 0x2, 0xa38, 
       0xa3a, 0x3, 0x2, 0x2, 0x2, 0xa39, 0xa33, 0x3, 0x2, 0x2, 0x2, 0xa39, 
       0xa3a, 0x3, 0x2, 0x2, 0x2, 0xa3a, 0xa3c, 0x3, 0x2, 0x2, 0x2, 0xa3b, 
       0xa30, 0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa3c, 0x3, 0x2, 0x2, 0x2, 0xa3c, 
       0xfd, 0x3, 0x2, 0x2, 0x2, 0xa3d, 0xa40, 0x5, 0xd4, 0x6b, 0x2, 0xa3e, 
       0xa41, 0x7, 0x26, 0x2, 0x2, 0xa3f, 0xa41, 0x7, 0x46, 0x2, 0x2, 0xa40, 
       0xa3e, 0x3, 0x2, 0x2, 0x2, 0xa40, 0xa3f, 0x3, 0x2, 0x2, 0x2, 0xa40, 
       0xa41, 0x3, 0x2, 0x2, 0x2, 0xa41, 0xff, 0x3, 0x2, 0x2, 0x2, 0xa42, 
       0xa43, 0x5, 0xd4, 0x6b, 0x2, 0xa43, 0x101, 0x3, 0x2, 0x2, 0x2, 0xa44, 
       0xa45, 0x7, 0x74, 0x2, 0x2, 0xa45, 0xa46, 0x7, 0x1aa, 0x2, 0x2, 0xa46, 
       0xa4b, 0x5, 0x104, 0x83, 0x2, 0xa47, 0xa48, 0x7, 0x1ac, 0x2, 0x2, 
       0xa48, 0xa4a, 0x5, 0x104, 0x83, 0x2, 0xa49, 0xa47, 0x3, 0x2, 0x2, 
       0x2, 0xa4a, 0xa4d, 0x3, 0x2, 0x2, 0x2, 0xa4b, 0xa49, 0x3, 0x2, 0x2, 
       0x2, 0xa4b, 0xa4c, 0x3, 0x2, 0x2, 0x2, 0xa4c, 0xa4e, 0x3, 0x2, 0x2, 
       0x2, 0xa4d, 0xa4b, 0x3, 0x2, 0x2, 0x2, 0xa4e, 0xa4f, 0x7, 0x1ab, 
       0x2, 0x2, 0xa4f, 0x103, 0x3, 0x2, 0x2, 0x2, 0xa50, 0xa51, 0x7, 0xdc, 
       0x2, 0x2, 0xa51, 0xa7b, 0x7, 0x192, 0x2, 0x2, 0xa52, 0xa53, 0x9, 
       0x24, 0x2, 0x2, 0xa53, 0xa7b, 0x7, 0x5a, 0x2, 0x2, 0xa54, 0xa55, 
       0x9, 0x25, 0x2, 0x2, 0xa55, 0xa7b, 0x7, 0x9a, 0x2, 0x2, 0xa56, 0xa57, 
       0x9, 0x26, 0x2, 0x2, 0xa57, 0xa7b, 0x7, 0x67, 0x2, 0x2, 0xa58, 0xa59, 
       0x7, 0xe1, 0x2, 0x2, 0xa59, 0xa7b, 0x7, 0x76, 0x2, 0x2, 0xa5a, 0xa5b, 
       0x7, 0xf5, 0x2, 0x2, 0xa5b, 0xa7b, 0x7, 0x7b, 0x2, 0x2, 0xa5c, 0xa5d, 
       0x7, 0xf6, 0x2, 0x2, 0xa5d, 0xa7b, 0x7, 0x7b, 0x2, 0x2, 0xa5e, 0xa5f, 
       0x7, 0x106, 0x2, 0x2, 0xa5f, 0xa7b, 0x7, 0x192, 0x2, 0x2, 0xa60, 
       0xa61, 0x7, 0x107, 0x2, 0x2, 0xa61, 0xa7b, 0x7, 0x192, 0x2, 0x2, 
       0xa62, 0xa63, 0x7, 0x11a, 0x2, 0x2, 0xa63, 0xa64, 0x7, 0x54, 0x2, 
       0x2, 0xa64, 0xa65, 0x7, 0x1aa, 0x2, 0x2, 0xa65, 0xa6a, 0x5, 0x106, 
       0x84, 0x2, 0xa66, 0xa67, 0x7, 0x1ac, 0x2, 0x2, 0xa67, 0xa69, 0x5, 
       0x106, 0x84, 0x2, 0xa68, 0xa66, 0x3, 0x2, 0x2, 0x2, 0xa69, 0xa6c, 
       0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa68, 0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa6b, 
       0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa6d, 0x3, 0x2, 0x2, 0x2, 0xa6c, 0xa6a, 
       0x3, 0x2, 0x2, 0x2, 0xa6d, 0xa6e, 0x7, 0x1ab, 0x2, 0x2, 0xa6e, 0xa7b, 
       0x3, 0x2, 0x2, 0x2, 0xa6f, 0xa70, 0x7, 0x11a, 0x2, 0x2, 0xa70, 0xa71, 
       0x7, 0x54, 0x2, 0x2, 0xa71, 0xa7b, 0x7, 0x15e, 0x2, 0x2, 0xa72, 0xa73, 
       0x7, 0x11e, 0x2, 0x2, 0xa73, 0xa7b, 0x9, 0x27, 0x2, 0x2, 0xa74, 0xa7b, 
       0x7, 0x130, 0x2, 0x2, 0xa75, 0xa76, 0x7, 0x134, 0x2, 0x2, 0xa76, 
       0xa7b, 0x7, 0x7b, 0x2, 0x2, 0xa77, 0xa78, 0x7, 0x9e, 0x2, 0x2, 0xa78, 
       0xa79, 0x7, 0x7b, 0x2, 0x2, 0xa79, 0xa7b, 0x7, 0x194, 0x2, 0x2, 0xa7a, 
       0xa50, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa52, 0x3, 0x2, 0x2, 0x2, 0xa7a, 
       0xa54, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa56, 0x3, 0x2, 0x2, 0x2, 0xa7a, 
       0xa58, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa5a, 0x3, 0x2, 0x2, 0x2, 0xa7a, 
       0xa5c, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa5e, 0x3, 0x2, 0x2, 0x2, 0xa7a, 
       0xa60, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa62, 0x3, 0x2, 0x2, 0x2, 0xa7a, 
       0xa6f, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa72, 0x3, 0x2, 0x2, 0x2, 0xa7a, 
       0xa74, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa75, 0x3, 0x2, 0x2, 0x2, 0xa7a, 
       0xa77, 0x3, 0x2, 0x2, 0x2, 0xa7b, 0x105, 0x3, 0x2, 0x2, 0x2, 0xa7c, 
       0xa83, 0x7, 0x191, 0x2, 0x2, 0xa7d, 0xa84, 0x7, 0x15e, 0x2, 0x2, 
       0xa7e, 0xa81, 0x7, 0x198, 0x2, 0x2, 0xa7f, 0xa82, 0x5, 0x1a2, 0xd2, 
       0x2, 0xa80, 0xa82, 0x7, 0x6e, 0x2, 0x2, 0xa81, 0xa7f, 0x3, 0x2, 0x2, 
       0x2, 0xa81, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa82, 0xa84, 0x3, 0x2, 0x2, 
       0x2, 0xa83, 0xa7d, 0x3, 0x2, 0x2, 0x2, 0xa83, 0xa7e, 0x3, 0x2, 0x2, 
       0x2, 0xa84, 0x107, 0x3, 0x2, 0x2, 0x2, 0xa85, 0xa8a, 0x5, 0x114, 
       0x8b, 0x2, 0xa86, 0xa87, 0x7, 0x1ac, 0x2, 0x2, 0xa87, 0xa89, 0x5, 
       0x114, 0x8b, 0x2, 0xa88, 0xa86, 0x3, 0x2, 0x2, 0x2, 0xa89, 0xa8c, 
       0x3, 0x2, 0x2, 0x2, 0xa8a, 0xa88, 0x3, 0x2, 0x2, 0x2, 0xa8a, 0xa8b, 
       0x3, 0x2, 0x2, 0x2, 0xa8b, 0x109, 0x3, 0x2, 0x2, 0x2, 0xa8c, 0xa8a, 
       0x3, 0x2, 0x2, 0x2, 0xa8d, 0xa8e, 0x7, 0x1aa, 0x2, 0x2, 0xa8e, 0xa93, 
       0x5, 0x9c, 0x4f, 0x2, 0xa8f, 0xa90, 0x7, 0x1ac, 0x2, 0x2, 0xa90, 
       0xa92, 0x5, 0x9c, 0x4f, 0x2, 0xa91, 0xa8f, 0x3, 0x2, 0x2, 0x2, 0xa92, 
       0xa95, 0x3, 0x2, 0x2, 0x2, 0xa93, 0xa91, 0x3, 0x2, 0x2, 0x2, 0xa93, 
       0xa94, 0x3, 0x2, 0x2, 0x2, 0xa94, 0xa96, 0x3, 0x2, 0x2, 0x2, 0xa95, 
       0xa93, 0x3, 0x2, 0x2, 0x2, 0xa96, 0xa97, 0x7, 0x1ab, 0x2, 0x2, 0xa97, 
       0x10b, 0x3, 0x2, 0x2, 0x2, 0xa98, 0xa99, 0x5, 0x17e, 0xc0, 0x2, 0xa99, 
       0xa9a, 0x7, 0x1a5, 0x2, 0x2, 0xa9a, 0xa9c, 0x3, 0x2, 0x2, 0x2, 0xa9b, 
       0xa98, 0x3, 0x2, 0x2, 0x2, 0xa9b, 0xa9c, 0x3, 0x2, 0x2, 0x2, 0xa9c, 
       0xa9d, 0x3, 0x2, 0x2, 0x2, 0xa9d, 0xaa2, 0x7, 0x1b0, 0x2, 0x2, 0xa9e, 
       0xa9f, 0x9, 0x28, 0x2, 0x2, 0xa9f, 0xaa0, 0x7, 0x1a5, 0x2, 0x2, 0xaa0, 
       0xaa2, 0x7, 0x1b0, 0x2, 0x2, 0xaa1, 0xa9b, 0x3, 0x2, 0x2, 0x2, 0xaa1, 
       0xa9e, 0x3, 0x2, 0x2, 0x2, 0xaa2, 0x10d, 0x3, 0x2, 0x2, 0x2, 0xaa3, 
       0xaaa, 0x5, 0x18a, 0xc6, 0x2, 0xaa4, 0xaa5, 0x7, 0x1a9, 0x2, 0x2, 
       0xaa5, 0xaaa, 0x7, 0x5d, 0x2, 0x2, 0xaa6, 0xaa7, 0x7, 0x1a9, 0x2, 
       0x2, 0xaa7, 0xaaa, 0x7, 0x137, 0x2, 0x2, 0xaa8, 0xaaa, 0x7, 0x6e, 
       0x2, 0x2, 0xaa9, 0xaa3, 0x3, 0x2, 0x2, 0x2, 0xaa9, 0xaa4, 0x3, 0x2, 
       0x2, 0x2, 0xaa9, 0xaa6, 0x3, 0x2, 0x2, 0x2, 0xaa9, 0xaa8, 0x3, 0x2, 
       0x2, 0x2, 0xaaa, 0xaac, 0x3, 0x2, 0x2, 0x2, 0xaab, 0xaad, 0x5, 0x14c, 
       0xa7, 0x2, 0xaac, 0xaab, 0x3, 0x2, 0x2, 0x2, 0xaac, 0xaad, 0x3, 0x2, 
       0x2, 0x2, 0xaad, 0x10f, 0x3, 0x2, 0x2, 0x2, 0xaae, 0xaaf, 0x5, 0x1a8, 
       0xd5, 0x2, 0xaaf, 0xab0, 0x7, 0x1a5, 0x2, 0x2, 0xab0, 0xab1, 0x5, 
       0x1a8, 0xd5, 0x2, 0xab1, 0xab3, 0x5, 0x10a, 0x86, 0x2, 0xab2, 0xab4, 
       0x5, 0x14c, 0xa7, 0x2, 0xab3, 0xab2, 0x3, 0x2, 0x2, 0x2, 0xab3, 0xab4, 
       0x3, 0x2, 0x2, 0x2, 0xab4, 0xabf, 0x3, 0x2, 0x2, 0x2, 0xab5, 0xab6, 
       0x5, 0x1a8, 0xd5, 0x2, 0xab6, 0xab7, 0x7, 0x1af, 0x2, 0x2, 0xab7, 
       0xab9, 0x5, 0x1a8, 0xd5, 0x2, 0xab8, 0xaba, 0x5, 0x10a, 0x86, 0x2, 
       0xab9, 0xab8, 0x3, 0x2, 0x2, 0x2, 0xab9, 0xaba, 0x3, 0x2, 0x2, 0x2, 
       0xaba, 0xabc, 0x3, 0x2, 0x2, 0x2, 0xabb, 0xabd, 0x5, 0x14c, 0xa7, 
       0x2, 0xabc, 0xabb, 0x3, 0x2, 0x2, 0x2, 0xabc, 0xabd, 0x3, 0x2, 0x2, 
       0x2, 0xabd, 0xabf, 0x3, 0x2, 0x2, 0x2, 0xabe, 0xaae, 0x3, 0x2, 0x2, 
       0x2, 0xabe, 0xab5, 0x3, 0x2, 0x2, 0x2, 0xabf, 0x111, 0x3, 0x2, 0x2, 
       0x2, 0xac0, 0xac1, 0x5, 0x15c, 0xaf, 0x2, 0xac1, 0xac2, 0x7, 0x198, 
       0x2, 0x2, 0xac2, 0xac3, 0x5, 0xd4, 0x6b, 0x2, 0xac3, 0xac9, 0x3, 
       0x2, 0x2, 0x2, 0xac4, 0xac6, 0x5, 0xd4, 0x6b, 0x2, 0xac5, 0xac7, 
       0x5, 0x14c, 0xa7, 0x2, 0xac6, 0xac5, 0x3, 0x2, 0x2, 0x2, 0xac6, 0xac7, 
       0x3, 0x2, 0x2, 0x2, 0xac7, 0xac9, 0x3, 0x2, 0x2, 0x2, 0xac8, 0xac0, 
       0x3, 0x2, 0x2, 0x2, 0xac8, 0xac4, 0x3, 0x2, 0x2, 0x2, 0xac9, 0x113, 
       0x3, 0x2, 0x2, 0x2, 0xaca, 0xad5, 0x5, 0x10c, 0x87, 0x2, 0xacb, 0xad5, 
       0x5, 0x10e, 0x88, 0x2, 0xacc, 0xad5, 0x5, 0x110, 0x89, 0x2, 0xacd, 
       0xad0, 0x7, 0x191, 0x2, 0x2, 0xace, 0xad1, 0x5, 0x1b0, 0xd9, 0x2, 
       0xacf, 0xad1, 0x7, 0x198, 0x2, 0x2, 0xad0, 0xace, 0x3, 0x2, 0x2, 
       0x2, 0xad0, 0xacf, 0x3, 0x2, 0x2, 0x2, 0xad1, 0xad2, 0x3, 0x2, 0x2, 
       0x2, 0xad2, 0xad5, 0x5, 0xd4, 0x6b, 0x2, 0xad3, 0xad5, 0x5, 0x112, 
       0x8a, 0x2, 0xad4, 0xaca, 0x3, 0x2, 0x2, 0x2, 0xad4, 0xacb, 0x3, 0x2, 
       0x2, 0x2, 0xad4, 0xacc, 0x3, 0x2, 0x2, 0x2, 0xad4, 0xacd, 0x3, 0x2, 
       0x2, 0x2, 0xad4, 0xad3, 0x3, 0x2, 0x2, 0x2, 0xad5, 0x115, 0x3, 0x2, 
       0x2, 0x2, 0xad6, 0xadb, 0x5, 0x118, 0x8d, 0x2, 0xad7, 0xad8, 0x7, 
       0x1ac, 0x2, 0x2, 0xad8, 0xada, 0x5, 0x118, 0x8d, 0x2, 0xad9, 0xad7, 
       0x3, 0x2, 0x2, 0x2, 0xada, 0xadd, 0x3, 0x2, 0x2, 0x2, 0xadb, 0xad9, 
       0x3, 0x2, 0x2, 0x2, 0xadb, 0xadc, 0x3, 0x2, 0x2, 0x2, 0xadc, 0x117, 
       0x3, 0x2, 0x2, 0x2, 0xadd, 0xadb, 0x3, 0x2, 0x2, 0x2, 0xade, 0xae4, 
       0x5, 0x11a, 0x8e, 0x2, 0xadf, 0xae0, 0x7, 0x1aa, 0x2, 0x2, 0xae0, 
       0xae1, 0x5, 0x118, 0x8d, 0x2, 0xae1, 0xae2, 0x7, 0x1ab, 0x2, 0x2, 
       0xae2, 0xae4, 0x3, 0x2, 0x2, 0x2, 0xae3, 0xade, 0x3, 0x2, 0x2, 0x2, 
       0xae3, 0xadf, 0x3, 0x2, 0x2, 0x2, 0xae4, 0x119, 0x3, 0x2, 0x2, 0x2, 
       0xae5, 0xae9, 0x5, 0x11c, 0x8f, 0x2, 0xae6, 0xae8, 0x5, 0x128, 0x95, 
       0x2, 0xae7, 0xae6, 0x3, 0x2, 0x2, 0x2, 0xae8, 0xaeb, 0x3, 0x2, 0x2, 
       0x2, 0xae9, 0xae7, 0x3, 0x2, 0x2, 0x2, 0xae9, 0xaea, 0x3, 0x2, 0x2, 
       0x2, 0xaea, 0xaf6, 0x3, 0x2, 0x2, 0x2, 0xaeb, 0xae9, 0x3, 0x2, 0x2, 
       0x2, 0xaec, 0xaed, 0x7, 0x1aa, 0x2, 0x2, 0xaed, 0xaee, 0x5, 0x11a, 
       0x8e, 0x2, 0xaee, 0xaf2, 0x7, 0x1ab, 0x2, 0x2, 0xaef, 0xaf1, 0x5, 
       0x128, 0x95, 0x2, 0xaf0, 0xaef, 0x3, 0x2, 0x2, 0x2, 0xaf1, 0xaf4, 
       0x3, 0x2, 0x2, 0x2, 0xaf2, 0xaf0, 0x3, 0x2, 0x2, 0x2, 0xaf2, 0xaf3, 
       0x3, 0x2, 0x2, 0x2, 0xaf3, 0xaf6, 0x3, 0x2, 0x2, 0x2, 0xaf4, 0xaf2, 
       0x3, 0x2, 0x2, 0x2, 0xaf5, 0xae5, 0x3, 0x2, 0x2, 0x2, 0xaf5, 0xaec, 
       0x3, 0x2, 0x2, 0x2, 0xaf6, 0x11b, 0x3, 0x2, 0x2, 0x2, 0xaf7, 0xaf9, 
       0x7, 0x191, 0x2, 0x2, 0xaf8, 0xafa, 0x5, 0x14e, 0xa8, 0x2, 0xaf9, 
       0xaf8, 0x3, 0x2, 0x2, 0x2, 0xaf9, 0xafa, 0x3, 0x2, 0x2, 0x2, 0xafa, 
       0xb2d, 0x3, 0x2, 0x2, 0x2, 0xafb, 0xafd, 0x5, 0x13a, 0x9e, 0x2, 0xafc, 
       0xafe, 0x5, 0x14e, 0xa8, 0x2, 0xafd, 0xafc, 0x3, 0x2, 0x2, 0x2, 0xafd, 
       0xafe, 0x3, 0x2, 0x2, 0x2, 0xafe, 0xb2d, 0x3, 0x2, 0x2, 0x2, 0xaff, 
       0xb01, 0x5, 0x17c, 0xbf, 0x2, 0xb00, 0xb02, 0x5, 0x14e, 0xa8, 0x2, 
       0xb01, 0xb00, 0x3, 0x2, 0x2, 0x2, 0xb01, 0xb02, 0x3, 0x2, 0x2, 0x2, 
       0xb02, 0xb2d, 0x3, 0x2, 0x2, 0x2, 0xb03, 0xb04, 0x7, 0x1aa, 0x2, 
       0x2, 0xb04, 0xb05, 0x5, 0x13e, 0xa0, 0x2, 0xb05, 0xb0a, 0x7, 0x1ab, 
       0x2, 0x2, 0xb06, 0xb08, 0x5, 0x14e, 0xa8, 0x2, 0xb07, 0xb09, 0x5, 
       0x15a, 0xae, 0x2, 0xb08, 0xb07, 0x3, 0x2, 0x2, 0x2, 0xb08, 0xb09, 
       0x3, 0x2, 0x2, 0x2, 0xb09, 0xb0b, 0x3, 0x2, 0x2, 0x2, 0xb0a, 0xb06, 
       0x3, 0x2, 0x2, 0x2, 0xb0a, 0xb0b, 0x3, 0x2, 0x2, 0x2, 0xb0b, 0xb2d, 
       0x3, 0x2, 0x2, 0x2, 0xb0c, 0xb0e, 0x5, 0x122, 0x92, 0x2, 0xb0d, 0xb0f, 
       0x5, 0x14e, 0xa8, 0x2, 0xb0e, 0xb0d, 0x3, 0x2, 0x2, 0x2, 0xb0e, 0xb0f, 
       0x3, 0x2, 0x2, 0x2, 0xb0f, 0xb2d, 0x3, 0x2, 0x2, 0x2, 0xb10, 0xb15, 
       0x5, 0x140, 0xa1, 0x2, 0xb11, 0xb13, 0x5, 0x14e, 0xa8, 0x2, 0xb12, 
       0xb14, 0x5, 0x15a, 0xae, 0x2, 0xb13, 0xb12, 0x3, 0x2, 0x2, 0x2, 0xb13, 
       0xb14, 0x3, 0x2, 0x2, 0x2, 0xb14, 0xb16, 0x3, 0x2, 0x2, 0x2, 0xb15, 
       0xb11, 0x3, 0x2, 0x2, 0x2, 0xb15, 0xb16, 0x3, 0x2, 0x2, 0x2, 0xb16, 
       0xb2d, 0x3, 0x2, 0x2, 0x2, 0xb17, 0xb1c, 0x5, 0x146, 0xa4, 0x2, 0xb18, 
       0xb1a, 0x5, 0x14e, 0xa8, 0x2, 0xb19, 0xb1b, 0x5, 0x15a, 0xae, 0x2, 
       0xb1a, 0xb19, 0x3, 0x2, 0x2, 0x2, 0xb1a, 0xb1b, 0x3, 0x2, 0x2, 0x2, 
       0xb1b, 0xb1d, 0x3, 0x2, 0x2, 0x2, 0xb1c, 0xb18, 0x3, 0x2, 0x2, 0x2, 
       0xb1c, 0xb1d, 0x3, 0x2, 0x2, 0x2, 0xb1d, 0xb2d, 0x3, 0x2, 0x2, 0x2, 
       0xb1e, 0xb1f, 0x7, 0x191, 0x2, 0x2, 0xb1f, 0xb20, 0x7, 0x1a5, 0x2, 
       0x2, 0xb20, 0xb25, 0x5, 0x140, 0xa1, 0x2, 0xb21, 0xb23, 0x5, 0x14e, 
       0xa8, 0x2, 0xb22, 0xb24, 0x5, 0x15a, 0xae, 0x2, 0xb23, 0xb22, 0x3, 
       0x2, 0x2, 0x2, 0xb23, 0xb24, 0x3, 0x2, 0x2, 0x2, 0xb24, 0xb26, 0x3, 
       0x2, 0x2, 0x2, 0xb25, 0xb21, 0x3, 0x2, 0x2, 0x2, 0xb25, 0xb26, 0x3, 
       0x2, 0x2, 0x2, 0xb26, 0xb2d, 0x3, 0x2, 0x2, 0x2, 0xb27, 0xb28, 0x7, 
       0x1af, 0x2, 0x2, 0xb28, 0xb2a, 0x5, 0x140, 0xa1, 0x2, 0xb29, 0xb2b, 
       0x5, 0x14e, 0xa8, 0x2, 0xb2a, 0xb29, 0x3, 0x2, 0x2, 0x2, 0xb2a, 0xb2b, 
       0x3, 0x2, 0x2, 0x2, 0xb2b, 0xb2d, 0x3, 0x2, 0x2, 0x2, 0xb2c, 0xaf7, 
       0x3, 0x2, 0x2, 0x2, 0xb2c, 0xafb, 0x3, 0x2, 0x2, 0x2, 0xb2c, 0xaff, 
       0x3, 0x2, 0x2, 0x2, 0xb2c, 0xb03, 0x3, 0x2, 0x2, 0x2, 0xb2c, 0xb0c, 
       0x3, 0x2, 0x2, 0x2, 0xb2c, 0xb10, 0x3, 0x2, 0x2, 0x2, 0xb2c, 0xb17, 
       0x3, 0x2, 0x2, 0x2, 0xb2c, 0xb1e, 0x3, 0x2, 0x2, 0x2, 0xb2c, 0xb27, 
       0x3, 0x2, 0x2, 0x2, 0xb2d, 0x11d, 0x3, 0x2, 0x2, 0x2, 0xb2e, 0xb33, 
       0x5, 0x120, 0x91, 0x2, 0xb2f, 0xb30, 0x7, 0x1ac, 0x2, 0x2, 0xb30, 
       0xb32, 0x5, 0x120, 0x91, 0x2, 0xb31, 0xb2f, 0x3, 0x2, 0x2, 0x2, 0xb32, 
       0xb35, 0x3, 0x2, 0x2, 0x2, 0xb33, 0xb31, 0x3, 0x2, 0x2, 0x2, 0xb33, 
       0xb34, 0x3, 0x2, 0x2, 0x2, 0xb34, 0x11f, 0x3, 0x2, 0x2, 0x2, 0xb35, 
       0xb33, 0x3, 0x2, 0x2, 0x2, 0xb36, 0xb37, 0x5, 0x1a8, 0xd5, 0x2, 0xb37, 
       0xb39, 0x5, 0x19e, 0xd0, 0x2, 0xb38, 0xb3a, 0x7, 0x194, 0x2, 0x2, 
       0xb39, 0xb38, 0x3, 0x2, 0x2, 0x2, 0xb39, 0xb3a, 0x3, 0x2, 0x2, 0x2, 
       0xb3a, 0x121, 0x3, 0x2, 0x2, 0x2, 0xb3b, 0xb3e, 0x5, 0x124, 0x93, 
       0x2, 0xb3c, 0xb3e, 0x5, 0x126, 0x94, 0x2, 0xb3d, 0xb3b, 0x3, 0x2, 
       0x2, 0x2, 0xb3d, 0xb3c, 0x3, 0x2, 0x2, 0x2, 0xb3e, 0x123, 0x3, 0x2, 
       0x2, 0x2, 0xb3f, 0xb40, 0x7, 0x16c, 0x2, 0x2, 0xb40, 0xb41, 0x7, 
       0x1aa, 0x2, 0x2, 0xb41, 0xb42, 0x7, 0x16d, 0x2, 0x2, 0xb42, 0xb43, 
       0x5, 0x17e, 0xc0, 0x2, 0xb43, 0xb44, 0x7, 0x1ac, 0x2, 0x2, 0xb44, 
       0xb45, 0x9, 0x29, 0x2, 0x2, 0xb45, 0xb46, 0x7, 0x1ab, 0x2, 0x2, 0xb46, 
       0x125, 0x3, 0x2, 0x2, 0x2, 0xb47, 0xb48, 0x7, 0x16c, 0x2, 0x2, 0xb48, 
       0xb49, 0x7, 0x1aa, 0x2, 0x2, 0xb49, 0xb4a, 0x7, 0x1c8, 0x2, 0x2, 
       0xb4a, 0xb4b, 0x5, 0x17e, 0xc0, 0x2, 0xb4b, 0xb4c, 0x7, 0x1ac, 0x2, 
       0x2, 0xb4c, 0xb4d, 0x5, 0x138, 0x9d, 0x2, 0xb4d, 0xb4e, 0x7, 0x1ac, 
       0x2, 0x2, 0xb4e, 0xb4f, 0x5, 0x108, 0x85, 0x2, 0xb4f, 0xb50, 0x7, 
       0x1ab, 0x2, 0x2, 0xb50, 0x127, 0x3, 0x2, 0x2, 0x2, 0xb51, 0xb57, 
       0x5, 0x12a, 0x96, 0x2, 0xb52, 0xb57, 0x5, 0x12c, 0x97, 0x2, 0xb53, 
       0xb57, 0x5, 0x12e, 0x98, 0x2, 0xb54, 0xb57, 0x5, 0x130, 0x99, 0x2, 
       0xb55, 0xb57, 0x5, 0x132, 0x9a, 0x2, 0xb56, 0xb51, 0x3, 0x2, 0x2, 
       0x2, 0xb56, 0xb52, 0x3, 0x2, 0x2, 0x2, 0xb56, 0xb53, 0x3, 0x2, 0x2, 
       0x2, 0xb56, 0xb54, 0x3, 0x2, 0x2, 0x2, 0xb56, 0xb55, 0x3, 0x2, 0x2, 
       0x2, 0xb57, 0x129, 0x3, 0x2, 0x2, 0x2, 0xb58, 0xb5a, 0x7, 0x62, 0x2, 
       0x2, 0xb59, 0xb58, 0x3, 0x2, 0x2, 0x2, 0xb59, 0xb5a, 0x3, 0x2, 0x2, 
       0x2, 0xb5a, 0xb60, 0x3, 0x2, 0x2, 0x2, 0xb5b, 0xb5d, 0x9, 0x2a, 0x2, 
       0x2, 0xb5c, 0xb5e, 0x7, 0x77, 0x2, 0x2, 0xb5d, 0xb5c, 0x3, 0x2, 0x2, 
       0x2, 0xb5d, 0xb5e, 0x3, 0x2, 0x2, 0x2, 0xb5e, 0xb60, 0x3, 0x2, 0x2, 
       0x2, 0xb5f, 0xb59, 0x3, 0x2, 0x2, 0x2, 0xb5f, 0xb5b, 0x3, 0x2, 0x2, 
       0x2, 0xb60, 0xb62, 0x3, 0x2, 0x2, 0x2, 0xb61, 0xb63, 0x9, 0x2b, 0x2, 
       0x2, 0xb62, 0xb61, 0x3, 0x2, 0x2, 0x2, 0xb62, 0xb63, 0x3, 0x2, 0x2, 
       0x2, 0xb63, 0xb64, 0x3, 0x2, 0x2, 0x2, 0xb64, 0xb65, 0x7, 0x67, 0x2, 
       0x2, 0xb65, 0xb66, 0x5, 0x118, 0x8d, 0x2, 0xb66, 0xb67, 0x7, 0x72, 
       0x2, 0x2, 0xb67, 0xb68, 0x5, 0xec, 0x77, 0x2, 0xb68, 0x12b, 0x3, 
       0x2, 0x2, 0x2, 0xb69, 0xb6a, 0x7, 0x39, 0x2, 0x2, 0xb6a, 0xb6b, 0x7, 
       0x67, 0x2, 0x2, 0xb6b, 0xb6c, 0x5, 0x118, 0x8d, 0x2, 0xb6c, 0x12d, 
       0x3, 0x2, 0x2, 0x2, 0xb6d, 0xb6e, 0x9, 0x2c, 0x2, 0x2, 0xb6e, 0xb6f, 
       0x7, 0xb2, 0x2, 0x2, 0xb6f, 0xb70, 0x5, 0x118, 0x8d, 0x2, 0xb70, 
       0x12f, 0x3, 0x2, 0x2, 0x2, 0xb71, 0xb72, 0x7, 0x7a, 0x2, 0x2, 0xb72, 
       0xb73, 0x5, 0x134, 0x9b, 0x2, 0xb73, 0xb74, 0x5, 0x14e, 0xa8, 0x2, 
       0xb74, 0x131, 0x3, 0x2, 0x2, 0x2, 0xb75, 0xb76, 0x7, 0x9c, 0x2, 0x2, 
       0xb76, 0xb77, 0x5, 0x136, 0x9c, 0x2, 0xb77, 0xb78, 0x5, 0x14e, 0xa8, 
       0x2, 0xb78, 0x133, 0x3, 0x2, 0x2, 0x2, 0xb79, 0xb7a, 0x7, 0x1aa, 
       0x2, 0x2, 0xb7a, 0xb7b, 0x5, 0x164, 0xb3, 0x2, 0xb7b, 0xb7c, 0x7, 
       0x54, 0x2, 0x2, 0xb7c, 0xb7d, 0x5, 0x18a, 0xc6, 0x2, 0xb7d, 0xb7e, 
       0x7, 0x60, 0x2, 0x2, 0xb7e, 0xb7f, 0x5, 0x15a, 0xae, 0x2, 0xb7f, 
       0xb80, 0x7, 0x1ab, 0x2, 0x2, 0xb80, 0x135, 0x3, 0x2, 0x2, 0x2, 0xb81, 
       0xb82, 0x7, 0x1aa, 0x2, 0x2, 0xb82, 0xb83, 0x5, 0xd4, 0x6b, 0x2, 
       0xb83, 0xb84, 0x7, 0x54, 0x2, 0x2, 0xb84, 0xb85, 0x5, 0x18a, 0xc6, 
       0x2, 0xb85, 0xb86, 0x7, 0x60, 0x2, 0x2, 0xb86, 0xb87, 0x7, 0x1aa, 
       0x2, 0x2, 0xb87, 0xb88, 0x5, 0x138, 0x9d, 0x2, 0xb88, 0xb89, 0x7, 
       0x1ab, 0x2, 0x2, 0xb89, 0xb8a, 0x7, 0x1ab, 0x2, 0x2, 0xb8a, 0x137, 
       0x3, 0x2, 0x2, 0x2, 0xb8b, 0xb90, 0x5, 0x18a, 0xc6, 0x2, 0xb8c, 0xb8d, 
       0x7, 0x1ac, 0x2, 0x2, 0xb8d, 0xb8f, 0x5, 0x18a, 0xc6, 0x2, 0xb8e, 
       0xb8c, 0x3, 0x2, 0x2, 0x2, 0xb8f, 0xb92, 0x3, 0x2, 0x2, 0x2, 0xb90, 
       0xb8e, 0x3, 0x2, 0x2, 0x2, 0xb90, 0xb91, 0x3, 0x2, 0x2, 0x2, 0xb91, 
       0x139, 0x3, 0x2, 0x2, 0x2, 0xb92, 0xb90, 0x3, 0x2, 0x2, 0x2, 0xb93, 
       0xb95, 0x5, 0x17e, 0xc0, 0x2, 0xb94, 0xb96, 0x5, 0x152, 0xaa, 0x2, 
       0xb95, 0xb94, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb96, 0x3, 0x2, 0x2, 0x2, 
       0xb96, 0x13b, 0x3, 0x2, 0x2, 0x2, 0xb97, 0xb98, 0x5, 0x1a8, 0xd5, 
       0x2, 0xb98, 0xb99, 0x7, 0x198, 0x2, 0x2, 0xb99, 0xb9a, 0x9, 0x10, 
       0x2, 0x2, 0xb9a, 0x13d, 0x3, 0x2, 0x2, 0x2, 0xb9b, 0xba6, 0x5, 0xe2, 
       0x72, 0x2, 0xb9c, 0xb9d, 0x7, 0x1aa, 0x2, 0x2, 0xb9d, 0xb9e, 0x5, 
       0xe2, 0x72, 0x2, 0xb9e, 0xb9f, 0x7, 0x1ab, 0x2, 0x2, 0xb9f, 0xba6, 
       0x3, 0x2, 0x2, 0x2, 0xba0, 0xba6, 0x5, 0x15e, 0xb0, 0x2, 0xba1, 0xba2, 
       0x7, 0x1aa, 0x2, 0x2, 0xba2, 0xba3, 0x5, 0x15e, 0xb0, 0x2, 0xba3, 
       0xba4, 0x7, 0x1ab, 0x2, 0x2, 0xba4, 0xba6, 0x3, 0x2, 0x2, 0x2, 0xba5, 
       0xb9b, 0x3, 0x2, 0x2, 0x2, 0xba5, 0xb9c, 0x3, 0x2, 0x2, 0x2, 0xba5, 
       0xba0, 0x3, 0x2, 0x2, 0x2, 0xba5, 0xba1, 0x3, 0x2, 0x2, 0x2, 0xba6, 
       0x13f, 0x3, 0x2, 0x2, 0x2, 0xba7, 0xbb4, 0x5, 0x162, 0xb2, 0x2, 0xba8, 
       0xbb4, 0x5, 0x164, 0xb3, 0x2, 0xba9, 0xbb4, 0x5, 0x166, 0xb4, 0x2, 
       0xbaa, 0xbb4, 0x5, 0x144, 0xa3, 0x2, 0xbab, 0xbac, 0x5, 0x19c, 0xcf, 
       0x2, 0xbac, 0xbae, 0x7, 0x1aa, 0x2, 0x2, 0xbad, 0xbaf, 0x5, 0x160, 
       0xb1, 0x2, 0xbae, 0xbad, 0x3, 0x2, 0x2, 0x2, 0xbae, 0xbaf, 0x3, 0x2, 
       0x2, 0x2, 0xbaf, 0xbb0, 0x3, 0x2, 0x2, 0x2, 0xbb0, 0xbb1, 0x7, 0x1ab, 
       0x2, 0x2, 0xbb1, 0xbb4, 0x3, 0x2, 0x2, 0x2, 0xbb2, 0xbb4, 0x5, 0x142, 
       0xa2, 0x2, 0xbb3, 0xba7, 0x3, 0x2, 0x2, 0x2, 0xbb3, 0xba8, 0x3, 0x2, 
       0x2, 0x2, 0xbb3, 0xba9, 0x3, 0x2, 0x2, 0x2, 0xbb3, 0xbaa, 0x3, 0x2, 
       0x2, 0x2, 0xbb3, 0xbab, 0x3, 0x2, 0x2, 0x2, 0xbb3, 0xbb2, 0x3, 0x2, 
       0x2, 0x2, 0xbb4, 0x141, 0x3, 0x2, 0x2, 0x2, 0xbb5, 0xbb6, 0x5, 0x1a8, 
       0xd5, 0x2, 0xbb6, 0xbb7, 0x7, 0x1a5, 0x2, 0x2, 0xbb7, 0xbb9, 0x3, 
       0x2, 0x2, 0x2, 0xbb8, 0xbb5, 0x3, 0x2, 0x2, 0x2, 0xbb8, 0xbb9, 0x3, 
       0x2, 0x2, 0x2, 0xbb9, 0xbba, 0x3, 0x2, 0x2, 0x2, 0xbba, 0xbbb, 0x7, 
       0xa7, 0x2, 0x2, 0xbbb, 0xbbc, 0x7, 0x1a5, 0x2, 0x2, 0xbbc, 0xbbd, 
       0x5, 0x1a8, 0xd5, 0x2, 0xbbd, 0xbbe, 0x7, 0x1aa, 0x2, 0x2, 0xbbe, 
       0xbbf, 0x5, 0xd4, 0x6b, 0x2, 0xbbf, 0xbc0, 0x7, 0x1ab, 0x2, 0x2, 
       0xbc0, 0x143, 0x3, 0x2, 0x2, 0x2, 0xbc1, 0xbc2, 0x7, 0xb9, 0x2, 0x2, 
       0xbc2, 0xbc3, 0x7, 0x1aa, 0x2, 0x2, 0xbc3, 0xbc4, 0x7, 0x1b0, 0x2, 
       0x2, 0xbc4, 0xc53, 0x7, 0x1ab, 0x2, 0x2, 0xbc5, 0xbc6, 0x7, 0xbb, 
       0x2, 0x2, 0xbc6, 0xbc7, 0x7, 0x1aa, 0x2, 0x2, 0xbc7, 0xbc8, 0x5, 
       0xd4, 0x6b, 0x2, 0xbc8, 0xbc9, 0x7, 0x25, 0x2, 0x2, 0xbc9, 0xbca, 
       0x5, 0x19e, 0xd0, 0x2, 0xbca, 0xbcb, 0x7, 0x1ab, 0x2, 0x2, 0xbcb, 
       0xc53, 0x3, 0x2, 0x2, 0x2, 0xbcc, 0xbcd, 0x7, 0xbc, 0x2, 0x2, 0xbcd, 
       0xbce, 0x7, 0x1aa, 0x2, 0x2, 0xbce, 0xbcf, 0x5, 0xd4, 0x6b, 0x2, 
       0xbcf, 0xbd0, 0x7, 0x25, 0x2, 0x2, 0xbd0, 0xbd1, 0x5, 0x19e, 0xd0, 
       0x2, 0xbd1, 0xbd2, 0x7, 0x1ab, 0x2, 0x2, 0xbd2, 0xc53, 0x3, 0x2, 
       0x2, 0x2, 0xbd3, 0xbd4, 0x7, 0x37, 0x2, 0x2, 0xbd4, 0xbd5, 0x7, 0x1aa, 
       0x2, 0x2, 0xbd5, 0xbd6, 0x5, 0x19e, 0xd0, 0x2, 0xbd6, 0xbd7, 0x7, 
       0x1ac, 0x2, 0x2, 0xbd7, 0xbda, 0x5, 0xd4, 0x6b, 0x2, 0xbd8, 0xbd9, 
       0x7, 0x1ac, 0x2, 0x2, 0xbd9, 0xbdb, 0x5, 0xd4, 0x6b, 0x2, 0xbda, 
       0xbd8, 0x3, 0x2, 0x2, 0x2, 0xbda, 0xbdb, 0x3, 0x2, 0x2, 0x2, 0xbdb, 
       0xbdc, 0x3, 0x2, 0x2, 0x2, 0xbdc, 0xbdd, 0x7, 0x1ab, 0x2, 0x2, 0xbdd, 
       0xc53, 0x3, 0x2, 0x2, 0x2, 0xbde, 0xbdf, 0x7, 0xbe, 0x2, 0x2, 0xbdf, 
       0xbe0, 0x7, 0x1aa, 0x2, 0x2, 0xbe0, 0xbe1, 0x7, 0x1b0, 0x2, 0x2, 
       0xbe1, 0xc53, 0x7, 0x1ab, 0x2, 0x2, 0xbe2, 0xbe3, 0x7, 0x30, 0x2, 
       0x2, 0xbe3, 0xbe4, 0x7, 0x1aa, 0x2, 0x2, 0xbe4, 0xbe5, 0x5, 0x160, 
       0xb1, 0x2, 0xbe5, 0xbe6, 0x7, 0x1ab, 0x2, 0x2, 0xbe6, 0xc53, 0x3, 
       0x2, 0x2, 0x2, 0xbe7, 0xc53, 0x7, 0x3d, 0x2, 0x2, 0xbe8, 0xc53, 0x7, 
       0x3e, 0x2, 0x2, 0xbe9, 0xbea, 0x7, 0xc9, 0x2, 0x2, 0xbea, 0xbeb, 
       0x7, 0x1aa, 0x2, 0x2, 0xbeb, 0xbec, 0x7, 0x193, 0x2, 0x2, 0xbec, 
       0xbed, 0x7, 0x1ac, 0x2, 0x2, 0xbed, 0xbee, 0x5, 0xd4, 0x6b, 0x2, 
       0xbee, 0xbef, 0x7, 0x1ac, 0x2, 0x2, 0xbef, 0xbf0, 0x5, 0xd4, 0x6b, 
       0x2, 0xbf0, 0xbf1, 0x7, 0x1ab, 0x2, 0x2, 0xbf1, 0xc53, 0x3, 0x2, 
       0x2, 0x2, 0xbf2, 0xbf3, 0x7, 0xca, 0x2, 0x2, 0xbf3, 0xbf4, 0x7, 0x1aa, 
       0x2, 0x2, 0xbf4, 0xbf5, 0x7, 0x193, 0x2, 0x2, 0xbf5, 0xbf6, 0x7, 
       0x1ac, 0x2, 0x2, 0xbf6, 0xbf7, 0x5, 0xd4, 0x6b, 0x2, 0xbf7, 0xbf8, 
       0x7, 0x1ac, 0x2, 0x2, 0xbf8, 0xbf9, 0x5, 0xd4, 0x6b, 0x2, 0xbf9, 
       0xbfa, 0x7, 0x1ab, 0x2, 0x2, 0xbfa, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xbfb, 
       0xbfc, 0x7, 0xcb, 0x2, 0x2, 0xbfc, 0xbfd, 0x7, 0x1aa, 0x2, 0x2, 0xbfd, 
       0xbfe, 0x7, 0x193, 0x2, 0x2, 0xbfe, 0xbff, 0x7, 0x1ac, 0x2, 0x2, 
       0xbff, 0xc00, 0x5, 0xd4, 0x6b, 0x2, 0xc00, 0xc01, 0x7, 0x1ab, 0x2, 
       0x2, 0xc01, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc02, 0xc03, 0x7, 0xcc, 0x2, 
       0x2, 0xc03, 0xc04, 0x7, 0x1aa, 0x2, 0x2, 0xc04, 0xc05, 0x7, 0x193, 
       0x2, 0x2, 0xc05, 0xc06, 0x7, 0x1ac, 0x2, 0x2, 0xc06, 0xc07, 0x5, 
       0xd4, 0x6b, 0x2, 0xc07, 0xc08, 0x7, 0x1ab, 0x2, 0x2, 0xc08, 0xc53, 
       0x3, 0x2, 0x2, 0x2, 0xc09, 0xc0a, 0x7, 0xe4, 0x2, 0x2, 0xc0a, 0xc0b, 
       0x7, 0x1aa, 0x2, 0x2, 0xc0b, 0xc53, 0x7, 0x1ab, 0x2, 0x2, 0xc0c, 
       0xc0d, 0x7, 0xe5, 0x2, 0x2, 0xc0d, 0xc0e, 0x7, 0x1aa, 0x2, 0x2, 0xc0e, 
       0xc53, 0x7, 0x1ab, 0x2, 0x2, 0xc0f, 0xc10, 0x7, 0x5d, 0x2, 0x2, 0xc10, 
       0xc11, 0x7, 0x1aa, 0x2, 0x2, 0xc11, 0xc14, 0x5, 0x19e, 0xd0, 0x2, 
       0xc12, 0xc13, 0x7, 0x1ac, 0x2, 0x2, 0xc13, 0xc15, 0x7, 0x192, 0x2, 
       0x2, 0xc14, 0xc12, 0x3, 0x2, 0x2, 0x2, 0xc14, 0xc15, 0x3, 0x2, 0x2, 
       0x2, 0xc15, 0xc18, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xc17, 0x7, 0x1ac, 
       0x2, 0x2, 0xc17, 0xc19, 0x7, 0x192, 0x2, 0x2, 0xc18, 0xc16, 0x3, 
       0x2, 0x2, 0x2, 0xc18, 0xc19, 0x3, 0x2, 0x2, 0x2, 0xc19, 0xc1a, 0x3, 
       0x2, 0x2, 0x2, 0xc1a, 0xc1b, 0x7, 0x1ab, 0x2, 0x2, 0xc1b, 0xc53, 
       0x3, 0x2, 0x2, 0x2, 0xc1c, 0xc1d, 0x7, 0x109, 0x2, 0x2, 0xc1d, 0xc1e, 
       0x7, 0x1aa, 0x2, 0x2, 0xc1e, 0xc53, 0x7, 0x1ab, 0x2, 0x2, 0xc1f, 
       0xc20, 0x7, 0x6f, 0x2, 0x2, 0xc20, 0xc21, 0x7, 0x1aa, 0x2, 0x2, 0xc21, 
       0xc22, 0x5, 0xd4, 0x6b, 0x2, 0xc22, 0xc23, 0x7, 0x1ac, 0x2, 0x2, 
       0xc23, 0xc24, 0x5, 0xd4, 0x6b, 0x2, 0xc24, 0xc25, 0x7, 0x1ab, 0x2, 
       0x2, 0xc25, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc26, 0xc27, 0x7, 0x14d, 
       0x2, 0x2, 0xc27, 0xc28, 0x7, 0x1aa, 0x2, 0x2, 0xc28, 0xc29, 0x5, 
       0xd4, 0x6b, 0x2, 0xc29, 0xc2a, 0x7, 0x1ac, 0x2, 0x2, 0xc2a, 0xc2b, 
       0x7, 0x192, 0x2, 0x2, 0xc2b, 0xc2c, 0x7, 0x1ac, 0x2, 0x2, 0xc2c, 
       0xc2d, 0x7, 0x192, 0x2, 0x2, 0xc2d, 0xc2e, 0x7, 0x1ac, 0x2, 0x2, 
       0xc2e, 0xc2f, 0x5, 0xd4, 0x6b, 0x2, 0xc2f, 0xc30, 0x7, 0x1ab, 0x2, 
       0x2, 0xc30, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc31, 0xc53, 0x7, 0x8e, 0x2, 
       0x2, 0xc32, 0xc53, 0x7, 0x92, 0x2, 0x2, 0xc33, 0xc53, 0x7, 0x9f, 
       0x2, 0x2, 0xc34, 0xc35, 0x7, 0x178, 0x2, 0x2, 0xc35, 0xc36, 0x7, 
       0x1aa, 0x2, 0x2, 0xc36, 0xc37, 0x5, 0xd4, 0x6b, 0x2, 0xc37, 0xc38, 
       0x7, 0x1ac, 0x2, 0x2, 0xc38, 0xc39, 0x5, 0xd4, 0x6b, 0x2, 0xc39, 
       0xc3a, 0x7, 0x1ab, 0x2, 0x2, 0xc3a, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc3b, 
       0xc3c, 0x7, 0x176, 0x2, 0x2, 0xc3c, 0xc3d, 0x7, 0x1aa, 0x2, 0x2, 
       0xc3d, 0xc3e, 0x5, 0xec, 0x77, 0x2, 0xc3e, 0xc3f, 0x7, 0x1ac, 0x2, 
       0x2, 0xc3f, 0xc40, 0x5, 0xd4, 0x6b, 0x2, 0xc40, 0xc41, 0x7, 0x1ac, 
       0x2, 0x2, 0xc41, 0xc42, 0x5, 0xd4, 0x6b, 0x2, 0xc42, 0xc43, 0x7, 
       0x1ab, 0x2, 0x2, 0xc43, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc44, 0xc45, 
       0x7, 0x14c, 0x2, 0x2, 0xc45, 0xc46, 0x7, 0x1aa, 0x2, 0x2, 0xc46, 
       0xc47, 0x5, 0xd4, 0x6b, 0x2, 0xc47, 0xc48, 0x7, 0x1ac, 0x2, 0x2, 
       0xc48, 0xc49, 0x5, 0xd4, 0x6b, 0x2, 0xc49, 0xc50, 0x7, 0x1ab, 0x2, 
       0x2, 0xc4a, 0xc4b, 0x7, 0xa6, 0x2, 0x2, 0xc4b, 0xc4c, 0x7, 0x5a, 
       0x2, 0x2, 0xc4c, 0xc4d, 0x7, 0x1aa, 0x2, 0x2, 0xc4d, 0xc4e, 0x5, 
       0xfc, 0x7f, 0x2, 0xc4e, 0xc4f, 0x7, 0x1ab, 0x2, 0x2, 0xc4f, 0xc51, 
       0x3, 0x2, 0x2, 0x2, 0xc50, 0xc4a, 0x3, 0x2, 0x2, 0x2, 0xc50, 0xc51, 
       0x3, 0x2, 0x2, 0x2, 0xc51, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xbc1, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xbc5, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xbcc, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xbd3, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xbde, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xbe2, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xbe7, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xbe8, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xbe9, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xbf2, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xbfb, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xc02, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc09, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xc0c, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc0f, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xc1c, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc1f, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xc26, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc31, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xc32, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc33, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xc34, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc3b, 
       0x3, 0x2, 0x2, 0x2, 0xc52, 0xc44, 0x3, 0x2, 0x2, 0x2, 0xc53, 0x145, 
       0x3, 0x2, 0x2, 0x2, 0xc54, 0xc5b, 0x7, 0x191, 0x2, 0x2, 0xc55, 0xc5b, 
       0x5, 0x1a8, 0xd5, 0x2, 0xc56, 0xc57, 0x7, 0x1aa, 0x2, 0x2, 0xc57, 
       0xc58, 0x5, 0xe2, 0x72, 0x2, 0xc58, 0xc59, 0x7, 0x1ab, 0x2, 0x2, 
       0xc59, 0xc5b, 0x3, 0x2, 0x2, 0x2, 0xc5a, 0xc54, 0x3, 0x2, 0x2, 0x2, 
       0xc5a, 0xc55, 0x3, 0x2, 0x2, 0x2, 0xc5a, 0xc56, 0x3, 0x2, 0x2, 0x2, 
       0xc5b, 0xc5c, 0x3, 0x2, 0x2, 0x2, 0xc5c, 0xc5d, 0x7, 0x1a5, 0x2, 
       0x2, 0xc5d, 0xc5e, 0x7, 0x10f, 0x2, 0x2, 0xc5e, 0xc5f, 0x7, 0x1aa, 
       0x2, 0x2, 0xc5f, 0xc60, 0x7, 0x194, 0x2, 0x2, 0xc60, 0xc61, 0x7, 
       0x1ab, 0x2, 0x2, 0xc61, 0x147, 0x3, 0x2, 0x2, 0x2, 0xc62, 0xc63, 
       0x7, 0xa2, 0x2, 0x2, 0xc63, 0xc64, 0x5, 0xd4, 0x6b, 0x2, 0xc64, 0xc65, 
       0x7, 0x94, 0x2, 0x2, 0xc65, 0xc66, 0x5, 0xd4, 0x6b, 0x2, 0xc66, 0x149, 
       0x3, 0x2, 0x2, 0x2, 0xc67, 0xc68, 0x7, 0xa2, 0x2, 0x2, 0xc68, 0xc69, 
       0x5, 0xec, 0x77, 0x2, 0xc69, 0xc6a, 0x7, 0x94, 0x2, 0x2, 0xc6a, 0xc6b, 
       0x5, 0xd4, 0x6b, 0x2, 0xc6b, 0x14b, 0x3, 0x2, 0x2, 0x2, 0xc6c, 0xc6e, 
       0x7, 0x25, 0x2, 0x2, 0xc6d, 0xc6c, 0x3, 0x2, 0x2, 0x2, 0xc6d, 0xc6e, 
       0x3, 0x2, 0x2, 0x2, 0xc6e, 0xc6f, 0x3, 0x2, 0x2, 0x2, 0xc6f, 0xc70, 
       0x5, 0x15c, 0xaf, 0x2, 0xc70, 0x14d, 0x3, 0x2, 0x2, 0x2, 0xc71, 0xc73, 
       0x7, 0x25, 0x2, 0x2, 0xc72, 0xc71, 0x3, 0x2, 0x2, 0x2, 0xc72, 0xc73, 
       0x3, 0x2, 0x2, 0x2, 0xc73, 0xc74, 0x3, 0x2, 0x2, 0x2, 0xc74, 0xc75, 
       0x5, 0x150, 0xa9, 0x2, 0xc75, 0x14f, 0x3, 0x2, 0x2, 0x2, 0xc76, 0xc78, 
       0x5, 0x1a8, 0xd5, 0x2, 0xc77, 0xc79, 0x5, 0x152, 0xaa, 0x2, 0xc78, 
       0xc77, 0x3, 0x2, 0x2, 0x2, 0xc78, 0xc79, 0x3, 0x2, 0x2, 0x2, 0xc79, 
       0x151, 0x3, 0x2, 0x2, 0x2, 0xc7a, 0xc7c, 0x7, 0xa5, 0x2, 0x2, 0xc7b, 
       0xc7a, 0x3, 0x2, 0x2, 0x2, 0xc7b, 0xc7c, 0x3, 0x2, 0x2, 0x2, 0xc7c, 
       0xc7d, 0x3, 0x2, 0x2, 0x2, 0xc7d, 0xc7e, 0x7, 0x1aa, 0x2, 0x2, 0xc7e, 
       0xc85, 0x5, 0x156, 0xac, 0x2, 0xc7f, 0xc81, 0x7, 0x1ac, 0x2, 0x2, 
       0xc80, 0xc7f, 0x3, 0x2, 0x2, 0x2, 0xc80, 0xc81, 0x3, 0x2, 0x2, 0x2, 
       0xc81, 0xc82, 0x3, 0x2, 0x2, 0x2, 0xc82, 0xc84, 0x5, 0x156, 0xac, 
       0x2, 0xc83, 0xc80, 0x3, 0x2, 0x2, 0x2, 0xc84, 0xc87, 0x3, 0x2, 0x2, 
       0x2, 0xc85, 0xc83, 0x3, 0x2, 0x2, 0x2, 0xc85, 0xc86, 0x3, 0x2, 0x2, 
       0x2, 0xc86, 0xc88, 0x3, 0x2, 0x2, 0x2, 0xc87, 0xc85, 0x3, 0x2, 0x2, 
       0x2, 0xc88, 0xc89, 0x7, 0x1ab, 0x2, 0x2, 0xc89, 0x153, 0x3, 0x2, 
       0x2, 0x2, 0xc8a, 0xc8b, 0x7, 0xa5, 0x2, 0x2, 0xc8b, 0xc8c, 0x7, 0x1aa, 
       0x2, 0x2, 0xc8c, 0xc93, 0x5, 0x156, 0xac, 0x2, 0xc8d, 0xc8f, 0x7, 
       0x1ac, 0x2, 0x2, 0xc8e, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0xc8e, 0xc8f, 
       0x3, 0x2, 0x2, 0x2, 0xc8f, 0xc90, 0x3, 0x2, 0x2, 0x2, 0xc90, 0xc92, 
       0x5, 0x156, 0xac, 0x2, 0xc91, 0xc8e, 0x3, 0x2, 0x2, 0x2, 0xc92, 0xc95, 
       0x3, 0x2, 0x2, 0x2, 0xc93, 0xc91, 0x3, 0x2, 0x2, 0x2, 0xc93, 0xc94, 
       0x3, 0x2, 0x2, 0x2, 0xc94, 0xc96, 0x3, 0x2, 0x2, 0x2, 0xc95, 0xc93, 
       0x3, 0x2, 0x2, 0x2, 0xc96, 0xc97, 0x7, 0x1ab, 0x2, 0x2, 0xc97, 0x155, 
       0x3, 0x2, 0x2, 0x2, 0xc98, 0xc9a, 0x7, 0x110, 0x2, 0x2, 0xc99, 0xc98, 
       0x3, 0x2, 0x2, 0x2, 0xc99, 0xc9a, 0x3, 0x2, 0x2, 0x2, 0xc9a, 0xccc, 
       0x3, 0x2, 0x2, 0x2, 0xc9b, 0xcaf, 0x7, 0x61, 0x2, 0x2, 0xc9c, 0xc9d, 
       0x7, 0x1aa, 0x2, 0x2, 0xc9d, 0xca2, 0x5, 0x158, 0xad, 0x2, 0xc9e, 
       0xc9f, 0x7, 0x1ac, 0x2, 0x2, 0xc9f, 0xca1, 0x5, 0x158, 0xad, 0x2, 
       0xca0, 0xc9e, 0x3, 0x2, 0x2, 0x2, 0xca1, 0xca4, 0x3, 0x2, 0x2, 0x2, 
       0xca2, 0xca0, 0x3, 0x2, 0x2, 0x2, 0xca2, 0xca3, 0x3, 0x2, 0x2, 0x2, 
       0xca3, 0xca5, 0x3, 0x2, 0x2, 0x2, 0xca4, 0xca2, 0x3, 0x2, 0x2, 0x2, 
       0xca5, 0xca6, 0x7, 0x1ab, 0x2, 0x2, 0xca6, 0xcb0, 0x3, 0x2, 0x2, 
       0x2, 0xca7, 0xcac, 0x5, 0x158, 0xad, 0x2, 0xca8, 0xca9, 0x7, 0x1ac, 
       0x2, 0x2, 0xca9, 0xcab, 0x5, 0x158, 0xad, 0x2, 0xcaa, 0xca8, 0x3, 
       0x2, 0x2, 0x2, 0xcab, 0xcae, 0x3, 0x2, 0x2, 0x2, 0xcac, 0xcaa, 0x3, 
       0x2, 0x2, 0x2, 0xcac, 0xcad, 0x3, 0x2, 0x2, 0x2, 0xcad, 0xcb0, 0x3, 
       0x2, 0x2, 0x2, 0xcae, 0xcac, 0x3, 0x2, 0x2, 0x2, 0xcaf, 0xc9c, 0x3, 
       0x2, 0x2, 0x2, 0xcaf, 0xca7, 0x3, 0x2, 0x2, 0x2, 0xcb0, 0xccd, 0x3, 
       0x2, 0x2, 0x2, 0xcb1, 0xcb2, 0x7, 0x61, 0x2, 0x2, 0xcb2, 0xcb3, 0x7, 
       0x198, 0x2, 0x2, 0xcb3, 0xccd, 0x5, 0x158, 0xad, 0x2, 0xcb4, 0xcc3, 
       0x7, 0x175, 0x2, 0x2, 0xcb5, 0xcb6, 0x7, 0x1aa, 0x2, 0x2, 0xcb6, 
       0xcb7, 0x5, 0x158, 0xad, 0x2, 0xcb7, 0xcb8, 0x7, 0x1aa, 0x2, 0x2, 
       0xcb8, 0xcbd, 0x7, 0x193, 0x2, 0x2, 0xcb9, 0xcba, 0x7, 0x1ac, 0x2, 
       0x2, 0xcba, 0xcbc, 0x7, 0x193, 0x2, 0x2, 0xcbb, 0xcb9, 0x3, 0x2, 
       0x2, 0x2, 0xcbc, 0xcbf, 0x3, 0x2, 0x2, 0x2, 0xcbd, 0xcbb, 0x3, 0x2, 
       0x2, 0x2, 0xcbd, 0xcbe, 0x3, 0x2, 0x2, 0x2, 0xcbe, 0xcc0, 0x3, 0x2, 
       0x2, 0x2, 0xcbf, 0xcbd, 0x3, 0x2, 0x2, 0x2, 0xcc0, 0xcc1, 0x7, 0x1ab, 
       0x2, 0x2, 0xcc1, 0xcc2, 0x7, 0x1ab, 0x2, 0x2, 0xcc2, 0xcc4, 0x3, 
       0x2, 0x2, 0x2, 0xcc3, 0xcb5, 0x3, 0x2, 0x2, 0x2, 0xcc3, 0xcc4, 0x3, 
       0x2, 0x2, 0x2, 0xcc4, 0xccd, 0x3, 0x2, 0x2, 0x2, 0xcc5, 0xccd, 0x7, 
       0x140, 0x2, 0x2, 0xcc6, 0xccd, 0x7, 0x146, 0x2, 0x2, 0xcc7, 0xcc8, 
       0x7, 0x147, 0x2, 0x2, 0xcc8, 0xcc9, 0x7, 0x198, 0x2, 0x2, 0xcc9, 
       0xccd, 0x7, 0x192, 0x2, 0x2, 0xcca, 0xccd, 0x7, 0x5c, 0x2, 0x2, 0xccb, 
       0xccd, 0x7, 0x193, 0x2, 0x2, 0xccc, 0xc9b, 0x3, 0x2, 0x2, 0x2, 0xccc, 
       0xcb1, 0x3, 0x2, 0x2, 0x2, 0xccc, 0xcb4, 0x3, 0x2, 0x2, 0x2, 0xccc, 
       0xcc5, 0x3, 0x2, 0x2, 0x2, 0xccc, 0xcc6, 0x3, 0x2, 0x2, 0x2, 0xccc, 
       0xcc7, 0x3, 0x2, 0x2, 0x2, 0xccc, 0xcca, 0x3, 0x2, 0x2, 0x2, 0xccc, 
       0xccb, 0x3, 0x2, 0x2, 0x2, 0xccd, 0x157, 0x3, 0x2, 0x2, 0x2, 0xcce, 
       0xcd1, 0x5, 0x1a8, 0xd5, 0x2, 0xccf, 0xcd1, 0x7, 0x192, 0x2, 0x2, 
       0xcd0, 0xcce, 0x3, 0x2, 0x2, 0x2, 0xcd0, 0xccf, 0x3, 0x2, 0x2, 0x2, 
       0xcd1, 0x159, 0x3, 0x2, 0x2, 0x2, 0xcd2, 0xcd3, 0x7, 0x1aa, 0x2, 
       0x2, 0xcd3, 0xcd8, 0x5, 0x15c, 0xaf, 0x2, 0xcd4, 0xcd5, 0x7, 0x1ac, 
       0x2, 0x2, 0xcd5, 0xcd7, 0x5, 0x15c, 0xaf, 0x2, 0xcd6, 0xcd4, 0x3, 
       0x2, 0x2, 0x2, 0xcd7, 0xcda, 0x3, 0x2, 0x2, 0x2, 0xcd8, 0xcd6, 0x3, 
       0x2, 0x2, 0x2, 0xcd8, 0xcd9, 0x3, 0x2, 0x2, 0x2, 0xcd9, 0xcdb, 0x3, 
       0x2, 0x2, 0x2, 0xcda, 0xcd8, 0x3, 0x2, 0x2, 0x2, 0xcdb, 0xcdc, 0x7, 
       0x1ab, 0x2, 0x2, 0xcdc, 0x15b, 0x3, 0x2, 0x2, 0x2, 0xcdd, 0xce0, 
       0x5, 0x1a8, 0xd5, 0x2, 0xcde, 0xce0, 0x7, 0x194, 0x2, 0x2, 0xcdf, 
       0xcdd, 0x3, 0x2, 0x2, 0x2, 0xcdf, 0xcde, 0x3, 0x2, 0x2, 0x2, 0xce0, 
       0x15d, 0x3, 0x2, 0x2, 0x2, 0xce1, 0xce2, 0x7, 0xa0, 0x2, 0x2, 0xce2, 
       0xce3, 0x7, 0x1aa, 0x2, 0x2, 0xce3, 0xce4, 0x5, 0x160, 0xb1, 0x2, 
       0xce4, 0xcec, 0x7, 0x1ab, 0x2, 0x2, 0xce5, 0xce6, 0x7, 0x1ac, 0x2, 
       0x2, 0xce6, 0xce7, 0x7, 0x1aa, 0x2, 0x2, 0xce7, 0xce8, 0x5, 0x160, 
       0xb1, 0x2, 0xce8, 0xce9, 0x7, 0x1ab, 0x2, 0x2, 0xce9, 0xceb, 0x3, 
       0x2, 0x2, 0x2, 0xcea, 0xce5, 0x3, 0x2, 0x2, 0x2, 0xceb, 0xcee, 0x3, 
       0x2, 0x2, 0x2, 0xcec, 0xcea, 0x3, 0x2, 0x2, 0x2, 0xcec, 0xced, 0x3, 
       0x2, 0x2, 0x2, 0xced, 0x15f, 0x3, 0x2, 0x2, 0x2, 0xcee, 0xcec, 0x3, 
       0x2, 0x2, 0x2, 0xcef, 0xcf4, 0x5, 0xd4, 0x6b, 0x2, 0xcf0, 0xcf1, 
       0x7, 0x1ac, 0x2, 0x2, 0xcf1, 0xcf3, 0x5, 0xd4, 0x6b, 0x2, 0xcf2, 
       0xcf0, 0x3, 0x2, 0x2, 0x2, 0xcf3, 0xcf6, 0x3, 0x2, 0x2, 0x2, 0xcf4, 
       0xcf2, 0x3, 0x2, 0x2, 0x2, 0xcf4, 0xcf5, 0x3, 0x2, 0x2, 0x2, 0xcf5, 
       0x161, 0x3, 0x2, 0x2, 0x2, 0xcf6, 0xcf4, 0x3, 0x2, 0x2, 0x2, 0xcf7, 
       0xcf8, 0x9, 0x2d, 0x2, 0x2, 0xcf8, 0xcf9, 0x7, 0x1aa, 0x2, 0x2, 0xcf9, 
       0xcfa, 0x7, 0x1ab, 0x2, 0x2, 0xcfa, 0xd02, 0x5, 0x16a, 0xb6, 0x2, 
       0xcfb, 0xcfc, 0x7, 0x112, 0x2, 0x2, 0xcfc, 0xcfd, 0x7, 0x1aa, 0x2, 
       0x2, 0xcfd, 0xcfe, 0x5, 0xd4, 0x6b, 0x2, 0xcfe, 0xcff, 0x7, 0x1ab, 
       0x2, 0x2, 0xcff, 0xd00, 0x5, 0x16a, 0xb6, 0x2, 0xd00, 0xd02, 0x3, 
       0x2, 0x2, 0x2, 0xd01, 0xcf7, 0x3, 0x2, 0x2, 0x2, 0xd01, 0xcfb, 0x3, 
       0x2, 0x2, 0x2, 0xd02, 0x163, 0x3, 0x2, 0x2, 0x2, 0xd03, 0xd04, 0x9, 
       0x2e, 0x2, 0x2, 0xd04, 0xd05, 0x7, 0x1aa, 0x2, 0x2, 0xd05, 0xd06, 
       0x5, 0x168, 0xb5, 0x2, 0xd06, 0xd08, 0x7, 0x1ab, 0x2, 0x2, 0xd07, 
       0xd09, 0x5, 0x16a, 0xb6, 0x2, 0xd08, 0xd07, 0x3, 0x2, 0x2, 0x2, 0xd08, 
       0xd09, 0x3, 0x2, 0x2, 0x2, 0xd09, 0xd24, 0x3, 0x2, 0x2, 0x2, 0xd0a, 
       0xd0b, 0x9, 0x2f, 0x2, 0x2, 0xd0b, 0xd0e, 0x7, 0x1aa, 0x2, 0x2, 0xd0c, 
       0xd0f, 0x7, 0x1b0, 0x2, 0x2, 0xd0d, 0xd0f, 0x5, 0x168, 0xb5, 0x2, 
       0xd0e, 0xd0c, 0x3, 0x2, 0x2, 0x2, 0xd0e, 0xd0d, 0x3, 0x2, 0x2, 0x2, 
       0xd0f, 0xd10, 0x3, 0x2, 0x2, 0x2, 0xd10, 0xd12, 0x7, 0x1ab, 0x2, 
       0x2, 0xd11, 0xd13, 0x5, 0x16a, 0xb6, 0x2, 0xd12, 0xd11, 0x3, 0x2, 
       0x2, 0x2, 0xd12, 0xd13, 0x3, 0x2, 0x2, 0x2, 0xd13, 0xd24, 0x3, 0x2, 
       0x2, 0x2, 0xd14, 0xd15, 0x7, 0xbf, 0x2, 0x2, 0xd15, 0xd16, 0x7, 0x1aa, 
       0x2, 0x2, 0xd16, 0xd17, 0x5, 0x168, 0xb5, 0x2, 0xd17, 0xd18, 0x7, 
       0x1ab, 0x2, 0x2, 0xd18, 0xd24, 0x3, 0x2, 0x2, 0x2, 0xd19, 0xd1a, 
       0x7, 0xe9, 0x2, 0x2, 0xd1a, 0xd1b, 0x7, 0x1aa, 0x2, 0x2, 0xd1b, 0xd1c, 
       0x5, 0xd4, 0x6b, 0x2, 0xd1c, 0xd1d, 0x7, 0x1ab, 0x2, 0x2, 0xd1d, 
       0xd24, 0x3, 0x2, 0x2, 0x2, 0xd1e, 0xd1f, 0x7, 0xea, 0x2, 0x2, 0xd1f, 
       0xd20, 0x7, 0x1aa, 0x2, 0x2, 0xd20, 0xd21, 0x5, 0x160, 0xb1, 0x2, 
       0xd21, 0xd22, 0x7, 0x1ab, 0x2, 0x2, 0xd22, 0xd24, 0x3, 0x2, 0x2, 
       0x2, 0xd23, 0xd03, 0x3, 0x2, 0x2, 0x2, 0xd23, 0xd0a, 0x3, 0x2, 0x2, 
       0x2, 0xd23, 0xd14, 0x3, 0x2, 0x2, 0x2, 0xd23, 0xd19, 0x3, 0x2, 0x2, 
       0x2, 0xd23, 0xd1e, 0x3, 0x2, 0x2, 0x2, 0xd24, 0x165, 0x3, 0x2, 0x2, 
       0x2, 0xd25, 0xd26, 0x9, 0x30, 0x2, 0x2, 0xd26, 0xd27, 0x7, 0x1aa, 
       0x2, 0x2, 0xd27, 0xd28, 0x5, 0xd4, 0x6b, 0x2, 0xd28, 0xd29, 0x7, 
       0x1ab, 0x2, 0x2, 0xd29, 0xd2a, 0x5, 0x16a, 0xb6, 0x2, 0xd2a, 0xd5e, 
       0x3, 0x2, 0x2, 0x2, 0xd2b, 0xd2c, 0x9, 0x31, 0x2, 0x2, 0xd2c, 0xd2d, 
       0x7, 0x1aa, 0x2, 0x2, 0xd2d, 0xd34, 0x5, 0xd4, 0x6b, 0x2, 0xd2e, 
       0xd2f, 0x7, 0x1ac, 0x2, 0x2, 0xd2f, 0xd32, 0x5, 0xd4, 0x6b, 0x2, 
       0xd30, 0xd31, 0x7, 0x1ac, 0x2, 0x2, 0xd31, 0xd33, 0x5, 0xd4, 0x6b, 
       0x2, 0xd32, 0xd30, 0x3, 0x2, 0x2, 0x2, 0xd32, 0xd33, 0x3, 0x2, 0x2, 
       0x2, 0xd33, 0xd35, 0x3, 0x2, 0x2, 0x2, 0xd34, 0xd2e, 0x3, 0x2, 0x2, 
       0x2, 0xd34, 0xd35, 0x3, 0x2, 0x2, 0x2, 0xd35, 0xd36, 0x3, 0x2, 0x2, 
       0x2, 0xd36, 0xd37, 0x7, 0x1ab, 0x2, 0x2, 0xd37, 0xd38, 0x5, 0x16a, 
       0xb6, 0x2, 0xd38, 0xd5e, 0x3, 0x2, 0x2, 0x2, 0xd39, 0xd3a, 0x9, 0x32, 
       0x2, 0x2, 0xd3a, 0xd3b, 0x7, 0x1aa, 0x2, 0x2, 0xd3b, 0xd3c, 0x7, 
       0x1ab, 0x2, 0x2, 0xd3c, 0xd3d, 0x7, 0x78, 0x2, 0x2, 0xd3d, 0xd41, 
       0x7, 0x1aa, 0x2, 0x2, 0xd3e, 0xd3f, 0x7, 0x11f, 0x2, 0x2, 0xd3f, 
       0xd40, 0x7, 0x2c, 0x2, 0x2, 0xd40, 0xd42, 0x5, 0x160, 0xb1, 0x2, 
       0xd41, 0xd3e, 0x3, 0x2, 0x2, 0x2, 0xd41, 0xd42, 0x3, 0x2, 0x2, 0x2, 
       0xd42, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd43, 0xd44, 0x5, 0xfc, 0x7f, 
       0x2, 0xd44, 0xd45, 0x7, 0x1ab, 0x2, 0x2, 0xd45, 0xd5e, 0x3, 0x2, 
       0x2, 0x2, 0xd46, 0xd47, 0x9, 0x33, 0x2, 0x2, 0xd47, 0xd48, 0x7, 0x1aa, 
       0x2, 0x2, 0xd48, 0xd49, 0x5, 0xd4, 0x6b, 0x2, 0xd49, 0xd4a, 0x7, 
       0x1ab, 0x2, 0x2, 0xd4a, 0xd4b, 0x7, 0xa6, 0x2, 0x2, 0xd4b, 0xd4c, 
       0x7, 0x5a, 0x2, 0x2, 0xd4c, 0xd4d, 0x7, 0x1aa, 0x2, 0x2, 0xd4d, 0xd4e, 
       0x7, 0x76, 0x2, 0x2, 0xd4e, 0xd4f, 0x7, 0x2c, 0x2, 0x2, 0xd4f, 0xd51, 
       0x5, 0xd4, 0x6b, 0x2, 0xd50, 0xd52, 0x9, 0x34, 0x2, 0x2, 0xd51, 0xd50, 
       0x3, 0x2, 0x2, 0x2, 0xd51, 0xd52, 0x3, 0x2, 0x2, 0x2, 0xd52, 0xd53, 
       0x3, 0x2, 0x2, 0x2, 0xd53, 0xd54, 0x7, 0x1ab, 0x2, 0x2, 0xd54, 0xd55, 
       0x7, 0x78, 0x2, 0x2, 0xd55, 0xd59, 0x7, 0x1aa, 0x2, 0x2, 0xd56, 0xd57, 
       0x7, 0x11f, 0x2, 0x2, 0xd57, 0xd58, 0x7, 0x2c, 0x2, 0x2, 0xd58, 0xd5a, 
       0x5, 0x160, 0xb1, 0x2, 0xd59, 0xd56, 0x3, 0x2, 0x2, 0x2, 0xd59, 0xd5a, 
       0x3, 0x2, 0x2, 0x2, 0xd5a, 0xd5b, 0x3, 0x2, 0x2, 0x2, 0xd5b, 0xd5c, 
       0x7, 0x1ab, 0x2, 0x2, 0xd5c, 0xd5e, 0x3, 0x2, 0x2, 0x2, 0xd5d, 0xd25, 
       0x3, 0x2, 0x2, 0x2, 0xd5d, 0xd2b, 0x3, 0x2, 0x2, 0x2, 0xd5d, 0xd39, 
       0x3, 0x2, 0x2, 0x2, 0xd5d, 0xd46, 0x3, 0x2, 0x2, 0x2, 0xd5e, 0x167, 
       0x3, 0x2, 0x2, 0x2, 0xd5f, 0xd61, 0x9, 0x20, 0x2, 0x2, 0xd60, 0xd5f, 
       0x3, 0x2, 0x2, 0x2, 0xd60, 0xd61, 0x3, 0x2, 0x2, 0x2, 0xd61, 0xd62, 
       0x3, 0x2, 0x2, 0x2, 0xd62, 0xd63, 0x5, 0xd4, 0x6b, 0x2, 0xd63, 0x169, 
       0x3, 0x2, 0x2, 0x2, 0xd64, 0xd65, 0x7, 0x78, 0x2, 0x2, 0xd65, 0xd69, 
       0x7, 0x1aa, 0x2, 0x2, 0xd66, 0xd67, 0x7, 0x11f, 0x2, 0x2, 0xd67, 
       0xd68, 0x7, 0x2c, 0x2, 0x2, 0xd68, 0xd6a, 0x5, 0x160, 0xb1, 0x2, 
       0xd69, 0xd66, 0x3, 0x2, 0x2, 0x2, 0xd69, 0xd6a, 0x3, 0x2, 0x2, 0x2, 
       0xd6a, 0xd6c, 0x3, 0x2, 0x2, 0x2, 0xd6b, 0xd6d, 0x5, 0xfc, 0x7f, 
       0x2, 0xd6c, 0xd6b, 0x3, 0x2, 0x2, 0x2, 0xd6c, 0xd6d, 0x3, 0x2, 0x2, 
       0x2, 0xd6d, 0xd6f, 0x3, 0x2, 0x2, 0x2, 0xd6e, 0xd70, 0x5, 0x16c, 
       0xb7, 0x2, 0xd6f, 0xd6e, 0x3, 0x2, 0x2, 0x2, 0xd6f, 0xd70, 0x3, 0x2, 
       0x2, 0x2, 0xd70, 0xd71, 0x3, 0x2, 0x2, 0x2, 0xd71, 0xd72, 0x7, 0x1ab, 
       0x2, 0x2, 0xd72, 0x16b, 0x3, 0x2, 0x2, 0x2, 0xd73, 0xd74, 0x9, 0x35, 
       0x2, 0x2, 0xd74, 0xd75, 0x5, 0x16e, 0xb8, 0x2, 0xd75, 0x16d, 0x3, 
       0x2, 0x2, 0x2, 0xd76, 0xd7d, 0x5, 0x172, 0xba, 0x2, 0xd77, 0xd78, 
       0x7, 0x2a, 0x2, 0x2, 0xd78, 0xd79, 0x5, 0x170, 0xb9, 0x2, 0xd79, 
       0xd7a, 0x7, 0x23, 0x2, 0x2, 0xd7a, 0xd7b, 0x5, 0x170, 0xb9, 0x2, 
       0xd7b, 0xd7d, 0x3, 0x2, 0x2, 0x2, 0xd7c, 0xd76, 0x3, 0x2, 0x2, 0x2, 
       0xd7c, 0xd77, 0x3, 0x2, 0x2, 0x2, 0xd7d, 0x16f, 0x3, 0x2, 0x2, 0x2, 
       0xd7e, 0xd81, 0x5, 0x172, 0xba, 0x2, 0xd7f, 0xd81, 0x5, 0x174, 0xbb, 
       0x2, 0xd80, 0xd7e, 0x3, 0x2, 0x2, 0x2, 0xd80, 0xd7f, 0x3, 0x2, 0x2, 
       0x2, 0xd81, 0x171, 0x3, 0x2, 0x2, 0x2, 0xd82, 0xd83, 0x7, 0x15c, 
       0x2, 0x2, 0xd83, 0xd89, 0x7, 0x124, 0x2, 0x2, 0xd84, 0xd85, 0x7, 
       0x192, 0x2, 0x2, 0xd85, 0xd89, 0x7, 0x124, 0x2, 0x2, 0xd86, 0xd87, 
       0x7, 0x3a, 0x2, 0x2, 0xd87, 0xd89, 0x7, 0x135, 0x2, 0x2, 0xd88, 0xd82, 
       0x3, 0x2, 0x2, 0x2, 0xd88, 0xd84, 0x3, 0x2, 0x2, 0x2, 0xd88, 0xd86, 
       0x3, 0x2, 0x2, 0x2, 0xd89, 0x173, 0x3, 0x2, 0x2, 0x2, 0xd8a, 0xd8b, 
       0x7, 0x15c, 0x2, 0x2, 0xd8b, 0xd8f, 0x7, 0xe0, 0x2, 0x2, 0xd8c, 0xd8d, 
       0x7, 0x192, 0x2, 0x2, 0xd8d, 0xd8f, 0x7, 0xe0, 0x2, 0x2, 0xd8e, 0xd8a, 
       0x3, 0x2, 0x2, 0x2, 0xd8e, 0xd8c, 0x3, 0x2, 0x2, 0x2, 0xd8f, 0x175, 
       0x3, 0x2, 0x2, 0x2, 0xd90, 0xd91, 0x5, 0x1a8, 0xd5, 0x2, 0xd91, 0xd92, 
       0x7, 0x1a5, 0x2, 0x2, 0xd92, 0xd93, 0x5, 0x1a8, 0xd5, 0x2, 0xd93, 
       0xd94, 0x7, 0x1a5, 0x2, 0x2, 0xd94, 0xd95, 0x5, 0x1a8, 0xd5, 0x2, 
       0xd95, 0xd96, 0x7, 0x1a5, 0x2, 0x2, 0xd96, 0xda2, 0x3, 0x2, 0x2, 
       0x2, 0xd97, 0xd98, 0x5, 0x1a8, 0xd5, 0x2, 0xd98, 0xd9a, 0x7, 0x1a5, 
       0x2, 0x2, 0xd99, 0xd9b, 0x5, 0x1a8, 0xd5, 0x2, 0xd9a, 0xd99, 0x3, 
       0x2, 0x2, 0x2, 0xd9a, 0xd9b, 0x3, 0x2, 0x2, 0x2, 0xd9b, 0xd9c, 0x3, 
       0x2, 0x2, 0x2, 0xd9c, 0xd9d, 0x7, 0x1a5, 0x2, 0x2, 0xd9d, 0xda2, 
       0x3, 0x2, 0x2, 0x2, 0xd9e, 0xd9f, 0x5, 0x1a8, 0xd5, 0x2, 0xd9f, 0xda0, 
       0x7, 0x1a5, 0x2, 0x2, 0xda0, 0xda2, 0x3, 0x2, 0x2, 0x2, 0xda1, 0xd90, 
       0x3, 0x2, 0x2, 0x2, 0xda1, 0xd97, 0x3, 0x2, 0x2, 0x2, 0xda1, 0xd9e, 
       0x3, 0x2, 0x2, 0x2, 0xda1, 0xda2, 0x3, 0x2, 0x2, 0x2, 0xda2, 0xda3, 
       0x3, 0x2, 0x2, 0x2, 0xda3, 0xda4, 0x5, 0x1a8, 0xd5, 0x2, 0xda4, 0x177, 
       0x3, 0x2, 0x2, 0x2, 0xda5, 0xdab, 0x5, 0x1a8, 0xd5, 0x2, 0xda6, 0xda7, 
       0x5, 0x1a8, 0xd5, 0x2, 0xda7, 0xda8, 0x7, 0x1a5, 0x2, 0x2, 0xda8, 
       0xda9, 0x5, 0x1a8, 0xd5, 0x2, 0xda9, 0xdab, 0x3, 0x2, 0x2, 0x2, 0xdaa, 
       0xda5, 0x3, 0x2, 0x2, 0x2, 0xdaa, 0xda6, 0x3, 0x2, 0x2, 0x2, 0xdab, 
       0x179, 0x3, 0x2, 0x2, 0x2, 0xdac, 0xdb2, 0x5, 0x1a8, 0xd5, 0x2, 0xdad, 
       0xdae, 0x5, 0x1a8, 0xd5, 0x2, 0xdae, 0xdaf, 0x7, 0x1a5, 0x2, 0x2, 
       0xdaf, 0xdb0, 0x5, 0x1a8, 0xd5, 0x2, 0xdb0, 0xdb2, 0x3, 0x2, 0x2, 
       0x2, 0xdb1, 0xdac, 0x3, 0x2, 0x2, 0x2, 0xdb1, 0xdad, 0x3, 0x2, 0x2, 
       0x2, 0xdb2, 0x17b, 0x3, 0x2, 0x2, 0x2, 0xdb3, 0xdb4, 0x5, 0x1a8, 
       0xd5, 0x2, 0xdb4, 0xdb5, 0x7, 0x1a5, 0x2, 0x2, 0xdb5, 0xdb6, 0x5, 
       0x1a8, 0xd5, 0x2, 0xdb6, 0xdb7, 0x7, 0x1a5, 0x2, 0x2, 0xdb7, 0xdb8, 
       0x5, 0x1a8, 0xd5, 0x2, 0xdb8, 0xdb9, 0x7, 0x1a5, 0x2, 0x2, 0xdb9, 
       0xdc5, 0x3, 0x2, 0x2, 0x2, 0xdba, 0xdbb, 0x5, 0x1a8, 0xd5, 0x2, 0xdbb, 
       0xdbd, 0x7, 0x1a5, 0x2, 0x2, 0xdbc, 0xdbe, 0x5, 0x1a8, 0xd5, 0x2, 
       0xdbd, 0xdbc, 0x3, 0x2, 0x2, 0x2, 0xdbd, 0xdbe, 0x3, 0x2, 0x2, 0x2, 
       0xdbe, 0xdbf, 0x3, 0x2, 0x2, 0x2, 0xdbf, 0xdc0, 0x7, 0x1a5, 0x2, 
       0x2, 0xdc0, 0xdc5, 0x3, 0x2, 0x2, 0x2, 0xdc1, 0xdc2, 0x5, 0x1a8, 
       0xd5, 0x2, 0xdc2, 0xdc3, 0x7, 0x1a5, 0x2, 0x2, 0xdc3, 0xdc5, 0x3, 
       0x2, 0x2, 0x2, 0xdc4, 0xdb3, 0x3, 0x2, 0x2, 0x2, 0xdc4, 0xdba, 0x3, 
       0x2, 0x2, 0x2, 0xdc4, 0xdc1, 0x3, 0x2, 0x2, 0x2, 0xdc4, 0xdc5, 0x3, 
       0x2, 0x2, 0x2, 0xdc5, 0xdc6, 0x3, 0x2, 0x2, 0x2, 0xdc6, 0xdc7, 0x5, 
       0x1a8, 0xd5, 0x2, 0xdc7, 0x17d, 0x3, 0x2, 0x2, 0x2, 0xdc8, 0xde4, 
       0x7, 0x191, 0x2, 0x2, 0xdc9, 0xdca, 0x5, 0x1a8, 0xd5, 0x2, 0xdca, 
       0xdcc, 0x7, 0x1a5, 0x2, 0x2, 0xdcb, 0xdcd, 0x5, 0x1a8, 0xd5, 0x2, 
       0xdcc, 0xdcb, 0x3, 0x2, 0x2, 0x2, 0xdcc, 0xdcd, 0x3, 0x2, 0x2, 0x2, 
       0xdcd, 0xdce, 0x3, 0x2, 0x2, 0x2, 0xdce, 0xdcf, 0x7, 0x1a5, 0x2, 
       0x2, 0xdcf, 0xdd4, 0x3, 0x2, 0x2, 0x2, 0xdd0, 0xdd1, 0x5, 0x1a8, 
       0xd5, 0x2, 0xdd1, 0xdd2, 0x7, 0x1a5, 0x2, 0x2, 0xdd2, 0xdd4, 0x3, 
       0x2, 0x2, 0x2, 0xdd3, 0xdc9, 0x3, 0x2, 0x2, 0x2, 0xdd3, 0xdd0, 0x3, 
       0x2, 0x2, 0x2, 0xdd3, 0xdd4, 0x3, 0x2, 0x2, 0x2, 0xdd4, 0xdd5, 0x3, 
       0x2, 0x2, 0x2, 0xdd5, 0xde4, 0x5, 0x1a8, 0xd5, 0x2, 0xdd6, 0xdd7, 
       0x5, 0x1a8, 0xd5, 0x2, 0xdd7, 0xdd9, 0x7, 0x1a5, 0x2, 0x2, 0xdd8, 
       0xdda, 0x5, 0x1a8, 0xd5, 0x2, 0xdd9, 0xdd8, 0x3, 0x2, 0x2, 0x2, 0xdd9, 
       0xdda, 0x3, 0x2, 0x2, 0x2, 0xdda, 0xddb, 0x3, 0x2, 0x2, 0x2, 0xddb, 
       0xddc, 0x7, 0x1a5, 0x2, 0x2, 0xddc, 0xde1, 0x3, 0x2, 0x2, 0x2, 0xddd, 
       0xdde, 0x5, 0x1a8, 0xd5, 0x2, 0xdde, 0xddf, 0x7, 0x1a5, 0x2, 0x2, 
       0xddf, 0xde1, 0x3, 0x2, 0x2, 0x2, 0xde0, 0xdd6, 0x3, 0x2, 0x2, 0x2, 
       0xde0, 0xddd, 0x3, 0x2, 0x2, 0x2, 0xde0, 0xde1, 0x3, 0x2, 0x2, 0x2, 
       0xde1, 0xde2, 0x3, 0x2, 0x2, 0x2, 0xde2, 0xde4, 0x7, 0x169, 0x2, 
       0x2, 0xde3, 0xdc8, 0x3, 0x2, 0x2, 0x2, 0xde3, 0xdd3, 0x3, 0x2, 0x2, 
       0x2, 0xde3, 0xde0, 0x3, 0x2, 0x2, 0x2, 0xde4, 0x17f, 0x3, 0x2, 0x2, 
       0x2, 0xde5, 0xde6, 0x5, 0x1a8, 0xd5, 0x2, 0xde6, 0xde7, 0x7, 0x1a5, 
       0x2, 0x2, 0xde7, 0xde9, 0x3, 0x2, 0x2, 0x2, 0xde8, 0xde5, 0x3, 0x2, 
       0x2, 0x2, 0xde8, 0xde9, 0x3, 0x2, 0x2, 0x2, 0xde9, 0xdea, 0x3, 0x2, 
       0x2, 0x2, 0xdea, 0xdeb, 0x5, 0x1a8, 0xd5, 0x2, 0xdeb, 0x181, 0x3, 
       0x2, 0x2, 0x2, 0xdec, 0xded, 0x5, 0x1a8, 0xd5, 0x2, 0xded, 0xdee, 
       0x7, 0x1a5, 0x2, 0x2, 0xdee, 0xdf0, 0x3, 0x2, 0x2, 0x2, 0xdef, 0xdec, 
       0x3, 0x2, 0x2, 0x2, 0xdef, 0xdf0, 0x3, 0x2, 0x2, 0x2, 0xdf0, 0xdf1, 
       0x3, 0x2, 0x2, 0x2, 0xdf1, 0xdf2, 0x5, 0x1a8, 0xd5, 0x2, 0xdf2, 0x183, 
       0x3, 0x2, 0x2, 0x2, 0xdf3, 0xdf5, 0x5, 0x1a8, 0xd5, 0x2, 0xdf4, 0xdf3, 
       0x3, 0x2, 0x2, 0x2, 0xdf4, 0xdf5, 0x3, 0x2, 0x2, 0x2, 0xdf5, 0xdf6, 
       0x3, 0x2, 0x2, 0x2, 0xdf6, 0xdf8, 0x7, 0x1a5, 0x2, 0x2, 0xdf7, 0xdf9, 
       0x5, 0x1a8, 0xd5, 0x2, 0xdf8, 0xdf7, 0x3, 0x2, 0x2, 0x2, 0xdf8, 0xdf9, 
       0x3, 0x2, 0x2, 0x2, 0xdf9, 0xdfa, 0x3, 0x2, 0x2, 0x2, 0xdfa, 0xdfb, 
       0x7, 0x1a5, 0x2, 0x2, 0xdfb, 0xdfe, 0x5, 0x1a8, 0xd5, 0x2, 0xdfc, 
       0xdfe, 0x5, 0x182, 0xc2, 0x2, 0xdfd, 0xdf4, 0x3, 0x2, 0x2, 0x2, 0xdfd, 
       0xdfc, 0x3, 0x2, 0x2, 0x2, 0xdfe, 0x185, 0x3, 0x2, 0x2, 0x2, 0xdff, 
       0xe01, 0x5, 0x1a8, 0xd5, 0x2, 0xe00, 0xdff, 0x3, 0x2, 0x2, 0x2, 0xe00, 
       0xe01, 0x3, 0x2, 0x2, 0x2, 0xe01, 0xe02, 0x3, 0x2, 0x2, 0x2, 0xe02, 
       0xe04, 0x7, 0x1a5, 0x2, 0x2, 0xe03, 0xe05, 0x5, 0x1a8, 0xd5, 0x2, 
       0xe04, 0xe03, 0x3, 0x2, 0x2, 0x2, 0xe04, 0xe05, 0x3, 0x2, 0x2, 0x2, 
       0xe05, 0xe06, 0x3, 0x2, 0x2, 0x2, 0xe06, 0xe08, 0x7, 0x1a5, 0x2, 
       0x2, 0xe07, 0xe09, 0x5, 0x1a8, 0xd5, 0x2, 0xe08, 0xe07, 0x3, 0x2, 
       0x2, 0x2, 0xe08, 0xe09, 0x3, 0x2, 0x2, 0x2, 0xe09, 0xe0a, 0x3, 0x2, 
       0x2, 0x2, 0xe0a, 0xe0b, 0x7, 0x1a5, 0x2, 0x2, 0xe0b, 0xe0e, 0x5, 
       0x1a8, 0xd5, 0x2, 0xe0c, 0xe0e, 0x5, 0x184, 0xc3, 0x2, 0xe0d, 0xe00, 
       0x3, 0x2, 0x2, 0x2, 0xe0d, 0xe0c, 0x3, 0x2, 0x2, 0x2, 0xe0e, 0x187, 
       0x3, 0x2, 0x2, 0x2, 0xe0f, 0xe12, 0x5, 0x17c, 0xbf, 0x2, 0xe10, 0xe12, 
       0x7, 0x191, 0x2, 0x2, 0xe11, 0xe0f, 0x3, 0x2, 0x2, 0x2, 0xe11, 0xe10, 
       0x3, 0x2, 0x2, 0x2, 0xe12, 0x189, 0x3, 0x2, 0x2, 0x2, 0xe13, 0xe14, 
       0x9, 0x28, 0x2, 0x2, 0xe14, 0xe15, 0x7, 0x1a5, 0x2, 0x2, 0xe15, 0xe33, 
       0x5, 0x1a8, 0xd5, 0x2, 0xe16, 0xe18, 0x5, 0x1a8, 0xd5, 0x2, 0xe17, 
       0xe16, 0x3, 0x2, 0x2, 0x2, 0xe17, 0xe18, 0x3, 0x2, 0x2, 0x2, 0xe18, 
       0xe19, 0x3, 0x2, 0x2, 0x2, 0xe19, 0xe1b, 0x7, 0x1a5, 0x2, 0x2, 0xe1a, 
       0xe1c, 0x5, 0x1a8, 0xd5, 0x2, 0xe1b, 0xe1a, 0x3, 0x2, 0x2, 0x2, 0xe1b, 
       0xe1c, 0x3, 0x2, 0x2, 0x2, 0xe1c, 0xe1d, 0x3, 0x2, 0x2, 0x2, 0xe1d, 
       0xe1f, 0x7, 0x1a5, 0x2, 0x2, 0xe1e, 0xe20, 0x5, 0x1a8, 0xd5, 0x2, 
       0xe1f, 0xe1e, 0x3, 0x2, 0x2, 0x2, 0xe1f, 0xe20, 0x3, 0x2, 0x2, 0x2, 
       0xe20, 0xe21, 0x3, 0x2, 0x2, 0x2, 0xe21, 0xe22, 0x7, 0x1a5, 0x2, 
       0x2, 0xe22, 0xe33, 0x5, 0x1a8, 0xd5, 0x2, 0xe23, 0xe25, 0x5, 0x1a8, 
       0xd5, 0x2, 0xe24, 0xe23, 0x3, 0x2, 0x2, 0x2, 0xe24, 0xe25, 0x3, 0x2, 
       0x2, 0x2, 0xe25, 0xe26, 0x3, 0x2, 0x2, 0x2, 0xe26, 0xe28, 0x7, 0x1a5, 
       0x2, 0x2, 0xe27, 0xe29, 0x5, 0x1a8, 0xd5, 0x2, 0xe28, 0xe27, 0x3, 
       0x2, 0x2, 0x2, 0xe28, 0xe29, 0x3, 0x2, 0x2, 0x2, 0xe29, 0xe2a, 0x3, 
       0x2, 0x2, 0x2, 0xe2a, 0xe2b, 0x7, 0x1a5, 0x2, 0x2, 0xe2b, 0xe33, 
       0x5, 0x1a8, 0xd5, 0x2, 0xe2c, 0xe2e, 0x5, 0x1a8, 0xd5, 0x2, 0xe2d, 
       0xe2c, 0x3, 0x2, 0x2, 0x2, 0xe2d, 0xe2e, 0x3, 0x2, 0x2, 0x2, 0xe2e, 
       0xe2f, 0x3, 0x2, 0x2, 0x2, 0xe2f, 0xe30, 0x7, 0x1a5, 0x2, 0x2, 0xe30, 
       0xe33, 0x5, 0x1a8, 0xd5, 0x2, 0xe31, 0xe33, 0x5, 0x1a8, 0xd5, 0x2, 
       0xe32, 0xe13, 0x3, 0x2, 0x2, 0x2, 0xe32, 0xe17, 0x3, 0x2, 0x2, 0x2, 
       0xe32, 0xe24, 0x3, 0x2, 0x2, 0x2, 0xe32, 0xe2d, 0x3, 0x2, 0x2, 0x2, 
       0xe32, 0xe31, 0x3, 0x2, 0x2, 0x2, 0xe33, 0x18b, 0x3, 0x2, 0x2, 0x2, 
       0xe34, 0xe36, 0x5, 0x1a8, 0xd5, 0x2, 0xe35, 0xe37, 0x9, 0x34, 0x2, 
       0x2, 0xe36, 0xe35, 0x3, 0x2, 0x2, 0x2, 0xe36, 0xe37, 0x3, 0x2, 0x2, 
       0x2, 0xe37, 0xe3f, 0x3, 0x2, 0x2, 0x2, 0xe38, 0xe39, 0x7, 0x1ac, 
       0x2, 0x2, 0xe39, 0xe3b, 0x5, 0x1a8, 0xd5, 0x2, 0xe3a, 0xe3c, 0x9, 
       0x34, 0x2, 0x2, 0xe3b, 0xe3a, 0x3, 0x2, 0x2, 0x2, 0xe3b, 0xe3c, 0x3, 
       0x2, 0x2, 0x2, 0xe3c, 0xe3e, 0x3, 0x2, 0x2, 0x2, 0xe3d, 0xe38, 0x3, 
       0x2, 0x2, 0x2, 0xe3e, 0xe41, 0x3, 0x2, 0x2, 0x2, 0xe3f, 0xe3d, 0x3, 
       0x2, 0x2, 0x2, 0xe3f, 0xe40, 0x3, 0x2, 0x2, 0x2, 0xe40, 0x18d, 0x3, 
       0x2, 0x2, 0x2, 0xe41, 0xe3f, 0x3, 0x2, 0x2, 0x2, 0xe42, 0xe47, 0x5, 
       0x190, 0xc9, 0x2, 0xe43, 0xe44, 0x7, 0x1ac, 0x2, 0x2, 0xe44, 0xe46, 
       0x5, 0x190, 0xc9, 0x2, 0xe45, 0xe43, 0x3, 0x2, 0x2, 0x2, 0xe46, 0xe49, 
       0x3, 0x2, 0x2, 0x2, 0xe47, 0xe45, 0x3, 0x2, 0x2, 0x2, 0xe47, 0xe48, 
       0x3, 0x2, 0x2, 0x2, 0xe48, 0x18f, 0x3, 0x2, 0x2, 0x2, 0xe49, 0xe47, 
       0x3, 0x2, 0x2, 0x2, 0xe4a, 0xe4c, 0x5, 0x1a8, 0xd5, 0x2, 0xe4b, 0xe4a, 
       0x3, 0x2, 0x2, 0x2, 0xe4b, 0xe4c, 0x3, 0x2, 0x2, 0x2, 0xe4c, 0xe4d, 
       0x3, 0x2, 0x2, 0x2, 0xe4d, 0xe4f, 0x7, 0x1a5, 0x2, 0x2, 0xe4e, 0xe4b, 
       0x3, 0x2, 0x2, 0x2, 0xe4f, 0xe52, 0x3, 0x2, 0x2, 0x2, 0xe50, 0xe4e, 
       0x3, 0x2, 0x2, 0x2, 0xe50, 0xe51, 0x3, 0x2, 0x2, 0x2, 0xe51, 0xe53, 
       0x3, 0x2, 0x2, 0x2, 0xe52, 0xe50, 0x3, 0x2, 0x2, 0x2, 0xe53, 0xe54, 
       0x5, 0x1a8, 0xd5, 0x2, 0xe54, 0x191, 0x3, 0x2, 0x2, 0x2, 0xe55, 0xe5a, 
       0x5, 0x1a8, 0xd5, 0x2, 0xe56, 0xe57, 0x7, 0x1ac, 0x2, 0x2, 0xe57, 
       0xe59, 0x5, 0x1a8, 0xd5, 0x2, 0xe58, 0xe56, 0x3, 0x2, 0x2, 0x2, 0xe59, 
       0xe5c, 0x3, 0x2, 0x2, 0x2, 0xe5a, 0xe58, 0x3, 0x2, 0x2, 0x2, 0xe5a, 
       0xe5b, 0x3, 0x2, 0x2, 0x2, 0xe5b, 0x193, 0x3, 0x2, 0x2, 0x2, 0xe5c, 
       0xe5a, 0x3, 0x2, 0x2, 0x2, 0xe5d, 0xe60, 0x5, 0x1a8, 0xd5, 0x2, 0xe5e, 
       0xe60, 0x7, 0x191, 0x2, 0x2, 0xe5f, 0xe5d, 0x3, 0x2, 0x2, 0x2, 0xe5f, 
       0xe5e, 0x3, 0x2, 0x2, 0x2, 0xe60, 0x195, 0x3, 0x2, 0x2, 0x2, 0xe61, 
       0xe62, 0x9, 0x14, 0x2, 0x2, 0xe62, 0x197, 0x3, 0x2, 0x2, 0x2, 0xe63, 
       0xe65, 0x7, 0x6d, 0x2, 0x2, 0xe64, 0xe63, 0x3, 0x2, 0x2, 0x2, 0xe64, 
       0xe65, 0x3, 0x2, 0x2, 0x2, 0xe65, 0xe66, 0x3, 0x2, 0x2, 0x2, 0xe66, 
       0xe67, 0x7, 0x6e, 0x2, 0x2, 0xe67, 0x199, 0x3, 0x2, 0x2, 0x2, 0xe68, 
       0xe74, 0x5, 0x198, 0xcd, 0x2, 0xe69, 0xe6a, 0x7, 0x44, 0x2, 0x2, 
       0xe6a, 0xe6d, 0x5, 0xe0, 0x71, 0x2, 0xe6b, 0xe6c, 0x7, 0x31, 0x2, 
       0x2, 0xe6c, 0xe6e, 0x5, 0x1a8, 0xd5, 0x2, 0xe6d, 0xe6b, 0x3, 0x2, 
       0x2, 0x2, 0xe6d, 0xe6e, 0x3, 0x2, 0x2, 0x2, 0xe6e, 0xe71, 0x3, 0x2, 
       0x2, 0x2, 0xe6f, 0xe70, 0x7, 0xa5, 0x2, 0x2, 0xe70, 0xe72, 0x7, 0xa0, 
       0x2, 0x2, 0xe71, 0xe6f, 0x3, 0x2, 0x2, 0x2, 0xe71, 0xe72, 0x3, 0x2, 
       0x2, 0x2, 0xe72, 0xe74, 0x3, 0x2, 0x2, 0x2, 0xe73, 0xe68, 0x3, 0x2, 
       0x2, 0x2, 0xe73, 0xe69, 0x3, 0x2, 0x2, 0x2, 0xe74, 0x19b, 0x3, 0x2, 
       0x2, 0x2, 0xe75, 0xe96, 0x5, 0x186, 0xc4, 0x2, 0xe76, 0xe96, 0x7, 
       0x87, 0x2, 0x2, 0xe77, 0xe96, 0x7, 0x6a, 0x2, 0x2, 0xe78, 0xe96, 
       0x7, 0xb9, 0x2, 0x2, 0xe79, 0xe96, 0x7, 0xbe, 0x2, 0x2, 0xe7a, 0xe96, 
       0x7, 0x3, 0x2, 0x2, 0xe7b, 0xe96, 0x7, 0x4, 0x2, 0x2, 0xe7c, 0xe96, 
       0x7, 0x5, 0x2, 0x2, 0xe7d, 0xe96, 0x7, 0x6, 0x2, 0x2, 0xe7e, 0xe96, 
       0x7, 0x7, 0x2, 0x2, 0xe7f, 0xe96, 0x7, 0x8, 0x2, 0x2, 0xe80, 0xe96, 
       0x7, 0x9, 0x2, 0x2, 0xe81, 0xe96, 0x7, 0xa, 0x2, 0x2, 0xe82, 0xe96, 
       0x7, 0xb, 0x2, 0x2, 0xe83, 0xe96, 0x7, 0xc, 0x2, 0x2, 0xe84, 0xe96, 
       0x7, 0xd, 0x2, 0x2, 0xe85, 0xe96, 0x7, 0xe, 0x2, 0x2, 0xe86, 0xe96, 
       0x7, 0xf, 0x2, 0x2, 0xe87, 0xe96, 0x7, 0x10, 0x2, 0x2, 0xe88, 0xe96, 
       0x7, 0x11, 0x2, 0x2, 0xe89, 0xe96, 0x7, 0x12, 0x2, 0x2, 0xe8a, 0xe96, 
       0x7, 0x13, 0x2, 0x2, 0xe8b, 0xe96, 0x7, 0x14, 0x2, 0x2, 0xe8c, 0xe96, 
       0x7, 0x15, 0x2, 0x2, 0xe8d, 0xe96, 0x7, 0x16, 0x2, 0x2, 0xe8e, 0xe96, 
       0x7, 0x17, 0x2, 0x2, 0xe8f, 0xe96, 0x7, 0x18b, 0x2, 0x2, 0xe90, 0xe96, 
       0x7, 0x19, 0x2, 0x2, 0xe91, 0xe96, 0x7, 0x1a, 0x2, 0x2, 0xe92, 0xe96, 
       0x7, 0x1b, 0x2, 0x2, 0xe93, 0xe96, 0x7, 0x1c, 0x2, 0x2, 0xe94, 0xe96, 
       0x7, 0x1d, 0x2, 0x2, 0xe95, 0xe75, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe76, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe77, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe78, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe7a, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe7b, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe7c, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe7d, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe7e, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe7f, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe80, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe81, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe82, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe83, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe84, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe85, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe86, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe87, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe88, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe89, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe8a, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe8b, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe8c, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe8d, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe8e, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe8f, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe90, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe91, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe92, 
       0x3, 0x2, 0x2, 0x2, 0xe95, 0xe93, 0x3, 0x2, 0x2, 0x2, 0xe95, 0xe94, 
       0x3, 0x2, 0x2, 0x2, 0xe96, 0x19d, 0x3, 0x2, 0x2, 0x2, 0xe97, 0xe98, 
       0x9, 0x36, 0x2, 0x2, 0xe98, 0xe99, 0x7, 0x1aa, 0x2, 0x2, 0xe99, 0xe9a, 
       0x7, 0x105, 0x2, 0x2, 0xe9a, 0xeb6, 0x7, 0x1ab, 0x2, 0x2, 0xe9b, 
       0xe9c, 0x5, 0x1a8, 0xd5, 0x2, 0xe9c, 0xe9d, 0x7, 0x1aa, 0x2, 0x2, 
       0xe9d, 0xe9e, 0x7, 0x192, 0x2, 0x2, 0xe9e, 0xe9f, 0x7, 0x1ac, 0x2, 
       0x2, 0xe9f, 0xea0, 0x7, 0x192, 0x2, 0x2, 0xea0, 0xea1, 0x7, 0x1ab, 
       0x2, 0x2, 0xea1, 0xeb6, 0x3, 0x2, 0x2, 0x2, 0xea2, 0xea3, 0x5, 0x1a8, 
       0xd5, 0x2, 0xea3, 0xea4, 0x7, 0x1aa, 0x2, 0x2, 0xea4, 0xea5, 0x7, 
       0x192, 0x2, 0x2, 0xea5, 0xea6, 0x7, 0x1ab, 0x2, 0x2, 0xea6, 0xeb6, 
       0x3, 0x2, 0x2, 0x2, 0xea7, 0xea8, 0x5, 0x1a8, 0xd5, 0x2, 0xea8, 0xeae, 
       0x7, 0x5d, 0x2, 0x2, 0xea9, 0xeaa, 0x7, 0x1aa, 0x2, 0x2, 0xeaa, 0xeab, 
       0x7, 0x192, 0x2, 0x2, 0xeab, 0xeac, 0x7, 0x1ac, 0x2, 0x2, 0xeac, 
       0xead, 0x7, 0x192, 0x2, 0x2, 0xead, 0xeaf, 0x7, 0x1ab, 0x2, 0x2, 
       0xeae, 0xea9, 0x3, 0x2, 0x2, 0x2, 0xeae, 0xeaf, 0x3, 0x2, 0x2, 0x2, 
       0xeaf, 0xeb6, 0x3, 0x2, 0x2, 0x2, 0xeb0, 0xeb2, 0x7, 0x49, 0x2, 0x2, 
       0xeb1, 0xeb3, 0x7, 0x7c, 0x2, 0x2, 0xeb2, 0xeb1, 0x3, 0x2, 0x2, 0x2, 
       0xeb2, 0xeb3, 0x3, 0x2, 0x2, 0x2, 0xeb3, 0xeb6, 0x3, 0x2, 0x2, 0x2, 
       0xeb4, 0xeb6, 0x5, 0x1a8, 0xd5, 0x2, 0xeb5, 0xe97, 0x3, 0x2, 0x2, 
       0x2, 0xeb5, 0xe9b, 0x3, 0x2, 0x2, 0x2, 0xeb5, 0xea2, 0x3, 0x2, 0x2, 
       0x2, 0xeb5, 0xea7, 0x3, 0x2, 0x2, 0x2, 0xeb5, 0xeb0, 0x3, 0x2, 0x2, 
       0x2, 0xeb5, 0xeb4, 0x3, 0x2, 0x2, 0x2, 0xeb6, 0x19f, 0x3, 0x2, 0x2, 
       0x2, 0xeb7, 0xebb, 0x7, 0x6e, 0x2, 0x2, 0xeb8, 0xebb, 0x7, 0x44, 
       0x2, 0x2, 0xeb9, 0xebb, 0x5, 0x1a2, 0xd2, 0x2, 0xeba, 0xeb7, 0x3, 
       0x2, 0x2, 0x2, 0xeba, 0xeb8, 0x3, 0x2, 0x2, 0x2, 0xeba, 0xeb9, 0x3, 
       0x2, 0x2, 0x2, 0xebb, 0x1a1, 0x3, 0x2, 0x2, 0x2, 0xebc, 0xecc, 0x7, 
       0x194, 0x2, 0x2, 0xebd, 0xecc, 0x7, 0x195, 0x2, 0x2, 0xebe, 0xec0, 
       0x5, 0x1a4, 0xd3, 0x2, 0xebf, 0xebe, 0x3, 0x2, 0x2, 0x2, 0xebf, 0xec0, 
       0x3, 0x2, 0x2, 0x2, 0xec0, 0xec1, 0x3, 0x2, 0x2, 0x2, 0xec1, 0xecc, 
       0x7, 0x192, 0x2, 0x2, 0xec2, 0xec4, 0x5, 0x1a4, 0xd3, 0x2, 0xec3, 
       0xec2, 0x3, 0x2, 0x2, 0x2, 0xec3, 0xec4, 0x3, 0x2, 0x2, 0x2, 0xec4, 
       0xec5, 0x3, 0x2, 0x2, 0x2, 0xec5, 0xecc, 0x9, 0x37, 0x2, 0x2, 0xec6, 
       0xec8, 0x5, 0x1a4, 0xd3, 0x2, 0xec7, 0xec6, 0x3, 0x2, 0x2, 0x2, 0xec7, 
       0xec8, 0x3, 0x2, 0x2, 0x2, 0xec8, 0xec9, 0x3, 0x2, 0x2, 0x2, 0xec9, 
       0xeca, 0x7, 0x1a9, 0x2, 0x2, 0xeca, 0xecc, 0x9, 0x38, 0x2, 0x2, 0xecb, 
       0xebc, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xebd, 0x3, 0x2, 0x2, 0x2, 0xecb, 
       0xebf, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xec3, 0x3, 0x2, 0x2, 0x2, 0xecb, 
       0xec7, 0x3, 0x2, 0x2, 0x2, 0xecc, 0x1a3, 0x3, 0x2, 0x2, 0x2, 0xecd, 
       0xece, 0x9, 0x1e, 0x2, 0x2, 0xece, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0xecf, 
       0xed0, 0x9, 0x39, 0x2, 0x2, 0xed0, 0x1a7, 0x3, 0x2, 0x2, 0x2, 0xed1, 
       0xed6, 0x7, 0x193, 0x2, 0x2, 0xed2, 0xed6, 0x7, 0x18e, 0x2, 0x2, 
       0xed3, 0xed6, 0x7, 0x190, 0x2, 0x2, 0xed4, 0xed6, 0x5, 0x1a6, 0xd4, 
       0x2, 0xed5, 0xed1, 0x3, 0x2, 0x2, 0x2, 0xed5, 0xed2, 0x3, 0x2, 0x2, 
       0x2, 0xed5, 0xed3, 0x3, 0x2, 0x2, 0x2, 0xed5, 0xed4, 0x3, 0x2, 0x2, 
       0x2, 0xed6, 0x1a9, 0x3, 0x2, 0x2, 0x2, 0xed7, 0xed8, 0x7, 0x193, 
       0x2, 0x2, 0xed8, 0x1ab, 0x3, 0x2, 0x2, 0x2, 0xed9, 0xedc, 0x5, 0x1a8, 
       0xd5, 0x2, 0xeda, 0xedc, 0x7, 0x194, 0x2, 0x2, 0xedb, 0xed9, 0x3, 
       0x2, 0x2, 0x2, 0xedb, 0xeda, 0x3, 0x2, 0x2, 0x2, 0xedc, 0x1ad, 0x3, 
       0x2, 0x2, 0x2, 0xedd, 0xeed, 0x7, 0x198, 0x2, 0x2, 0xede, 0xeed, 
       0x7, 0x199, 0x2, 0x2, 0xedf, 0xeed, 0x7, 0x19a, 0x2, 0x2, 0xee0, 
       0xee1, 0x7, 0x19a, 0x2, 0x2, 0xee1, 0xeed, 0x7, 0x198, 0x2, 0x2, 
       0xee2, 0xee3, 0x7, 0x199, 0x2, 0x2, 0xee3, 0xeed, 0x7, 0x198, 0x2, 
       0x2, 0xee4, 0xee5, 0x7, 0x19a, 0x2, 0x2, 0xee5, 0xeed, 0x7, 0x199, 
       0x2, 0x2, 0xee6, 0xee7, 0x7, 0x19b, 0x2, 0x2, 0xee7, 0xeed, 0x7, 
       0x198, 0x2, 0x2, 0xee8, 0xee9, 0x7, 0x19b, 0x2, 0x2, 0xee9, 0xeed, 
       0x7, 0x199, 0x2, 0x2, 0xeea, 0xeeb, 0x7, 0x19b, 0x2, 0x2, 0xeeb, 
       0xeed, 0x7, 0x19a, 0x2, 0x2, 0xeec, 0xedd, 0x3, 0x2, 0x2, 0x2, 0xeec, 
       0xede, 0x3, 0x2, 0x2, 0x2, 0xeec, 0xedf, 0x3, 0x2, 0x2, 0x2, 0xeec, 
       0xee0, 0x3, 0x2, 0x2, 0x2, 0xeec, 0xee2, 0x3, 0x2, 0x2, 0x2, 0xeec, 
       0xee4, 0x3, 0x2, 0x2, 0x2, 0xeec, 0xee6, 0x3, 0x2, 0x2, 0x2, 0xeec, 
       0xee8, 0x3, 0x2, 0x2, 0x2, 0xeec, 0xeea, 0x3, 0x2, 0x2, 0x2, 0xeed, 
       0x1af, 0x3, 0x2, 0x2, 0x2, 0xeee, 0xeef, 0x9, 0x3a, 0x2, 0x2, 0xeef, 
       0x1b1, 0x3, 0x2, 0x2, 0x2, 0x228, 0x1b5, 0x1bd, 0x1c2, 0x1c6, 0x1cc, 
       0x1ce, 0x1d3, 0x1da, 0x1de, 0x1e2, 0x1e6, 0x1ea, 0x1ee, 0x1f2, 0x1f6, 
       0x1fa, 0x1fd, 0x204, 0x20f, 0x21d, 0x221, 0x226, 0x22b, 0x22f, 0x233, 
       0x238, 0x23d, 0x23f, 0x243, 0x246, 0x24d, 0x250, 0x259, 0x25c, 0x267, 
       0x26c, 0x271, 0x276, 0x27b, 0x281, 0x285, 0x288, 0x28c, 0x28f, 0x292, 
       0x299, 0x29d, 0x29f, 0x2a4, 0x2aa, 0x2ae, 0x2bb, 0x2c1, 0x2c4, 0x2cd, 
       0x2d0, 0x2dc, 0x2f3, 0x2f6, 0x300, 0x306, 0x30a, 0x30e, 0x315, 0x31b, 
       0x31d, 0x322, 0x328, 0x32e, 0x333, 0x339, 0x340, 0x345, 0x34a, 0x34f, 
       0x352, 0x356, 0x35a, 0x35e, 0x362, 0x367, 0x36b, 0x36f, 0x372, 0x37a, 
       0x37c, 0x37f, 0x383, 0x386, 0x38f, 0x392, 0x395, 0x39d, 0x3a3, 0x3aa, 
       0x3ae, 0x3b9, 0x3bf, 0x3c1, 0x3ca, 0x3ce, 0x3d5, 0x3da, 0x3dd, 0x3e5, 
       0x3e9, 0x3ec, 0x3f0, 0x3f3, 0x3f7, 0x3fe, 0x402, 0x404, 0x406, 0x409, 
       0x40c, 0x411, 0x414, 0x41c, 0x41e, 0x421, 0x425, 0x42b, 0x42e, 0x437, 
       0x43a, 0x441, 0x447, 0x44b, 0x455, 0x458, 0x45b, 0x461, 0x464, 0x467, 
       0x46b, 0x46e, 0x476, 0x478, 0x47c, 0x484, 0x488, 0x48c, 0x493, 0x497, 
       0x499, 0x49b, 0x49e, 0x4a1, 0x4a9, 0x4af, 0x4b5, 0x4b7, 0x4bb, 0x4be, 
       0x4c3, 0x4c6, 0x4cc, 0x4cf, 0x4d6, 0x4da, 0x4dc, 0x4e4, 0x4e7, 0x4eb, 
       0x4f1, 0x4f7, 0x4fa, 0x504, 0x50b, 0x510, 0x513, 0x51d, 0x520, 0x523, 
       0x52b, 0x536, 0x539, 0x53c, 0x542, 0x547, 0x54b, 0x555, 0x558, 0x55b, 
       0x561, 0x567, 0x56d, 0x572, 0x576, 0x57a, 0x57d, 0x582, 0x590, 0x598, 
       0x59d, 0x5a2, 0x5a8, 0x5ad, 0x5b0, 0x5b9, 0x5c3, 0x5c6, 0x5dd, 0x5f8, 
       0x5fb, 0x603, 0x609, 0x610, 0x614, 0x61a, 0x621, 0x625, 0x62b, 0x62f, 
       0x634, 0x638, 0x640, 0x644, 0x646, 0x64a, 0x64e, 0x652, 0x655, 0x659, 
       0x65f, 0x663, 0x665, 0x66a, 0x66e, 0x672, 0x679, 0x67e, 0x686, 0x689, 
       0x68c, 0x690, 0x694, 0x697, 0x69f, 0x6a4, 0x6ab, 0x6b3, 0x6b6, 0x6c1, 
       0x6c6, 0x6d0, 0x6d5, 0x6dc, 0x6e9, 0x6eb, 0x6ed, 0x6f0, 0x6f3, 0x6fa, 
       0x6fd, 0x703, 0x708, 0x70a, 0x70d, 0x713, 0x71b, 0x71d, 0x720, 0x724, 
       0x727, 0x731, 0x734, 0x738, 0x73b, 0x741, 0x744, 0x746, 0x74a, 0x74e, 
       0x753, 0x758, 0x762, 0x765, 0x768, 0x770, 0x774, 0x777, 0x77b, 0x780, 
       0x788, 0x78d, 0x796, 0x79b, 0x7a0, 0x7a7, 0x7a9, 0x7ad, 0x7b0, 0x7b4, 
       0x7b8, 0x7c0, 0x7c5, 0x7c7, 0x7ca, 0x7cf, 0x7d4, 0x7d9, 0x7dc, 0x7e2, 
       0x7ea, 0x7f3, 0x7f7, 0x7fc, 0x802, 0x806, 0x80c, 0x814, 0x81a, 0x81c, 
       0x81f, 0x82e, 0x830, 0x839, 0x840, 0x847, 0x851, 0x853, 0x855, 0x858, 
       0x85b, 0x866, 0x868, 0x86a, 0x86d, 0x872, 0x87d, 0x886, 0x889, 0x88c, 
       0x895, 0x898, 0x89b, 0x8a2, 0x8a5, 0x8ab, 0x8ba, 0x8bd, 0x8c4, 0x8c9, 
       0x8cd, 0x8d8, 0x8e5, 0x8e7, 0x8f3, 0x8fa, 0x8fe, 0x906, 0x90a, 0x90e, 
       0x914, 0x91e, 0x928, 0x932, 0x93a, 0x946, 0x94c, 0x950, 0x95a, 0x95e, 
       0x962, 0x96c, 0x972, 0x97a, 0x982, 0x984, 0x99b, 0x9a7, 0x9ae, 0x9b6, 
       0x9bd, 0x9c3, 0x9ca, 0x9ce, 0x9d3, 0x9d5, 0x9d9, 0x9dd, 0x9e4, 0x9e8, 
       0x9eb, 0x9f0, 0x9f4, 0x9f8, 0x9fd, 0xa04, 0xa07, 0xa0b, 0xa10, 0xa14, 
       0xa1d, 0xa24, 0xa2d, 0xa39, 0xa3b, 0xa40, 0xa4b, 0xa6a, 0xa7a, 0xa81, 
       0xa83, 0xa8a, 0xa93, 0xa9b, 0xaa1, 0xaa9, 0xaac, 0xab3, 0xab9, 0xabc, 
       0xabe, 0xac6, 0xac8, 0xad0, 0xad4, 0xadb, 0xae3, 0xae9, 0xaf2, 0xaf5, 
       0xaf9, 0xafd, 0xb01, 0xb08, 0xb0a, 0xb0e, 0xb13, 0xb15, 0xb1a, 0xb1c, 
       0xb23, 0xb25, 0xb2a, 0xb2c, 0xb33, 0xb39, 0xb3d, 0xb56, 0xb59, 0xb5d, 
       0xb5f, 0xb62, 0xb90, 0xb95, 0xba5, 0xbae, 0xbb3, 0xbb8, 0xbda, 0xc14, 
       0xc18, 0xc50, 0xc52, 0xc5a, 0xc6d, 0xc72, 0xc78, 0xc7b, 0xc80, 0xc85, 
       0xc8e, 0xc93, 0xc99, 0xca2, 0xcac, 0xcaf, 0xcbd, 0xcc3, 0xccc, 0xcd0, 
       0xcd8, 0xcdf, 0xcec, 0xcf4, 0xd01, 0xd08, 0xd0e, 0xd12, 0xd23, 0xd32, 
       0xd34, 0xd41, 0xd51, 0xd59, 0xd5d, 0xd60, 0xd69, 0xd6c, 0xd6f, 0xd7c, 
       0xd80, 0xd88, 0xd8e, 0xd9a, 0xda1, 0xdaa, 0xdb1, 0xdbd, 0xdc4, 0xdcc, 
       0xdd3, 0xdd9, 0xde0, 0xde3, 0xde8, 0xdef, 0xdf4, 0xdf8, 0xdfd, 0xe00, 
       0xe04, 0xe08, 0xe0d, 0xe11, 0xe17, 0xe1b, 0xe1f, 0xe24, 0xe28, 0xe2d, 
       0xe32, 0xe36, 0xe3b, 0xe3f, 0xe47, 0xe4b, 0xe50, 0xe5a, 0xe5f, 0xe64, 
       0xe6d, 0xe71, 0xe73, 0xe95, 0xeae, 0xeb2, 0xeb5, 0xeba, 0xebf, 0xec3, 
       0xec7, 0xecb, 0xed5, 0xedb, 0xeec, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

TSqlParser::Initializer TSqlParser::_init;
