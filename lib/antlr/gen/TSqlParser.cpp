
// Generated from TSqlParser.g4 by ANTLR 4.12.0


#include "TSqlParserListener.h"

#include "TSqlParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct TSqlParserStaticData final {
  TSqlParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  TSqlParserStaticData(const TSqlParserStaticData&) = delete;
  TSqlParserStaticData(TSqlParserStaticData&&) = delete;
  TSqlParserStaticData& operator=(const TSqlParserStaticData&) = delete;
  TSqlParserStaticData& operator=(TSqlParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag tsqlparserParserOnceFlag;
TSqlParserStaticData *tsqlparserParserStaticData = nullptr;

void tsqlparserParserInitialize() {
  assert(tsqlparserParserStaticData == nullptr);
  auto staticData = std::make_unique<TSqlParserStaticData>(
    std::vector<std::string>{
      "tsql_file", "batch", "batch_level_statement", "sql_clauses", "dml_clause", 
      "ddl_clause", "cfl_statement", "block_statement", "break_statement", 
      "continue_statement", "goto_statement", "return_statement", "if_statement", 
      "throw_statement", "throw_error_number", "throw_message", "throw_state", 
      "try_catch_statement", "waitfor_statement", "while_statement", "print_statement", 
      "raiseerror_statement", "empty_statement", "another_statement", "entity_to", 
      "colon_colon", "class_type", "class_type_for_sql_database", "class_type_for_azure_dw", 
      "class_type_for_parallel_dw", "lock_table", "truncate_table", "alter_sequence", 
      "create_sequence", "merge_statement", "when_matches", "merge_matched", 
      "merge_not_matched", "delete_statement", "delete_statement_from", 
      "insert_statement", "insert_statement_value", "receive_statement", 
      "select_statement_standalone", "select_statement", "time", "update_statement", 
      "output_clause", "output_dml_list_elem", "create_or_alter_procedure", 
      "create_or_alter_function", "func_body_returns_select", "func_body_returns_table", 
      "func_body_returns_scalar", "procedure_param", "procedure_option", 
      "function_option", "create_table", "table_options", "alter_table", 
      "database_optionspec", "cursor_option", "drop_procedure", "drop_function", 
      "drop_table", "declare_statement", "cursor_statement", "kill_statement", 
      "kill_process", "kill_query_notification", "execute_statement", "execute_body_batch", 
      "execute_body", "execute_statement_arg", "execute_statement_arg_named", 
      "execute_statement_arg_unnamed", "execute_parameter", "execute_var_string", 
      "algorithm", "set_statement", "transaction_statement", "go_batch_statement", 
      "go_statement", "use_statement", "shutdown_statement", "dbcc_special", 
      "dbcc_clause", "dbcc_command", "dbcc_options", "execute_clause", "declare_local", 
      "table_type_definition", "column_def_table_constraints", "column_def_table_constraint", 
      "column_definition", "column_constraint", "table_constraint", "index_options", 
      "index_option", "declare_cursor", "declare_set_cursor_common", "declare_set_cursor_common_partial", 
      "fetch_cursor", "set_special", "constant_LOCAL_ID", "expression", 
      "time_zone", "primitive_expression", "case_expression", "unary_operator_expression", 
      "bracket_expression", "constant_expression", "subquery", "with_expression", 
      "common_table_expression", "update_elem", "update_elem_merge", "search_condition", 
      "predicate", "query_expression", "sql_union", "query_specification", 
      "top_clause", "top_percent", "top_count", "order_by_clause", "order_by_expression", 
      "group_by_item", "option_clause", "option", "optimize_for_arg", "select_list", 
      "udt_method_arguments", "asterisk", "column_elem", "udt_elem", "expression_elem", 
      "select_list_elem", "table_sources", "table_source", "table_source_item_joined", 
      "table_source_item", "schema_declaration", "column_declaration", "change_table", 
      "change_table_changes", "change_table_version", "join_part", "join_on", 
      "cross_join", "apply_", "pivot", "unpivot", "pivot_clause", "unpivot_clause", 
      "full_column_name_list", "table_name_with_hint", "bulk_option", "derived_table", 
      "function_call", "partition_function", "built_in_functions", "nodes_method", 
      "switch_section", "switch_search_condition_section", "as_column_alias", 
      "as_table_alias", "table_alias", "with_table_hints", "insert_with_table_hints", 
      "table_hint", "index_value", "column_alias_list", "column_alias", 
      "table_value_constructor", "expression_list", "ranking_windowed_function", 
      "aggregate_windowed_function", "analytic_windowed_function", "all_distinct_expression", 
      "over_clause", "row_or_range_clause", "window_frame_extent", "window_frame_bound", 
      "window_frame_preceding", "window_frame_following", "entity_name", 
      "entity_name_for_azure_dw", "entity_name_for_parallel_dw", "full_table_name", 
      "table_name", "simple_name", "func_proc_name_schema", "func_proc_name_database_schema", 
      "func_proc_name_server_database_schema", "ddl_object", "full_column_name", 
      "column_name_list_with_order", "insert_column_name_list", "insert_column_id", 
      "column_name_list", "cursor_name", "on_off", "null_notnull", "null_or_default", 
      "scalar_function_name", "data_type", "default_value", "constant", 
      "sign", "keyword", "id_", "simple_id", "id_or_string", "comparison_operator", 
      "assignment_operator"
    },
    std::vector<std::string>{
      "", "'ABS'", "'ASCII'", "'CEILING'", "'CHAR'", "'CHARINDEX'", "'DATALENGTH'", 
      "'DAY'", "'FLOOR'", "'ISDATE'", "'ISNUMERIC'", "'LEN'", "'LOWER'", 
      "'LTRIM'", "'MONTH'", "'NCHAR'", "'PATINDEX'", "'RAND'", "'REPLACE'", 
      "'ROUND'", "'RTRIM'", "'SIGN'", "'SPACE'", "'STR'", "'SUBSTRING'", 
      "'UPPER'", "'USER_NAME'", "'YEAR'", "'TEXT'", "'NTEXT'", "'ADD'", 
      "'ALL'", "'ALTER'", "'AND'", "'ANY'", "'AS'", "'ASC'", "'AUTHORIZATION'", 
      "'\\'", "'BEGIN'", "'BETWEEN'", "'BREAK'", "'BY'", "'CASE'", "'CHECK'", 
      "'CLOSE'", "'COALESCE'", "'COLLATE'", "'COLUMN'", "'COMMIT'", "'COMPUTE'", 
      "'CONSTRAINT'", "'CONTINUE'", "", "'CREATE'", "'CROSS'", "'CURRENT'", 
      "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", 
      "'CURSOR'", "'DATABASE'", "'DBCC'", "'DEALLOCATE'", "'DECLARE'", "'DEFAULT'", 
      "'DELETE'", "'DESC'", "'DISTINCT'", "'DISTRIBUTED'", "'DOUBLE'", "'\\\\'", 
      "'//'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", "", "'EXISTS'", 
      "'FETCH'", "'FOR'", "'FOREIGN'", "'FROM'", "'FULL'", "'FUNCTION'", 
      "'GOTO'", "'GROUP'", "'HAVING'", "'HOLDLOCK'", "'IDENTITY'", "'IDENTITY_INSERT'", 
      "'IF'", "'IN'", "'INDEX'", "'INNER'", "'INSERT'", "'INTERSECT'", "'INTO'", 
      "'IS'", "'JOIN'", "'KEY'", "'KILL'", "'LEFT'", "'LIKE'", "'MERGE'", 
      "'NOT'", "'NULL'", "'NULLIF'", "'OF'", "'OFF'", "'ON'", "'OPEN'", 
      "'OPTION'", "'OR'", "'ORDER'", "'OUTER'", "'OVER'", "'PERCENT'", "'PIVOT'", 
      "'PLAN'", "'PRECISION'", "'PRIMARY'", "'PRINT'", "'PROC'", "'PROCEDURE'", 
      "'RAISERROR'", "'READ'", "'REFERENCES'", "'REPLICATION'", "'RETURN'", 
      "'REVERT'", "'RIGHT'", "'ROLLBACK'", "'ROWCOUNT'", "'ROWGUIDCOL'", 
      "'SAVE'", "'SCHEMA'", "'SELECT'", "'SESSION_USER'", "'SET'", "'SHUTDOWN'", 
      "'SOME'", "'SYSTEM_USER'", "'TABLE'", "'THEN'", "'TO'", "'TOP'", "'TRAN'", 
      "'TRANSACTION'", "'TRUNCATE'", "'UNION'", "'UNIQUE'", "'UNPIVOT'", 
      "'UPDATE'", "'USE'", "'USER'", "'VALUES'", "'VARYING'", "'WHEN'", 
      "'WHERE'", "'WHILE'", "'WITH'", "'WITHIN'", "'$PARTITION'", "'ABSOLUTE'", 
      "'AT'", "'ACTION'", "'AES_128'", "'AES_192'", "'AES_256'", "'ALGORITHM'", 
      "'ANSI_NULLS'", "'ANSI_PADDING'", "'ANSI_WARNINGS'", "'APPLY'", "'ARITHABORT'", 
      "'AUTO'", "'AVG'", "'BIGINT'", "'BINARY'", "'BINARY BASE64'", "'BINARY_CHECKSUM'", 
      "'CALLER'", "'CAST'", "'TRY_CAST'", "'CATCH'", "'CHECKSUM'", "'CHECKSUM_AGG'", 
      "'COMMITTED'", "'CONCAT'", "'CONCAT_NULL_YIELDS_NULL'", "'COUNT'", 
      "'COUNT_BIG'", "'CUME_DIST'", "'CURSOR_CLOSE_ON_COMMIT'", "'CURSOR_DEFAULT'", 
      "'DATA'", "'DATEADD'", "'DATEDIFF'", "'DATENAME'", "'DATEPART'", "'DAYS'", 
      "", "'DELAY'", "'DELAYED_DURABILITY'", "'DELETED'", "'DENSE_RANK'", 
      "'DES'", "'DESCRIPTION'", "'DESX'", "'DISABLE'", "'DYNAMIC'", "'ELEMENTS'", 
      "'EMPTY'", "'ENCRYPTION'", "'EXCLUSIVE'", "'FAST'", "'FAST_FORWARD'", 
      "'FIRST'", "'FIRST_VALUE'", "'FOLLOWING'", "'FORCE'", "'FORCED'", 
      "'FORWARD_ONLY'", "'GETDATE'", "'GETUTCDATE'", "'GLOBAL'", "", "'GO'", 
      "'GROUPING'", "'GROUPING_ID'", "'HASH'", "'HIGH'", "'HOURS'", "'IDENTITY_VALUE'", 
      "'INCLUDE_NULL_VALUES'", "'INPUT'", "'INSENSITIVE'", "'INSERTED'", 
      "'INT'", "'ISOLATION'", "'KEEP'", "'KEEPFIXED'", "'KEYSET'", "'LAG'", 
      "'LAST'", "'LAST_VALUE'", "'LEAD'", "'LEVEL'", "'LOCAL'", "'LOCATION'", 
      "'LOCK'", "'LOCK_ESCALATION'", "'LOOP'", "'LOW'", "'MANUAL'", "'MARK'", 
      "'MAX'", "'MAXDOP'", "'MAXRECURSION'", "'MIN'", "'MIN_ACTIVE_ROWVERSION'", 
      "'MINUTES'", "'MODE'", "'NEXT'", "'NO'", "'NOCOUNT'", "'NODES'", "'NOEXPAND'", 
      "'NOWAIT'", "'NTILE'", "'NUMANODE'", "'NUMERIC_ROUNDABORT'", "'OBJECT'", 
      "'OFFSET'", "'ONLINE'", "'ONLY'", "'OPTIMISTIC'", "'OPTIMIZE'", "'OUT'", 
      "'OUTPUT'", "'OWNER'", "'PARAMETERIZATION'", "'PARTITION'", "'PARTITIONS'", 
      "'PERCENT_RANK'", "'PERCENTILE_CONT'", "'PERCENTILE_DISC'", "'PRECEDING'", 
      "'PRIOR'", "'QUERY'", "'QUOTED_IDENTIFIER'", "'RANGE'", "'RANK'", 
      "'RC2'", "'RC4'", "'RC4_128'", "'READ_ONLY'", "'READONLY'", "'REBUILD'", 
      "'RECOMPILE'", "'RELATIVE'", "'REMOTE'", "'REPEATABLE'", "'ROBUST'", 
      "'ROW'", "'ROW_NUMBER'", "'ROWGUID'", "'ROWS'", "'SCHEMABINDING'", 
      "'SCROLL'", "'SCROLL_LOCKS'", "'SECONDS'", "'SELF'", "'SEMI_SENSITIVE'", 
      "'SEQUENCE'", "'SERIALIZABLE'", "'SETERROR'", "'SHARE'", "'SIMPLE'", 
      "'SIZE'", "'SMALLINT'", "'SNAPSHOT'", "'SPATIAL_WINDOW_MAX_CELLS'", 
      "'STATIC'", "'STATUSONLY'", "'STDEV'", "'STDEVP'", "'STRING_AGG'", 
      "'STUFF'", "'SUBSCRIPTION'", "'SUM'", "'TEXTIMAGE_ON'", "'THROW'", 
      "'TIES'", "'TIME'", "'TIMEOUT'", "'TINYINT'", "'TRIPLE_DES'", "'TRIPLE_DES_3KEY'", 
      "'TRY'", "'TWO_DIGIT_YEAR_CUTOFF'", "'TYPE'", "'TYPE_WARNING'", "'UNBOUNDED'", 
      "'UNCOMMITTED'", "'UNKNOWN'", "'UOW'", "'USING'", "'VAR'", "'VARBINARY'", 
      "'VARP'", "'WAIT'", "'WAITFOR'", "'WORK'", "'ZONE'", "'$ACTION'", 
      "'BLOCKING_HIERARCHY'", "'CACHE'", "'CALLED'", "'CHANGETABLE'", "'CHANGES'", 
      "'CONNECTION'", "'CONTRACT'", "'CYCLE'", "'DATA_COMPRESSION'", "'DDL'", 
      "'ERROR'", "'EVENT'", "'FORCESEEK'", "'IIF'", "'INCREMENT'", "'ISNULL'", 
      "'LOG'", "'MATCHED'", "'MAXVALUE'", "'MINVALUE'", "'NOTIFICATION'", 
      "'PERSISTED'", "'PREDICATE'", "'RESTART'", "'RETURNS'", "'SHRINKLOG'", 
      "'SOURCE'", "'SQL'", "'STATE'", "'START'", "'TARGET'", "'WITHOUT'", 
      "'VARCHAR'", "'NVARCHAR'", "", "", "", "", "'''", "", "", "", "", 
      "", "", "", "", "'='", "'>'", "'<'", "'!'", "'+='", "'-='", "'*='", 
      "'/='", "'%='", "'&='", "'^='", "'|='", "'||'", "'.'", "'_'", "'@'", 
      "'#'", "'$'", "'('", "')'", "','", "';'", "':'", "'::'", "'*'", "'/'", 
      "'%'", "'+'", "'-'", "'~'", "'|'", "'&'", "'^'"
    },
    std::vector<std::string>{
      "", "ABS", "ASCII", "CEILING", "CHAR", "CHARINDEX", "DATALENGTH", 
      "DAY", "FLOOR", "ISDATE", "ISNUMERIC", "LEN", "LOWER", "LTRIM", "MONTH", 
      "NCHAR", "PATINDEX", "RAND", "REPLACE", "ROUND", "RTRIM", "SIGN", 
      "SPACE_fn", "STR", "SUBSTRING", "UPPER", "USER_NAME", "YEAR", "TEXT", 
      "NTEXT", "ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "AUTHORIZATION", 
      "BACKSLASH", "BEGIN", "BETWEEN", "BREAK", "BY", "CASE", "CHECK", "CLOSE", 
      "COALESCE", "COLLATE", "COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", 
      "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", 
      "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", 
      "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", "DELETE", "DESC", "DISTINCT", 
      "DISTRIBUTED", "DOUBLE", "DOUBLE_BACK_SLASH", "DOUBLE_FORWARD_SLASH", 
      "DROP", "ELSE", "END", "ESCAPE", "EXCEPT", "EXECUTE", "EXISTS", "FETCH", 
      "FOR", "FOREIGN", "FROM", "FULL", "FUNCTION", "GOTO", "GROUP", "HAVING", 
      "HOLDLOCK", "IDENTITY", "IDENTITY_INSERT", "IF", "IN", "INDEX", "INNER", 
      "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "KEY", "KILL", "LEFT", 
      "LIKE", "MERGE", "NOT", "NULL_", "NULLIF", "OF", "OFF", "ON", "OPEN", 
      "OPTION", "OR", "ORDER", "OUTER", "OVER", "PERCENT", "PIVOT", "PLAN", 
      "PRECISION", "PRIMARY", "PRINT", "PROC", "PROCEDURE", "RAISERROR", 
      "READ", "REFERENCES", "REPLICATION", "RETURN", "REVERT", "RIGHT", 
      "ROLLBACK", "ROWCOUNT", "ROWGUIDCOL", "SAVE", "SCHEMA", "SELECT", 
      "SESSION_USER", "SET", "SHUTDOWN", "SOME", "SYSTEM_USER", "TABLE", 
      "THEN", "TO", "TOP", "TRAN", "TRANSACTION", "TRUNCATE", "UNION", "UNIQUE", 
      "UNPIVOT", "UPDATE", "USE", "USER", "VALUES", "VARYING", "WHEN", "WHERE", 
      "WHILE", "WITH", "WITHIN", "DOLLAR_PARTITION", "ABSOLUTE", "AT_KEYWORD", 
      "ACTION", "AES_128", "AES_192", "AES_256", "ALGORITHM", "ANSI_NULLS", 
      "ANSI_PADDING", "ANSI_WARNINGS", "APPLY", "ARITHABORT", "AUTO", "AVG", 
      "BIGINT", "BINARY_KEYWORD", "BINARY_BASE64", "BINARY_CHECKSUM", "CALLER", 
      "CAST", "TRY_CAST", "CATCH", "CHECKSUM", "CHECKSUM_AGG", "COMMITTED", 
      "CONCAT", "CONCAT_NULL_YIELDS_NULL", "COUNT", "COUNT_BIG", "CUME_DIST", 
      "CURSOR_CLOSE_ON_COMMIT", "CURSOR_DEFAULT", "DATA", "DATEADD", "DATEDIFF", 
      "DATENAME", "DATEPART", "DAYS", "DEFAULT_DOUBLE_QUOTE", "DELAY", "DELAYED_DURABILITY", 
      "DELETED", "DENSE_RANK", "DES", "DESCRIPTION", "DESX", "DISABLE", 
      "DYNAMIC", "ELEMENTS", "EMPTY", "ENCRYPTION", "EXCLUSIVE", "FAST", 
      "FAST_FORWARD", "FIRST", "FIRST_VALUE", "FOLLOWING", "FORCE", "FORCED", 
      "FORWARD_ONLY", "GETDATE", "GETUTCDATE", "GLOBAL", "GO_BATCH", "GO", 
      "GROUPING", "GROUPING_ID", "HASH", "HIGH", "HOURS", "IDENTITY_VALUE", 
      "INCLUDE_NULL_VALUES", "INPUT", "INSENSITIVE", "INSERTED", "INT", 
      "ISOLATION", "KEEP", "KEEPFIXED", "KEYSET", "LAG", "LAST", "LAST_VALUE", 
      "LEAD", "LEVEL", "LOCAL", "LOCATION", "LOCK", "LOCK_ESCALATION", "LOOP", 
      "LOW", "MANUAL", "MARK", "MAX", "MAXDOP", "MAXRECURSION", "MIN", "MIN_ACTIVE_ROWVERSION", 
      "MINUTES", "MODE", "NEXT", "NO", "NOCOUNT", "NODES", "NOEXPAND", "NOWAIT", 
      "NTILE", "NUMANODE", "NUMERIC_ROUNDABORT", "OBJECT", "OFFSET", "ONLINE", 
      "ONLY", "OPTIMISTIC", "OPTIMIZE", "OUT", "OUTPUT", "OWNER", "PARAMETERIZATION", 
      "PARTITION", "PARTITIONS", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", 
      "PRECEDING", "PRIOR", "QUERY", "QUOTED_IDENTIFIER", "RANGE", "RANK", 
      "RC2", "RC4", "RC4_128", "READ_ONLY", "READONLY", "REBUILD", "RECOMPILE", 
      "RELATIVE", "REMOTE", "REPEATABLE", "ROBUST", "ROW", "ROW_NUMBER", 
      "ROWGUID", "ROWS", "SCHEMABINDING", "SCROLL", "SCROLL_LOCKS", "SECONDS", 
      "SELF", "SEMI_SENSITIVE", "SEQUENCE", "SERIALIZABLE", "SETERROR", 
      "SHARE", "SIMPLE", "SIZE", "SMALLINT", "SNAPSHOT", "SPATIAL_WINDOW_MAX_CELLS", 
      "STATIC", "STATUSONLY", "STDEV", "STDEVP", "STRING_AGG", "STUFF", 
      "SUBSCRIPTION", "SUM", "TEXTIMAGE_ON", "THROW", "TIES", "TIME", "TIMEOUT", 
      "TINYINT", "TRIPLE_DES", "TRIPLE_DES_3KEY", "TRY", "TWO_DIGIT_YEAR_CUTOFF", 
      "TYPE", "TYPE_WARNING", "UNBOUNDED", "UNCOMMITTED", "UNKNOWN", "UOW", 
      "USING", "VAR", "VARBINARY_KEYWORD", "VARP", "WAIT", "WAITFOR", "WORK", 
      "ZONE", "DOLLAR_ACTION", "BLOCKING_HIERARCHY", "CACHE", "CALLED", 
      "CHANGETABLE", "CHANGES", "CONNECTION", "CONTRACT", "CYCLE", "DATA_COMPRESSION", 
      "DDL", "ERROR", "EVENT", "FORCESEEK", "IIF", "INCREMENT", "ISNULL", 
      "LOG", "MATCHED", "MAXVALUE", "MINVALUE", "NOTIFICATION", "PERSISTED", 
      "PREDICATE", "RESTART", "RETURNS", "SHRINKLOG", "SOURCE", "SQL", "STATE", 
      "START", "TARGET", "WITHOUT", "VARCHAR", "NVARCHAR", "SPACE", "COMMENT", 
      "LINE_COMMENT", "DOUBLE_QUOTE_ID", "SINGLE_QUOTE", "SQUARE_BRACKET_ID", 
      "LOCAL_ID", "DECIMAL", "ID", "STRING", "BINARY", "FLOAT", "REAL", 
      "EQUAL", "GREATER", "LESS", "EXCLAMATION", "PLUS_ASSIGN", "MINUS_ASSIGN", 
      "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", 
      "OR_ASSIGN", "DOUBLE_BAR", "DOT", "UNDERLINE", "AT", "SHARP", "DOLLAR", 
      "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "COLON", "DOUBLE_COLON", 
      "STAR", "DIVIDE", "MODULE", "PLUS", "MINUS", "BIT_NOT", "BIT_OR", 
      "BIT_AND", "BIT_XOR", "RECEIVE", "ANSI_DEFAULTS", "ANSI_NULL_DFLT_OFF", 
      "ANSI_NULL_DFLT_ON", "ARITHIGNORE", "FMTONLY", "FORCEPLAN", "IMPLICIT_TRANSACTIONS", 
      "NOEXEC", "PARSEONLY", "REMOTE_PROC_TRANSACTIONS", "SHOWPLAN_ALL", 
      "SHOWPLAN_TEXT", "SHOWPLAN_XML", "XACT_ABORT", "VERSION"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,454,3823,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,1,0,5,0,434,8,0,10,0,12,0,437,
  	9,0,1,0,1,0,1,0,5,0,442,8,0,10,0,12,0,445,9,0,1,0,1,0,3,0,449,8,0,1,1,
  	1,1,3,1,453,8,1,1,1,1,1,4,1,457,8,1,11,1,12,1,458,3,1,461,8,1,1,1,5,1,
  	464,8,1,10,1,12,1,467,9,1,1,1,1,1,5,1,471,8,1,10,1,12,1,474,9,1,1,1,3,
  	1,477,8,1,1,2,1,2,3,2,481,8,2,1,3,1,3,3,3,485,8,3,1,3,1,3,3,3,489,8,3,
  	1,3,1,3,3,3,493,8,3,1,3,1,3,3,3,497,8,3,1,3,1,3,3,3,501,8,3,1,3,1,3,3,
  	3,505,8,3,1,3,3,3,508,8,3,1,4,1,4,1,4,1,4,1,4,3,4,515,8,4,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,3,5,526,8,5,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,
  	6,1,6,1,6,1,6,3,6,540,8,6,1,7,1,7,3,7,544,8,7,1,7,5,7,547,8,7,10,7,12,
  	7,550,9,7,1,7,1,7,3,7,554,8,7,1,8,1,8,3,8,558,8,8,1,9,1,9,3,9,562,8,9,
  	1,10,1,10,1,10,3,10,567,8,10,1,10,1,10,1,10,3,10,572,8,10,3,10,574,8,
  	10,1,11,1,11,3,11,578,8,11,1,11,3,11,581,8,11,1,12,1,12,1,12,1,12,1,12,
  	3,12,588,8,12,1,12,3,12,591,8,12,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,
  	13,600,8,13,1,13,3,13,603,8,13,1,14,1,14,1,15,1,15,1,16,1,16,1,17,1,17,
  	1,17,3,17,614,8,17,1,17,4,17,617,8,17,11,17,12,17,618,1,17,1,17,1,17,
  	3,17,624,8,17,1,17,1,17,1,17,3,17,629,8,17,1,17,5,17,632,8,17,10,17,12,
  	17,635,9,17,1,17,1,17,1,17,3,17,640,8,17,1,18,1,18,3,18,644,8,18,1,18,
  	3,18,647,8,18,1,18,1,18,3,18,651,8,18,1,18,3,18,654,8,18,1,18,3,18,657,
  	8,18,1,19,1,19,1,19,1,19,1,19,3,19,664,8,19,1,19,1,19,3,19,668,8,19,3,
  	19,670,8,19,1,20,1,20,1,20,3,20,675,8,20,1,20,1,20,5,20,679,8,20,10,20,
  	12,20,682,9,20,1,20,3,20,685,8,20,1,21,1,21,1,21,1,21,1,21,1,21,1,21,
  	1,21,1,21,5,21,696,8,21,10,21,12,21,699,9,21,1,21,1,21,1,21,3,21,704,
  	8,21,1,21,3,21,707,8,21,1,21,1,21,1,21,1,21,1,21,5,21,714,8,21,10,21,
  	12,21,717,9,21,3,21,719,8,21,1,22,1,22,1,23,1,23,1,23,1,23,1,23,1,23,
  	1,23,1,23,3,23,731,8,23,1,24,1,24,1,25,1,25,1,26,1,26,1,27,1,27,1,28,
  	1,28,1,29,1,29,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,754,
  	8,30,1,30,3,30,757,8,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,31,
  	767,8,31,1,31,1,31,1,31,1,31,3,31,773,8,31,4,31,775,8,31,11,31,12,31,
  	776,1,31,1,31,3,31,781,8,31,1,32,1,32,1,32,1,32,1,32,3,32,788,8,32,1,
  	32,1,32,1,32,1,32,3,32,794,8,32,3,32,796,8,32,1,32,1,32,1,32,3,32,801,
  	8,32,1,32,1,32,1,32,1,32,3,32,807,8,32,1,32,1,32,1,32,1,32,3,32,813,8,
  	32,1,32,1,32,1,32,3,32,818,8,32,1,32,1,32,1,32,1,32,3,32,824,8,32,1,33,
  	1,33,1,33,1,33,1,33,3,33,831,8,33,1,33,1,33,1,33,3,33,836,8,33,1,33,1,
  	33,1,33,3,33,841,8,33,1,33,1,33,1,33,3,33,846,8,33,1,33,3,33,849,8,33,
  	1,33,1,33,3,33,853,8,33,1,33,1,33,3,33,857,8,33,1,33,1,33,3,33,861,8,
  	33,1,33,1,33,3,33,865,8,33,1,33,1,33,1,33,3,33,870,8,33,1,33,1,33,3,33,
  	874,8,33,1,33,1,33,3,33,878,8,33,1,34,3,34,881,8,34,1,34,1,34,1,34,1,
  	34,1,34,1,34,3,34,889,8,34,3,34,891,8,34,1,34,3,34,894,8,34,1,34,1,34,
  	3,34,898,8,34,1,34,3,34,901,8,34,1,34,1,34,1,34,1,34,1,34,4,34,908,8,
  	34,11,34,12,34,909,1,34,3,34,913,8,34,1,34,3,34,916,8,34,1,34,1,34,1,
  	35,1,35,1,35,1,35,3,35,924,8,35,1,35,1,35,4,35,928,8,35,11,35,12,35,929,
  	1,35,1,35,1,35,1,35,1,35,3,35,937,8,35,1,35,1,35,3,35,941,8,35,1,35,1,
  	35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,952,8,35,1,35,1,35,4,35,956,
  	8,35,11,35,12,35,957,3,35,960,8,35,1,36,1,36,1,36,1,36,1,36,5,36,967,
  	8,36,10,36,12,36,970,9,36,1,36,3,36,973,8,36,1,37,1,37,1,37,1,37,1,37,
  	3,37,980,8,37,1,37,1,37,1,37,3,37,985,8,37,1,38,3,38,988,8,38,1,38,1,
  	38,1,38,1,38,1,38,1,38,3,38,996,8,38,1,38,1,38,3,38,1000,8,38,1,38,3,
  	38,1003,8,38,1,38,1,38,3,38,1007,8,38,1,38,3,38,1010,8,38,1,38,1,38,3,
  	38,1014,8,38,1,38,1,38,1,38,1,38,1,38,3,38,1021,8,38,1,38,1,38,3,38,1025,
  	8,38,3,38,1027,8,38,3,38,1029,8,38,1,38,3,38,1032,8,38,1,38,3,38,1035,
  	8,38,1,39,1,39,1,39,3,39,1040,8,39,1,40,3,40,1043,8,40,1,40,1,40,1,40,
  	1,40,1,40,1,40,3,40,1051,8,40,3,40,1053,8,40,1,40,3,40,1056,8,40,1,40,
  	1,40,3,40,1060,8,40,1,40,1,40,1,40,1,40,3,40,1066,8,40,1,40,3,40,1069,
  	8,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,3,41,1078,8,41,1,42,3,42,1081,
  	8,42,1,42,1,42,1,42,1,42,1,42,3,42,1088,8,42,1,42,1,42,1,42,1,42,3,42,
  	1094,8,42,5,42,1096,8,42,10,42,12,42,1099,9,42,1,42,1,42,1,42,1,42,1,
  	42,1,42,1,42,3,42,1108,8,42,1,42,3,42,1111,8,42,1,43,3,43,1114,8,43,1,
  	43,1,43,1,44,1,44,3,44,1120,8,44,1,44,3,44,1123,8,44,1,44,3,44,1126,8,
  	44,1,45,1,45,3,45,1130,8,45,1,46,3,46,1133,8,46,1,46,1,46,1,46,1,46,1,
  	46,1,46,3,46,1141,8,46,3,46,1143,8,46,1,46,1,46,3,46,1147,8,46,1,46,1,
  	46,1,46,1,46,5,46,1153,8,46,10,46,12,46,1156,9,46,1,46,3,46,1159,8,46,
  	1,46,1,46,3,46,1163,8,46,1,46,1,46,1,46,1,46,1,46,3,46,1170,8,46,1,46,
  	1,46,3,46,1174,8,46,3,46,1176,8,46,3,46,1178,8,46,1,46,3,46,1181,8,46,
  	1,46,3,46,1184,8,46,1,47,1,47,1,47,1,47,5,47,1190,8,47,10,47,12,47,1193,
  	9,47,1,47,1,47,1,47,3,47,1198,8,47,1,47,1,47,1,47,1,47,3,47,1204,8,47,
  	3,47,1206,8,47,1,48,1,48,3,48,1210,8,48,1,48,3,48,1213,8,48,1,49,1,49,
  	1,49,3,49,1218,8,49,1,49,3,49,1221,8,49,1,49,1,49,1,49,1,49,3,49,1227,
  	8,49,1,49,3,49,1230,8,49,1,49,1,49,1,49,5,49,1235,8,49,10,49,12,49,1238,
  	9,49,1,49,3,49,1241,8,49,3,49,1243,8,49,1,49,1,49,1,49,1,49,5,49,1249,
  	8,49,10,49,12,49,1252,9,49,3,49,1254,8,49,1,49,1,49,3,49,1258,8,49,1,
  	49,1,49,5,49,1262,8,49,10,49,12,49,1265,9,49,1,50,1,50,1,50,3,50,1270,
  	8,50,1,50,3,50,1273,8,50,1,50,1,50,1,50,1,50,1,50,1,50,5,50,1281,8,50,
  	10,50,12,50,1284,9,50,1,50,1,50,1,50,1,50,3,50,1290,8,50,1,50,1,50,1,
  	50,3,50,1295,8,50,1,50,3,50,1298,8,50,1,51,1,51,1,51,1,51,1,51,1,51,5,
  	51,1306,8,51,10,51,12,51,1309,9,51,3,51,1311,8,51,1,51,3,51,1314,8,51,
  	1,51,1,51,1,51,1,51,1,51,1,51,3,51,1322,8,51,1,52,1,52,1,52,1,52,1,52,
  	1,52,1,52,5,52,1331,8,52,10,52,12,52,1334,9,52,3,52,1336,8,52,1,52,3,
  	52,1339,8,52,1,52,1,52,5,52,1343,8,52,10,52,12,52,1346,9,52,1,52,1,52,
  	3,52,1350,8,52,1,52,1,52,3,52,1354,8,52,1,53,1,53,1,53,1,53,1,53,1,53,
  	5,53,1362,8,53,10,53,12,53,1365,9,53,3,53,1367,8,53,1,53,3,53,1370,8,
  	53,1,53,1,53,5,53,1374,8,53,10,53,12,53,1377,9,53,1,53,1,53,1,53,3,53,
  	1382,8,53,1,53,1,53,1,54,1,54,3,54,1388,8,54,1,54,1,54,1,54,3,54,1393,
  	8,54,1,54,1,54,3,54,1397,8,54,1,54,1,54,3,54,1401,8,54,1,54,3,54,1404,
  	8,54,1,55,1,55,1,55,3,55,1409,8,55,1,56,1,56,1,56,1,56,1,56,1,56,1,56,
  	1,56,1,56,1,56,1,56,1,56,3,56,1423,8,56,1,57,1,57,1,57,1,57,1,57,1,57,
  	3,57,1431,8,57,1,57,1,57,1,57,3,57,1436,8,57,1,57,5,57,1439,8,57,10,57,
  	12,57,1442,9,57,1,57,1,57,1,57,3,57,1447,8,57,1,57,1,57,1,57,3,57,1452,
  	8,57,1,57,3,57,1455,8,57,1,58,1,58,1,58,1,58,1,58,5,58,1462,8,58,10,58,
  	12,58,1465,9,58,1,58,1,58,1,58,1,58,1,58,5,58,1472,8,58,10,58,12,58,1475,
  	9,58,3,58,1477,8,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,
  	1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,1498,8,59,10,59,12,
  	59,1501,9,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,
  	59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,1527,
  	8,59,1,59,3,59,1530,8,59,1,60,1,60,1,61,1,61,1,61,1,61,3,61,1538,8,61,
  	1,62,1,62,1,62,1,62,3,62,1544,8,62,1,62,1,62,1,62,5,62,1549,8,62,10,62,
  	12,62,1552,9,62,1,62,3,62,1555,8,62,1,63,1,63,1,63,1,63,3,63,1561,8,63,
  	1,63,1,63,1,63,5,63,1566,8,63,10,63,12,63,1569,9,63,1,63,3,63,1572,8,
  	63,1,64,1,64,1,64,1,64,3,64,1578,8,64,1,64,1,64,3,64,1582,8,64,1,65,1,
  	65,1,65,3,65,1587,8,65,1,65,1,65,3,65,1591,8,65,1,65,1,65,1,65,1,65,5,
  	65,1597,8,65,10,65,12,65,1600,9,65,1,65,3,65,1603,8,65,3,65,1605,8,65,
  	1,66,1,66,3,66,1609,8,66,1,66,1,66,3,66,1613,8,66,1,66,1,66,3,66,1617,
  	8,66,1,66,3,66,1620,8,66,1,66,1,66,3,66,1624,8,66,1,66,1,66,1,66,1,66,
  	3,66,1630,8,66,1,66,1,66,3,66,1634,8,66,3,66,1636,8,66,1,67,1,67,1,67,
  	3,67,1641,8,67,1,68,1,68,3,68,1645,8,68,1,68,1,68,3,68,1649,8,68,1,69,
  	1,69,1,69,1,69,1,69,3,69,1656,8,69,1,70,1,70,1,70,3,70,1661,8,70,1,71,
  	1,71,1,71,1,71,5,71,1667,8,71,10,71,12,71,1670,9,71,3,71,1672,8,71,1,
  	71,3,71,1675,8,71,1,72,1,72,3,72,1679,8,72,1,72,1,72,3,72,1683,8,72,1,
  	72,3,72,1686,8,72,1,72,1,72,1,72,1,72,5,72,1692,8,72,10,72,12,72,1695,
  	9,72,1,72,1,72,3,72,1699,8,72,1,73,1,73,1,73,5,73,1704,8,73,10,73,12,
  	73,1707,9,73,1,73,1,73,1,73,5,73,1712,8,73,10,73,12,73,1715,9,73,3,73,
  	1717,8,73,1,74,1,74,1,74,1,74,1,75,1,75,1,76,1,76,1,76,3,76,1728,8,76,
  	1,76,1,76,1,76,3,76,1733,8,76,1,77,1,77,1,78,1,78,1,79,1,79,1,79,1,79,
  	3,79,1743,8,79,1,79,1,79,1,79,3,79,1748,8,79,1,79,1,79,1,79,1,79,1,79,
  	3,79,1755,8,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,
  	3,79,1768,8,79,3,79,1770,8,79,3,79,1772,8,79,1,79,3,79,1775,8,79,1,79,
  	3,79,1778,8,79,1,80,1,80,1,80,1,80,1,80,3,80,1785,8,80,1,80,3,80,1788,
  	8,80,1,80,1,80,1,80,1,80,3,80,1794,8,80,1,80,1,80,1,80,3,80,1799,8,80,
  	3,80,1801,8,80,1,80,3,80,1804,8,80,1,80,1,80,1,80,1,80,3,80,1810,8,80,
  	1,80,1,80,1,80,1,80,1,80,1,80,3,80,1818,8,80,3,80,1820,8,80,1,80,3,80,
  	1823,8,80,1,80,1,80,3,80,1827,8,80,1,80,3,80,1830,8,80,1,80,1,80,1,80,
  	1,80,1,80,1,80,1,80,1,80,3,80,1840,8,80,1,80,3,80,1843,8,80,1,80,1,80,
  	3,80,1847,8,80,1,80,3,80,1850,8,80,1,80,1,80,1,80,1,80,3,80,1856,8,80,
  	1,80,3,80,1859,8,80,3,80,1861,8,80,1,81,1,81,3,81,1865,8,81,1,82,1,82,
  	3,82,1869,8,82,1,83,1,83,1,83,3,83,1874,8,83,1,84,1,84,1,84,3,84,1879,
  	8,84,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,3,85,1889,8,85,1,85,3,85,
  	1892,8,85,1,85,3,85,1895,8,85,1,86,1,86,1,86,1,86,1,86,1,86,3,86,1903,
  	8,86,1,86,1,86,3,86,1907,8,86,1,86,3,86,1910,8,86,1,87,1,87,3,87,1914,
  	8,87,1,88,1,88,1,88,3,88,1919,8,88,1,89,1,89,1,89,1,89,1,90,1,90,3,90,
  	1927,8,90,1,90,1,90,1,90,3,90,1932,8,90,1,91,1,91,1,91,1,91,1,91,1,92,
  	1,92,3,92,1941,8,92,1,92,5,92,1944,8,92,10,92,12,92,1947,9,92,1,93,1,
  	93,3,93,1951,8,93,1,94,1,94,1,94,1,94,1,94,3,94,1958,8,94,3,94,1960,8,
  	94,1,94,1,94,3,94,1964,8,94,1,94,3,94,1967,8,94,1,94,1,94,3,94,1971,8,
  	94,1,94,1,94,3,94,1975,8,94,1,94,1,94,1,94,1,94,1,94,1,94,3,94,1983,8,
  	94,1,94,1,94,1,94,3,94,1988,8,94,3,94,1990,8,94,1,94,3,94,1993,8,94,1,
  	94,5,94,1996,8,94,10,94,12,94,1999,9,94,1,95,1,95,3,95,2003,8,95,1,95,
  	1,95,1,95,3,95,2008,8,95,1,95,3,95,2011,8,95,1,95,1,95,1,95,1,95,3,95,
  	2017,8,95,1,95,1,95,1,95,1,95,1,95,1,95,3,95,2025,8,95,1,95,1,95,1,95,
  	1,95,1,95,1,95,1,95,3,95,2034,8,95,1,96,1,96,3,96,2038,8,96,1,96,1,96,
  	1,96,3,96,2043,8,96,1,96,1,96,1,96,1,96,3,96,2049,8,96,1,96,1,96,3,96,
  	2053,8,96,1,96,1,96,1,96,1,96,3,96,2059,8,96,1,96,1,96,1,96,1,96,1,96,
  	1,96,3,96,2067,8,96,1,96,1,96,1,96,1,96,4,96,2073,8,96,11,96,12,96,2074,
  	1,96,3,96,2078,8,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,
  	1,96,1,96,1,96,3,96,2093,8,96,3,96,2095,8,96,1,97,1,97,1,97,1,97,1,97,
  	5,97,2102,8,97,10,97,12,97,2105,9,97,1,97,1,97,1,98,1,98,3,98,2111,8,
  	98,1,98,1,98,1,98,1,98,1,98,3,98,2118,8,98,1,99,1,99,1,99,1,99,1,99,1,
  	99,1,99,1,99,3,99,2128,8,99,3,99,2130,8,99,3,99,2132,8,99,1,99,3,99,2135,
  	8,99,1,99,3,99,2138,8,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,
  	3,99,2149,8,99,3,99,2151,8,99,3,99,2153,8,99,1,99,3,99,2156,8,99,1,100,
  	5,100,2159,8,100,10,100,12,100,2162,9,100,1,100,1,100,1,100,1,101,1,101,
  	1,101,1,101,1,101,3,101,2172,8,101,1,102,1,102,1,102,1,102,1,102,1,102,
  	1,102,3,102,2181,8,102,1,102,3,102,2184,8,102,1,102,3,102,2187,8,102,
  	1,102,1,102,1,102,1,102,1,102,5,102,2194,8,102,10,102,12,102,2197,9,102,
  	3,102,2199,8,102,1,102,3,102,2202,8,102,1,103,1,103,1,103,1,103,1,103,
  	3,103,2209,8,103,1,103,3,103,2212,8,103,1,103,1,103,1,103,1,103,3,103,
  	2218,8,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,
  	1,103,1,103,1,103,3,103,2233,8,103,1,103,3,103,2236,8,103,1,103,1,103,
  	1,103,1,103,1,103,3,103,2243,8,103,1,103,1,103,1,103,3,103,2248,8,103,
  	1,104,1,104,3,104,2252,8,104,1,105,1,105,1,105,1,105,1,105,1,105,1,105,
  	1,105,1,105,3,105,2263,8,105,1,105,1,105,1,105,1,105,1,105,1,105,1,105,
  	1,105,1,105,1,105,1,105,5,105,2276,8,105,10,105,12,105,2279,9,105,1,106,
  	1,106,1,106,1,106,1,106,1,107,1,107,1,107,1,107,3,107,2290,8,107,1,108,
  	1,108,1,108,4,108,2295,8,108,11,108,12,108,2296,1,108,1,108,3,108,2301,
  	8,108,1,108,1,108,1,108,1,108,4,108,2307,8,108,11,108,12,108,2308,1,108,
  	1,108,3,108,2313,8,108,1,108,1,108,3,108,2317,8,108,1,109,1,109,1,109,
  	1,109,3,109,2323,8,109,1,110,1,110,1,110,1,110,1,110,1,110,1,110,1,110,
  	3,110,2333,8,110,1,111,1,111,1,111,1,111,1,111,1,111,1,111,1,111,3,111,
  	2343,8,111,1,112,1,112,1,113,1,113,1,113,1,113,5,113,2351,8,113,10,113,
  	12,113,2354,9,113,1,114,1,114,1,114,1,114,1,114,3,114,2361,8,114,1,114,
  	1,114,1,114,1,114,1,114,1,115,1,115,1,115,1,115,1,115,3,115,2373,8,115,
  	1,115,1,115,1,115,1,115,3,115,2379,8,115,1,115,1,115,3,115,2383,8,115,
  	1,115,1,115,1,115,1,115,1,115,1,115,1,115,1,115,3,115,2393,8,115,1,116,
  	1,116,3,116,2397,8,116,1,116,1,116,3,116,2401,8,116,1,116,1,116,1,116,
  	1,116,1,116,1,116,1,116,1,116,3,116,2411,8,116,1,117,1,117,5,117,2415,
  	8,117,10,117,12,117,2418,9,117,1,117,1,117,1,117,1,117,1,117,3,117,2425,
  	8,117,1,117,1,117,1,117,1,117,1,117,1,117,5,117,2433,8,117,10,117,12,
  	117,2436,9,117,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,
  	1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,5,118,2456,8,118,
  	10,118,12,118,2459,9,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,5,
  	118,2468,8,118,10,118,12,118,2471,9,118,1,118,1,118,1,118,1,118,3,118,
  	2477,8,118,1,118,1,118,1,118,1,118,5,118,2483,8,118,10,118,12,118,2486,
  	9,118,1,118,1,118,1,118,1,118,3,118,2492,8,118,1,118,1,118,1,118,1,118,
  	3,118,2498,8,118,1,119,1,119,1,119,1,119,1,119,3,119,2505,8,119,1,119,
  	1,119,3,119,2509,8,119,1,119,4,119,2512,8,119,11,119,12,119,2513,3,119,
  	2516,8,119,1,120,1,120,3,120,2520,8,120,1,120,1,120,3,120,2524,8,120,
  	1,120,1,120,1,120,1,120,1,120,3,120,2531,8,120,1,121,1,121,3,121,2535,
  	8,121,1,121,3,121,2538,8,121,1,121,1,121,1,121,3,121,2543,8,121,1,121,
  	1,121,3,121,2547,8,121,1,121,1,121,3,121,2551,8,121,1,121,1,121,1,121,
  	3,121,2556,8,121,1,121,1,121,1,121,5,121,2561,8,121,10,121,12,121,2564,
  	9,121,3,121,2566,8,121,1,121,1,121,3,121,2570,8,121,1,122,1,122,1,122,
  	3,122,2575,8,122,1,122,1,122,3,122,2579,8,122,1,123,1,123,1,123,1,123,
  	1,123,1,123,1,123,3,123,2588,8,123,1,124,1,124,1,124,1,124,1,124,3,124,
  	2595,8,124,1,125,1,125,1,125,1,125,1,125,5,125,2602,8,125,10,125,12,125,
  	2605,9,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,3,125,
  	2616,8,125,3,125,2618,8,125,1,126,1,126,1,126,3,126,2623,8,126,1,127,
  	1,127,1,128,1,128,1,128,1,128,1,128,5,128,2632,8,128,10,128,12,128,2635,
  	9,128,1,128,1,128,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,
  	1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,
  	1,129,1,129,1,129,5,129,2663,8,129,10,129,12,129,2666,9,129,1,129,1,129,
  	1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,3,129,
  	2681,8,129,1,130,1,130,1,130,1,130,1,130,3,130,2688,8,130,3,130,2690,
  	8,130,1,131,1,131,1,131,5,131,2695,8,131,10,131,12,131,2698,9,131,1,132,
  	1,132,1,132,1,132,5,132,2704,8,132,10,132,12,132,2707,9,132,1,132,1,132,
  	1,133,1,133,1,133,3,133,2714,8,133,1,133,1,133,1,133,1,133,3,133,2720,
  	8,133,1,134,1,134,1,134,1,134,1,134,1,134,3,134,2728,8,134,1,134,3,134,
  	2731,8,134,1,135,1,135,1,135,1,135,1,135,3,135,2738,8,135,1,135,1,135,
  	1,135,1,135,3,135,2744,8,135,1,135,3,135,2747,8,135,3,135,2749,8,135,
  	1,136,1,136,1,136,1,136,1,136,1,136,3,136,2757,8,136,3,136,2759,8,136,
  	1,137,1,137,1,137,1,137,1,137,1,137,3,137,2767,8,137,1,137,1,137,3,137,
  	2771,8,137,1,138,1,138,1,138,5,138,2776,8,138,10,138,12,138,2779,9,138,
  	1,139,1,139,1,139,1,139,1,139,3,139,2786,8,139,1,140,1,140,5,140,2790,
  	8,140,10,140,12,140,2793,9,140,1,140,1,140,1,140,1,140,5,140,2799,8,140,
  	10,140,12,140,2802,9,140,3,140,2804,8,140,1,141,1,141,3,141,2808,8,141,
  	1,141,1,141,3,141,2812,8,141,1,141,1,141,3,141,2816,8,141,1,141,1,141,
  	1,141,1,141,1,141,3,141,2823,8,141,3,141,2825,8,141,1,141,1,141,3,141,
  	2829,8,141,1,141,1,141,1,141,3,141,2834,8,141,3,141,2836,8,141,1,141,
  	1,141,1,141,3,141,2841,8,141,3,141,2843,8,141,1,141,1,141,1,141,1,141,
  	1,141,3,141,2850,8,141,3,141,2852,8,141,1,141,1,141,1,141,3,141,2857,
  	8,141,3,141,2859,8,141,1,142,1,142,1,142,5,142,2864,8,142,10,142,12,142,
  	2867,9,142,1,143,1,143,1,143,3,143,2872,8,143,1,144,1,144,3,144,2876,
  	8,144,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,146,1,146,1,146,
  	1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,147,1,147,1,147,1,147,1,147,
  	3,147,2901,8,147,1,148,3,148,2904,8,148,1,148,1,148,3,148,2908,8,148,
  	3,148,2910,8,148,1,148,3,148,2913,8,148,1,148,1,148,1,148,1,148,1,148,
  	1,149,1,149,1,149,1,149,1,150,1,150,1,150,1,150,1,151,1,151,1,151,1,151,
  	1,152,1,152,1,152,1,152,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
  	1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,155,1,155,
  	1,155,5,155,2957,8,155,10,155,12,155,2960,9,155,1,156,1,156,3,156,2964,
  	8,156,1,157,1,157,1,157,1,157,1,158,1,158,1,158,1,158,1,158,1,158,1,158,
  	1,158,1,158,1,158,3,158,2980,8,158,1,159,1,159,1,159,1,159,1,159,1,159,
  	1,159,3,159,2989,8,159,1,159,1,159,1,159,3,159,2994,8,159,1,160,1,160,
  	1,160,3,160,2999,8,160,1,160,1,160,1,160,1,160,1,160,1,160,1,160,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	3,161,3033,8,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,3,161,
  	3091,8,161,1,161,1,161,3,161,3095,8,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
  	1,161,3,161,3151,8,161,3,161,3153,8,161,1,162,1,162,1,162,1,162,1,162,
  	1,162,3,162,3161,8,162,1,162,1,162,1,162,1,162,1,162,1,162,1,163,1,163,
  	1,163,1,163,1,163,1,164,1,164,1,164,1,164,1,164,1,165,3,165,3180,8,165,
  	1,165,1,165,1,166,3,166,3185,8,166,1,166,1,166,1,167,1,167,3,167,3191,
  	8,167,1,168,3,168,3194,8,168,1,168,1,168,1,168,3,168,3199,8,168,1,168,
  	5,168,3202,8,168,10,168,12,168,3205,9,168,1,168,1,168,1,169,1,169,1,169,
  	1,169,3,169,3213,8,169,1,169,5,169,3216,8,169,10,169,12,169,3219,9,169,
  	1,169,1,169,1,170,3,170,3224,8,170,1,170,1,170,1,170,1,170,1,170,5,170,
  	3231,8,170,10,170,12,170,3234,9,170,1,170,1,170,1,170,1,170,1,170,5,170,
  	3241,8,170,10,170,12,170,3244,9,170,3,170,3246,8,170,1,170,1,170,1,170,
  	1,170,1,170,1,170,1,170,1,170,1,170,1,170,5,170,3258,8,170,10,170,12,
  	170,3261,9,170,1,170,1,170,1,170,3,170,3266,8,170,1,170,1,170,1,170,1,
  	170,1,170,1,170,1,170,3,170,3275,8,170,1,171,1,171,3,171,3279,8,171,1,
  	172,1,172,1,172,1,172,5,172,3285,8,172,10,172,12,172,3288,9,172,1,172,
  	1,172,1,173,1,173,3,173,3294,8,173,1,174,1,174,1,174,1,174,1,174,1,174,
  	1,174,1,174,1,174,5,174,3305,8,174,10,174,12,174,3308,9,174,1,175,1,175,
  	1,175,5,175,3313,8,175,10,175,12,175,3316,9,175,1,176,1,176,1,176,1,176,
  	1,176,1,176,1,176,1,176,1,176,1,176,3,176,3328,8,176,1,177,1,177,1,177,
  	1,177,1,177,3,177,3335,8,177,1,177,1,177,1,177,1,177,3,177,3341,8,177,
  	1,177,1,177,3,177,3345,8,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,
  	1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,3,177,3362,8,177,1,178,
  	1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,
  	3,178,3377,8,178,3,178,3379,8,178,1,178,1,178,1,178,1,178,1,178,1,178,
  	1,178,1,178,1,178,1,178,1,178,3,178,3392,8,178,1,178,1,178,1,178,1,178,
  	1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,1,178,3,178,3408,
  	8,178,1,178,1,178,1,178,1,178,1,178,1,178,3,178,3416,8,178,1,178,1,178,
  	3,178,3420,8,178,1,179,3,179,3423,8,179,1,179,1,179,1,180,1,180,1,180,
  	1,180,1,180,3,180,3432,8,180,1,180,3,180,3435,8,180,1,180,3,180,3438,
  	8,180,1,180,1,180,1,181,1,181,1,181,1,182,1,182,1,182,1,182,1,182,1,182,
  	3,182,3451,8,182,1,183,1,183,3,183,3455,8,183,1,184,1,184,1,184,1,184,
  	1,184,1,184,3,184,3463,8,184,1,185,1,185,1,185,1,185,3,185,3469,8,185,
  	1,186,1,186,1,186,1,186,1,186,1,186,1,186,1,186,1,186,1,186,3,186,3481,
  	8,186,1,186,1,186,1,186,1,186,1,186,3,186,3488,8,186,1,186,1,186,1,187,
  	1,187,1,187,1,187,1,187,3,187,3497,8,187,1,188,1,188,1,188,1,188,1,188,
  	3,188,3504,8,188,1,189,1,189,1,189,1,189,1,189,1,189,1,189,1,189,1,189,
  	1,189,3,189,3516,8,189,1,189,1,189,1,189,1,189,1,189,3,189,3523,8,189,
  	1,189,1,189,1,190,1,190,1,190,1,190,3,190,3531,8,190,1,190,1,190,1,190,
  	1,190,1,190,3,190,3538,8,190,1,190,1,190,1,190,1,190,3,190,3544,8,190,
  	1,190,1,190,1,190,1,190,1,190,3,190,3551,8,190,1,190,3,190,3554,8,190,
  	1,191,1,191,1,191,3,191,3559,8,191,1,191,1,191,1,192,1,192,1,192,3,192,
  	3566,8,192,1,192,1,192,1,193,3,193,3571,8,193,1,193,1,193,3,193,3575,
  	8,193,1,193,1,193,1,193,3,193,3580,8,193,1,194,3,194,3583,8,194,1,194,
  	1,194,3,194,3587,8,194,1,194,1,194,3,194,3591,8,194,1,194,1,194,1,194,
  	3,194,3596,8,194,1,195,1,195,3,195,3600,8,195,1,196,1,196,1,196,1,196,
  	3,196,3606,8,196,1,196,1,196,3,196,3610,8,196,1,196,1,196,3,196,3614,
  	8,196,1,196,1,196,1,196,3,196,3619,8,196,1,196,1,196,3,196,3623,8,196,
  	1,196,1,196,1,196,3,196,3628,8,196,1,196,1,196,1,196,3,196,3633,8,196,
  	1,197,1,197,3,197,3637,8,197,1,197,1,197,1,197,3,197,3642,8,197,5,197,
  	3644,8,197,10,197,12,197,3647,9,197,1,198,1,198,1,198,5,198,3652,8,198,
  	10,198,12,198,3655,9,198,1,199,3,199,3658,8,199,1,199,5,199,3661,8,199,
  	10,199,12,199,3664,9,199,1,199,1,199,1,200,1,200,1,200,5,200,3671,8,200,
  	10,200,12,200,3674,9,200,1,201,1,201,3,201,3678,8,201,1,202,1,202,1,203,
  	3,203,3683,8,203,1,203,1,203,1,204,1,204,1,204,1,204,1,204,3,204,3692,
  	8,204,1,204,1,204,3,204,3696,8,204,3,204,3698,8,204,1,205,1,205,1,205,
  	1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,
  	1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,1,205,
  	1,205,1,205,1,205,1,205,1,205,3,205,3732,8,205,1,206,1,206,1,206,1,206,
  	1,206,1,206,1,206,1,206,1,206,1,206,1,206,1,206,1,206,1,206,1,206,1,206,
  	1,206,1,206,1,206,1,206,1,206,1,206,1,206,3,206,3757,8,206,1,206,1,206,
  	3,206,3761,8,206,1,206,3,206,3764,8,206,1,207,1,207,1,207,3,207,3769,
  	8,207,1,208,1,208,1,208,3,208,3774,8,208,1,208,1,208,3,208,3778,8,208,
  	1,208,1,208,3,208,3782,8,208,1,208,1,208,3,208,3786,8,208,1,209,1,209,
  	1,210,1,210,1,211,1,211,1,211,1,211,3,211,3796,8,211,1,212,1,212,1,213,
  	1,213,3,213,3802,8,213,1,214,1,214,1,214,1,214,1,214,1,214,1,214,1,214,
  	1,214,1,214,1,214,1,214,1,214,1,214,1,214,3,214,3819,8,214,1,215,1,215,
  	1,215,0,2,210,234,216,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,
  	36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,
  	82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,
  	122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,
  	158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,
  	194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,
  	230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,
  	266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,
  	302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,
  	338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,
  	374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,
  	410,412,414,416,418,420,422,424,426,428,430,0,57,1,0,399,400,2,0,399,
  	399,402,402,2,0,205,205,337,338,2,0,399,400,402,402,3,0,271,271,319,319,
  	375,375,3,0,396,396,399,399,402,402,3,0,138,138,275,275,344,344,2,0,138,
  	138,275,275,3,0,62,62,138,138,275,275,2,0,217,217,320,320,1,0,125,126,
  	2,0,281,282,300,300,3,0,145,145,178,178,212,212,2,0,228,228,251,251,2,
  	0,400,400,402,402,1,0,281,282,5,0,169,171,209,209,211,211,296,298,340,
  	341,1,0,149,150,1,0,111,112,4,0,184,184,283,283,315,315,402,402,2,0,239,
  	239,316,316,2,0,225,225,312,312,4,0,213,213,219,219,245,245,326,326,3,
  	0,279,279,299,299,313,313,2,0,166,166,303,303,8,0,173,175,177,177,192,
  	192,196,196,268,268,274,274,293,293,440,453,1,0,430,432,3,0,418,418,433,
  	434,436,438,1,0,433,434,3,0,31,31,34,34,143,143,2,0,31,31,69,69,2,0,400,
  	400,404,405,2,0,307,307,310,310,2,0,220,220,266,266,2,0,116,116,233,233,
  	3,0,106,106,191,191,233,233,3,0,106,106,233,233,255,255,2,0,224,224,321,
  	321,2,0,207,207,240,240,2,0,108,108,399,400,3,0,85,85,104,104,133,133,
  	4,0,106,106,233,233,255,255,304,304,2,0,55,55,117,117,3,0,208,208,295,
  	295,308,308,7,0,179,179,259,259,262,262,328,329,333,333,351,351,353,353,
  	1,0,193,194,2,0,221,221,248,248,2,0,246,246,249,249,2,0,195,195,287,287,
  	1,0,288,289,2,0,36,36,68,68,2,0,294,294,310,310,6,0,4,4,15,15,28,29,181,
  	181,352,352,391,392,1,0,404,405,2,0,400,400,404,404,14,0,4,4,15,15,28,
  	29,122,122,166,262,264,354,356,357,359,363,366,367,369,369,371,383,385,
  	385,387,389,391,392,1,0,410,417,4410,0,448,1,0,0,0,2,476,1,0,0,0,4,480,
  	1,0,0,0,6,507,1,0,0,0,8,514,1,0,0,0,10,525,1,0,0,0,12,539,1,0,0,0,14,
  	541,1,0,0,0,16,555,1,0,0,0,18,559,1,0,0,0,20,573,1,0,0,0,22,575,1,0,0,
  	0,24,582,1,0,0,0,26,592,1,0,0,0,28,604,1,0,0,0,30,606,1,0,0,0,32,608,
  	1,0,0,0,34,610,1,0,0,0,36,641,1,0,0,0,38,658,1,0,0,0,40,671,1,0,0,0,42,
  	718,1,0,0,0,44,720,1,0,0,0,46,730,1,0,0,0,48,732,1,0,0,0,50,734,1,0,0,
  	0,52,736,1,0,0,0,54,738,1,0,0,0,56,740,1,0,0,0,58,742,1,0,0,0,60,744,
  	1,0,0,0,62,758,1,0,0,0,64,782,1,0,0,0,66,825,1,0,0,0,68,880,1,0,0,0,70,
  	959,1,0,0,0,72,972,1,0,0,0,74,974,1,0,0,0,76,987,1,0,0,0,78,1039,1,0,
  	0,0,80,1042,1,0,0,0,82,1077,1,0,0,0,84,1080,1,0,0,0,86,1113,1,0,0,0,88,
  	1117,1,0,0,0,90,1129,1,0,0,0,92,1132,1,0,0,0,94,1185,1,0,0,0,96,1209,
  	1,0,0,0,98,1220,1,0,0,0,100,1272,1,0,0,0,102,1299,1,0,0,0,104,1323,1,
  	0,0,0,106,1355,1,0,0,0,108,1385,1,0,0,0,110,1408,1,0,0,0,112,1422,1,0,
  	0,0,114,1424,1,0,0,0,116,1456,1,0,0,0,118,1478,1,0,0,0,120,1531,1,0,0,
  	0,122,1537,1,0,0,0,124,1539,1,0,0,0,126,1556,1,0,0,0,128,1573,1,0,0,0,
  	130,1604,1,0,0,0,132,1635,1,0,0,0,134,1637,1,0,0,0,136,1644,1,0,0,0,138,
  	1650,1,0,0,0,140,1657,1,0,0,0,142,1662,1,0,0,0,144,1698,1,0,0,0,146,1716,
  	1,0,0,0,148,1718,1,0,0,0,150,1722,1,0,0,0,152,1732,1,0,0,0,154,1734,1,
  	0,0,0,156,1736,1,0,0,0,158,1777,1,0,0,0,160,1860,1,0,0,0,162,1862,1,0,
  	0,0,164,1866,1,0,0,0,166,1870,1,0,0,0,168,1875,1,0,0,0,170,1880,1,0,0,
  	0,172,1896,1,0,0,0,174,1913,1,0,0,0,176,1915,1,0,0,0,178,1920,1,0,0,0,
  	180,1924,1,0,0,0,182,1933,1,0,0,0,184,1938,1,0,0,0,186,1950,1,0,0,0,188,
  	1952,1,0,0,0,190,2002,1,0,0,0,192,2037,1,0,0,0,194,2096,1,0,0,0,196,2110,
  	1,0,0,0,198,2119,1,0,0,0,200,2160,1,0,0,0,202,2171,1,0,0,0,204,2173,1,
  	0,0,0,206,2247,1,0,0,0,208,2251,1,0,0,0,210,2262,1,0,0,0,212,2280,1,0,
  	0,0,214,2289,1,0,0,0,216,2316,1,0,0,0,218,2322,1,0,0,0,220,2332,1,0,0,
  	0,222,2342,1,0,0,0,224,2344,1,0,0,0,226,2346,1,0,0,0,228,2355,1,0,0,0,
  	230,2392,1,0,0,0,232,2410,1,0,0,0,234,2412,1,0,0,0,236,2497,1,0,0,0,238,
  	2515,1,0,0,0,240,2523,1,0,0,0,242,2532,1,0,0,0,244,2571,1,0,0,0,246,2587,
  	1,0,0,0,248,2594,1,0,0,0,250,2596,1,0,0,0,252,2619,1,0,0,0,254,2624,1,
  	0,0,0,256,2626,1,0,0,0,258,2680,1,0,0,0,260,2682,1,0,0,0,262,2691,1,0,
  	0,0,264,2699,1,0,0,0,266,2719,1,0,0,0,268,2727,1,0,0,0,270,2748,1,0,0,
  	0,272,2758,1,0,0,0,274,2770,1,0,0,0,276,2772,1,0,0,0,278,2785,1,0,0,0,
  	280,2803,1,0,0,0,282,2858,1,0,0,0,284,2860,1,0,0,0,286,2868,1,0,0,0,288,
  	2875,1,0,0,0,290,2877,1,0,0,0,292,2885,1,0,0,0,294,2900,1,0,0,0,296,2909,
  	1,0,0,0,298,2919,1,0,0,0,300,2923,1,0,0,0,302,2927,1,0,0,0,304,2931,1,
  	0,0,0,306,2935,1,0,0,0,308,2943,1,0,0,0,310,2953,1,0,0,0,312,2961,1,0,
  	0,0,314,2965,1,0,0,0,316,2979,1,0,0,0,318,2993,1,0,0,0,320,2998,1,0,0,
  	0,322,3152,1,0,0,0,324,3160,1,0,0,0,326,3168,1,0,0,0,328,3173,1,0,0,0,
  	330,3179,1,0,0,0,332,3184,1,0,0,0,334,3188,1,0,0,0,336,3193,1,0,0,0,338,
  	3208,1,0,0,0,340,3223,1,0,0,0,342,3278,1,0,0,0,344,3280,1,0,0,0,346,3293,
  	1,0,0,0,348,3295,1,0,0,0,350,3309,1,0,0,0,352,3327,1,0,0,0,354,3361,1,
  	0,0,0,356,3419,1,0,0,0,358,3422,1,0,0,0,360,3426,1,0,0,0,362,3441,1,0,
  	0,0,364,3450,1,0,0,0,366,3454,1,0,0,0,368,3462,1,0,0,0,370,3468,1,0,0,
  	0,372,3487,1,0,0,0,374,3496,1,0,0,0,376,3503,1,0,0,0,378,3522,1,0,0,0,
  	380,3553,1,0,0,0,382,3558,1,0,0,0,384,3565,1,0,0,0,386,3579,1,0,0,0,388,
  	3595,1,0,0,0,390,3599,1,0,0,0,392,3632,1,0,0,0,394,3634,1,0,0,0,396,3648,
  	1,0,0,0,398,3662,1,0,0,0,400,3667,1,0,0,0,402,3677,1,0,0,0,404,3679,1,
  	0,0,0,406,3682,1,0,0,0,408,3697,1,0,0,0,410,3731,1,0,0,0,412,3763,1,0,
  	0,0,414,3768,1,0,0,0,416,3785,1,0,0,0,418,3787,1,0,0,0,420,3789,1,0,0,
  	0,422,3795,1,0,0,0,424,3797,1,0,0,0,426,3801,1,0,0,0,428,3818,1,0,0,0,
  	430,3820,1,0,0,0,432,434,3,2,1,0,433,432,1,0,0,0,434,437,1,0,0,0,435,
  	433,1,0,0,0,435,436,1,0,0,0,436,438,1,0,0,0,437,435,1,0,0,0,438,449,5,
  	0,0,1,439,443,3,142,71,0,440,442,3,162,81,0,441,440,1,0,0,0,442,445,1,
  	0,0,0,443,441,1,0,0,0,443,444,1,0,0,0,444,446,1,0,0,0,445,443,1,0,0,0,
  	446,447,5,0,0,1,447,449,1,0,0,0,448,435,1,0,0,0,448,439,1,0,0,0,449,1,
  	1,0,0,0,450,477,3,162,81,0,451,453,3,142,71,0,452,451,1,0,0,0,452,453,
  	1,0,0,0,453,460,1,0,0,0,454,461,3,162,81,0,455,457,3,6,3,0,456,455,1,
  	0,0,0,457,458,1,0,0,0,458,456,1,0,0,0,458,459,1,0,0,0,459,461,1,0,0,0,
  	460,454,1,0,0,0,460,456,1,0,0,0,461,465,1,0,0,0,462,464,3,164,82,0,463,
  	462,1,0,0,0,464,467,1,0,0,0,465,463,1,0,0,0,465,466,1,0,0,0,466,477,1,
  	0,0,0,467,465,1,0,0,0,468,472,3,4,2,0,469,471,3,164,82,0,470,469,1,0,
  	0,0,471,474,1,0,0,0,472,470,1,0,0,0,472,473,1,0,0,0,473,477,1,0,0,0,474,
  	472,1,0,0,0,475,477,3,164,82,0,476,450,1,0,0,0,476,452,1,0,0,0,476,468,
  	1,0,0,0,476,475,1,0,0,0,477,3,1,0,0,0,478,481,3,100,50,0,479,481,3,98,
  	49,0,480,478,1,0,0,0,480,479,1,0,0,0,481,5,1,0,0,0,482,484,3,8,4,0,483,
  	485,5,427,0,0,484,483,1,0,0,0,484,485,1,0,0,0,485,508,1,0,0,0,486,488,
  	3,12,6,0,487,489,5,427,0,0,488,487,1,0,0,0,488,489,1,0,0,0,489,508,1,
  	0,0,0,490,492,3,46,23,0,491,493,5,427,0,0,492,491,1,0,0,0,492,493,1,0,
  	0,0,493,508,1,0,0,0,494,496,3,10,5,0,495,497,5,427,0,0,496,495,1,0,0,
  	0,496,497,1,0,0,0,497,508,1,0,0,0,498,500,3,170,85,0,499,501,5,427,0,
  	0,500,499,1,0,0,0,500,501,1,0,0,0,501,508,1,0,0,0,502,504,3,172,86,0,
  	503,505,5,427,0,0,504,503,1,0,0,0,504,505,1,0,0,0,505,508,1,0,0,0,506,
  	508,5,427,0,0,507,482,1,0,0,0,507,486,1,0,0,0,507,490,1,0,0,0,507,494,
  	1,0,0,0,507,498,1,0,0,0,507,502,1,0,0,0,507,506,1,0,0,0,508,7,1,0,0,0,
  	509,515,3,68,34,0,510,515,3,76,38,0,511,515,3,80,40,0,512,515,3,86,43,
  	0,513,515,3,92,46,0,514,509,1,0,0,0,514,510,1,0,0,0,514,511,1,0,0,0,514,
  	512,1,0,0,0,514,513,1,0,0,0,515,9,1,0,0,0,516,526,3,64,32,0,517,526,3,
  	118,59,0,518,526,3,66,33,0,519,526,3,114,57,0,520,526,3,126,63,0,521,
  	526,3,124,62,0,522,526,3,128,64,0,523,526,3,60,30,0,524,526,3,62,31,0,
  	525,516,1,0,0,0,525,517,1,0,0,0,525,518,1,0,0,0,525,519,1,0,0,0,525,520,
  	1,0,0,0,525,521,1,0,0,0,525,522,1,0,0,0,525,523,1,0,0,0,525,524,1,0,0,
  	0,526,11,1,0,0,0,527,540,3,14,7,0,528,540,3,16,8,0,529,540,3,18,9,0,530,
  	540,3,20,10,0,531,540,3,24,12,0,532,540,3,22,11,0,533,540,3,26,13,0,534,
  	540,3,34,17,0,535,540,3,36,18,0,536,540,3,38,19,0,537,540,3,40,20,0,538,
  	540,3,42,21,0,539,527,1,0,0,0,539,528,1,0,0,0,539,529,1,0,0,0,539,530,
  	1,0,0,0,539,531,1,0,0,0,539,532,1,0,0,0,539,533,1,0,0,0,539,534,1,0,0,
  	0,539,535,1,0,0,0,539,536,1,0,0,0,539,537,1,0,0,0,539,538,1,0,0,0,540,
  	13,1,0,0,0,541,543,5,39,0,0,542,544,5,427,0,0,543,542,1,0,0,0,543,544,
  	1,0,0,0,544,548,1,0,0,0,545,547,3,6,3,0,546,545,1,0,0,0,547,550,1,0,0,
  	0,548,546,1,0,0,0,548,549,1,0,0,0,549,551,1,0,0,0,550,548,1,0,0,0,551,
  	553,5,76,0,0,552,554,5,427,0,0,553,552,1,0,0,0,553,554,1,0,0,0,554,15,
  	1,0,0,0,555,557,5,41,0,0,556,558,5,427,0,0,557,556,1,0,0,0,557,558,1,
  	0,0,0,558,17,1,0,0,0,559,561,5,52,0,0,560,562,5,427,0,0,561,560,1,0,0,
  	0,561,562,1,0,0,0,562,19,1,0,0,0,563,564,5,87,0,0,564,566,3,422,211,0,
  	565,567,5,427,0,0,566,565,1,0,0,0,566,567,1,0,0,0,567,574,1,0,0,0,568,
  	569,3,422,211,0,569,571,5,428,0,0,570,572,5,427,0,0,571,570,1,0,0,0,571,
  	572,1,0,0,0,572,574,1,0,0,0,573,563,1,0,0,0,573,568,1,0,0,0,574,21,1,
  	0,0,0,575,577,5,131,0,0,576,578,3,210,105,0,577,576,1,0,0,0,577,578,1,
  	0,0,0,578,580,1,0,0,0,579,581,5,427,0,0,580,579,1,0,0,0,580,581,1,0,0,
  	0,581,23,1,0,0,0,582,583,5,93,0,0,583,584,3,234,117,0,584,587,3,6,3,0,
  	585,586,5,75,0,0,586,588,3,6,3,0,587,585,1,0,0,0,587,588,1,0,0,0,588,
  	590,1,0,0,0,589,591,5,427,0,0,590,589,1,0,0,0,590,591,1,0,0,0,591,25,
  	1,0,0,0,592,599,5,335,0,0,593,594,3,28,14,0,594,595,5,426,0,0,595,596,
  	3,30,15,0,596,597,5,426,0,0,597,598,3,32,16,0,598,600,1,0,0,0,599,593,
  	1,0,0,0,599,600,1,0,0,0,600,602,1,0,0,0,601,603,5,427,0,0,602,601,1,0,
  	0,0,602,603,1,0,0,0,603,27,1,0,0,0,604,605,7,0,0,0,605,29,1,0,0,0,606,
  	607,7,1,0,0,607,31,1,0,0,0,608,609,7,0,0,0,609,33,1,0,0,0,610,611,5,39,
  	0,0,611,613,5,342,0,0,612,614,5,427,0,0,613,612,1,0,0,0,613,614,1,0,0,
  	0,614,616,1,0,0,0,615,617,3,6,3,0,616,615,1,0,0,0,617,618,1,0,0,0,618,
  	616,1,0,0,0,618,619,1,0,0,0,619,620,1,0,0,0,620,621,5,76,0,0,621,623,
  	5,342,0,0,622,624,5,427,0,0,623,622,1,0,0,0,623,624,1,0,0,0,624,625,1,
  	0,0,0,625,626,5,39,0,0,626,628,5,187,0,0,627,629,5,427,0,0,628,627,1,
  	0,0,0,628,629,1,0,0,0,629,633,1,0,0,0,630,632,3,6,3,0,631,630,1,0,0,0,
  	632,635,1,0,0,0,633,631,1,0,0,0,633,634,1,0,0,0,634,636,1,0,0,0,635,633,
  	1,0,0,0,636,637,5,76,0,0,637,639,5,187,0,0,638,640,5,427,0,0,639,638,
  	1,0,0,0,639,640,1,0,0,0,640,35,1,0,0,0,641,643,5,355,0,0,642,644,3,84,
  	42,0,643,642,1,0,0,0,643,644,1,0,0,0,644,646,1,0,0,0,645,647,5,426,0,
  	0,646,645,1,0,0,0,646,647,1,0,0,0,647,650,1,0,0,0,648,649,7,2,0,0,649,
  	651,3,90,45,0,650,648,1,0,0,0,650,651,1,0,0,0,651,653,1,0,0,0,652,654,
  	3,210,105,0,653,652,1,0,0,0,653,654,1,0,0,0,654,656,1,0,0,0,655,657,5,
  	427,0,0,656,655,1,0,0,0,656,657,1,0,0,0,657,37,1,0,0,0,658,659,5,162,
  	0,0,659,669,3,234,117,0,660,670,3,6,3,0,661,663,5,41,0,0,662,664,5,427,
  	0,0,663,662,1,0,0,0,663,664,1,0,0,0,664,670,1,0,0,0,665,667,5,52,0,0,
  	666,668,5,427,0,0,667,666,1,0,0,0,667,668,1,0,0,0,668,670,1,0,0,0,669,
  	660,1,0,0,0,669,661,1,0,0,0,669,665,1,0,0,0,670,39,1,0,0,0,671,674,5,
  	124,0,0,672,675,3,210,105,0,673,675,5,396,0,0,674,672,1,0,0,0,674,673,
  	1,0,0,0,675,680,1,0,0,0,676,677,5,426,0,0,677,679,5,399,0,0,678,676,1,
  	0,0,0,679,682,1,0,0,0,680,678,1,0,0,0,680,681,1,0,0,0,681,684,1,0,0,0,
  	682,680,1,0,0,0,683,685,5,427,0,0,684,683,1,0,0,0,684,685,1,0,0,0,685,
  	41,1,0,0,0,686,687,5,127,0,0,687,688,5,424,0,0,688,689,7,3,0,0,689,690,
  	5,426,0,0,690,691,3,208,104,0,691,692,5,426,0,0,692,697,3,208,104,0,693,
  	694,5,426,0,0,694,696,3,208,104,0,695,693,1,0,0,0,696,699,1,0,0,0,697,
  	695,1,0,0,0,697,698,1,0,0,0,698,700,1,0,0,0,699,697,1,0,0,0,700,703,5,
  	425,0,0,701,702,5,163,0,0,702,704,7,4,0,0,703,701,1,0,0,0,703,704,1,0,
  	0,0,704,706,1,0,0,0,705,707,5,427,0,0,706,705,1,0,0,0,706,707,1,0,0,0,
  	707,719,1,0,0,0,708,709,5,127,0,0,709,710,5,400,0,0,710,715,7,5,0,0,711,
  	712,5,426,0,0,712,714,7,3,0,0,713,711,1,0,0,0,714,717,1,0,0,0,715,713,
  	1,0,0,0,715,716,1,0,0,0,716,719,1,0,0,0,717,715,1,0,0,0,718,686,1,0,0,
  	0,718,708,1,0,0,0,719,43,1,0,0,0,720,721,5,427,0,0,721,45,1,0,0,0,722,
  	731,3,130,65,0,723,731,3,140,70,0,724,731,3,132,66,0,725,731,3,134,67,
  	0,726,731,3,158,79,0,727,731,3,160,80,0,728,731,3,166,83,0,729,731,3,
  	168,84,0,730,722,1,0,0,0,730,723,1,0,0,0,730,724,1,0,0,0,730,725,1,0,
  	0,0,730,726,1,0,0,0,730,727,1,0,0,0,730,728,1,0,0,0,730,729,1,0,0,0,731,
  	47,1,0,0,0,732,733,5,147,0,0,733,49,1,0,0,0,734,735,5,429,0,0,735,51,
  	1,0,0,0,736,737,7,6,0,0,737,53,1,0,0,0,738,739,7,6,0,0,739,55,1,0,0,0,
  	740,741,7,7,0,0,741,57,1,0,0,0,742,743,7,8,0,0,743,59,1,0,0,0,744,745,
  	5,253,0,0,745,746,5,145,0,0,746,747,3,380,190,0,747,748,5,94,0,0,748,
  	749,7,9,0,0,749,753,5,265,0,0,750,751,5,354,0,0,751,754,5,400,0,0,752,
  	754,5,271,0,0,753,750,1,0,0,0,753,752,1,0,0,0,753,754,1,0,0,0,754,756,
  	1,0,0,0,755,757,5,427,0,0,756,755,1,0,0,0,756,757,1,0,0,0,757,61,1,0,
  	0,0,758,759,5,151,0,0,759,760,5,145,0,0,760,780,3,380,190,0,761,762,5,
  	163,0,0,762,763,5,424,0,0,763,764,5,286,0,0,764,774,5,424,0,0,765,767,
  	5,426,0,0,766,765,1,0,0,0,766,767,1,0,0,0,767,772,1,0,0,0,768,773,5,400,
  	0,0,769,770,5,400,0,0,770,771,5,147,0,0,771,773,5,400,0,0,772,768,1,0,
  	0,0,772,769,1,0,0,0,773,775,1,0,0,0,774,766,1,0,0,0,775,776,1,0,0,0,776,
  	774,1,0,0,0,776,777,1,0,0,0,777,778,1,0,0,0,778,779,5,425,0,0,779,781,
  	5,425,0,0,780,761,1,0,0,0,780,781,1,0,0,0,781,63,1,0,0,0,782,783,5,32,
  	0,0,783,787,5,317,0,0,784,785,3,422,211,0,785,786,5,419,0,0,786,788,1,
  	0,0,0,787,784,1,0,0,0,787,788,1,0,0,0,788,789,1,0,0,0,789,795,3,422,211,
  	0,790,793,5,382,0,0,791,792,5,163,0,0,792,794,5,400,0,0,793,791,1,0,0,
  	0,793,794,1,0,0,0,794,796,1,0,0,0,795,790,1,0,0,0,795,796,1,0,0,0,796,
  	800,1,0,0,0,797,798,5,373,0,0,798,799,5,42,0,0,799,801,5,400,0,0,800,
  	797,1,0,0,0,800,801,1,0,0,0,801,806,1,0,0,0,802,803,5,378,0,0,803,807,
  	5,400,0,0,804,805,5,267,0,0,805,807,5,378,0,0,806,802,1,0,0,0,806,804,
  	1,0,0,0,806,807,1,0,0,0,807,812,1,0,0,0,808,809,5,377,0,0,809,813,5,400,
  	0,0,810,811,5,267,0,0,811,813,5,377,0,0,812,808,1,0,0,0,812,810,1,0,0,
  	0,812,813,1,0,0,0,813,817,1,0,0,0,814,818,5,366,0,0,815,816,5,267,0,0,
  	816,818,5,366,0,0,817,814,1,0,0,0,817,815,1,0,0,0,817,818,1,0,0,0,818,
  	823,1,0,0,0,819,820,5,360,0,0,820,824,5,400,0,0,821,822,5,267,0,0,822,
  	824,5,360,0,0,823,819,1,0,0,0,823,821,1,0,0,0,823,824,1,0,0,0,824,65,
  	1,0,0,0,825,826,5,54,0,0,826,830,5,317,0,0,827,828,3,422,211,0,828,829,
  	5,419,0,0,829,831,1,0,0,0,830,827,1,0,0,0,830,831,1,0,0,0,831,832,1,0,
  	0,0,832,835,3,422,211,0,833,834,5,35,0,0,834,836,3,412,206,0,835,833,
  	1,0,0,0,835,836,1,0,0,0,836,840,1,0,0,0,837,838,5,388,0,0,838,839,5,163,
  	0,0,839,841,5,400,0,0,840,837,1,0,0,0,840,841,1,0,0,0,841,848,1,0,0,0,
  	842,843,5,373,0,0,843,845,5,42,0,0,844,846,5,434,0,0,845,844,1,0,0,0,
  	845,846,1,0,0,0,846,847,1,0,0,0,847,849,5,400,0,0,848,842,1,0,0,0,848,
  	849,1,0,0,0,849,856,1,0,0,0,850,852,5,378,0,0,851,853,5,400,0,0,852,851,
  	1,0,0,0,852,853,1,0,0,0,853,857,1,0,0,0,854,855,5,267,0,0,855,857,5,378,
  	0,0,856,850,1,0,0,0,856,854,1,0,0,0,856,857,1,0,0,0,857,864,1,0,0,0,858,
  	860,5,377,0,0,859,861,5,400,0,0,860,859,1,0,0,0,860,861,1,0,0,0,861,865,
  	1,0,0,0,862,863,5,267,0,0,863,865,5,377,0,0,864,858,1,0,0,0,864,862,1,
  	0,0,0,864,865,1,0,0,0,865,869,1,0,0,0,866,870,5,366,0,0,867,868,5,267,
  	0,0,868,870,5,366,0,0,869,866,1,0,0,0,869,867,1,0,0,0,869,870,1,0,0,0,
  	870,877,1,0,0,0,871,873,5,360,0,0,872,874,5,400,0,0,873,872,1,0,0,0,873,
  	874,1,0,0,0,874,878,1,0,0,0,875,876,5,267,0,0,876,878,5,360,0,0,877,871,
  	1,0,0,0,877,875,1,0,0,0,877,878,1,0,0,0,878,67,1,0,0,0,879,881,3,226,
  	113,0,880,879,1,0,0,0,880,881,1,0,0,0,881,882,1,0,0,0,882,890,5,106,0,
  	0,883,884,5,148,0,0,884,885,5,424,0,0,885,886,3,210,105,0,886,888,5,425,
  	0,0,887,889,5,119,0,0,888,887,1,0,0,0,888,889,1,0,0,0,889,891,1,0,0,0,
  	890,883,1,0,0,0,890,891,1,0,0,0,891,893,1,0,0,0,892,894,5,99,0,0,893,
  	892,1,0,0,0,893,894,1,0,0,0,894,895,1,0,0,0,895,897,3,390,195,0,896,898,
  	3,338,169,0,897,896,1,0,0,0,897,898,1,0,0,0,898,900,1,0,0,0,899,901,3,
  	332,166,0,900,899,1,0,0,0,900,901,1,0,0,0,901,902,1,0,0,0,902,903,5,350,
  	0,0,903,904,3,276,138,0,904,905,5,112,0,0,905,907,3,234,117,0,906,908,
  	3,70,35,0,907,906,1,0,0,0,908,909,1,0,0,0,909,907,1,0,0,0,909,910,1,0,
  	0,0,910,912,1,0,0,0,911,913,3,94,47,0,912,911,1,0,0,0,912,913,1,0,0,0,
  	913,915,1,0,0,0,914,916,3,256,128,0,915,914,1,0,0,0,915,916,1,0,0,0,916,
  	917,1,0,0,0,917,918,5,427,0,0,918,69,1,0,0,0,919,920,5,160,0,0,920,923,
  	5,376,0,0,921,922,5,33,0,0,922,924,3,234,117,0,923,921,1,0,0,0,923,924,
  	1,0,0,0,924,925,1,0,0,0,925,926,5,146,0,0,926,928,3,72,36,0,927,919,1,
  	0,0,0,928,929,1,0,0,0,929,927,1,0,0,0,929,930,1,0,0,0,930,960,1,0,0,0,
  	931,932,5,160,0,0,932,933,5,107,0,0,933,936,5,376,0,0,934,935,5,42,0,
  	0,935,937,5,389,0,0,936,934,1,0,0,0,936,937,1,0,0,0,937,940,1,0,0,0,938,
  	939,5,33,0,0,939,941,3,234,117,0,940,938,1,0,0,0,940,941,1,0,0,0,941,
  	942,1,0,0,0,942,943,5,146,0,0,943,960,3,74,37,0,944,945,5,160,0,0,945,
  	946,5,107,0,0,946,947,5,376,0,0,947,948,5,42,0,0,948,951,5,385,0,0,949,
  	950,5,33,0,0,950,952,3,234,117,0,951,949,1,0,0,0,951,952,1,0,0,0,952,
  	953,1,0,0,0,953,954,5,146,0,0,954,956,3,72,36,0,955,944,1,0,0,0,956,957,
  	1,0,0,0,957,955,1,0,0,0,957,958,1,0,0,0,958,960,1,0,0,0,959,927,1,0,0,
  	0,959,931,1,0,0,0,959,955,1,0,0,0,960,71,1,0,0,0,961,962,5,155,0,0,962,
  	963,5,141,0,0,963,968,3,232,116,0,964,965,5,426,0,0,965,967,3,232,116,
  	0,966,964,1,0,0,0,967,970,1,0,0,0,968,966,1,0,0,0,968,969,1,0,0,0,969,
  	973,1,0,0,0,970,968,1,0,0,0,971,973,5,67,0,0,972,961,1,0,0,0,972,971,
  	1,0,0,0,973,73,1,0,0,0,974,979,5,97,0,0,975,976,5,424,0,0,976,977,3,400,
  	200,0,977,978,5,425,0,0,978,980,1,0,0,0,979,975,1,0,0,0,979,980,1,0,0,
  	0,980,984,1,0,0,0,981,985,3,348,174,0,982,983,5,66,0,0,983,985,5,158,
  	0,0,984,981,1,0,0,0,984,982,1,0,0,0,985,75,1,0,0,0,986,988,3,226,113,
  	0,987,986,1,0,0,0,987,988,1,0,0,0,988,989,1,0,0,0,989,999,5,67,0,0,990,
  	991,5,148,0,0,991,992,5,424,0,0,992,993,3,210,105,0,993,995,5,425,0,0,
  	994,996,5,119,0,0,995,994,1,0,0,0,995,996,1,0,0,0,996,1000,1,0,0,0,997,
  	998,5,148,0,0,998,1000,5,400,0,0,999,990,1,0,0,0,999,997,1,0,0,0,999,
  	1000,1,0,0,0,1000,1002,1,0,0,0,1001,1003,5,84,0,0,1002,1001,1,0,0,0,1002,
  	1003,1,0,0,0,1003,1004,1,0,0,0,1004,1006,3,78,39,0,1005,1007,3,338,169,
  	0,1006,1005,1,0,0,0,1006,1007,1,0,0,0,1007,1009,1,0,0,0,1008,1010,3,94,
  	47,0,1009,1008,1,0,0,0,1009,1010,1,0,0,0,1010,1013,1,0,0,0,1011,1012,
  	5,84,0,0,1012,1014,3,276,138,0,1013,1011,1,0,0,0,1013,1014,1,0,0,0,1014,
  	1028,1,0,0,0,1015,1026,5,161,0,0,1016,1027,3,234,117,0,1017,1018,5,56,
  	0,0,1018,1024,5,110,0,0,1019,1021,5,228,0,0,1020,1019,1,0,0,0,1020,1021,
  	1,0,0,0,1021,1022,1,0,0,0,1022,1025,3,402,201,0,1023,1025,5,399,0,0,1024,
  	1020,1,0,0,0,1024,1023,1,0,0,0,1025,1027,1,0,0,0,1026,1016,1,0,0,0,1026,
  	1017,1,0,0,0,1027,1029,1,0,0,0,1028,1015,1,0,0,0,1028,1029,1,0,0,0,1029,
  	1031,1,0,0,0,1030,1032,3,256,128,0,1031,1030,1,0,0,0,1031,1032,1,0,0,
  	0,1032,1034,1,0,0,0,1033,1035,5,427,0,0,1034,1033,1,0,0,0,1034,1035,1,
  	0,0,0,1035,77,1,0,0,0,1036,1040,3,390,195,0,1037,1040,3,334,167,0,1038,
  	1040,5,399,0,0,1039,1036,1,0,0,0,1039,1037,1,0,0,0,1039,1038,1,0,0,0,
  	1040,79,1,0,0,0,1041,1043,3,226,113,0,1042,1041,1,0,0,0,1042,1043,1,0,
  	0,0,1043,1044,1,0,0,0,1044,1052,5,97,0,0,1045,1046,5,148,0,0,1046,1047,
  	5,424,0,0,1047,1048,3,210,105,0,1048,1050,5,425,0,0,1049,1051,5,119,0,
  	0,1050,1049,1,0,0,0,1050,1051,1,0,0,0,1051,1053,1,0,0,0,1052,1045,1,0,
  	0,0,1052,1053,1,0,0,0,1053,1055,1,0,0,0,1054,1056,5,99,0,0,1055,1054,
  	1,0,0,0,1055,1056,1,0,0,0,1056,1057,1,0,0,0,1057,1059,3,390,195,0,1058,
  	1060,3,338,169,0,1059,1058,1,0,0,0,1059,1060,1,0,0,0,1060,1065,1,0,0,
  	0,1061,1062,5,424,0,0,1062,1063,3,396,198,0,1063,1064,5,425,0,0,1064,
  	1066,1,0,0,0,1065,1061,1,0,0,0,1065,1066,1,0,0,0,1066,1068,1,0,0,0,1067,
  	1069,3,94,47,0,1068,1067,1,0,0,0,1068,1069,1,0,0,0,1069,1070,1,0,0,0,
  	1070,1071,3,82,41,0,1071,81,1,0,0,0,1072,1078,3,348,174,0,1073,1078,3,
  	316,158,0,1074,1078,3,140,70,0,1075,1076,5,66,0,0,1076,1078,5,158,0,0,
  	1077,1072,1,0,0,0,1077,1073,1,0,0,0,1077,1074,1,0,0,0,1077,1075,1,0,0,
  	0,1078,83,1,0,0,0,1079,1081,5,424,0,0,1080,1079,1,0,0,0,1080,1081,1,0,
  	0,0,1081,1082,1,0,0,0,1082,1087,5,439,0,0,1083,1088,5,31,0,0,1084,1088,
  	5,69,0,0,1085,1088,3,244,122,0,1086,1088,5,430,0,0,1087,1083,1,0,0,0,
  	1087,1084,1,0,0,0,1087,1085,1,0,0,0,1087,1086,1,0,0,0,1088,1097,1,0,0,
  	0,1089,1090,5,399,0,0,1090,1091,5,406,0,0,1091,1093,3,210,105,0,1092,
  	1094,5,426,0,0,1093,1092,1,0,0,0,1093,1094,1,0,0,0,1094,1096,1,0,0,0,
  	1095,1089,1,0,0,0,1096,1099,1,0,0,0,1097,1095,1,0,0,0,1097,1098,1,0,0,
  	0,1098,1100,1,0,0,0,1099,1097,1,0,0,0,1100,1101,5,84,0,0,1101,1107,3,
  	378,189,0,1102,1103,5,99,0,0,1103,1104,3,422,211,0,1104,1105,5,161,0,
  	0,1105,1106,3,234,117,0,1106,1108,1,0,0,0,1107,1102,1,0,0,0,1107,1108,
  	1,0,0,0,1108,1110,1,0,0,0,1109,1111,5,425,0,0,1110,1109,1,0,0,0,1110,
  	1111,1,0,0,0,1111,85,1,0,0,0,1112,1114,3,226,113,0,1113,1112,1,0,0,0,
  	1113,1114,1,0,0,0,1114,1115,1,0,0,0,1115,1116,3,88,44,0,1116,87,1,0,0,
  	0,1117,1119,3,238,119,0,1118,1120,3,250,125,0,1119,1118,1,0,0,0,1119,
  	1120,1,0,0,0,1120,1122,1,0,0,0,1121,1123,3,256,128,0,1122,1121,1,0,0,
  	0,1122,1123,1,0,0,0,1123,1125,1,0,0,0,1124,1126,5,427,0,0,1125,1124,1,
  	0,0,0,1125,1126,1,0,0,0,1126,89,1,0,0,0,1127,1130,5,399,0,0,1128,1130,
  	3,416,208,0,1129,1127,1,0,0,0,1129,1128,1,0,0,0,1130,91,1,0,0,0,1131,
  	1133,3,226,113,0,1132,1131,1,0,0,0,1132,1133,1,0,0,0,1133,1134,1,0,0,
  	0,1134,1142,5,155,0,0,1135,1136,5,148,0,0,1136,1137,5,424,0,0,1137,1138,
  	3,210,105,0,1138,1140,5,425,0,0,1139,1141,5,119,0,0,1140,1139,1,0,0,0,
  	1140,1141,1,0,0,0,1141,1143,1,0,0,0,1142,1135,1,0,0,0,1142,1143,1,0,0,
  	0,1143,1144,1,0,0,0,1144,1146,3,390,195,0,1145,1147,3,336,168,0,1146,
  	1145,1,0,0,0,1146,1147,1,0,0,0,1147,1148,1,0,0,0,1148,1149,5,141,0,0,
  	1149,1154,3,230,115,0,1150,1151,5,426,0,0,1151,1153,3,230,115,0,1152,
  	1150,1,0,0,0,1153,1156,1,0,0,0,1154,1152,1,0,0,0,1154,1155,1,0,0,0,1155,
  	1158,1,0,0,0,1156,1154,1,0,0,0,1157,1159,3,94,47,0,1158,1157,1,0,0,0,
  	1158,1159,1,0,0,0,1159,1162,1,0,0,0,1160,1161,5,84,0,0,1161,1163,3,276,
  	138,0,1162,1160,1,0,0,0,1162,1163,1,0,0,0,1163,1177,1,0,0,0,1164,1175,
  	5,161,0,0,1165,1176,3,234,117,0,1166,1167,5,56,0,0,1167,1173,5,110,0,
  	0,1168,1170,5,228,0,0,1169,1168,1,0,0,0,1169,1170,1,0,0,0,1170,1171,1,
  	0,0,0,1171,1174,3,402,201,0,1172,1174,5,399,0,0,1173,1169,1,0,0,0,1173,
  	1172,1,0,0,0,1174,1176,1,0,0,0,1175,1165,1,0,0,0,1175,1166,1,0,0,0,1176,
  	1178,1,0,0,0,1177,1164,1,0,0,0,1177,1178,1,0,0,0,1178,1180,1,0,0,0,1179,
  	1181,3,256,128,0,1180,1179,1,0,0,0,1180,1181,1,0,0,0,1181,1183,1,0,0,
  	0,1182,1184,5,427,0,0,1183,1182,1,0,0,0,1183,1184,1,0,0,0,1184,93,1,0,
  	0,0,1185,1186,5,282,0,0,1186,1191,3,96,48,0,1187,1188,5,426,0,0,1188,
  	1190,3,96,48,0,1189,1187,1,0,0,0,1190,1193,1,0,0,0,1191,1189,1,0,0,0,
  	1191,1192,1,0,0,0,1192,1205,1,0,0,0,1193,1191,1,0,0,0,1194,1197,5,99,
  	0,0,1195,1198,5,399,0,0,1196,1198,3,380,190,0,1197,1195,1,0,0,0,1197,
  	1196,1,0,0,0,1198,1203,1,0,0,0,1199,1200,5,424,0,0,1200,1201,3,400,200,
  	0,1201,1202,5,425,0,0,1202,1204,1,0,0,0,1203,1199,1,0,0,0,1203,1204,1,
  	0,0,0,1204,1206,1,0,0,0,1205,1194,1,0,0,0,1205,1206,1,0,0,0,1206,95,1,
  	0,0,0,1207,1210,3,210,105,0,1208,1210,3,266,133,0,1209,1207,1,0,0,0,1209,
  	1208,1,0,0,0,1210,1212,1,0,0,0,1211,1213,3,330,165,0,1212,1211,1,0,0,
  	0,1212,1213,1,0,0,0,1213,97,1,0,0,0,1214,1217,5,54,0,0,1215,1216,5,115,
  	0,0,1216,1218,5,32,0,0,1217,1215,1,0,0,0,1217,1218,1,0,0,0,1218,1221,
  	1,0,0,0,1219,1221,5,32,0,0,1220,1214,1,0,0,0,1220,1219,1,0,0,0,1221,1222,
  	1,0,0,0,1222,1223,7,10,0,0,1223,1226,3,384,192,0,1224,1225,5,427,0,0,
  	1225,1227,5,400,0,0,1226,1224,1,0,0,0,1226,1227,1,0,0,0,1227,1242,1,0,
  	0,0,1228,1230,5,424,0,0,1229,1228,1,0,0,0,1229,1230,1,0,0,0,1230,1231,
  	1,0,0,0,1231,1236,3,108,54,0,1232,1233,5,426,0,0,1233,1235,3,108,54,0,
  	1234,1232,1,0,0,0,1235,1238,1,0,0,0,1236,1234,1,0,0,0,1236,1237,1,0,0,
  	0,1237,1240,1,0,0,0,1238,1236,1,0,0,0,1239,1241,5,425,0,0,1240,1239,1,
  	0,0,0,1240,1241,1,0,0,0,1241,1243,1,0,0,0,1242,1229,1,0,0,0,1242,1243,
  	1,0,0,0,1243,1253,1,0,0,0,1244,1245,5,163,0,0,1245,1250,3,110,55,0,1246,
  	1247,5,426,0,0,1247,1249,3,110,55,0,1248,1246,1,0,0,0,1249,1252,1,0,0,
  	0,1250,1248,1,0,0,0,1250,1251,1,0,0,0,1251,1254,1,0,0,0,1252,1250,1,0,
  	0,0,1253,1244,1,0,0,0,1253,1254,1,0,0,0,1254,1257,1,0,0,0,1255,1256,5,
  	82,0,0,1256,1258,5,130,0,0,1257,1255,1,0,0,0,1257,1258,1,0,0,0,1258,1259,
  	1,0,0,0,1259,1263,5,35,0,0,1260,1262,3,6,3,0,1261,1260,1,0,0,0,1262,1265,
  	1,0,0,0,1263,1261,1,0,0,0,1263,1264,1,0,0,0,1264,99,1,0,0,0,1265,1263,
  	1,0,0,0,1266,1269,5,54,0,0,1267,1268,5,115,0,0,1268,1270,5,32,0,0,1269,
  	1267,1,0,0,0,1269,1270,1,0,0,0,1270,1273,1,0,0,0,1271,1273,5,32,0,0,1272,
  	1266,1,0,0,0,1272,1271,1,0,0,0,1273,1274,1,0,0,0,1274,1275,5,86,0,0,1275,
  	1289,3,384,192,0,1276,1277,5,424,0,0,1277,1282,3,108,54,0,1278,1279,5,
  	426,0,0,1279,1281,3,108,54,0,1280,1278,1,0,0,0,1281,1284,1,0,0,0,1282,
  	1280,1,0,0,0,1282,1283,1,0,0,0,1283,1285,1,0,0,0,1284,1282,1,0,0,0,1285,
  	1286,5,425,0,0,1286,1290,1,0,0,0,1287,1288,5,424,0,0,1288,1290,5,425,
  	0,0,1289,1276,1,0,0,0,1289,1287,1,0,0,0,1290,1294,1,0,0,0,1291,1295,3,
  	102,51,0,1292,1295,3,104,52,0,1293,1295,3,106,53,0,1294,1291,1,0,0,0,
  	1294,1292,1,0,0,0,1294,1293,1,0,0,0,1295,1297,1,0,0,0,1296,1298,5,427,
  	0,0,1297,1296,1,0,0,0,1297,1298,1,0,0,0,1298,101,1,0,0,0,1299,1300,5,
  	383,0,0,1300,1310,5,145,0,0,1301,1302,5,163,0,0,1302,1307,3,112,56,0,
  	1303,1304,5,426,0,0,1304,1306,3,112,56,0,1305,1303,1,0,0,0,1306,1309,
  	1,0,0,0,1307,1305,1,0,0,0,1307,1308,1,0,0,0,1308,1311,1,0,0,0,1309,1307,
  	1,0,0,0,1310,1301,1,0,0,0,1310,1311,1,0,0,0,1311,1313,1,0,0,0,1312,1314,
  	5,35,0,0,1313,1312,1,0,0,0,1313,1314,1,0,0,0,1314,1315,1,0,0,0,1315,1321,
  	5,131,0,0,1316,1317,5,424,0,0,1317,1318,3,86,43,0,1318,1319,5,425,0,0,
  	1319,1322,1,0,0,0,1320,1322,3,86,43,0,1321,1316,1,0,0,0,1321,1320,1,0,
  	0,0,1322,103,1,0,0,0,1323,1324,5,383,0,0,1324,1325,5,399,0,0,1325,1335,
  	3,182,91,0,1326,1327,5,163,0,0,1327,1332,3,112,56,0,1328,1329,5,426,0,
  	0,1329,1331,3,112,56,0,1330,1328,1,0,0,0,1331,1334,1,0,0,0,1332,1330,
  	1,0,0,0,1332,1333,1,0,0,0,1333,1336,1,0,0,0,1334,1332,1,0,0,0,1335,1326,
  	1,0,0,0,1335,1336,1,0,0,0,1336,1338,1,0,0,0,1337,1339,5,35,0,0,1338,1337,
  	1,0,0,0,1338,1339,1,0,0,0,1339,1340,1,0,0,0,1340,1344,5,39,0,0,1341,1343,
  	3,6,3,0,1342,1341,1,0,0,0,1343,1346,1,0,0,0,1344,1342,1,0,0,0,1344,1345,
  	1,0,0,0,1345,1347,1,0,0,0,1346,1344,1,0,0,0,1347,1349,5,131,0,0,1348,
  	1350,5,427,0,0,1349,1348,1,0,0,0,1349,1350,1,0,0,0,1350,1351,1,0,0,0,
  	1351,1353,5,76,0,0,1352,1354,5,427,0,0,1353,1352,1,0,0,0,1353,1354,1,
  	0,0,0,1354,105,1,0,0,0,1355,1356,5,383,0,0,1356,1366,3,412,206,0,1357,
  	1358,5,163,0,0,1358,1363,3,112,56,0,1359,1360,5,426,0,0,1360,1362,3,112,
  	56,0,1361,1359,1,0,0,0,1362,1365,1,0,0,0,1363,1361,1,0,0,0,1363,1364,
  	1,0,0,0,1364,1367,1,0,0,0,1365,1363,1,0,0,0,1366,1357,1,0,0,0,1366,1367,
  	1,0,0,0,1367,1369,1,0,0,0,1368,1370,5,35,0,0,1369,1368,1,0,0,0,1369,1370,
  	1,0,0,0,1370,1371,1,0,0,0,1371,1375,5,39,0,0,1372,1374,3,6,3,0,1373,1372,
  	1,0,0,0,1374,1377,1,0,0,0,1375,1373,1,0,0,0,1375,1376,1,0,0,0,1376,1378,
  	1,0,0,0,1377,1375,1,0,0,0,1378,1379,5,131,0,0,1379,1381,3,210,105,0,1380,
  	1382,5,427,0,0,1381,1380,1,0,0,0,1381,1382,1,0,0,0,1382,1383,1,0,0,0,
  	1383,1384,5,76,0,0,1384,107,1,0,0,0,1385,1387,5,399,0,0,1386,1388,5,35,
  	0,0,1387,1386,1,0,0,0,1387,1388,1,0,0,0,1388,1392,1,0,0,0,1389,1390,3,
  	422,211,0,1390,1391,5,419,0,0,1391,1393,1,0,0,0,1392,1389,1,0,0,0,1392,
  	1393,1,0,0,0,1393,1394,1,0,0,0,1394,1396,3,412,206,0,1395,1397,5,159,
  	0,0,1396,1395,1,0,0,0,1396,1397,1,0,0,0,1397,1400,1,0,0,0,1398,1399,5,
  	406,0,0,1399,1401,3,414,207,0,1400,1398,1,0,0,0,1400,1401,1,0,0,0,1401,
  	1403,1,0,0,0,1402,1404,7,11,0,0,1403,1402,1,0,0,0,1403,1404,1,0,0,0,1404,
  	109,1,0,0,0,1405,1409,5,216,0,0,1406,1409,5,302,0,0,1407,1409,3,178,89,
  	0,1408,1405,1,0,0,0,1408,1406,1,0,0,0,1408,1407,1,0,0,0,1409,111,1,0,
  	0,0,1410,1423,5,216,0,0,1411,1423,5,311,0,0,1412,1413,5,383,0,0,1413,
  	1414,5,108,0,0,1414,1415,5,112,0,0,1415,1416,5,108,0,0,1416,1423,5,238,
  	0,0,1417,1418,5,361,0,0,1418,1419,5,112,0,0,1419,1420,5,108,0,0,1420,
  	1423,5,238,0,0,1421,1423,3,178,89,0,1422,1410,1,0,0,0,1422,1411,1,0,0,
  	0,1422,1412,1,0,0,0,1422,1417,1,0,0,0,1422,1421,1,0,0,0,1423,113,1,0,
  	0,0,1424,1425,5,54,0,0,1425,1426,5,145,0,0,1426,1427,3,380,190,0,1427,
  	1428,5,424,0,0,1428,1430,3,184,92,0,1429,1431,5,426,0,0,1430,1429,1,0,
  	0,0,1430,1431,1,0,0,0,1431,1432,1,0,0,0,1432,1435,5,425,0,0,1433,1434,
  	5,253,0,0,1434,1436,3,424,212,0,1435,1433,1,0,0,0,1435,1436,1,0,0,0,1436,
  	1440,1,0,0,0,1437,1439,3,116,58,0,1438,1437,1,0,0,0,1439,1442,1,0,0,0,
  	1440,1438,1,0,0,0,1440,1441,1,0,0,0,1441,1446,1,0,0,0,1442,1440,1,0,0,
  	0,1443,1444,5,112,0,0,1444,1447,3,422,211,0,1445,1447,5,66,0,0,1446,1443,
  	1,0,0,0,1446,1445,1,0,0,0,1446,1447,1,0,0,0,1447,1451,1,0,0,0,1448,1449,
  	5,334,0,0,1449,1452,3,422,211,0,1450,1452,5,66,0,0,1451,1448,1,0,0,0,
  	1451,1450,1,0,0,0,1451,1452,1,0,0,0,1452,1454,1,0,0,0,1453,1455,5,427,
  	0,0,1454,1453,1,0,0,0,1454,1455,1,0,0,0,1455,115,1,0,0,0,1456,1476,5,
  	163,0,0,1457,1458,5,424,0,0,1458,1463,3,196,98,0,1459,1460,5,426,0,0,
  	1460,1462,3,196,98,0,1461,1459,1,0,0,0,1462,1465,1,0,0,0,1463,1461,1,
  	0,0,0,1463,1464,1,0,0,0,1464,1466,1,0,0,0,1465,1463,1,0,0,0,1466,1467,
  	5,425,0,0,1467,1477,1,0,0,0,1468,1473,3,196,98,0,1469,1470,5,426,0,0,
  	1470,1472,3,196,98,0,1471,1469,1,0,0,0,1472,1475,1,0,0,0,1473,1471,1,
  	0,0,0,1473,1474,1,0,0,0,1474,1477,1,0,0,0,1475,1473,1,0,0,0,1476,1457,
  	1,0,0,0,1476,1468,1,0,0,0,1477,117,1,0,0,0,1478,1479,5,32,0,0,1479,1480,
  	5,145,0,0,1480,1526,3,380,190,0,1481,1482,5,141,0,0,1482,1483,5,424,0,
  	0,1483,1484,5,254,0,0,1484,1485,5,406,0,0,1485,1486,7,12,0,0,1486,1527,
  	5,425,0,0,1487,1488,5,30,0,0,1488,1527,3,184,92,0,1489,1490,5,32,0,0,
  	1490,1491,5,48,0,0,1491,1527,3,188,94,0,1492,1493,5,74,0,0,1493,1494,
  	5,48,0,0,1494,1499,3,422,211,0,1495,1496,5,426,0,0,1496,1498,3,422,211,
  	0,1497,1495,1,0,0,0,1498,1501,1,0,0,0,1499,1497,1,0,0,0,1499,1500,1,0,
  	0,0,1500,1527,1,0,0,0,1501,1499,1,0,0,0,1502,1503,5,74,0,0,1503,1504,
  	5,51,0,0,1504,1527,3,422,211,0,1505,1506,5,163,0,0,1506,1507,5,44,0,0,
  	1507,1508,5,30,0,0,1508,1509,5,51,0,0,1509,1510,3,422,211,0,1510,1511,
  	5,83,0,0,1511,1512,5,102,0,0,1512,1513,5,424,0,0,1513,1514,3,400,200,
  	0,1514,1515,5,425,0,0,1515,1516,5,129,0,0,1516,1517,3,380,190,0,1517,
  	1518,5,424,0,0,1518,1519,3,400,200,0,1519,1520,5,425,0,0,1520,1527,1,
  	0,0,0,1521,1522,5,44,0,0,1522,1523,5,51,0,0,1523,1527,3,422,211,0,1524,
  	1525,5,301,0,0,1525,1527,3,116,58,0,1526,1481,1,0,0,0,1526,1487,1,0,0,
  	0,1526,1489,1,0,0,0,1526,1492,1,0,0,0,1526,1502,1,0,0,0,1526,1505,1,0,
  	0,0,1526,1521,1,0,0,0,1526,1524,1,0,0,0,1527,1529,1,0,0,0,1528,1530,5,
  	427,0,0,1529,1528,1,0,0,0,1529,1530,1,0,0,0,1530,119,1,0,0,0,1531,1532,
  	3,122,61,0,1532,121,1,0,0,0,1533,1534,5,196,0,0,1534,1538,3,404,202,0,
  	1535,1536,5,197,0,0,1536,1538,7,13,0,0,1537,1533,1,0,0,0,1537,1535,1,
  	0,0,0,1538,123,1,0,0,0,1539,1540,5,74,0,0,1540,1543,7,10,0,0,1541,1542,
  	5,93,0,0,1542,1544,5,80,0,0,1543,1541,1,0,0,0,1543,1544,1,0,0,0,1544,
  	1545,1,0,0,0,1545,1550,3,384,192,0,1546,1547,5,426,0,0,1547,1549,3,384,
  	192,0,1548,1546,1,0,0,0,1549,1552,1,0,0,0,1550,1548,1,0,0,0,1550,1551,
  	1,0,0,0,1551,1554,1,0,0,0,1552,1550,1,0,0,0,1553,1555,5,427,0,0,1554,
  	1553,1,0,0,0,1554,1555,1,0,0,0,1555,125,1,0,0,0,1556,1557,5,74,0,0,1557,
  	1560,5,86,0,0,1558,1559,5,93,0,0,1559,1561,5,80,0,0,1560,1558,1,0,0,0,
  	1560,1561,1,0,0,0,1561,1562,1,0,0,0,1562,1567,3,384,192,0,1563,1564,5,
  	426,0,0,1564,1566,3,384,192,0,1565,1563,1,0,0,0,1566,1569,1,0,0,0,1567,
  	1565,1,0,0,0,1567,1568,1,0,0,0,1568,1571,1,0,0,0,1569,1567,1,0,0,0,1570,
  	1572,5,427,0,0,1571,1570,1,0,0,0,1571,1572,1,0,0,0,1572,127,1,0,0,0,1573,
  	1574,5,74,0,0,1574,1577,5,145,0,0,1575,1576,5,93,0,0,1576,1578,5,80,0,
  	0,1577,1575,1,0,0,0,1577,1578,1,0,0,0,1578,1579,1,0,0,0,1579,1581,3,380,
  	190,0,1580,1582,5,427,0,0,1581,1580,1,0,0,0,1581,1582,1,0,0,0,1582,129,
  	1,0,0,0,1583,1584,5,65,0,0,1584,1586,5,399,0,0,1585,1587,5,35,0,0,1586,
  	1585,1,0,0,0,1586,1587,1,0,0,0,1587,1588,1,0,0,0,1588,1590,3,182,91,0,
  	1589,1591,5,427,0,0,1590,1589,1,0,0,0,1590,1591,1,0,0,0,1591,1605,1,0,
  	0,0,1592,1593,5,65,0,0,1593,1598,3,180,90,0,1594,1595,5,426,0,0,1595,
  	1597,3,180,90,0,1596,1594,1,0,0,0,1597,1600,1,0,0,0,1598,1596,1,0,0,0,
  	1598,1599,1,0,0,0,1599,1602,1,0,0,0,1600,1598,1,0,0,0,1601,1603,5,427,
  	0,0,1602,1601,1,0,0,0,1602,1603,1,0,0,0,1603,1605,1,0,0,0,1604,1583,1,
  	0,0,0,1604,1592,1,0,0,0,1605,131,1,0,0,0,1606,1608,5,45,0,0,1607,1609,
  	5,228,0,0,1608,1607,1,0,0,0,1608,1609,1,0,0,0,1609,1610,1,0,0,0,1610,
  	1612,3,402,201,0,1611,1613,5,427,0,0,1612,1611,1,0,0,0,1612,1613,1,0,
  	0,0,1613,1636,1,0,0,0,1614,1616,5,64,0,0,1615,1617,5,228,0,0,1616,1615,
  	1,0,0,0,1616,1617,1,0,0,0,1617,1619,1,0,0,0,1618,1620,5,61,0,0,1619,1618,
  	1,0,0,0,1619,1620,1,0,0,0,1620,1621,1,0,0,0,1621,1623,3,402,201,0,1622,
  	1624,5,427,0,0,1623,1622,1,0,0,0,1623,1624,1,0,0,0,1624,1636,1,0,0,0,
  	1625,1636,3,198,99,0,1626,1636,3,204,102,0,1627,1629,5,113,0,0,1628,1630,
  	5,228,0,0,1629,1628,1,0,0,0,1629,1630,1,0,0,0,1630,1631,1,0,0,0,1631,
  	1633,3,402,201,0,1632,1634,5,427,0,0,1633,1632,1,0,0,0,1633,1634,1,0,
  	0,0,1634,1636,1,0,0,0,1635,1606,1,0,0,0,1635,1614,1,0,0,0,1635,1625,1,
  	0,0,0,1635,1626,1,0,0,0,1635,1627,1,0,0,0,1636,133,1,0,0,0,1637,1640,
  	5,103,0,0,1638,1641,3,136,68,0,1639,1641,3,138,69,0,1640,1638,1,0,0,0,
  	1640,1639,1,0,0,0,1641,135,1,0,0,0,1642,1645,7,14,0,0,1643,1645,5,349,
  	0,0,1644,1642,1,0,0,0,1644,1643,1,0,0,0,1645,1648,1,0,0,0,1646,1647,5,
  	163,0,0,1647,1649,5,327,0,0,1648,1646,1,0,0,0,1648,1649,1,0,0,0,1649,
  	137,1,0,0,0,1650,1651,5,292,0,0,1651,1652,5,379,0,0,1652,1655,5,332,0,
  	0,1653,1656,5,31,0,0,1654,1656,5,400,0,0,1655,1653,1,0,0,0,1655,1654,
  	1,0,0,0,1656,139,1,0,0,0,1657,1658,5,79,0,0,1658,1660,3,144,72,0,1659,
  	1661,5,427,0,0,1660,1659,1,0,0,0,1660,1661,1,0,0,0,1661,141,1,0,0,0,1662,
  	1671,3,388,194,0,1663,1668,3,146,73,0,1664,1665,5,426,0,0,1665,1667,3,
  	146,73,0,1666,1664,1,0,0,0,1667,1670,1,0,0,0,1668,1666,1,0,0,0,1668,1669,
  	1,0,0,0,1669,1672,1,0,0,0,1670,1668,1,0,0,0,1671,1663,1,0,0,0,1671,1672,
  	1,0,0,0,1672,1674,1,0,0,0,1673,1675,5,427,0,0,1674,1673,1,0,0,0,1674,
  	1675,1,0,0,0,1675,143,1,0,0,0,1676,1677,5,399,0,0,1677,1679,5,406,0,0,
  	1678,1676,1,0,0,0,1678,1679,1,0,0,0,1679,1682,1,0,0,0,1680,1683,3,388,
  	194,0,1681,1683,3,154,77,0,1682,1680,1,0,0,0,1682,1681,1,0,0,0,1683,1685,
  	1,0,0,0,1684,1686,3,146,73,0,1685,1684,1,0,0,0,1685,1686,1,0,0,0,1686,
  	1699,1,0,0,0,1687,1688,5,424,0,0,1688,1693,3,154,77,0,1689,1690,5,433,
  	0,0,1690,1692,3,154,77,0,1691,1689,1,0,0,0,1692,1695,1,0,0,0,1693,1691,
  	1,0,0,0,1693,1694,1,0,0,0,1694,1696,1,0,0,0,1695,1693,1,0,0,0,1696,1697,
  	5,425,0,0,1697,1699,1,0,0,0,1698,1678,1,0,0,0,1698,1687,1,0,0,0,1699,
  	145,1,0,0,0,1700,1705,3,150,75,0,1701,1702,5,426,0,0,1702,1704,3,146,
  	73,0,1703,1701,1,0,0,0,1704,1707,1,0,0,0,1705,1703,1,0,0,0,1705,1706,
  	1,0,0,0,1706,1717,1,0,0,0,1707,1705,1,0,0,0,1708,1713,3,148,74,0,1709,
  	1710,5,426,0,0,1710,1712,3,148,74,0,1711,1709,1,0,0,0,1712,1715,1,0,0,
  	0,1713,1711,1,0,0,0,1713,1714,1,0,0,0,1714,1717,1,0,0,0,1715,1713,1,0,
  	0,0,1716,1700,1,0,0,0,1716,1708,1,0,0,0,1717,147,1,0,0,0,1718,1719,5,
  	399,0,0,1719,1720,5,406,0,0,1720,1721,3,152,76,0,1721,149,1,0,0,0,1722,
  	1723,3,152,76,0,1723,151,1,0,0,0,1724,1733,3,416,208,0,1725,1727,5,399,
  	0,0,1726,1728,7,15,0,0,1727,1726,1,0,0,0,1727,1728,1,0,0,0,1728,1733,
  	1,0,0,0,1729,1733,3,422,211,0,1730,1733,5,66,0,0,1731,1733,5,108,0,0,
  	1732,1724,1,0,0,0,1732,1725,1,0,0,0,1732,1729,1,0,0,0,1732,1730,1,0,0,
  	0,1732,1731,1,0,0,0,1733,153,1,0,0,0,1734,1735,7,1,0,0,1735,155,1,0,0,
  	0,1736,1737,7,16,0,0,1737,157,1,0,0,0,1738,1739,5,141,0,0,1739,1742,5,
  	399,0,0,1740,1741,5,419,0,0,1741,1743,3,422,211,0,1742,1740,1,0,0,0,1742,
  	1743,1,0,0,0,1743,1744,1,0,0,0,1744,1745,5,406,0,0,1745,1747,3,210,105,
  	0,1746,1748,5,427,0,0,1747,1746,1,0,0,0,1747,1748,1,0,0,0,1748,1778,1,
  	0,0,0,1749,1750,5,141,0,0,1750,1751,5,399,0,0,1751,1752,3,430,215,0,1752,
  	1754,3,210,105,0,1753,1755,5,427,0,0,1754,1753,1,0,0,0,1754,1755,1,0,
  	0,0,1755,1778,1,0,0,0,1756,1757,5,141,0,0,1757,1758,5,399,0,0,1758,1759,
  	5,406,0,0,1759,1760,5,61,0,0,1760,1771,3,200,100,0,1761,1769,5,82,0,0,
  	1762,1763,5,128,0,0,1763,1770,5,278,0,0,1764,1767,5,155,0,0,1765,1766,
  	5,110,0,0,1766,1768,3,400,200,0,1767,1765,1,0,0,0,1767,1768,1,0,0,0,1768,
  	1770,1,0,0,0,1769,1762,1,0,0,0,1769,1764,1,0,0,0,1770,1772,1,0,0,0,1771,
  	1761,1,0,0,0,1771,1772,1,0,0,0,1772,1774,1,0,0,0,1773,1775,5,427,0,0,
  	1774,1773,1,0,0,0,1774,1775,1,0,0,0,1775,1778,1,0,0,0,1776,1778,3,206,
  	103,0,1777,1738,1,0,0,0,1777,1749,1,0,0,0,1777,1756,1,0,0,0,1777,1776,
  	1,0,0,0,1778,159,1,0,0,0,1779,1780,5,39,0,0,1780,1781,5,70,0,0,1781,1784,
  	7,17,0,0,1782,1785,3,422,211,0,1783,1785,5,399,0,0,1784,1782,1,0,0,0,
  	1784,1783,1,0,0,0,1784,1785,1,0,0,0,1785,1787,1,0,0,0,1786,1788,5,427,
  	0,0,1787,1786,1,0,0,0,1787,1788,1,0,0,0,1788,1861,1,0,0,0,1789,1790,5,
  	39,0,0,1790,1800,7,17,0,0,1791,1794,3,422,211,0,1792,1794,5,399,0,0,1793,
  	1791,1,0,0,0,1793,1792,1,0,0,0,1794,1798,1,0,0,0,1795,1796,5,163,0,0,
  	1796,1797,5,258,0,0,1797,1799,5,402,0,0,1798,1795,1,0,0,0,1798,1799,1,
  	0,0,0,1799,1801,1,0,0,0,1800,1793,1,0,0,0,1800,1801,1,0,0,0,1801,1803,
  	1,0,0,0,1802,1804,5,427,0,0,1803,1802,1,0,0,0,1803,1804,1,0,0,0,1804,
  	1861,1,0,0,0,1805,1806,5,49,0,0,1806,1819,7,17,0,0,1807,1810,3,422,211,
  	0,1808,1810,5,399,0,0,1809,1807,1,0,0,0,1809,1808,1,0,0,0,1810,1817,1,
  	0,0,0,1811,1812,5,163,0,0,1812,1813,5,424,0,0,1813,1814,5,206,0,0,1814,
  	1815,5,406,0,0,1815,1816,7,18,0,0,1816,1818,5,425,0,0,1817,1811,1,0,0,
  	0,1817,1818,1,0,0,0,1818,1820,1,0,0,0,1819,1809,1,0,0,0,1819,1820,1,0,
  	0,0,1820,1822,1,0,0,0,1821,1823,5,427,0,0,1822,1821,1,0,0,0,1822,1823,
  	1,0,0,0,1823,1861,1,0,0,0,1824,1826,5,49,0,0,1825,1827,5,356,0,0,1826,
  	1825,1,0,0,0,1826,1827,1,0,0,0,1827,1829,1,0,0,0,1828,1830,5,427,0,0,
  	1829,1828,1,0,0,0,1829,1830,1,0,0,0,1830,1861,1,0,0,0,1831,1832,5,49,
  	0,0,1832,1861,3,422,211,0,1833,1834,5,134,0,0,1834,1861,3,422,211,0,1835,
  	1836,5,134,0,0,1836,1839,7,17,0,0,1837,1840,3,422,211,0,1838,1840,5,399,
  	0,0,1839,1837,1,0,0,0,1839,1838,1,0,0,0,1839,1840,1,0,0,0,1840,1842,1,
  	0,0,0,1841,1843,5,427,0,0,1842,1841,1,0,0,0,1842,1843,1,0,0,0,1843,1861,
  	1,0,0,0,1844,1846,5,134,0,0,1845,1847,5,356,0,0,1846,1845,1,0,0,0,1846,
  	1847,1,0,0,0,1847,1849,1,0,0,0,1848,1850,5,427,0,0,1849,1848,1,0,0,0,
  	1849,1850,1,0,0,0,1850,1861,1,0,0,0,1851,1852,5,137,0,0,1852,1855,7,17,
  	0,0,1853,1856,3,422,211,0,1854,1856,5,399,0,0,1855,1853,1,0,0,0,1855,
  	1854,1,0,0,0,1855,1856,1,0,0,0,1856,1858,1,0,0,0,1857,1859,5,427,0,0,
  	1858,1857,1,0,0,0,1858,1859,1,0,0,0,1859,1861,1,0,0,0,1860,1779,1,0,0,
  	0,1860,1789,1,0,0,0,1860,1805,1,0,0,0,1860,1824,1,0,0,0,1860,1831,1,0,
  	0,0,1860,1833,1,0,0,0,1860,1835,1,0,0,0,1860,1844,1,0,0,0,1860,1851,1,
  	0,0,0,1861,161,1,0,0,0,1862,1864,5,229,0,0,1863,1865,5,400,0,0,1864,1863,
  	1,0,0,0,1864,1865,1,0,0,0,1865,163,1,0,0,0,1866,1868,5,230,0,0,1867,1869,
  	5,400,0,0,1868,1867,1,0,0,0,1868,1869,1,0,0,0,1869,165,1,0,0,0,1870,1871,
  	5,156,0,0,1871,1873,3,422,211,0,1872,1874,5,427,0,0,1873,1872,1,0,0,0,
  	1873,1874,1,0,0,0,1874,167,1,0,0,0,1875,1878,5,142,0,0,1876,1877,5,163,
  	0,0,1877,1879,5,271,0,0,1878,1876,1,0,0,0,1878,1879,1,0,0,0,1879,169,
  	1,0,0,0,1880,1881,5,63,0,0,1881,1891,5,384,0,0,1882,1883,5,424,0,0,1883,
  	1884,5,322,0,0,1884,1888,5,406,0,0,1885,1889,3,222,111,0,1886,1889,3,
  	422,211,0,1887,1889,5,66,0,0,1888,1885,1,0,0,0,1888,1886,1,0,0,0,1888,
  	1887,1,0,0,0,1889,1890,1,0,0,0,1890,1892,5,425,0,0,1891,1882,1,0,0,0,
  	1891,1892,1,0,0,0,1892,1894,1,0,0,0,1893,1895,5,427,0,0,1894,1893,1,0,
  	0,0,1894,1895,1,0,0,0,1895,171,1,0,0,0,1896,1897,5,63,0,0,1897,1902,3,
  	174,87,0,1898,1899,5,424,0,0,1899,1900,3,350,175,0,1900,1901,5,425,0,
  	0,1901,1903,1,0,0,0,1902,1898,1,0,0,0,1902,1903,1,0,0,0,1903,1906,1,0,
  	0,0,1904,1905,5,163,0,0,1905,1907,3,176,88,0,1906,1904,1,0,0,0,1906,1907,
  	1,0,0,0,1907,1909,1,0,0,0,1908,1910,5,427,0,0,1909,1908,1,0,0,0,1909,
  	1910,1,0,0,0,1910,173,1,0,0,0,1911,1914,3,424,212,0,1912,1914,3,420,210,
  	0,1913,1911,1,0,0,0,1913,1912,1,0,0,0,1914,175,1,0,0,0,1915,1918,3,424,
  	212,0,1916,1917,5,426,0,0,1917,1919,3,424,212,0,1918,1916,1,0,0,0,1918,
  	1919,1,0,0,0,1919,177,1,0,0,0,1920,1921,5,79,0,0,1921,1922,5,35,0,0,1922,
  	1923,7,19,0,0,1923,179,1,0,0,0,1924,1926,5,399,0,0,1925,1927,5,35,0,0,
  	1926,1925,1,0,0,0,1926,1927,1,0,0,0,1927,1928,1,0,0,0,1928,1931,3,412,
  	206,0,1929,1930,5,406,0,0,1930,1932,3,210,105,0,1931,1929,1,0,0,0,1931,
  	1932,1,0,0,0,1932,181,1,0,0,0,1933,1934,5,145,0,0,1934,1935,5,424,0,0,
  	1935,1936,3,184,92,0,1936,1937,5,425,0,0,1937,183,1,0,0,0,1938,1945,3,
  	186,93,0,1939,1941,5,426,0,0,1940,1939,1,0,0,0,1940,1941,1,0,0,0,1941,
  	1942,1,0,0,0,1942,1944,3,186,93,0,1943,1940,1,0,0,0,1944,1947,1,0,0,0,
  	1945,1943,1,0,0,0,1945,1946,1,0,0,0,1946,185,1,0,0,0,1947,1945,1,0,0,
  	0,1948,1951,3,188,94,0,1949,1951,3,192,96,0,1950,1948,1,0,0,0,1950,1949,
  	1,0,0,0,1951,187,1,0,0,0,1952,1959,3,422,211,0,1953,1960,3,412,206,0,
  	1954,1955,5,35,0,0,1955,1957,3,210,105,0,1956,1958,5,380,0,0,1957,1956,
  	1,0,0,0,1957,1958,1,0,0,0,1958,1960,1,0,0,0,1959,1953,1,0,0,0,1959,1954,
  	1,0,0,0,1960,1963,1,0,0,0,1961,1962,5,47,0,0,1962,1964,3,422,211,0,1963,
  	1961,1,0,0,0,1963,1964,1,0,0,0,1964,1966,1,0,0,0,1965,1967,3,406,203,
  	0,1966,1965,1,0,0,0,1966,1967,1,0,0,0,1967,1989,1,0,0,0,1968,1969,5,51,
  	0,0,1969,1971,3,422,211,0,1970,1968,1,0,0,0,1970,1971,1,0,0,0,1971,1972,
  	1,0,0,0,1972,1974,3,408,204,0,1973,1975,3,408,204,0,1974,1973,1,0,0,0,
  	1974,1975,1,0,0,0,1975,1990,1,0,0,0,1976,1982,5,91,0,0,1977,1978,5,424,
  	0,0,1978,1979,5,400,0,0,1979,1980,5,426,0,0,1980,1981,5,400,0,0,1981,
  	1983,5,425,0,0,1982,1977,1,0,0,0,1982,1983,1,0,0,0,1983,1987,1,0,0,0,
  	1984,1985,5,107,0,0,1985,1986,5,82,0,0,1986,1988,5,130,0,0,1987,1984,
  	1,0,0,0,1987,1988,1,0,0,0,1988,1990,1,0,0,0,1989,1970,1,0,0,0,1989,1976,
  	1,0,0,0,1989,1990,1,0,0,0,1990,1992,1,0,0,0,1991,1993,5,136,0,0,1992,
  	1991,1,0,0,0,1992,1993,1,0,0,0,1993,1997,1,0,0,0,1994,1996,3,190,95,0,
  	1995,1994,1,0,0,0,1996,1999,1,0,0,0,1997,1995,1,0,0,0,1997,1998,1,0,0,
  	0,1998,189,1,0,0,0,1999,1997,1,0,0,0,2000,2001,5,51,0,0,2001,2003,3,422,
  	211,0,2002,2000,1,0,0,0,2002,2003,1,0,0,0,2003,2033,1,0,0,0,2004,2005,
  	5,123,0,0,2005,2008,5,102,0,0,2006,2008,5,153,0,0,2007,2004,1,0,0,0,2007,
  	2006,1,0,0,0,2008,2010,1,0,0,0,2009,2011,3,194,97,0,2010,2009,1,0,0,0,
  	2010,2011,1,0,0,0,2011,2034,1,0,0,0,2012,2016,5,44,0,0,2013,2014,5,107,
  	0,0,2014,2015,5,82,0,0,2015,2017,5,130,0,0,2016,2013,1,0,0,0,2016,2017,
  	1,0,0,0,2017,2018,1,0,0,0,2018,2019,5,424,0,0,2019,2020,3,234,117,0,2020,
  	2021,5,425,0,0,2021,2034,1,0,0,0,2022,2023,5,83,0,0,2023,2025,5,102,0,
  	0,2024,2022,1,0,0,0,2024,2025,1,0,0,0,2025,2026,1,0,0,0,2026,2027,5,129,
  	0,0,2027,2028,3,380,190,0,2028,2029,5,424,0,0,2029,2030,3,400,200,0,2030,
  	2031,5,425,0,0,2031,2034,1,0,0,0,2032,2034,3,406,203,0,2033,2007,1,0,
  	0,0,2033,2012,1,0,0,0,2033,2024,1,0,0,0,2033,2032,1,0,0,0,2034,191,1,
  	0,0,0,2035,2036,5,51,0,0,2036,2038,3,422,211,0,2037,2035,1,0,0,0,2037,
  	2038,1,0,0,0,2038,2094,1,0,0,0,2039,2040,5,123,0,0,2040,2043,5,102,0,
  	0,2041,2043,5,153,0,0,2042,2039,1,0,0,0,2042,2041,1,0,0,0,2043,2044,1,
  	0,0,0,2044,2045,5,424,0,0,2045,2046,3,394,197,0,2046,2048,5,425,0,0,2047,
  	2049,3,194,97,0,2048,2047,1,0,0,0,2048,2049,1,0,0,0,2049,2052,1,0,0,0,
  	2050,2051,5,112,0,0,2051,2053,3,422,211,0,2052,2050,1,0,0,0,2052,2053,
  	1,0,0,0,2053,2095,1,0,0,0,2054,2058,5,44,0,0,2055,2056,5,107,0,0,2056,
  	2057,5,82,0,0,2057,2059,5,130,0,0,2058,2055,1,0,0,0,2058,2059,1,0,0,0,
  	2059,2060,1,0,0,0,2060,2061,5,424,0,0,2061,2062,3,234,117,0,2062,2063,
  	5,425,0,0,2063,2095,1,0,0,0,2064,2066,5,66,0,0,2065,2067,5,424,0,0,2066,
  	2065,1,0,0,0,2066,2067,1,0,0,0,2067,2072,1,0,0,0,2068,2073,5,402,0,0,
  	2069,2073,5,433,0,0,2070,2073,3,318,159,0,2071,2073,5,400,0,0,2072,2068,
  	1,0,0,0,2072,2069,1,0,0,0,2072,2070,1,0,0,0,2072,2071,1,0,0,0,2073,2074,
  	1,0,0,0,2074,2072,1,0,0,0,2074,2075,1,0,0,0,2075,2077,1,0,0,0,2076,2078,
  	5,425,0,0,2077,2076,1,0,0,0,2077,2078,1,0,0,0,2078,2079,1,0,0,0,2079,
  	2080,5,82,0,0,2080,2095,3,422,211,0,2081,2082,5,83,0,0,2082,2083,5,102,
  	0,0,2083,2084,5,424,0,0,2084,2085,3,400,200,0,2085,2086,5,425,0,0,2086,
  	2087,5,129,0,0,2087,2092,3,380,190,0,2088,2089,5,424,0,0,2089,2090,3,
  	400,200,0,2090,2091,5,425,0,0,2091,2093,1,0,0,0,2092,2088,1,0,0,0,2092,
  	2093,1,0,0,0,2093,2095,1,0,0,0,2094,2042,1,0,0,0,2094,2054,1,0,0,0,2094,
  	2064,1,0,0,0,2094,2081,1,0,0,0,2095,193,1,0,0,0,2096,2097,5,163,0,0,2097,
  	2098,5,424,0,0,2098,2103,3,196,98,0,2099,2100,5,426,0,0,2100,2102,3,196,
  	98,0,2101,2099,1,0,0,0,2102,2105,1,0,0,0,2103,2101,1,0,0,0,2103,2104,
  	1,0,0,0,2104,2106,1,0,0,0,2105,2103,1,0,0,0,2106,2107,5,425,0,0,2107,
  	195,1,0,0,0,2108,2111,3,424,212,0,2109,2111,3,420,210,0,2110,2108,1,0,
  	0,0,2110,2109,1,0,0,0,2111,2112,1,0,0,0,2112,2117,5,406,0,0,2113,2118,
  	3,424,212,0,2114,2118,3,420,210,0,2115,2118,3,404,202,0,2116,2118,5,400,
  	0,0,2117,2113,1,0,0,0,2117,2114,1,0,0,0,2117,2115,1,0,0,0,2117,2116,1,
  	0,0,0,2118,197,1,0,0,0,2119,2120,5,65,0,0,2120,2152,3,402,201,0,2121,
  	2131,5,61,0,0,2122,2129,3,200,100,0,2123,2124,5,82,0,0,2124,2127,5,155,
  	0,0,2125,2126,5,110,0,0,2126,2128,3,400,200,0,2127,2125,1,0,0,0,2127,
  	2128,1,0,0,0,2128,2130,1,0,0,0,2129,2123,1,0,0,0,2129,2130,1,0,0,0,2130,
  	2132,1,0,0,0,2131,2122,1,0,0,0,2131,2132,1,0,0,0,2132,2153,1,0,0,0,2133,
  	2135,7,20,0,0,2134,2133,1,0,0,0,2134,2135,1,0,0,0,2135,2137,1,0,0,0,2136,
  	2138,5,312,0,0,2137,2136,1,0,0,0,2137,2138,1,0,0,0,2138,2139,1,0,0,0,
  	2139,2140,5,61,0,0,2140,2141,5,82,0,0,2141,2150,3,86,43,0,2142,2148,5,
  	82,0,0,2143,2144,5,128,0,0,2144,2149,5,278,0,0,2145,2149,5,155,0,0,2146,
  	2147,5,110,0,0,2147,2149,3,400,200,0,2148,2143,1,0,0,0,2148,2145,1,0,
  	0,0,2148,2146,1,0,0,0,2149,2151,1,0,0,0,2150,2142,1,0,0,0,2150,2151,1,
  	0,0,0,2151,2153,1,0,0,0,2152,2121,1,0,0,0,2152,2134,1,0,0,0,2153,2155,
  	1,0,0,0,2154,2156,5,427,0,0,2155,2154,1,0,0,0,2155,2156,1,0,0,0,2156,
  	199,1,0,0,0,2157,2159,3,202,101,0,2158,2157,1,0,0,0,2159,2162,1,0,0,0,
  	2160,2158,1,0,0,0,2160,2161,1,0,0,0,2161,2163,1,0,0,0,2162,2160,1,0,0,
  	0,2163,2164,5,82,0,0,2164,2165,3,86,43,0,2165,201,1,0,0,0,2166,2172,7,
  	13,0,0,2167,2172,7,21,0,0,2168,2172,7,22,0,0,2169,2172,7,23,0,0,2170,
  	2172,5,345,0,0,2171,2166,1,0,0,0,2171,2167,1,0,0,0,2171,2168,1,0,0,0,
  	2171,2169,1,0,0,0,2171,2170,1,0,0,0,2172,203,1,0,0,0,2173,2183,5,81,0,
  	0,2174,2181,5,266,0,0,2175,2181,5,291,0,0,2176,2181,5,220,0,0,2177,2181,
  	5,247,0,0,2178,2179,7,24,0,0,2179,2181,3,210,105,0,2180,2174,1,0,0,0,
  	2180,2175,1,0,0,0,2180,2176,1,0,0,0,2180,2177,1,0,0,0,2180,2178,1,0,0,
  	0,2180,2181,1,0,0,0,2181,2182,1,0,0,0,2182,2184,5,84,0,0,2183,2180,1,
  	0,0,0,2183,2184,1,0,0,0,2184,2186,1,0,0,0,2185,2187,5,228,0,0,2186,2185,
  	1,0,0,0,2186,2187,1,0,0,0,2187,2188,1,0,0,0,2188,2198,3,402,201,0,2189,
  	2190,5,99,0,0,2190,2195,5,399,0,0,2191,2192,5,426,0,0,2192,2194,5,399,
  	0,0,2193,2191,1,0,0,0,2194,2197,1,0,0,0,2195,2193,1,0,0,0,2195,2196,1,
  	0,0,0,2196,2199,1,0,0,0,2197,2195,1,0,0,0,2198,2189,1,0,0,0,2198,2199,
  	1,0,0,0,2199,2201,1,0,0,0,2200,2202,5,427,0,0,2201,2200,1,0,0,0,2201,
  	2202,1,0,0,0,2202,205,1,0,0,0,2203,2204,5,141,0,0,2204,2208,3,422,211,
  	0,2205,2209,3,422,211,0,2206,2209,3,208,104,0,2207,2209,3,404,202,0,2208,
  	2205,1,0,0,0,2208,2206,1,0,0,0,2208,2207,1,0,0,0,2209,2211,1,0,0,0,2210,
  	2212,5,427,0,0,2211,2210,1,0,0,0,2211,2212,1,0,0,0,2212,2248,1,0,0,0,
  	2213,2214,5,141,0,0,2214,2215,5,135,0,0,2215,2217,7,0,0,0,2216,2218,5,
  	427,0,0,2217,2216,1,0,0,0,2217,2218,1,0,0,0,2218,2248,1,0,0,0,2219,2220,
  	5,141,0,0,2220,2221,5,150,0,0,2221,2222,5,242,0,0,2222,2232,5,250,0,0,
  	2223,2224,5,128,0,0,2224,2233,5,347,0,0,2225,2226,5,128,0,0,2226,2233,
  	5,190,0,0,2227,2228,5,305,0,0,2228,2233,5,128,0,0,2229,2233,5,324,0,0,
  	2230,2233,5,318,0,0,2231,2233,5,400,0,0,2232,2223,1,0,0,0,2232,2225,1,
  	0,0,0,2232,2227,1,0,0,0,2232,2229,1,0,0,0,2232,2230,1,0,0,0,2232,2231,
  	1,0,0,0,2233,2235,1,0,0,0,2234,2236,5,427,0,0,2235,2234,1,0,0,0,2235,
  	2236,1,0,0,0,2236,2248,1,0,0,0,2237,2238,5,141,0,0,2238,2239,5,92,0,0,
  	2239,2240,3,380,190,0,2240,2242,3,404,202,0,2241,2243,5,427,0,0,2242,
  	2241,1,0,0,0,2242,2243,1,0,0,0,2243,2248,1,0,0,0,2244,2245,5,141,0,0,
  	2245,2246,7,25,0,0,2246,2248,3,404,202,0,2247,2203,1,0,0,0,2247,2213,
  	1,0,0,0,2247,2219,1,0,0,0,2247,2237,1,0,0,0,2247,2244,1,0,0,0,2248,207,
  	1,0,0,0,2249,2252,3,416,208,0,2250,2252,5,399,0,0,2251,2249,1,0,0,0,2251,
  	2250,1,0,0,0,2252,209,1,0,0,0,2253,2254,6,105,-1,0,2254,2263,3,214,107,
  	0,2255,2263,3,318,159,0,2256,2263,3,216,108,0,2257,2263,3,392,196,0,2258,
  	2263,3,220,110,0,2259,2263,3,218,109,0,2260,2263,3,360,180,0,2261,2263,
  	5,358,0,0,2262,2253,1,0,0,0,2262,2255,1,0,0,0,2262,2256,1,0,0,0,2262,
  	2257,1,0,0,0,2262,2258,1,0,0,0,2262,2259,1,0,0,0,2262,2260,1,0,0,0,2262,
  	2261,1,0,0,0,2263,2277,1,0,0,0,2264,2265,10,5,0,0,2265,2266,7,26,0,0,
  	2266,2276,3,210,105,6,2267,2268,10,4,0,0,2268,2269,7,27,0,0,2269,2276,
  	3,210,105,5,2270,2271,10,10,0,0,2271,2272,5,47,0,0,2272,2276,3,422,211,
  	0,2273,2274,10,3,0,0,2274,2276,3,212,106,0,2275,2264,1,0,0,0,2275,2267,
  	1,0,0,0,2275,2270,1,0,0,0,2275,2273,1,0,0,0,2276,2279,1,0,0,0,2277,2275,
  	1,0,0,0,2277,2278,1,0,0,0,2278,211,1,0,0,0,2279,2277,1,0,0,0,2280,2281,
  	5,167,0,0,2281,2282,5,337,0,0,2282,2283,5,357,0,0,2283,2284,3,210,105,
  	0,2284,213,1,0,0,0,2285,2290,5,66,0,0,2286,2290,5,108,0,0,2287,2290,5,
  	399,0,0,2288,2290,3,416,208,0,2289,2285,1,0,0,0,2289,2286,1,0,0,0,2289,
  	2287,1,0,0,0,2289,2288,1,0,0,0,2290,215,1,0,0,0,2291,2292,5,43,0,0,2292,
  	2294,3,210,105,0,2293,2295,3,326,163,0,2294,2293,1,0,0,0,2295,2296,1,
  	0,0,0,2296,2294,1,0,0,0,2296,2297,1,0,0,0,2297,2300,1,0,0,0,2298,2299,
  	5,75,0,0,2299,2301,3,210,105,0,2300,2298,1,0,0,0,2300,2301,1,0,0,0,2301,
  	2302,1,0,0,0,2302,2303,5,76,0,0,2303,2317,1,0,0,0,2304,2306,5,43,0,0,
  	2305,2307,3,328,164,0,2306,2305,1,0,0,0,2307,2308,1,0,0,0,2308,2306,1,
  	0,0,0,2308,2309,1,0,0,0,2309,2312,1,0,0,0,2310,2311,5,75,0,0,2311,2313,
  	3,210,105,0,2312,2310,1,0,0,0,2312,2313,1,0,0,0,2313,2314,1,0,0,0,2314,
  	2315,5,76,0,0,2315,2317,1,0,0,0,2316,2291,1,0,0,0,2316,2304,1,0,0,0,2317,
  	217,1,0,0,0,2318,2319,5,435,0,0,2319,2323,3,210,105,0,2320,2321,7,28,
  	0,0,2321,2323,3,210,105,0,2322,2318,1,0,0,0,2322,2320,1,0,0,0,2323,219,
  	1,0,0,0,2324,2325,5,424,0,0,2325,2326,3,210,105,0,2326,2327,5,425,0,0,
  	2327,2333,1,0,0,0,2328,2329,5,424,0,0,2329,2330,3,224,112,0,2330,2331,
  	5,425,0,0,2331,2333,1,0,0,0,2332,2324,1,0,0,0,2332,2328,1,0,0,0,2333,
  	221,1,0,0,0,2334,2343,5,108,0,0,2335,2343,3,416,208,0,2336,2343,3,318,
  	159,0,2337,2343,5,399,0,0,2338,2339,5,424,0,0,2339,2340,3,222,111,0,2340,
  	2341,5,425,0,0,2341,2343,1,0,0,0,2342,2334,1,0,0,0,2342,2335,1,0,0,0,
  	2342,2336,1,0,0,0,2342,2337,1,0,0,0,2342,2338,1,0,0,0,2343,223,1,0,0,
  	0,2344,2345,3,88,44,0,2345,225,1,0,0,0,2346,2347,5,163,0,0,2347,2352,
  	3,228,114,0,2348,2349,5,426,0,0,2349,2351,3,228,114,0,2350,2348,1,0,0,
  	0,2351,2354,1,0,0,0,2352,2350,1,0,0,0,2352,2353,1,0,0,0,2353,227,1,0,
  	0,0,2354,2352,1,0,0,0,2355,2360,3,422,211,0,2356,2357,5,424,0,0,2357,
  	2358,3,400,200,0,2358,2359,5,425,0,0,2359,2361,1,0,0,0,2360,2356,1,0,
  	0,0,2360,2361,1,0,0,0,2361,2362,1,0,0,0,2362,2363,5,35,0,0,2363,2364,
  	5,424,0,0,2364,2365,3,88,44,0,2365,2366,5,425,0,0,2366,229,1,0,0,0,2367,
  	2368,5,399,0,0,2368,2369,5,406,0,0,2369,2372,3,392,196,0,2370,2373,5,
  	406,0,0,2371,2373,3,430,215,0,2372,2370,1,0,0,0,2372,2371,1,0,0,0,2373,
  	2374,1,0,0,0,2374,2375,3,210,105,0,2375,2393,1,0,0,0,2376,2379,3,392,
  	196,0,2377,2379,5,399,0,0,2378,2376,1,0,0,0,2378,2377,1,0,0,0,2379,2382,
  	1,0,0,0,2380,2383,5,406,0,0,2381,2383,3,430,215,0,2382,2380,1,0,0,0,2382,
  	2381,1,0,0,0,2383,2384,1,0,0,0,2384,2393,3,210,105,0,2385,2386,3,422,
  	211,0,2386,2387,5,419,0,0,2387,2388,3,422,211,0,2388,2389,5,424,0,0,2389,
  	2390,3,350,175,0,2390,2391,5,425,0,0,2391,2393,1,0,0,0,2392,2367,1,0,
  	0,0,2392,2378,1,0,0,0,2392,2385,1,0,0,0,2393,231,1,0,0,0,2394,2397,3,
  	392,196,0,2395,2397,5,399,0,0,2396,2394,1,0,0,0,2396,2395,1,0,0,0,2397,
  	2400,1,0,0,0,2398,2401,5,406,0,0,2399,2401,3,430,215,0,2400,2398,1,0,
  	0,0,2400,2399,1,0,0,0,2401,2402,1,0,0,0,2402,2411,3,210,105,0,2403,2404,
  	3,422,211,0,2404,2405,5,419,0,0,2405,2406,3,422,211,0,2406,2407,5,424,
  	0,0,2407,2408,3,350,175,0,2408,2409,5,425,0,0,2409,2411,1,0,0,0,2410,
  	2396,1,0,0,0,2410,2403,1,0,0,0,2411,233,1,0,0,0,2412,2416,6,117,-1,0,
  	2413,2415,5,107,0,0,2414,2413,1,0,0,0,2415,2418,1,0,0,0,2416,2414,1,0,
  	0,0,2416,2417,1,0,0,0,2417,2424,1,0,0,0,2418,2416,1,0,0,0,2419,2425,3,
  	236,118,0,2420,2421,5,424,0,0,2421,2422,3,234,117,0,2422,2423,5,425,0,
  	0,2423,2425,1,0,0,0,2424,2419,1,0,0,0,2424,2420,1,0,0,0,2425,2434,1,0,
  	0,0,2426,2427,10,2,0,0,2427,2428,5,33,0,0,2428,2433,3,234,117,3,2429,
  	2430,10,1,0,0,2430,2431,5,115,0,0,2431,2433,3,234,117,2,2432,2426,1,0,
  	0,0,2432,2429,1,0,0,0,2433,2436,1,0,0,0,2434,2432,1,0,0,0,2434,2435,1,
  	0,0,0,2435,235,1,0,0,0,2436,2434,1,0,0,0,2437,2438,5,80,0,0,2438,2439,
  	5,424,0,0,2439,2440,3,224,112,0,2440,2441,5,425,0,0,2441,2498,1,0,0,0,
  	2442,2443,3,210,105,0,2443,2444,3,428,214,0,2444,2445,3,210,105,0,2445,
  	2498,1,0,0,0,2446,2447,3,210,105,0,2447,2448,3,428,214,0,2448,2449,7,
  	29,0,0,2449,2450,5,424,0,0,2450,2451,3,224,112,0,2451,2452,5,425,0,0,
  	2452,2498,1,0,0,0,2453,2457,3,210,105,0,2454,2456,5,107,0,0,2455,2454,
  	1,0,0,0,2456,2459,1,0,0,0,2457,2455,1,0,0,0,2457,2458,1,0,0,0,2458,2460,
  	1,0,0,0,2459,2457,1,0,0,0,2460,2461,5,40,0,0,2461,2462,3,210,105,0,2462,
  	2463,5,33,0,0,2463,2464,3,210,105,0,2464,2498,1,0,0,0,2465,2469,3,210,
  	105,0,2466,2468,5,107,0,0,2467,2466,1,0,0,0,2468,2471,1,0,0,0,2469,2467,
  	1,0,0,0,2469,2470,1,0,0,0,2470,2472,1,0,0,0,2471,2469,1,0,0,0,2472,2473,
  	5,94,0,0,2473,2476,5,424,0,0,2474,2477,3,224,112,0,2475,2477,3,350,175,
  	0,2476,2474,1,0,0,0,2476,2475,1,0,0,0,2477,2478,1,0,0,0,2478,2479,5,425,
  	0,0,2479,2498,1,0,0,0,2480,2484,3,210,105,0,2481,2483,5,107,0,0,2482,
  	2481,1,0,0,0,2483,2486,1,0,0,0,2484,2482,1,0,0,0,2484,2485,1,0,0,0,2485,
  	2487,1,0,0,0,2486,2484,1,0,0,0,2487,2488,5,105,0,0,2488,2491,3,210,105,
  	0,2489,2490,5,77,0,0,2490,2492,3,210,105,0,2491,2489,1,0,0,0,2491,2492,
  	1,0,0,0,2492,2498,1,0,0,0,2493,2494,3,210,105,0,2494,2495,5,100,0,0,2495,
  	2496,3,406,203,0,2496,2498,1,0,0,0,2497,2437,1,0,0,0,2497,2442,1,0,0,
  	0,2497,2446,1,0,0,0,2497,2453,1,0,0,0,2497,2465,1,0,0,0,2497,2480,1,0,
  	0,0,2497,2493,1,0,0,0,2498,237,1,0,0,0,2499,2505,3,242,121,0,2500,2501,
  	5,424,0,0,2501,2502,3,238,119,0,2502,2503,5,425,0,0,2503,2505,1,0,0,0,
  	2504,2499,1,0,0,0,2504,2500,1,0,0,0,2505,2516,1,0,0,0,2506,2508,3,242,
  	121,0,2507,2509,3,250,125,0,2508,2507,1,0,0,0,2508,2509,1,0,0,0,2509,
  	2511,1,0,0,0,2510,2512,3,240,120,0,2511,2510,1,0,0,0,2512,2513,1,0,0,
  	0,2513,2511,1,0,0,0,2513,2514,1,0,0,0,2514,2516,1,0,0,0,2515,2504,1,0,
  	0,0,2515,2506,1,0,0,0,2516,239,1,0,0,0,2517,2519,5,152,0,0,2518,2520,
  	5,31,0,0,2519,2518,1,0,0,0,2519,2520,1,0,0,0,2520,2524,1,0,0,0,2521,2524,
  	5,78,0,0,2522,2524,5,98,0,0,2523,2517,1,0,0,0,2523,2521,1,0,0,0,2523,
  	2522,1,0,0,0,2524,2530,1,0,0,0,2525,2531,3,242,121,0,2526,2527,5,424,
  	0,0,2527,2528,3,238,119,0,2528,2529,5,425,0,0,2529,2531,1,0,0,0,2530,
  	2525,1,0,0,0,2530,2526,1,0,0,0,2531,241,1,0,0,0,2532,2534,5,139,0,0,2533,
  	2535,7,30,0,0,2534,2533,1,0,0,0,2534,2535,1,0,0,0,2535,2537,1,0,0,0,2536,
  	2538,3,244,122,0,2537,2536,1,0,0,0,2537,2538,1,0,0,0,2538,2539,1,0,0,
  	0,2539,2542,3,262,131,0,2540,2541,5,99,0,0,2541,2543,3,380,190,0,2542,
  	2540,1,0,0,0,2542,2543,1,0,0,0,2543,2546,1,0,0,0,2544,2545,5,84,0,0,2545,
  	2547,3,276,138,0,2546,2544,1,0,0,0,2546,2547,1,0,0,0,2547,2550,1,0,0,
  	0,2548,2549,5,161,0,0,2549,2551,3,234,117,0,2550,2548,1,0,0,0,2550,2551,
  	1,0,0,0,2551,2565,1,0,0,0,2552,2553,5,88,0,0,2553,2555,5,42,0,0,2554,
  	2556,5,31,0,0,2555,2554,1,0,0,0,2555,2556,1,0,0,0,2556,2557,1,0,0,0,2557,
  	2562,3,254,127,0,2558,2559,5,426,0,0,2559,2561,3,254,127,0,2560,2558,
  	1,0,0,0,2561,2564,1,0,0,0,2562,2560,1,0,0,0,2562,2563,1,0,0,0,2563,2566,
  	1,0,0,0,2564,2562,1,0,0,0,2565,2552,1,0,0,0,2565,2566,1,0,0,0,2566,2569,
  	1,0,0,0,2567,2568,5,89,0,0,2568,2570,3,234,117,0,2569,2567,1,0,0,0,2569,
  	2570,1,0,0,0,2570,243,1,0,0,0,2571,2574,5,148,0,0,2572,2575,3,246,123,
  	0,2573,2575,3,248,124,0,2574,2572,1,0,0,0,2574,2573,1,0,0,0,2575,2578,
  	1,0,0,0,2576,2577,5,163,0,0,2577,2579,5,336,0,0,2578,2576,1,0,0,0,2578,
  	2579,1,0,0,0,2579,245,1,0,0,0,2580,2581,7,31,0,0,2581,2588,5,119,0,0,
  	2582,2583,5,424,0,0,2583,2584,3,210,105,0,2584,2585,5,425,0,0,2585,2586,
  	5,119,0,0,2586,2588,1,0,0,0,2587,2580,1,0,0,0,2587,2582,1,0,0,0,2588,
  	247,1,0,0,0,2589,2595,5,400,0,0,2590,2591,5,424,0,0,2591,2592,3,210,105,
  	0,2592,2593,5,425,0,0,2593,2595,1,0,0,0,2594,2589,1,0,0,0,2594,2590,1,
  	0,0,0,2595,249,1,0,0,0,2596,2597,5,116,0,0,2597,2598,5,42,0,0,2598,2603,
  	3,252,126,0,2599,2600,5,426,0,0,2600,2602,3,252,126,0,2601,2599,1,0,0,
  	0,2602,2605,1,0,0,0,2603,2601,1,0,0,0,2603,2604,1,0,0,0,2604,2617,1,0,
  	0,0,2605,2603,1,0,0,0,2606,2607,5,276,0,0,2607,2608,3,210,105,0,2608,
  	2615,7,32,0,0,2609,2610,5,81,0,0,2610,2611,7,33,0,0,2611,2612,3,210,105,
  	0,2612,2613,7,32,0,0,2613,2614,5,278,0,0,2614,2616,1,0,0,0,2615,2609,
  	1,0,0,0,2615,2616,1,0,0,0,2616,2618,1,0,0,0,2617,2606,1,0,0,0,2617,2618,
  	1,0,0,0,2618,251,1,0,0,0,2619,2622,3,210,105,0,2620,2623,5,36,0,0,2621,
  	2623,5,68,0,0,2622,2620,1,0,0,0,2622,2621,1,0,0,0,2622,2623,1,0,0,0,2623,
  	253,1,0,0,0,2624,2625,3,210,105,0,2625,255,1,0,0,0,2626,2627,5,114,0,
  	0,2627,2628,5,424,0,0,2628,2633,3,258,129,0,2629,2630,5,426,0,0,2630,
  	2632,3,258,129,0,2631,2629,1,0,0,0,2632,2635,1,0,0,0,2633,2631,1,0,0,
  	0,2633,2634,1,0,0,0,2634,2636,1,0,0,0,2635,2633,1,0,0,0,2636,2637,5,425,
  	0,0,2637,257,1,0,0,0,2638,2639,5,218,0,0,2639,2681,5,400,0,0,2640,2641,
  	7,34,0,0,2641,2681,5,88,0,0,2642,2643,7,35,0,0,2643,2681,5,152,0,0,2644,
  	2645,7,36,0,0,2645,2681,5,101,0,0,2646,2647,5,223,0,0,2647,2681,5,116,
  	0,0,2648,2649,5,243,0,0,2649,2681,5,121,0,0,2650,2651,5,244,0,0,2651,
  	2681,5,121,0,0,2652,2653,5,260,0,0,2653,2681,5,400,0,0,2654,2655,5,261,
  	0,0,2655,2681,5,400,0,0,2656,2657,5,280,0,0,2657,2658,5,82,0,0,2658,2659,
  	5,424,0,0,2659,2664,3,260,130,0,2660,2661,5,426,0,0,2661,2663,3,260,130,
  	0,2662,2660,1,0,0,0,2663,2666,1,0,0,0,2664,2662,1,0,0,0,2664,2665,1,0,
  	0,0,2665,2667,1,0,0,0,2666,2664,1,0,0,0,2667,2668,5,425,0,0,2668,2681,
  	1,0,0,0,2669,2670,5,280,0,0,2670,2671,5,82,0,0,2671,2681,5,348,0,0,2672,
  	2673,5,284,0,0,2673,2681,7,37,0,0,2674,2681,5,302,0,0,2675,2676,5,306,
  	0,0,2676,2681,5,121,0,0,2677,2678,5,156,0,0,2678,2679,5,121,0,0,2679,
  	2681,5,402,0,0,2680,2638,1,0,0,0,2680,2640,1,0,0,0,2680,2642,1,0,0,0,
  	2680,2644,1,0,0,0,2680,2646,1,0,0,0,2680,2648,1,0,0,0,2680,2650,1,0,0,
  	0,2680,2652,1,0,0,0,2680,2654,1,0,0,0,2680,2656,1,0,0,0,2680,2669,1,0,
  	0,0,2680,2672,1,0,0,0,2680,2674,1,0,0,0,2680,2675,1,0,0,0,2680,2677,1,
  	0,0,0,2681,259,1,0,0,0,2682,2689,5,399,0,0,2683,2690,5,348,0,0,2684,2687,
  	5,406,0,0,2685,2688,3,416,208,0,2686,2688,5,108,0,0,2687,2685,1,0,0,0,
  	2687,2686,1,0,0,0,2688,2690,1,0,0,0,2689,2683,1,0,0,0,2689,2684,1,0,0,
  	0,2690,261,1,0,0,0,2691,2696,3,274,137,0,2692,2693,5,426,0,0,2693,2695,
  	3,274,137,0,2694,2692,1,0,0,0,2695,2698,1,0,0,0,2696,2694,1,0,0,0,2696,
  	2697,1,0,0,0,2697,263,1,0,0,0,2698,2696,1,0,0,0,2699,2700,5,424,0,0,2700,
  	2705,3,154,77,0,2701,2702,5,426,0,0,2702,2704,3,154,77,0,2703,2701,1,
  	0,0,0,2704,2707,1,0,0,0,2705,2703,1,0,0,0,2705,2706,1,0,0,0,2706,2708,
  	1,0,0,0,2707,2705,1,0,0,0,2708,2709,5,425,0,0,2709,265,1,0,0,0,2710,2711,
  	3,380,190,0,2711,2712,5,419,0,0,2712,2714,1,0,0,0,2713,2710,1,0,0,0,2713,
  	2714,1,0,0,0,2714,2715,1,0,0,0,2715,2720,5,430,0,0,2716,2717,7,38,0,0,
  	2717,2718,5,419,0,0,2718,2720,5,430,0,0,2719,2713,1,0,0,0,2719,2716,1,
  	0,0,0,2720,267,1,0,0,0,2721,2728,3,392,196,0,2722,2723,5,423,0,0,2723,
  	2728,5,91,0,0,2724,2725,5,423,0,0,2725,2728,5,309,0,0,2726,2728,5,108,
  	0,0,2727,2721,1,0,0,0,2727,2722,1,0,0,0,2727,2724,1,0,0,0,2727,2726,1,
  	0,0,0,2728,2730,1,0,0,0,2729,2731,3,330,165,0,2730,2729,1,0,0,0,2730,
  	2731,1,0,0,0,2731,269,1,0,0,0,2732,2733,3,422,211,0,2733,2734,5,419,0,
  	0,2734,2735,3,422,211,0,2735,2737,3,264,132,0,2736,2738,3,330,165,0,2737,
  	2736,1,0,0,0,2737,2738,1,0,0,0,2738,2749,1,0,0,0,2739,2740,3,422,211,
  	0,2740,2741,5,429,0,0,2741,2743,3,422,211,0,2742,2744,3,264,132,0,2743,
  	2742,1,0,0,0,2743,2744,1,0,0,0,2744,2746,1,0,0,0,2745,2747,3,330,165,
  	0,2746,2745,1,0,0,0,2746,2747,1,0,0,0,2747,2749,1,0,0,0,2748,2732,1,0,
  	0,0,2748,2739,1,0,0,0,2749,271,1,0,0,0,2750,2751,3,346,173,0,2751,2752,
  	5,406,0,0,2752,2753,3,210,105,0,2753,2759,1,0,0,0,2754,2756,3,210,105,
  	0,2755,2757,3,330,165,0,2756,2755,1,0,0,0,2756,2757,1,0,0,0,2757,2759,
  	1,0,0,0,2758,2750,1,0,0,0,2758,2754,1,0,0,0,2759,273,1,0,0,0,2760,2771,
  	3,266,133,0,2761,2771,3,268,134,0,2762,2771,3,270,135,0,2763,2766,5,399,
  	0,0,2764,2767,3,430,215,0,2765,2767,5,406,0,0,2766,2764,1,0,0,0,2766,
  	2765,1,0,0,0,2767,2768,1,0,0,0,2768,2771,3,210,105,0,2769,2771,3,272,
  	136,0,2770,2760,1,0,0,0,2770,2761,1,0,0,0,2770,2762,1,0,0,0,2770,2763,
  	1,0,0,0,2770,2769,1,0,0,0,2771,275,1,0,0,0,2772,2777,3,278,139,0,2773,
  	2774,5,426,0,0,2774,2776,3,278,139,0,2775,2773,1,0,0,0,2776,2779,1,0,
  	0,0,2777,2775,1,0,0,0,2777,2778,1,0,0,0,2778,277,1,0,0,0,2779,2777,1,
  	0,0,0,2780,2786,3,280,140,0,2781,2782,5,424,0,0,2782,2783,3,278,139,0,
  	2783,2784,5,425,0,0,2784,2786,1,0,0,0,2785,2780,1,0,0,0,2785,2781,1,0,
  	0,0,2786,279,1,0,0,0,2787,2791,3,282,141,0,2788,2790,3,294,147,0,2789,
  	2788,1,0,0,0,2790,2793,1,0,0,0,2791,2789,1,0,0,0,2791,2792,1,0,0,0,2792,
  	2804,1,0,0,0,2793,2791,1,0,0,0,2794,2795,5,424,0,0,2795,2796,3,280,140,
  	0,2796,2800,5,425,0,0,2797,2799,3,294,147,0,2798,2797,1,0,0,0,2799,2802,
  	1,0,0,0,2800,2798,1,0,0,0,2800,2801,1,0,0,0,2801,2804,1,0,0,0,2802,2800,
  	1,0,0,0,2803,2787,1,0,0,0,2803,2794,1,0,0,0,2804,281,1,0,0,0,2805,2807,
  	5,399,0,0,2806,2808,3,332,166,0,2807,2806,1,0,0,0,2807,2808,1,0,0,0,2808,
  	2859,1,0,0,0,2809,2811,3,312,156,0,2810,2812,3,332,166,0,2811,2810,1,
  	0,0,0,2811,2812,1,0,0,0,2812,2859,1,0,0,0,2813,2815,3,378,189,0,2814,
  	2816,3,332,166,0,2815,2814,1,0,0,0,2815,2816,1,0,0,0,2816,2859,1,0,0,
  	0,2817,2818,5,424,0,0,2818,2819,3,316,158,0,2819,2824,5,425,0,0,2820,
  	2822,3,332,166,0,2821,2823,3,344,172,0,2822,2821,1,0,0,0,2822,2823,1,
  	0,0,0,2823,2825,1,0,0,0,2824,2820,1,0,0,0,2824,2825,1,0,0,0,2825,2859,
  	1,0,0,0,2826,2828,3,288,144,0,2827,2829,3,332,166,0,2828,2827,1,0,0,0,
  	2828,2829,1,0,0,0,2829,2859,1,0,0,0,2830,2835,3,318,159,0,2831,2833,3,
  	332,166,0,2832,2834,3,344,172,0,2833,2832,1,0,0,0,2833,2834,1,0,0,0,2834,
  	2836,1,0,0,0,2835,2831,1,0,0,0,2835,2836,1,0,0,0,2836,2859,1,0,0,0,2837,
  	2842,3,324,162,0,2838,2840,3,332,166,0,2839,2841,3,344,172,0,2840,2839,
  	1,0,0,0,2840,2841,1,0,0,0,2841,2843,1,0,0,0,2842,2838,1,0,0,0,2842,2843,
  	1,0,0,0,2843,2859,1,0,0,0,2844,2845,5,399,0,0,2845,2846,5,419,0,0,2846,
  	2851,3,318,159,0,2847,2849,3,332,166,0,2848,2850,3,344,172,0,2849,2848,
  	1,0,0,0,2849,2850,1,0,0,0,2850,2852,1,0,0,0,2851,2847,1,0,0,0,2851,2852,
  	1,0,0,0,2852,2859,1,0,0,0,2853,2854,5,429,0,0,2854,2856,3,318,159,0,2855,
  	2857,3,332,166,0,2856,2855,1,0,0,0,2856,2857,1,0,0,0,2857,2859,1,0,0,
  	0,2858,2805,1,0,0,0,2858,2809,1,0,0,0,2858,2813,1,0,0,0,2858,2817,1,0,
  	0,0,2858,2826,1,0,0,0,2858,2830,1,0,0,0,2858,2837,1,0,0,0,2858,2844,1,
  	0,0,0,2858,2853,1,0,0,0,2859,283,1,0,0,0,2860,2865,3,286,143,0,2861,2862,
  	5,426,0,0,2862,2864,3,286,143,0,2863,2861,1,0,0,0,2864,2867,1,0,0,0,2865,
  	2863,1,0,0,0,2865,2866,1,0,0,0,2866,285,1,0,0,0,2867,2865,1,0,0,0,2868,
  	2869,3,422,211,0,2869,2871,3,412,206,0,2870,2872,5,402,0,0,2871,2870,
  	1,0,0,0,2871,2872,1,0,0,0,2872,287,1,0,0,0,2873,2876,3,290,145,0,2874,
  	2876,3,292,146,0,2875,2873,1,0,0,0,2875,2874,1,0,0,0,2876,289,1,0,0,0,
  	2877,2878,5,362,0,0,2878,2879,5,424,0,0,2879,2880,5,363,0,0,2880,2881,
  	3,380,190,0,2881,2882,5,426,0,0,2882,2883,7,39,0,0,2883,2884,5,425,0,
  	0,2884,291,1,0,0,0,2885,2886,5,362,0,0,2886,2887,5,424,0,0,2887,2888,
  	5,454,0,0,2888,2889,3,380,190,0,2889,2890,5,426,0,0,2890,2891,3,310,155,
  	0,2891,2892,5,426,0,0,2892,2893,3,262,131,0,2893,2894,5,425,0,0,2894,
  	293,1,0,0,0,2895,2901,3,296,148,0,2896,2901,3,298,149,0,2897,2901,3,300,
  	150,0,2898,2901,3,302,151,0,2899,2901,3,304,152,0,2900,2895,1,0,0,0,2900,
  	2896,1,0,0,0,2900,2897,1,0,0,0,2900,2898,1,0,0,0,2900,2899,1,0,0,0,2901,
  	295,1,0,0,0,2902,2904,5,96,0,0,2903,2902,1,0,0,0,2903,2904,1,0,0,0,2904,
  	2910,1,0,0,0,2905,2907,7,40,0,0,2906,2908,5,117,0,0,2907,2906,1,0,0,0,
  	2907,2908,1,0,0,0,2908,2910,1,0,0,0,2909,2903,1,0,0,0,2909,2905,1,0,0,
  	0,2910,2912,1,0,0,0,2911,2913,7,41,0,0,2912,2911,1,0,0,0,2912,2913,1,
  	0,0,0,2913,2914,1,0,0,0,2914,2915,5,101,0,0,2915,2916,3,278,139,0,2916,
  	2917,5,112,0,0,2917,2918,3,234,117,0,2918,297,1,0,0,0,2919,2920,5,55,
  	0,0,2920,2921,5,101,0,0,2921,2922,3,278,139,0,2922,299,1,0,0,0,2923,2924,
  	7,42,0,0,2924,2925,5,176,0,0,2925,2926,3,278,139,0,2926,301,1,0,0,0,2927,
  	2928,5,120,0,0,2928,2929,3,306,153,0,2929,2930,3,332,166,0,2930,303,1,
  	0,0,0,2931,2932,5,154,0,0,2932,2933,3,308,154,0,2933,2934,3,332,166,0,
  	2934,305,1,0,0,0,2935,2936,5,424,0,0,2936,2937,3,354,177,0,2937,2938,
  	5,82,0,0,2938,2939,3,392,196,0,2939,2940,5,94,0,0,2940,2941,3,344,172,
  	0,2941,2942,5,425,0,0,2942,307,1,0,0,0,2943,2944,5,424,0,0,2944,2945,
  	3,210,105,0,2945,2946,5,82,0,0,2946,2947,3,392,196,0,2947,2948,5,94,0,
  	0,2948,2949,5,424,0,0,2949,2950,3,310,155,0,2950,2951,5,425,0,0,2951,
  	2952,5,425,0,0,2952,309,1,0,0,0,2953,2958,3,392,196,0,2954,2955,5,426,
  	0,0,2955,2957,3,392,196,0,2956,2954,1,0,0,0,2957,2960,1,0,0,0,2958,2956,
  	1,0,0,0,2958,2959,1,0,0,0,2959,311,1,0,0,0,2960,2958,1,0,0,0,2961,2963,
  	3,380,190,0,2962,2964,3,336,168,0,2963,2962,1,0,0,0,2963,2964,1,0,0,0,
  	2964,313,1,0,0,0,2965,2966,3,422,211,0,2966,2967,5,406,0,0,2967,2968,
  	7,14,0,0,2968,315,1,0,0,0,2969,2980,3,224,112,0,2970,2971,5,424,0,0,2971,
  	2972,3,224,112,0,2972,2973,5,425,0,0,2973,2980,1,0,0,0,2974,2980,3,348,
  	174,0,2975,2976,5,424,0,0,2976,2977,3,348,174,0,2977,2978,5,425,0,0,2978,
  	2980,1,0,0,0,2979,2969,1,0,0,0,2979,2970,1,0,0,0,2979,2974,1,0,0,0,2979,
  	2975,1,0,0,0,2980,317,1,0,0,0,2981,2994,3,352,176,0,2982,2994,3,354,177,
  	0,2983,2994,3,356,178,0,2984,2994,3,322,161,0,2985,2986,3,410,205,0,2986,
  	2988,5,424,0,0,2987,2989,3,350,175,0,2988,2987,1,0,0,0,2988,2989,1,0,
  	0,0,2989,2990,1,0,0,0,2990,2991,5,425,0,0,2991,2994,1,0,0,0,2992,2994,
  	3,320,160,0,2993,2981,1,0,0,0,2993,2982,1,0,0,0,2993,2983,1,0,0,0,2993,
  	2984,1,0,0,0,2993,2985,1,0,0,0,2993,2992,1,0,0,0,2994,319,1,0,0,0,2995,
  	2996,3,422,211,0,2996,2997,5,419,0,0,2997,2999,1,0,0,0,2998,2995,1,0,
  	0,0,2998,2999,1,0,0,0,2999,3000,1,0,0,0,3000,3001,5,165,0,0,3001,3002,
  	5,419,0,0,3002,3003,3,422,211,0,3003,3004,5,424,0,0,3004,3005,3,210,105,
  	0,3005,3006,5,425,0,0,3006,321,1,0,0,0,3007,3008,5,183,0,0,3008,3009,
  	5,424,0,0,3009,3010,5,430,0,0,3010,3153,5,425,0,0,3011,3012,5,185,0,0,
  	3012,3013,5,424,0,0,3013,3014,3,210,105,0,3014,3015,5,35,0,0,3015,3016,
  	3,412,206,0,3016,3017,5,425,0,0,3017,3153,1,0,0,0,3018,3019,5,186,0,0,
  	3019,3020,5,424,0,0,3020,3021,3,210,105,0,3021,3022,5,35,0,0,3022,3023,
  	3,412,206,0,3023,3024,5,425,0,0,3024,3153,1,0,0,0,3025,3026,5,53,0,0,
  	3026,3027,5,424,0,0,3027,3028,3,412,206,0,3028,3029,5,426,0,0,3029,3032,
  	3,210,105,0,3030,3031,5,426,0,0,3031,3033,3,210,105,0,3032,3030,1,0,0,
  	0,3032,3033,1,0,0,0,3033,3034,1,0,0,0,3034,3035,5,425,0,0,3035,3153,1,
  	0,0,0,3036,3037,5,188,0,0,3037,3038,5,424,0,0,3038,3039,5,430,0,0,3039,
  	3153,5,425,0,0,3040,3041,5,46,0,0,3041,3042,5,424,0,0,3042,3043,3,350,
  	175,0,3043,3044,5,425,0,0,3044,3153,1,0,0,0,3045,3153,5,59,0,0,3046,3153,
  	5,60,0,0,3047,3048,5,199,0,0,3048,3049,5,424,0,0,3049,3050,5,401,0,0,
  	3050,3051,5,426,0,0,3051,3052,3,210,105,0,3052,3053,5,426,0,0,3053,3054,
  	3,210,105,0,3054,3055,5,425,0,0,3055,3153,1,0,0,0,3056,3057,5,200,0,0,
  	3057,3058,5,424,0,0,3058,3059,5,401,0,0,3059,3060,5,426,0,0,3060,3061,
  	3,210,105,0,3061,3062,5,426,0,0,3062,3063,3,210,105,0,3063,3064,5,425,
  	0,0,3064,3153,1,0,0,0,3065,3066,5,201,0,0,3066,3067,5,424,0,0,3067,3068,
  	5,401,0,0,3068,3069,5,426,0,0,3069,3070,3,210,105,0,3070,3071,5,425,0,
  	0,3071,3153,1,0,0,0,3072,3073,5,202,0,0,3073,3074,5,424,0,0,3074,3075,
  	5,401,0,0,3075,3076,5,426,0,0,3076,3077,3,210,105,0,3077,3078,5,425,0,
  	0,3078,3153,1,0,0,0,3079,3080,5,226,0,0,3080,3081,5,424,0,0,3081,3153,
  	5,425,0,0,3082,3083,5,227,0,0,3083,3084,5,424,0,0,3084,3153,5,425,0,0,
  	3085,3086,5,91,0,0,3086,3087,5,424,0,0,3087,3090,3,412,206,0,3088,3089,
  	5,426,0,0,3089,3091,5,400,0,0,3090,3088,1,0,0,0,3090,3091,1,0,0,0,3091,
  	3094,1,0,0,0,3092,3093,5,426,0,0,3093,3095,5,400,0,0,3094,3092,1,0,0,
  	0,3094,3095,1,0,0,0,3095,3096,1,0,0,0,3096,3097,5,425,0,0,3097,3153,1,
  	0,0,0,3098,3099,5,263,0,0,3099,3100,5,424,0,0,3100,3153,5,425,0,0,3101,
  	3102,5,109,0,0,3102,3103,5,424,0,0,3103,3104,3,210,105,0,3104,3105,5,
  	426,0,0,3105,3106,3,210,105,0,3106,3107,5,425,0,0,3107,3153,1,0,0,0,3108,
  	3109,5,331,0,0,3109,3110,5,424,0,0,3110,3111,3,210,105,0,3111,3112,5,
  	426,0,0,3112,3113,5,400,0,0,3113,3114,5,426,0,0,3114,3115,5,400,0,0,3115,
  	3116,5,426,0,0,3116,3117,3,210,105,0,3117,3118,5,425,0,0,3118,3153,1,
  	0,0,0,3119,3153,5,140,0,0,3120,3153,5,144,0,0,3121,3153,5,157,0,0,3122,
  	3123,5,374,0,0,3123,3124,5,424,0,0,3124,3125,3,210,105,0,3125,3126,5,
  	426,0,0,3126,3127,3,210,105,0,3127,3128,5,425,0,0,3128,3153,1,0,0,0,3129,
  	3130,5,372,0,0,3130,3131,5,424,0,0,3131,3132,3,234,117,0,3132,3133,5,
  	426,0,0,3133,3134,3,210,105,0,3134,3135,5,426,0,0,3135,3136,3,210,105,
  	0,3136,3137,5,425,0,0,3137,3153,1,0,0,0,3138,3139,5,330,0,0,3139,3140,
  	5,424,0,0,3140,3141,3,210,105,0,3141,3142,5,426,0,0,3142,3143,3,210,105,
  	0,3143,3150,5,425,0,0,3144,3145,5,164,0,0,3145,3146,5,88,0,0,3146,3147,
  	5,424,0,0,3147,3148,3,250,125,0,3148,3149,5,425,0,0,3149,3151,1,0,0,0,
  	3150,3144,1,0,0,0,3150,3151,1,0,0,0,3151,3153,1,0,0,0,3152,3007,1,0,0,
  	0,3152,3011,1,0,0,0,3152,3018,1,0,0,0,3152,3025,1,0,0,0,3152,3036,1,0,
  	0,0,3152,3040,1,0,0,0,3152,3045,1,0,0,0,3152,3046,1,0,0,0,3152,3047,1,
  	0,0,0,3152,3056,1,0,0,0,3152,3065,1,0,0,0,3152,3072,1,0,0,0,3152,3079,
  	1,0,0,0,3152,3082,1,0,0,0,3152,3085,1,0,0,0,3152,3098,1,0,0,0,3152,3101,
  	1,0,0,0,3152,3108,1,0,0,0,3152,3119,1,0,0,0,3152,3120,1,0,0,0,3152,3121,
  	1,0,0,0,3152,3122,1,0,0,0,3152,3129,1,0,0,0,3152,3138,1,0,0,0,3153,323,
  	1,0,0,0,3154,3161,5,399,0,0,3155,3161,3,422,211,0,3156,3157,5,424,0,0,
  	3157,3158,3,224,112,0,3158,3159,5,425,0,0,3159,3161,1,0,0,0,3160,3154,
  	1,0,0,0,3160,3155,1,0,0,0,3160,3156,1,0,0,0,3161,3162,1,0,0,0,3162,3163,
  	5,419,0,0,3163,3164,5,269,0,0,3164,3165,5,424,0,0,3165,3166,5,402,0,0,
  	3166,3167,5,425,0,0,3167,325,1,0,0,0,3168,3169,5,160,0,0,3169,3170,3,
  	210,105,0,3170,3171,5,146,0,0,3171,3172,3,210,105,0,3172,327,1,0,0,0,
  	3173,3174,5,160,0,0,3174,3175,3,234,117,0,3175,3176,5,146,0,0,3176,3177,
  	3,210,105,0,3177,329,1,0,0,0,3178,3180,5,35,0,0,3179,3178,1,0,0,0,3179,
  	3180,1,0,0,0,3180,3181,1,0,0,0,3181,3182,3,346,173,0,3182,331,1,0,0,0,
  	3183,3185,5,35,0,0,3184,3183,1,0,0,0,3184,3185,1,0,0,0,3185,3186,1,0,
  	0,0,3186,3187,3,334,167,0,3187,333,1,0,0,0,3188,3190,3,422,211,0,3189,
  	3191,3,336,168,0,3190,3189,1,0,0,0,3190,3191,1,0,0,0,3191,335,1,0,0,0,
  	3192,3194,5,163,0,0,3193,3192,1,0,0,0,3193,3194,1,0,0,0,3194,3195,1,0,
  	0,0,3195,3196,5,424,0,0,3196,3203,3,340,170,0,3197,3199,5,426,0,0,3198,
  	3197,1,0,0,0,3198,3199,1,0,0,0,3199,3200,1,0,0,0,3200,3202,3,340,170,
  	0,3201,3198,1,0,0,0,3202,3205,1,0,0,0,3203,3201,1,0,0,0,3203,3204,1,0,
  	0,0,3204,3206,1,0,0,0,3205,3203,1,0,0,0,3206,3207,5,425,0,0,3207,337,
  	1,0,0,0,3208,3209,5,163,0,0,3209,3210,5,424,0,0,3210,3217,3,340,170,0,
  	3211,3213,5,426,0,0,3212,3211,1,0,0,0,3212,3213,1,0,0,0,3213,3214,1,0,
  	0,0,3214,3216,3,340,170,0,3215,3212,1,0,0,0,3216,3219,1,0,0,0,3217,3215,
  	1,0,0,0,3217,3218,1,0,0,0,3218,3220,1,0,0,0,3219,3217,1,0,0,0,3220,3221,
  	5,425,0,0,3221,339,1,0,0,0,3222,3224,5,270,0,0,3223,3222,1,0,0,0,3223,
  	3224,1,0,0,0,3224,3274,1,0,0,0,3225,3245,5,95,0,0,3226,3227,5,424,0,0,
  	3227,3232,3,342,171,0,3228,3229,5,426,0,0,3229,3231,3,342,171,0,3230,
  	3228,1,0,0,0,3231,3234,1,0,0,0,3232,3230,1,0,0,0,3232,3233,1,0,0,0,3233,
  	3235,1,0,0,0,3234,3232,1,0,0,0,3235,3236,5,425,0,0,3236,3246,1,0,0,0,
  	3237,3242,3,342,171,0,3238,3239,5,426,0,0,3239,3241,3,342,171,0,3240,
  	3238,1,0,0,0,3241,3244,1,0,0,0,3242,3240,1,0,0,0,3242,3243,1,0,0,0,3243,
  	3246,1,0,0,0,3244,3242,1,0,0,0,3245,3226,1,0,0,0,3245,3237,1,0,0,0,3246,
  	3275,1,0,0,0,3247,3248,5,95,0,0,3248,3249,5,406,0,0,3249,3275,3,342,171,
  	0,3250,3265,5,371,0,0,3251,3252,5,424,0,0,3252,3253,3,342,171,0,3253,
  	3254,5,424,0,0,3254,3259,5,401,0,0,3255,3256,5,426,0,0,3256,3258,5,401,
  	0,0,3257,3255,1,0,0,0,3258,3261,1,0,0,0,3259,3257,1,0,0,0,3259,3260,1,
  	0,0,0,3260,3262,1,0,0,0,3261,3259,1,0,0,0,3262,3263,5,425,0,0,3263,3264,
  	5,425,0,0,3264,3266,1,0,0,0,3265,3251,1,0,0,0,3265,3266,1,0,0,0,3266,
  	3275,1,0,0,0,3267,3275,5,318,0,0,3268,3275,5,324,0,0,3269,3270,5,325,
  	0,0,3270,3271,5,406,0,0,3271,3275,5,400,0,0,3272,3275,5,90,0,0,3273,3275,
  	5,401,0,0,3274,3225,1,0,0,0,3274,3247,1,0,0,0,3274,3250,1,0,0,0,3274,
  	3267,1,0,0,0,3274,3268,1,0,0,0,3274,3269,1,0,0,0,3274,3272,1,0,0,0,3274,
  	3273,1,0,0,0,3275,341,1,0,0,0,3276,3279,3,422,211,0,3277,3279,5,400,0,
  	0,3278,3276,1,0,0,0,3278,3277,1,0,0,0,3279,343,1,0,0,0,3280,3281,5,424,
  	0,0,3281,3286,3,346,173,0,3282,3283,5,426,0,0,3283,3285,3,346,173,0,3284,
  	3282,1,0,0,0,3285,3288,1,0,0,0,3286,3284,1,0,0,0,3286,3287,1,0,0,0,3287,
  	3289,1,0,0,0,3288,3286,1,0,0,0,3289,3290,5,425,0,0,3290,345,1,0,0,0,3291,
  	3294,3,422,211,0,3292,3294,5,402,0,0,3293,3291,1,0,0,0,3293,3292,1,0,
  	0,0,3294,347,1,0,0,0,3295,3296,5,158,0,0,3296,3297,5,424,0,0,3297,3298,
  	3,350,175,0,3298,3306,5,425,0,0,3299,3300,5,426,0,0,3300,3301,5,424,0,
  	0,3301,3302,3,350,175,0,3302,3303,5,425,0,0,3303,3305,1,0,0,0,3304,3299,
  	1,0,0,0,3305,3308,1,0,0,0,3306,3304,1,0,0,0,3306,3307,1,0,0,0,3307,349,
  	1,0,0,0,3308,3306,1,0,0,0,3309,3314,3,210,105,0,3310,3311,5,426,0,0,3311,
  	3313,3,210,105,0,3312,3310,1,0,0,0,3313,3316,1,0,0,0,3314,3312,1,0,0,
  	0,3314,3315,1,0,0,0,3315,351,1,0,0,0,3316,3314,1,0,0,0,3317,3318,7,43,
  	0,0,3318,3319,5,424,0,0,3319,3320,5,425,0,0,3320,3328,3,360,180,0,3321,
  	3322,5,272,0,0,3322,3323,5,424,0,0,3323,3324,3,210,105,0,3324,3325,5,
  	425,0,0,3325,3326,3,360,180,0,3326,3328,1,0,0,0,3327,3317,1,0,0,0,3327,
  	3321,1,0,0,0,3328,353,1,0,0,0,3329,3330,7,44,0,0,3330,3331,5,424,0,0,
  	3331,3332,3,358,179,0,3332,3334,5,425,0,0,3333,3335,3,360,180,0,3334,
  	3333,1,0,0,0,3334,3335,1,0,0,0,3335,3362,1,0,0,0,3336,3337,7,45,0,0,3337,
  	3340,5,424,0,0,3338,3341,5,430,0,0,3339,3341,3,358,179,0,3340,3338,1,
  	0,0,0,3340,3339,1,0,0,0,3341,3342,1,0,0,0,3342,3344,5,425,0,0,3343,3345,
  	3,360,180,0,3344,3343,1,0,0,0,3344,3345,1,0,0,0,3345,3362,1,0,0,0,3346,
  	3347,5,189,0,0,3347,3348,5,424,0,0,3348,3349,3,358,179,0,3349,3350,5,
  	425,0,0,3350,3362,1,0,0,0,3351,3352,5,231,0,0,3352,3353,5,424,0,0,3353,
  	3354,3,210,105,0,3354,3355,5,425,0,0,3355,3362,1,0,0,0,3356,3357,5,232,
  	0,0,3357,3358,5,424,0,0,3358,3359,3,350,175,0,3359,3360,5,425,0,0,3360,
  	3362,1,0,0,0,3361,3329,1,0,0,0,3361,3336,1,0,0,0,3361,3346,1,0,0,0,3361,
  	3351,1,0,0,0,3361,3356,1,0,0,0,3362,355,1,0,0,0,3363,3364,7,46,0,0,3364,
  	3365,5,424,0,0,3365,3366,3,210,105,0,3366,3367,5,425,0,0,3367,3368,3,
  	360,180,0,3368,3420,1,0,0,0,3369,3370,7,47,0,0,3370,3371,5,424,0,0,3371,
  	3378,3,210,105,0,3372,3373,5,426,0,0,3373,3376,3,210,105,0,3374,3375,
  	5,426,0,0,3375,3377,3,210,105,0,3376,3374,1,0,0,0,3376,3377,1,0,0,0,3377,
  	3379,1,0,0,0,3378,3372,1,0,0,0,3378,3379,1,0,0,0,3379,3380,1,0,0,0,3380,
  	3381,5,425,0,0,3381,3382,3,360,180,0,3382,3420,1,0,0,0,3383,3384,7,48,
  	0,0,3384,3385,5,424,0,0,3385,3386,5,425,0,0,3386,3387,5,118,0,0,3387,
  	3391,5,424,0,0,3388,3389,5,285,0,0,3389,3390,5,42,0,0,3390,3392,3,350,
  	175,0,3391,3388,1,0,0,0,3391,3392,1,0,0,0,3392,3393,1,0,0,0,3393,3394,
  	3,250,125,0,3394,3395,5,425,0,0,3395,3420,1,0,0,0,3396,3397,7,49,0,0,
  	3397,3398,5,424,0,0,3398,3399,3,210,105,0,3399,3400,5,425,0,0,3400,3401,
  	5,164,0,0,3401,3402,5,88,0,0,3402,3403,5,424,0,0,3403,3404,5,116,0,0,
  	3404,3405,5,42,0,0,3405,3407,3,210,105,0,3406,3408,7,50,0,0,3407,3406,
  	1,0,0,0,3407,3408,1,0,0,0,3408,3409,1,0,0,0,3409,3410,5,425,0,0,3410,
  	3411,5,118,0,0,3411,3415,5,424,0,0,3412,3413,5,285,0,0,3413,3414,5,42,
  	0,0,3414,3416,3,350,175,0,3415,3412,1,0,0,0,3415,3416,1,0,0,0,3416,3417,
  	1,0,0,0,3417,3418,5,425,0,0,3418,3420,1,0,0,0,3419,3363,1,0,0,0,3419,
  	3369,1,0,0,0,3419,3383,1,0,0,0,3419,3396,1,0,0,0,3420,357,1,0,0,0,3421,
  	3423,7,30,0,0,3422,3421,1,0,0,0,3422,3423,1,0,0,0,3423,3424,1,0,0,0,3424,
  	3425,3,210,105,0,3425,359,1,0,0,0,3426,3427,5,118,0,0,3427,3431,5,424,
  	0,0,3428,3429,5,285,0,0,3429,3430,5,42,0,0,3430,3432,3,350,175,0,3431,
  	3428,1,0,0,0,3431,3432,1,0,0,0,3432,3434,1,0,0,0,3433,3435,3,250,125,
  	0,3434,3433,1,0,0,0,3434,3435,1,0,0,0,3435,3437,1,0,0,0,3436,3438,3,362,
  	181,0,3437,3436,1,0,0,0,3437,3438,1,0,0,0,3438,3439,1,0,0,0,3439,3440,
  	5,425,0,0,3440,361,1,0,0,0,3441,3442,7,51,0,0,3442,3443,3,364,182,0,3443,
  	363,1,0,0,0,3444,3451,3,368,184,0,3445,3446,5,40,0,0,3446,3447,3,366,
  	183,0,3447,3448,5,33,0,0,3448,3449,3,366,183,0,3449,3451,1,0,0,0,3450,
  	3444,1,0,0,0,3450,3445,1,0,0,0,3451,365,1,0,0,0,3452,3455,3,368,184,0,
  	3453,3455,3,370,185,0,3454,3452,1,0,0,0,3454,3453,1,0,0,0,3455,367,1,
  	0,0,0,3456,3457,5,346,0,0,3457,3463,5,290,0,0,3458,3459,5,400,0,0,3459,
  	3463,5,290,0,0,3460,3461,5,56,0,0,3461,3463,5,307,0,0,3462,3456,1,0,0,
  	0,3462,3458,1,0,0,0,3462,3460,1,0,0,0,3463,369,1,0,0,0,3464,3465,5,346,
  	0,0,3465,3469,5,222,0,0,3466,3467,5,400,0,0,3467,3469,5,222,0,0,3468,
  	3464,1,0,0,0,3468,3466,1,0,0,0,3469,371,1,0,0,0,3470,3471,3,422,211,0,
  	3471,3472,5,419,0,0,3472,3473,3,422,211,0,3473,3474,5,419,0,0,3474,3475,
  	3,422,211,0,3475,3476,5,419,0,0,3476,3488,1,0,0,0,3477,3478,3,422,211,
  	0,3478,3480,5,419,0,0,3479,3481,3,422,211,0,3480,3479,1,0,0,0,3480,3481,
  	1,0,0,0,3481,3482,1,0,0,0,3482,3483,5,419,0,0,3483,3488,1,0,0,0,3484,
  	3485,3,422,211,0,3485,3486,5,419,0,0,3486,3488,1,0,0,0,3487,3470,1,0,
  	0,0,3487,3477,1,0,0,0,3487,3484,1,0,0,0,3487,3488,1,0,0,0,3488,3489,1,
  	0,0,0,3489,3490,3,422,211,0,3490,373,1,0,0,0,3491,3497,3,422,211,0,3492,
  	3493,3,422,211,0,3493,3494,5,419,0,0,3494,3495,3,422,211,0,3495,3497,
  	1,0,0,0,3496,3491,1,0,0,0,3496,3492,1,0,0,0,3497,375,1,0,0,0,3498,3504,
  	3,422,211,0,3499,3500,3,422,211,0,3500,3501,5,419,0,0,3501,3502,3,422,
  	211,0,3502,3504,1,0,0,0,3503,3498,1,0,0,0,3503,3499,1,0,0,0,3504,377,
  	1,0,0,0,3505,3506,3,422,211,0,3506,3507,5,419,0,0,3507,3508,3,422,211,
  	0,3508,3509,5,419,0,0,3509,3510,3,422,211,0,3510,3511,5,419,0,0,3511,
  	3523,1,0,0,0,3512,3513,3,422,211,0,3513,3515,5,419,0,0,3514,3516,3,422,
  	211,0,3515,3514,1,0,0,0,3515,3516,1,0,0,0,3516,3517,1,0,0,0,3517,3518,
  	5,419,0,0,3518,3523,1,0,0,0,3519,3520,3,422,211,0,3520,3521,5,419,0,0,
  	3521,3523,1,0,0,0,3522,3505,1,0,0,0,3522,3512,1,0,0,0,3522,3519,1,0,0,
  	0,3522,3523,1,0,0,0,3523,3524,1,0,0,0,3524,3525,3,422,211,0,3525,379,
  	1,0,0,0,3526,3554,5,399,0,0,3527,3528,3,422,211,0,3528,3530,5,419,0,0,
  	3529,3531,3,422,211,0,3530,3529,1,0,0,0,3530,3531,1,0,0,0,3531,3532,1,
  	0,0,0,3532,3533,5,419,0,0,3533,3538,1,0,0,0,3534,3535,3,422,211,0,3535,
  	3536,5,419,0,0,3536,3538,1,0,0,0,3537,3527,1,0,0,0,3537,3534,1,0,0,0,
  	3537,3538,1,0,0,0,3538,3539,1,0,0,0,3539,3554,3,422,211,0,3540,3541,3,
  	422,211,0,3541,3543,5,419,0,0,3542,3544,3,422,211,0,3543,3542,1,0,0,0,
  	3543,3544,1,0,0,0,3544,3545,1,0,0,0,3545,3546,5,419,0,0,3546,3551,1,0,
  	0,0,3547,3548,3,422,211,0,3548,3549,5,419,0,0,3549,3551,1,0,0,0,3550,
  	3540,1,0,0,0,3550,3547,1,0,0,0,3550,3551,1,0,0,0,3551,3552,1,0,0,0,3552,
  	3554,5,359,0,0,3553,3526,1,0,0,0,3553,3537,1,0,0,0,3553,3550,1,0,0,0,
  	3554,381,1,0,0,0,3555,3556,3,422,211,0,3556,3557,5,419,0,0,3557,3559,
  	1,0,0,0,3558,3555,1,0,0,0,3558,3559,1,0,0,0,3559,3560,1,0,0,0,3560,3561,
  	3,422,211,0,3561,383,1,0,0,0,3562,3563,3,422,211,0,3563,3564,5,419,0,
  	0,3564,3566,1,0,0,0,3565,3562,1,0,0,0,3565,3566,1,0,0,0,3566,3567,1,0,
  	0,0,3567,3568,3,422,211,0,3568,385,1,0,0,0,3569,3571,3,422,211,0,3570,
  	3569,1,0,0,0,3570,3571,1,0,0,0,3571,3572,1,0,0,0,3572,3574,5,419,0,0,
  	3573,3575,3,422,211,0,3574,3573,1,0,0,0,3574,3575,1,0,0,0,3575,3576,1,
  	0,0,0,3576,3577,5,419,0,0,3577,3580,3,422,211,0,3578,3580,3,384,192,0,
  	3579,3570,1,0,0,0,3579,3578,1,0,0,0,3580,387,1,0,0,0,3581,3583,3,422,
  	211,0,3582,3581,1,0,0,0,3582,3583,1,0,0,0,3583,3584,1,0,0,0,3584,3586,
  	5,419,0,0,3585,3587,3,422,211,0,3586,3585,1,0,0,0,3586,3587,1,0,0,0,3587,
  	3588,1,0,0,0,3588,3590,5,419,0,0,3589,3591,3,422,211,0,3590,3589,1,0,
  	0,0,3590,3591,1,0,0,0,3591,3592,1,0,0,0,3592,3593,5,419,0,0,3593,3596,
  	3,422,211,0,3594,3596,3,386,193,0,3595,3582,1,0,0,0,3595,3594,1,0,0,0,
  	3596,389,1,0,0,0,3597,3600,3,378,189,0,3598,3600,5,399,0,0,3599,3597,
  	1,0,0,0,3599,3598,1,0,0,0,3600,391,1,0,0,0,3601,3602,7,38,0,0,3602,3603,
  	5,419,0,0,3603,3633,3,422,211,0,3604,3606,3,422,211,0,3605,3604,1,0,0,
  	0,3605,3606,1,0,0,0,3606,3607,1,0,0,0,3607,3609,5,419,0,0,3608,3610,3,
  	422,211,0,3609,3608,1,0,0,0,3609,3610,1,0,0,0,3610,3611,1,0,0,0,3611,
  	3613,5,419,0,0,3612,3614,3,422,211,0,3613,3612,1,0,0,0,3613,3614,1,0,
  	0,0,3614,3615,1,0,0,0,3615,3616,5,419,0,0,3616,3633,3,422,211,0,3617,
  	3619,3,422,211,0,3618,3617,1,0,0,0,3618,3619,1,0,0,0,3619,3620,1,0,0,
  	0,3620,3622,5,419,0,0,3621,3623,3,422,211,0,3622,3621,1,0,0,0,3622,3623,
  	1,0,0,0,3623,3624,1,0,0,0,3624,3625,5,419,0,0,3625,3633,3,422,211,0,3626,
  	3628,3,422,211,0,3627,3626,1,0,0,0,3627,3628,1,0,0,0,3628,3629,1,0,0,
  	0,3629,3630,5,419,0,0,3630,3633,3,422,211,0,3631,3633,3,422,211,0,3632,
  	3601,1,0,0,0,3632,3605,1,0,0,0,3632,3618,1,0,0,0,3632,3627,1,0,0,0,3632,
  	3631,1,0,0,0,3633,393,1,0,0,0,3634,3636,3,422,211,0,3635,3637,7,50,0,
  	0,3636,3635,1,0,0,0,3636,3637,1,0,0,0,3637,3645,1,0,0,0,3638,3639,5,426,
  	0,0,3639,3641,3,422,211,0,3640,3642,7,50,0,0,3641,3640,1,0,0,0,3641,3642,
  	1,0,0,0,3642,3644,1,0,0,0,3643,3638,1,0,0,0,3644,3647,1,0,0,0,3645,3643,
  	1,0,0,0,3645,3646,1,0,0,0,3646,395,1,0,0,0,3647,3645,1,0,0,0,3648,3653,
  	3,398,199,0,3649,3650,5,426,0,0,3650,3652,3,398,199,0,3651,3649,1,0,0,
  	0,3652,3655,1,0,0,0,3653,3651,1,0,0,0,3653,3654,1,0,0,0,3654,397,1,0,
  	0,0,3655,3653,1,0,0,0,3656,3658,3,422,211,0,3657,3656,1,0,0,0,3657,3658,
  	1,0,0,0,3658,3659,1,0,0,0,3659,3661,5,419,0,0,3660,3657,1,0,0,0,3661,
  	3664,1,0,0,0,3662,3660,1,0,0,0,3662,3663,1,0,0,0,3663,3665,1,0,0,0,3664,
  	3662,1,0,0,0,3665,3666,3,422,211,0,3666,399,1,0,0,0,3667,3672,3,422,211,
  	0,3668,3669,5,426,0,0,3669,3671,3,422,211,0,3670,3668,1,0,0,0,3671,3674,
  	1,0,0,0,3672,3670,1,0,0,0,3672,3673,1,0,0,0,3673,401,1,0,0,0,3674,3672,
  	1,0,0,0,3675,3678,3,422,211,0,3676,3678,5,399,0,0,3677,3675,1,0,0,0,3677,
  	3676,1,0,0,0,3678,403,1,0,0,0,3679,3680,7,18,0,0,3680,405,1,0,0,0,3681,
  	3683,5,107,0,0,3682,3681,1,0,0,0,3682,3683,1,0,0,0,3683,3684,1,0,0,0,
  	3684,3685,5,108,0,0,3685,407,1,0,0,0,3686,3698,3,406,203,0,3687,3688,
  	5,66,0,0,3688,3691,3,222,111,0,3689,3690,5,47,0,0,3690,3692,3,422,211,
  	0,3691,3689,1,0,0,0,3691,3692,1,0,0,0,3692,3695,1,0,0,0,3693,3694,5,163,
  	0,0,3694,3696,5,158,0,0,3695,3693,1,0,0,0,3695,3696,1,0,0,0,3696,3698,
  	1,0,0,0,3697,3686,1,0,0,0,3697,3687,1,0,0,0,3698,409,1,0,0,0,3699,3732,
  	3,388,194,0,3700,3732,5,133,0,0,3701,3732,5,104,0,0,3702,3732,5,183,0,
  	0,3703,3732,5,188,0,0,3704,3732,5,1,0,0,3705,3732,5,2,0,0,3706,3732,5,
  	3,0,0,3707,3732,5,4,0,0,3708,3732,5,5,0,0,3709,3732,5,6,0,0,3710,3732,
  	5,7,0,0,3711,3732,5,8,0,0,3712,3732,5,9,0,0,3713,3732,5,10,0,0,3714,3732,
  	5,11,0,0,3715,3732,5,12,0,0,3716,3732,5,13,0,0,3717,3732,5,14,0,0,3718,
  	3732,5,15,0,0,3719,3732,5,16,0,0,3720,3732,5,17,0,0,3721,3732,5,18,0,
  	0,3722,3732,5,19,0,0,3723,3732,5,20,0,0,3724,3732,5,21,0,0,3725,3732,
  	5,393,0,0,3726,3732,5,23,0,0,3727,3732,5,24,0,0,3728,3732,5,25,0,0,3729,
  	3732,5,26,0,0,3730,3732,5,27,0,0,3731,3699,1,0,0,0,3731,3700,1,0,0,0,
  	3731,3701,1,0,0,0,3731,3702,1,0,0,0,3731,3703,1,0,0,0,3731,3704,1,0,0,
  	0,3731,3705,1,0,0,0,3731,3706,1,0,0,0,3731,3707,1,0,0,0,3731,3708,1,0,
  	0,0,3731,3709,1,0,0,0,3731,3710,1,0,0,0,3731,3711,1,0,0,0,3731,3712,1,
  	0,0,0,3731,3713,1,0,0,0,3731,3714,1,0,0,0,3731,3715,1,0,0,0,3731,3716,
  	1,0,0,0,3731,3717,1,0,0,0,3731,3718,1,0,0,0,3731,3719,1,0,0,0,3731,3720,
  	1,0,0,0,3731,3721,1,0,0,0,3731,3722,1,0,0,0,3731,3723,1,0,0,0,3731,3724,
  	1,0,0,0,3731,3725,1,0,0,0,3731,3726,1,0,0,0,3731,3727,1,0,0,0,3731,3728,
  	1,0,0,0,3731,3729,1,0,0,0,3731,3730,1,0,0,0,3732,411,1,0,0,0,3733,3734,
  	7,52,0,0,3734,3735,5,424,0,0,3735,3736,5,259,0,0,3736,3764,5,425,0,0,
  	3737,3738,3,422,211,0,3738,3739,5,424,0,0,3739,3740,5,400,0,0,3740,3741,
  	5,426,0,0,3741,3742,5,400,0,0,3742,3743,5,425,0,0,3743,3764,1,0,0,0,3744,
  	3745,3,422,211,0,3745,3746,5,424,0,0,3746,3747,5,400,0,0,3747,3748,5,
  	425,0,0,3748,3764,1,0,0,0,3749,3750,3,422,211,0,3750,3756,5,91,0,0,3751,
  	3752,5,424,0,0,3752,3753,5,400,0,0,3753,3754,5,426,0,0,3754,3755,5,400,
  	0,0,3755,3757,5,425,0,0,3756,3751,1,0,0,0,3756,3757,1,0,0,0,3757,3764,
  	1,0,0,0,3758,3760,5,71,0,0,3759,3761,5,122,0,0,3760,3759,1,0,0,0,3760,
  	3761,1,0,0,0,3761,3764,1,0,0,0,3762,3764,3,422,211,0,3763,3733,1,0,0,
  	0,3763,3737,1,0,0,0,3763,3744,1,0,0,0,3763,3749,1,0,0,0,3763,3758,1,0,
  	0,0,3763,3762,1,0,0,0,3764,413,1,0,0,0,3765,3769,5,108,0,0,3766,3769,
  	5,66,0,0,3767,3769,3,416,208,0,3768,3765,1,0,0,0,3768,3766,1,0,0,0,3768,
  	3767,1,0,0,0,3769,415,1,0,0,0,3770,3786,5,402,0,0,3771,3786,5,403,0,0,
  	3772,3774,3,418,209,0,3773,3772,1,0,0,0,3773,3774,1,0,0,0,3774,3775,1,
  	0,0,0,3775,3786,5,400,0,0,3776,3778,3,418,209,0,3777,3776,1,0,0,0,3777,
  	3778,1,0,0,0,3778,3779,1,0,0,0,3779,3786,7,53,0,0,3780,3782,3,418,209,
  	0,3781,3780,1,0,0,0,3781,3782,1,0,0,0,3782,3783,1,0,0,0,3783,3784,5,423,
  	0,0,3784,3786,7,54,0,0,3785,3770,1,0,0,0,3785,3771,1,0,0,0,3785,3773,
  	1,0,0,0,3785,3777,1,0,0,0,3785,3781,1,0,0,0,3786,417,1,0,0,0,3787,3788,
  	7,28,0,0,3788,419,1,0,0,0,3789,3790,7,55,0,0,3790,421,1,0,0,0,3791,3796,
  	5,401,0,0,3792,3796,5,396,0,0,3793,3796,5,398,0,0,3794,3796,3,420,210,
  	0,3795,3791,1,0,0,0,3795,3792,1,0,0,0,3795,3793,1,0,0,0,3795,3794,1,0,
  	0,0,3796,423,1,0,0,0,3797,3798,5,401,0,0,3798,425,1,0,0,0,3799,3802,3,
  	422,211,0,3800,3802,5,402,0,0,3801,3799,1,0,0,0,3801,3800,1,0,0,0,3802,
  	427,1,0,0,0,3803,3819,5,406,0,0,3804,3819,5,407,0,0,3805,3819,5,408,0,
  	0,3806,3807,5,408,0,0,3807,3819,5,406,0,0,3808,3809,5,407,0,0,3809,3819,
  	5,406,0,0,3810,3811,5,408,0,0,3811,3819,5,407,0,0,3812,3813,5,409,0,0,
  	3813,3819,5,406,0,0,3814,3815,5,409,0,0,3815,3819,5,407,0,0,3816,3817,
  	5,409,0,0,3817,3819,5,408,0,0,3818,3803,1,0,0,0,3818,3804,1,0,0,0,3818,
  	3805,1,0,0,0,3818,3806,1,0,0,0,3818,3808,1,0,0,0,3818,3810,1,0,0,0,3818,
  	3812,1,0,0,0,3818,3814,1,0,0,0,3818,3816,1,0,0,0,3819,429,1,0,0,0,3820,
  	3821,7,56,0,0,3821,431,1,0,0,0,550,435,443,448,452,458,460,465,472,476,
  	480,484,488,492,496,500,504,507,514,525,539,543,548,553,557,561,566,571,
  	573,577,580,587,590,599,602,613,618,623,628,633,639,643,646,650,653,656,
  	663,667,669,674,680,684,697,703,706,715,718,730,753,756,766,772,776,780,
  	787,793,795,800,806,812,817,823,830,835,840,845,848,852,856,860,864,869,
  	873,877,880,888,890,893,897,900,909,912,915,923,929,936,940,951,957,959,
  	968,972,979,984,987,995,999,1002,1006,1009,1013,1020,1024,1026,1028,1031,
  	1034,1039,1042,1050,1052,1055,1059,1065,1068,1077,1080,1087,1093,1097,
  	1107,1110,1113,1119,1122,1125,1129,1132,1140,1142,1146,1154,1158,1162,
  	1169,1173,1175,1177,1180,1183,1191,1197,1203,1205,1209,1212,1217,1220,
  	1226,1229,1236,1240,1242,1250,1253,1257,1263,1269,1272,1282,1289,1294,
  	1297,1307,1310,1313,1321,1332,1335,1338,1344,1349,1353,1363,1366,1369,
  	1375,1381,1387,1392,1396,1400,1403,1408,1422,1430,1435,1440,1446,1451,
  	1454,1463,1473,1476,1499,1526,1529,1537,1543,1550,1554,1560,1567,1571,
  	1577,1581,1586,1590,1598,1602,1604,1608,1612,1616,1619,1623,1629,1633,
  	1635,1640,1644,1648,1655,1660,1668,1671,1674,1678,1682,1685,1693,1698,
  	1705,1713,1716,1727,1732,1742,1747,1754,1767,1769,1771,1774,1777,1784,
  	1787,1793,1798,1800,1803,1809,1817,1819,1822,1826,1829,1839,1842,1846,
  	1849,1855,1858,1860,1864,1868,1873,1878,1888,1891,1894,1902,1906,1909,
  	1913,1918,1926,1931,1940,1945,1950,1957,1959,1963,1966,1970,1974,1982,
  	1987,1989,1992,1997,2002,2007,2010,2016,2024,2033,2037,2042,2048,2052,
  	2058,2066,2072,2074,2077,2092,2094,2103,2110,2117,2127,2129,2131,2134,
  	2137,2148,2150,2152,2155,2160,2171,2180,2183,2186,2195,2198,2201,2208,
  	2211,2217,2232,2235,2242,2247,2251,2262,2275,2277,2289,2296,2300,2308,
  	2312,2316,2322,2332,2342,2352,2360,2372,2378,2382,2392,2396,2400,2410,
  	2416,2424,2432,2434,2457,2469,2476,2484,2491,2497,2504,2508,2513,2515,
  	2519,2523,2530,2534,2537,2542,2546,2550,2555,2562,2565,2569,2574,2578,
  	2587,2594,2603,2615,2617,2622,2633,2664,2680,2687,2689,2696,2705,2713,
  	2719,2727,2730,2737,2743,2746,2748,2756,2758,2766,2770,2777,2785,2791,
  	2800,2803,2807,2811,2815,2822,2824,2828,2833,2835,2840,2842,2849,2851,
  	2856,2858,2865,2871,2875,2900,2903,2907,2909,2912,2958,2963,2979,2988,
  	2993,2998,3032,3090,3094,3150,3152,3160,3179,3184,3190,3193,3198,3203,
  	3212,3217,3223,3232,3242,3245,3259,3265,3274,3278,3286,3293,3306,3314,
  	3327,3334,3340,3344,3361,3376,3378,3391,3407,3415,3419,3422,3431,3434,
  	3437,3450,3454,3462,3468,3480,3487,3496,3503,3515,3522,3530,3537,3543,
  	3550,3553,3558,3565,3570,3574,3579,3582,3586,3590,3595,3599,3605,3609,
  	3613,3618,3622,3627,3632,3636,3641,3645,3653,3657,3662,3672,3677,3682,
  	3691,3695,3697,3731,3756,3760,3763,3768,3773,3777,3781,3785,3795,3801,
  	3818
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  tsqlparserParserStaticData = staticData.release();
}

}

TSqlParser::TSqlParser(TokenStream *input) : TSqlParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

TSqlParser::TSqlParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  TSqlParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *tsqlparserParserStaticData->atn, tsqlparserParserStaticData->decisionToDFA, tsqlparserParserStaticData->sharedContextCache, options);
}

TSqlParser::~TSqlParser() {
  delete _interpreter;
}

const atn::ATN& TSqlParser::getATN() const {
  return *tsqlparserParserStaticData->atn;
}

std::string TSqlParser::getGrammarFileName() const {
  return "TSqlParser.g4";
}

const std::vector<std::string>& TSqlParser::getRuleNames() const {
  return tsqlparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& TSqlParser::getVocabulary() const {
  return tsqlparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView TSqlParser::getSerializedATN() const {
  return tsqlparserParserStaticData->serializedATN;
}


//----------------- Tsql_fileContext ------------------------------------------------------------------

TSqlParser::Tsql_fileContext::Tsql_fileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Tsql_fileContext::EOF() {
  return getToken(TSqlParser::EOF, 0);
}

std::vector<TSqlParser::BatchContext *> TSqlParser::Tsql_fileContext::batch() {
  return getRuleContexts<TSqlParser::BatchContext>();
}

TSqlParser::BatchContext* TSqlParser::Tsql_fileContext::batch(size_t i) {
  return getRuleContext<TSqlParser::BatchContext>(i);
}

TSqlParser::Execute_body_batchContext* TSqlParser::Tsql_fileContext::execute_body_batch() {
  return getRuleContext<TSqlParser::Execute_body_batchContext>(0);
}

std::vector<TSqlParser::Go_batch_statementContext *> TSqlParser::Tsql_fileContext::go_batch_statement() {
  return getRuleContexts<TSqlParser::Go_batch_statementContext>();
}

TSqlParser::Go_batch_statementContext* TSqlParser::Tsql_fileContext::go_batch_statement(size_t i) {
  return getRuleContext<TSqlParser::Go_batch_statementContext>(i);
}


size_t TSqlParser::Tsql_fileContext::getRuleIndex() const {
  return TSqlParser::RuleTsql_file;
}

void TSqlParser::Tsql_fileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsql_file(this);
}

void TSqlParser::Tsql_fileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsql_file(this);
}

TSqlParser::Tsql_fileContext* TSqlParser::tsql_file() {
  Tsql_fileContext *_localctx = _tracker.createInstance<Tsql_fileContext>(_ctx, getState());
  enterRule(_localctx, 0, TSqlParser::RuleTsql_file);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(448);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(435);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -9200253150513037296) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -7781652249205111797) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & -27865903799) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 195)) & -1) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & -17) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 323)) & 6917346474351132671) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 387)) & 1241245567543) != 0)) {
        setState(432);
        batch();
        setState(437);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(438);
      match(TSqlParser::EOF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(439);
      execute_body_batch();
      setState(443);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::GO_BATCH) {
        setState(440);
        go_batch_statement();
        setState(445);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(446);
      match(TSqlParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BatchContext ------------------------------------------------------------------

TSqlParser::BatchContext::BatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Go_batch_statementContext* TSqlParser::BatchContext::go_batch_statement() {
  return getRuleContext<TSqlParser::Go_batch_statementContext>(0);
}

TSqlParser::Execute_body_batchContext* TSqlParser::BatchContext::execute_body_batch() {
  return getRuleContext<TSqlParser::Execute_body_batchContext>(0);
}

std::vector<TSqlParser::Go_statementContext *> TSqlParser::BatchContext::go_statement() {
  return getRuleContexts<TSqlParser::Go_statementContext>();
}

TSqlParser::Go_statementContext* TSqlParser::BatchContext::go_statement(size_t i) {
  return getRuleContext<TSqlParser::Go_statementContext>(i);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::BatchContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::BatchContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

TSqlParser::Batch_level_statementContext* TSqlParser::BatchContext::batch_level_statement() {
  return getRuleContext<TSqlParser::Batch_level_statementContext>(0);
}


size_t TSqlParser::BatchContext::getRuleIndex() const {
  return TSqlParser::RuleBatch;
}

void TSqlParser::BatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBatch(this);
}

void TSqlParser::BatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBatch(this);
}

TSqlParser::BatchContext* TSqlParser::batch() {
  BatchContext *_localctx = _tracker.createInstance<BatchContext>(_ctx, getState());
  enterRule(_localctx, 2, TSqlParser::RuleBatch);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(476);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(450);
      go_batch_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(452);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
      case 1: {
        setState(451);
        execute_body_batch();
        break;
      }

      default:
        break;
      }
      setState(460);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
      case 1: {
        setState(454);
        go_batch_statement();
        break;
      }

      case 2: {
        setState(456); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(455);
                  sql_clauses();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(458); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      default:
        break;
      }
      setState(465);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(462);
          go_statement(); 
        }
        setState(467);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(468);
      batch_level_statement();
      setState(472);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(469);
          go_statement(); 
        }
        setState(474);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(475);
      go_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Batch_level_statementContext ------------------------------------------------------------------

TSqlParser::Batch_level_statementContext::Batch_level_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Create_or_alter_functionContext* TSqlParser::Batch_level_statementContext::create_or_alter_function() {
  return getRuleContext<TSqlParser::Create_or_alter_functionContext>(0);
}

TSqlParser::Create_or_alter_procedureContext* TSqlParser::Batch_level_statementContext::create_or_alter_procedure() {
  return getRuleContext<TSqlParser::Create_or_alter_procedureContext>(0);
}


size_t TSqlParser::Batch_level_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBatch_level_statement;
}

void TSqlParser::Batch_level_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBatch_level_statement(this);
}

void TSqlParser::Batch_level_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBatch_level_statement(this);
}

TSqlParser::Batch_level_statementContext* TSqlParser::batch_level_statement() {
  Batch_level_statementContext *_localctx = _tracker.createInstance<Batch_level_statementContext>(_ctx, getState());
  enterRule(_localctx, 4, TSqlParser::RuleBatch_level_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(480);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(478);
      create_or_alter_function();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(479);
      create_or_alter_procedure();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_clausesContext ------------------------------------------------------------------

TSqlParser::Sql_clausesContext::Sql_clausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Dml_clauseContext* TSqlParser::Sql_clausesContext::dml_clause() {
  return getRuleContext<TSqlParser::Dml_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Sql_clausesContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Cfl_statementContext* TSqlParser::Sql_clausesContext::cfl_statement() {
  return getRuleContext<TSqlParser::Cfl_statementContext>(0);
}

TSqlParser::Another_statementContext* TSqlParser::Sql_clausesContext::another_statement() {
  return getRuleContext<TSqlParser::Another_statementContext>(0);
}

TSqlParser::Ddl_clauseContext* TSqlParser::Sql_clausesContext::ddl_clause() {
  return getRuleContext<TSqlParser::Ddl_clauseContext>(0);
}

TSqlParser::Dbcc_specialContext* TSqlParser::Sql_clausesContext::dbcc_special() {
  return getRuleContext<TSqlParser::Dbcc_specialContext>(0);
}

TSqlParser::Dbcc_clauseContext* TSqlParser::Sql_clausesContext::dbcc_clause() {
  return getRuleContext<TSqlParser::Dbcc_clauseContext>(0);
}


size_t TSqlParser::Sql_clausesContext::getRuleIndex() const {
  return TSqlParser::RuleSql_clauses;
}

void TSqlParser::Sql_clausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_clauses(this);
}

void TSqlParser::Sql_clausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_clauses(this);
}

TSqlParser::Sql_clausesContext* TSqlParser::sql_clauses() {
  Sql_clausesContext *_localctx = _tracker.createInstance<Sql_clausesContext>(_ctx, getState());
  enterRule(_localctx, 6, TSqlParser::RuleSql_clauses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(507);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(482);
      dml_clause();
      setState(484);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
      case 1: {
        setState(483);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(486);
      cfl_statement();
      setState(488);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
      case 1: {
        setState(487);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(490);
      another_statement();
      setState(492);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
      case 1: {
        setState(491);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(494);
      ddl_clause();
      setState(496);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
      case 1: {
        setState(495);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(498);
      dbcc_special();
      setState(500);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
      case 1: {
        setState(499);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(502);
      dbcc_clause();
      setState(504);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
      case 1: {
        setState(503);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(506);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dml_clauseContext ------------------------------------------------------------------

TSqlParser::Dml_clauseContext::Dml_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Merge_statementContext* TSqlParser::Dml_clauseContext::merge_statement() {
  return getRuleContext<TSqlParser::Merge_statementContext>(0);
}

TSqlParser::Delete_statementContext* TSqlParser::Dml_clauseContext::delete_statement() {
  return getRuleContext<TSqlParser::Delete_statementContext>(0);
}

TSqlParser::Insert_statementContext* TSqlParser::Dml_clauseContext::insert_statement() {
  return getRuleContext<TSqlParser::Insert_statementContext>(0);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Dml_clauseContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

TSqlParser::Update_statementContext* TSqlParser::Dml_clauseContext::update_statement() {
  return getRuleContext<TSqlParser::Update_statementContext>(0);
}


size_t TSqlParser::Dml_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDml_clause;
}

void TSqlParser::Dml_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDml_clause(this);
}

void TSqlParser::Dml_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDml_clause(this);
}

TSqlParser::Dml_clauseContext* TSqlParser::dml_clause() {
  Dml_clauseContext *_localctx = _tracker.createInstance<Dml_clauseContext>(_ctx, getState());
  enterRule(_localctx, 8, TSqlParser::RuleDml_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(514);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(509);
      merge_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(510);
      delete_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(511);
      insert_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(512);
      select_statement_standalone();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(513);
      update_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_clauseContext ------------------------------------------------------------------

TSqlParser::Ddl_clauseContext::Ddl_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Alter_sequenceContext* TSqlParser::Ddl_clauseContext::alter_sequence() {
  return getRuleContext<TSqlParser::Alter_sequenceContext>(0);
}

TSqlParser::Alter_tableContext* TSqlParser::Ddl_clauseContext::alter_table() {
  return getRuleContext<TSqlParser::Alter_tableContext>(0);
}

TSqlParser::Create_sequenceContext* TSqlParser::Ddl_clauseContext::create_sequence() {
  return getRuleContext<TSqlParser::Create_sequenceContext>(0);
}

TSqlParser::Create_tableContext* TSqlParser::Ddl_clauseContext::create_table() {
  return getRuleContext<TSqlParser::Create_tableContext>(0);
}

TSqlParser::Drop_functionContext* TSqlParser::Ddl_clauseContext::drop_function() {
  return getRuleContext<TSqlParser::Drop_functionContext>(0);
}

TSqlParser::Drop_procedureContext* TSqlParser::Ddl_clauseContext::drop_procedure() {
  return getRuleContext<TSqlParser::Drop_procedureContext>(0);
}

TSqlParser::Drop_tableContext* TSqlParser::Ddl_clauseContext::drop_table() {
  return getRuleContext<TSqlParser::Drop_tableContext>(0);
}

TSqlParser::Lock_tableContext* TSqlParser::Ddl_clauseContext::lock_table() {
  return getRuleContext<TSqlParser::Lock_tableContext>(0);
}

TSqlParser::Truncate_tableContext* TSqlParser::Ddl_clauseContext::truncate_table() {
  return getRuleContext<TSqlParser::Truncate_tableContext>(0);
}


size_t TSqlParser::Ddl_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDdl_clause;
}

void TSqlParser::Ddl_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDdl_clause(this);
}

void TSqlParser::Ddl_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDdl_clause(this);
}

TSqlParser::Ddl_clauseContext* TSqlParser::ddl_clause() {
  Ddl_clauseContext *_localctx = _tracker.createInstance<Ddl_clauseContext>(_ctx, getState());
  enterRule(_localctx, 10, TSqlParser::RuleDdl_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(525);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(516);
      alter_sequence();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(517);
      alter_table();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(518);
      create_sequence();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(519);
      create_table();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(520);
      drop_function();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(521);
      drop_procedure();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(522);
      drop_table();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(523);
      lock_table();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(524);
      truncate_table();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cfl_statementContext ------------------------------------------------------------------

TSqlParser::Cfl_statementContext::Cfl_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Block_statementContext* TSqlParser::Cfl_statementContext::block_statement() {
  return getRuleContext<TSqlParser::Block_statementContext>(0);
}

TSqlParser::Break_statementContext* TSqlParser::Cfl_statementContext::break_statement() {
  return getRuleContext<TSqlParser::Break_statementContext>(0);
}

TSqlParser::Continue_statementContext* TSqlParser::Cfl_statementContext::continue_statement() {
  return getRuleContext<TSqlParser::Continue_statementContext>(0);
}

TSqlParser::Goto_statementContext* TSqlParser::Cfl_statementContext::goto_statement() {
  return getRuleContext<TSqlParser::Goto_statementContext>(0);
}

TSqlParser::If_statementContext* TSqlParser::Cfl_statementContext::if_statement() {
  return getRuleContext<TSqlParser::If_statementContext>(0);
}

TSqlParser::Return_statementContext* TSqlParser::Cfl_statementContext::return_statement() {
  return getRuleContext<TSqlParser::Return_statementContext>(0);
}

TSqlParser::Throw_statementContext* TSqlParser::Cfl_statementContext::throw_statement() {
  return getRuleContext<TSqlParser::Throw_statementContext>(0);
}

TSqlParser::Try_catch_statementContext* TSqlParser::Cfl_statementContext::try_catch_statement() {
  return getRuleContext<TSqlParser::Try_catch_statementContext>(0);
}

TSqlParser::Waitfor_statementContext* TSqlParser::Cfl_statementContext::waitfor_statement() {
  return getRuleContext<TSqlParser::Waitfor_statementContext>(0);
}

TSqlParser::While_statementContext* TSqlParser::Cfl_statementContext::while_statement() {
  return getRuleContext<TSqlParser::While_statementContext>(0);
}

TSqlParser::Print_statementContext* TSqlParser::Cfl_statementContext::print_statement() {
  return getRuleContext<TSqlParser::Print_statementContext>(0);
}

TSqlParser::Raiseerror_statementContext* TSqlParser::Cfl_statementContext::raiseerror_statement() {
  return getRuleContext<TSqlParser::Raiseerror_statementContext>(0);
}


size_t TSqlParser::Cfl_statementContext::getRuleIndex() const {
  return TSqlParser::RuleCfl_statement;
}

void TSqlParser::Cfl_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCfl_statement(this);
}

void TSqlParser::Cfl_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCfl_statement(this);
}

TSqlParser::Cfl_statementContext* TSqlParser::cfl_statement() {
  Cfl_statementContext *_localctx = _tracker.createInstance<Cfl_statementContext>(_ctx, getState());
  enterRule(_localctx, 12, TSqlParser::RuleCfl_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(527);
      block_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(528);
      break_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(529);
      continue_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(530);
      goto_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(531);
      if_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(532);
      return_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(533);
      throw_statement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(534);
      try_catch_statement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(535);
      waitfor_statement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(536);
      while_statement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(537);
      print_statement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(538);
      raiseerror_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_statementContext ------------------------------------------------------------------

TSqlParser::Block_statementContext::Block_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Block_statementContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Block_statementContext::END() {
  return getToken(TSqlParser::END, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Block_statementContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Block_statementContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Block_statementContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Block_statementContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}


size_t TSqlParser::Block_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBlock_statement;
}

void TSqlParser::Block_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_statement(this);
}

void TSqlParser::Block_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_statement(this);
}

TSqlParser::Block_statementContext* TSqlParser::block_statement() {
  Block_statementContext *_localctx = _tracker.createInstance<Block_statementContext>(_ctx, getState());
  enterRule(_localctx, 14, TSqlParser::RuleBlock_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    match(TSqlParser::BEGIN);
    setState(543);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(542);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
    setState(548);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -9200253150513037296) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -7781652249205111797) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & -27865903799) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 195)) & -1) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & -17) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 323)) & 6917346474351132671) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 387)) & 1236950600247) != 0)) {
      setState(545);
      sql_clauses();
      setState(550);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(551);
    match(TSqlParser::END);
    setState(553);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(552);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_statementContext ------------------------------------------------------------------

TSqlParser::Break_statementContext::Break_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Break_statementContext::BREAK() {
  return getToken(TSqlParser::BREAK, 0);
}

tree::TerminalNode* TSqlParser::Break_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Break_statementContext::getRuleIndex() const {
  return TSqlParser::RuleBreak_statement;
}

void TSqlParser::Break_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_statement(this);
}

void TSqlParser::Break_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_statement(this);
}

TSqlParser::Break_statementContext* TSqlParser::break_statement() {
  Break_statementContext *_localctx = _tracker.createInstance<Break_statementContext>(_ctx, getState());
  enterRule(_localctx, 16, TSqlParser::RuleBreak_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(555);
    match(TSqlParser::BREAK);
    setState(557);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(556);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continue_statementContext ------------------------------------------------------------------

TSqlParser::Continue_statementContext::Continue_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Continue_statementContext::CONTINUE() {
  return getToken(TSqlParser::CONTINUE, 0);
}

tree::TerminalNode* TSqlParser::Continue_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Continue_statementContext::getRuleIndex() const {
  return TSqlParser::RuleContinue_statement;
}

void TSqlParser::Continue_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinue_statement(this);
}

void TSqlParser::Continue_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinue_statement(this);
}

TSqlParser::Continue_statementContext* TSqlParser::continue_statement() {
  Continue_statementContext *_localctx = _tracker.createInstance<Continue_statementContext>(_ctx, getState());
  enterRule(_localctx, 18, TSqlParser::RuleContinue_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(TSqlParser::CONTINUE);
    setState(561);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(560);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Goto_statementContext ------------------------------------------------------------------

TSqlParser::Goto_statementContext::Goto_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Goto_statementContext::GOTO() {
  return getToken(TSqlParser::GOTO, 0);
}

TSqlParser::Id_Context* TSqlParser::Goto_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Goto_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Goto_statementContext::COLON() {
  return getToken(TSqlParser::COLON, 0);
}


size_t TSqlParser::Goto_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGoto_statement;
}

void TSqlParser::Goto_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoto_statement(this);
}

void TSqlParser::Goto_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoto_statement(this);
}

TSqlParser::Goto_statementContext* TSqlParser::goto_statement() {
  Goto_statementContext *_localctx = _tracker.createInstance<Goto_statementContext>(_ctx, getState());
  enterRule(_localctx, 20, TSqlParser::RuleGoto_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(573);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::GOTO: {
        enterOuterAlt(_localctx, 1);
        setState(563);
        match(TSqlParser::GOTO);
        setState(564);
        id_();
        setState(566);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
        case 1: {
          setState(565);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 2);
        setState(568);
        id_();
        setState(569);
        match(TSqlParser::COLON);
        setState(571);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
        case 1: {
          setState(570);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_statementContext ------------------------------------------------------------------

TSqlParser::Return_statementContext::Return_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Return_statementContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Return_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Return_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Return_statementContext::getRuleIndex() const {
  return TSqlParser::RuleReturn_statement;
}

void TSqlParser::Return_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_statement(this);
}

void TSqlParser::Return_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_statement(this);
}

TSqlParser::Return_statementContext* TSqlParser::return_statement() {
  Return_statementContext *_localctx = _tracker.createInstance<Return_statementContext>(_ctx, getState());
  enterRule(_localctx, 22, TSqlParser::RuleReturn_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(575);
    match(TSqlParser::RETURN);
    setState(577);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(576);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(580);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      setState(579);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_statementContext ------------------------------------------------------------------

TSqlParser::If_statementContext::If_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::If_statementContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::If_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::If_statementContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::If_statementContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

tree::TerminalNode* TSqlParser::If_statementContext::ELSE() {
  return getToken(TSqlParser::ELSE, 0);
}

tree::TerminalNode* TSqlParser::If_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::If_statementContext::getRuleIndex() const {
  return TSqlParser::RuleIf_statement;
}

void TSqlParser::If_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_statement(this);
}

void TSqlParser::If_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_statement(this);
}

TSqlParser::If_statementContext* TSqlParser::if_statement() {
  If_statementContext *_localctx = _tracker.createInstance<If_statementContext>(_ctx, getState());
  enterRule(_localctx, 24, TSqlParser::RuleIf_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(582);
    match(TSqlParser::IF);
    setState(583);
    search_condition(0);
    setState(584);
    sql_clauses();
    setState(587);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(585);
      match(TSqlParser::ELSE);
      setState(586);
      sql_clauses();
      break;
    }

    default:
      break;
    }
    setState(590);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(589);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_statementContext ------------------------------------------------------------------

TSqlParser::Throw_statementContext::Throw_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_statementContext::THROW() {
  return getToken(TSqlParser::THROW, 0);
}

TSqlParser::Throw_error_numberContext* TSqlParser::Throw_statementContext::throw_error_number() {
  return getRuleContext<TSqlParser::Throw_error_numberContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Throw_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Throw_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Throw_messageContext* TSqlParser::Throw_statementContext::throw_message() {
  return getRuleContext<TSqlParser::Throw_messageContext>(0);
}

TSqlParser::Throw_stateContext* TSqlParser::Throw_statementContext::throw_state() {
  return getRuleContext<TSqlParser::Throw_stateContext>(0);
}

tree::TerminalNode* TSqlParser::Throw_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Throw_statementContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_statement;
}

void TSqlParser::Throw_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_statement(this);
}

void TSqlParser::Throw_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_statement(this);
}

TSqlParser::Throw_statementContext* TSqlParser::throw_statement() {
  Throw_statementContext *_localctx = _tracker.createInstance<Throw_statementContext>(_ctx, getState());
  enterRule(_localctx, 26, TSqlParser::RuleThrow_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(592);
    match(TSqlParser::THROW);
    setState(599);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL) {
      setState(593);
      throw_error_number();
      setState(594);
      match(TSqlParser::COMMA);
      setState(595);
      throw_message();
      setState(596);
      match(TSqlParser::COMMA);
      setState(597);
      throw_state();
    }
    setState(602);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      setState(601);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_error_numberContext ------------------------------------------------------------------

TSqlParser::Throw_error_numberContext::Throw_error_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_error_numberContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Throw_error_numberContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_error_numberContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_error_number;
}

void TSqlParser::Throw_error_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_error_number(this);
}

void TSqlParser::Throw_error_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_error_number(this);
}

TSqlParser::Throw_error_numberContext* TSqlParser::throw_error_number() {
  Throw_error_numberContext *_localctx = _tracker.createInstance<Throw_error_numberContext>(_ctx, getState());
  enterRule(_localctx, 28, TSqlParser::RuleThrow_error_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(604);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_messageContext ------------------------------------------------------------------

TSqlParser::Throw_messageContext::Throw_messageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_messageContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Throw_messageContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_messageContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_message;
}

void TSqlParser::Throw_messageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_message(this);
}

void TSqlParser::Throw_messageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_message(this);
}

TSqlParser::Throw_messageContext* TSqlParser::throw_message() {
  Throw_messageContext *_localctx = _tracker.createInstance<Throw_messageContext>(_ctx, getState());
  enterRule(_localctx, 30, TSqlParser::RuleThrow_message);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(606);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_stateContext ------------------------------------------------------------------

TSqlParser::Throw_stateContext::Throw_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Throw_stateContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Throw_stateContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Throw_stateContext::getRuleIndex() const {
  return TSqlParser::RuleThrow_state;
}

void TSqlParser::Throw_stateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_state(this);
}

void TSqlParser::Throw_stateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_state(this);
}

TSqlParser::Throw_stateContext* TSqlParser::throw_state() {
  Throw_stateContext *_localctx = _tracker.createInstance<Throw_stateContext>(_ctx, getState());
  enterRule(_localctx, 32, TSqlParser::RuleThrow_state);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Try_catch_statementContext ------------------------------------------------------------------

TSqlParser::Try_catch_statementContext::Try_catch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::BEGIN() {
  return getTokens(TSqlParser::BEGIN);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::BEGIN(size_t i) {
  return getToken(TSqlParser::BEGIN, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::TRY() {
  return getTokens(TSqlParser::TRY);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::TRY(size_t i) {
  return getToken(TSqlParser::TRY, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::END() {
  return getTokens(TSqlParser::END);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::END(size_t i) {
  return getToken(TSqlParser::END, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::CATCH() {
  return getTokens(TSqlParser::CATCH);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::CATCH(size_t i) {
  return getToken(TSqlParser::CATCH, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Try_catch_statementContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Try_catch_statementContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Try_catch_statementContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Try_catch_statementContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}


size_t TSqlParser::Try_catch_statementContext::getRuleIndex() const {
  return TSqlParser::RuleTry_catch_statement;
}

void TSqlParser::Try_catch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTry_catch_statement(this);
}

void TSqlParser::Try_catch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTry_catch_statement(this);
}

TSqlParser::Try_catch_statementContext* TSqlParser::try_catch_statement() {
  Try_catch_statementContext *_localctx = _tracker.createInstance<Try_catch_statementContext>(_ctx, getState());
  enterRule(_localctx, 34, TSqlParser::RuleTry_catch_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    match(TSqlParser::BEGIN);
    setState(611);
    match(TSqlParser::TRY);
    setState(613);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(612);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
    setState(616); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(615);
      antlrcpp::downCast<Try_catch_statementContext *>(_localctx)->try_clauses = sql_clauses();
      setState(618); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -9200253150513037296) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -7781652249205111797) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & -27865903799) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 195)) & -1) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & -17) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 323)) & 6917346474351132671) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 387)) & 1236950600247) != 0));
    setState(620);
    match(TSqlParser::END);
    setState(621);
    match(TSqlParser::TRY);
    setState(623);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(622);
      match(TSqlParser::SEMI);
    }
    setState(625);
    match(TSqlParser::BEGIN);
    setState(626);
    match(TSqlParser::CATCH);
    setState(628);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(627);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
    setState(633);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -9200253150513037296) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -7781652249205111797) != 0) || ((((_la - 131) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 131)) & -27865903799) != 0) || ((((_la - 195) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 195)) & -1) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & -17) != 0) || ((((_la - 323) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 323)) & 6917346474351132671) != 0) || ((((_la - 387) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 387)) & 1236950600247) != 0)) {
      setState(630);
      antlrcpp::downCast<Try_catch_statementContext *>(_localctx)->catch_clauses = sql_clauses();
      setState(635);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(636);
    match(TSqlParser::END);
    setState(637);
    match(TSqlParser::CATCH);
    setState(639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(638);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Waitfor_statementContext ------------------------------------------------------------------

TSqlParser::Waitfor_statementContext::Waitfor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::WAITFOR() {
  return getToken(TSqlParser::WAITFOR, 0);
}

TSqlParser::Receive_statementContext* TSqlParser::Waitfor_statementContext::receive_statement() {
  return getRuleContext<TSqlParser::Receive_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

TSqlParser::TimeContext* TSqlParser::Waitfor_statementContext::time() {
  return getRuleContext<TSqlParser::TimeContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Waitfor_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::DELAY() {
  return getToken(TSqlParser::DELAY, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::Waitfor_statementContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}


size_t TSqlParser::Waitfor_statementContext::getRuleIndex() const {
  return TSqlParser::RuleWaitfor_statement;
}

void TSqlParser::Waitfor_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWaitfor_statement(this);
}

void TSqlParser::Waitfor_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWaitfor_statement(this);
}

TSqlParser::Waitfor_statementContext* TSqlParser::waitfor_statement() {
  Waitfor_statementContext *_localctx = _tracker.createInstance<Waitfor_statementContext>(_ctx, getState());
  enterRule(_localctx, 36, TSqlParser::RuleWaitfor_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(TSqlParser::WAITFOR);
    setState(643);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      setState(642);
      receive_statement();
      break;
    }

    default:
      break;
    }
    setState(646);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(645);
      match(TSqlParser::COMMA);
    }
    setState(650);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(648);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DELAY || _la == TSqlParser::TIME

      || _la == TSqlParser::TIMEOUT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(649);
      time();
      break;
    }

    default:
      break;
    }
    setState(653);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(652);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(656);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(655);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_statementContext ------------------------------------------------------------------

TSqlParser::While_statementContext::While_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::While_statementContext::WHILE() {
  return getToken(TSqlParser::WHILE, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::While_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

TSqlParser::Sql_clausesContext* TSqlParser::While_statementContext::sql_clauses() {
  return getRuleContext<TSqlParser::Sql_clausesContext>(0);
}

tree::TerminalNode* TSqlParser::While_statementContext::BREAK() {
  return getToken(TSqlParser::BREAK, 0);
}

tree::TerminalNode* TSqlParser::While_statementContext::CONTINUE() {
  return getToken(TSqlParser::CONTINUE, 0);
}

tree::TerminalNode* TSqlParser::While_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::While_statementContext::getRuleIndex() const {
  return TSqlParser::RuleWhile_statement;
}

void TSqlParser::While_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_statement(this);
}

void TSqlParser::While_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_statement(this);
}

TSqlParser::While_statementContext* TSqlParser::while_statement() {
  While_statementContext *_localctx = _tracker.createInstance<While_statementContext>(_ctx, getState());
  enterRule(_localctx, 38, TSqlParser::RuleWhile_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(658);
    match(TSqlParser::WHILE);
    setState(659);
    search_condition(0);
    setState(669);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(660);
      sql_clauses();
      break;
    }

    case 2: {
      setState(661);
      match(TSqlParser::BREAK);
      setState(663);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
      case 1: {
        setState(662);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      setState(665);
      match(TSqlParser::CONTINUE);
      setState(667);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        setState(666);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Print_statementContext ------------------------------------------------------------------

TSqlParser::Print_statementContext::Print_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Print_statementContext::PRINT() {
  return getToken(TSqlParser::PRINT, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Print_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Print_statementContext::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Print_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Print_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Print_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Print_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Print_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Print_statementContext::getRuleIndex() const {
  return TSqlParser::RulePrint_statement;
}

void TSqlParser::Print_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrint_statement(this);
}

void TSqlParser::Print_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrint_statement(this);
}

TSqlParser::Print_statementContext* TSqlParser::print_statement() {
  Print_statementContext *_localctx = _tracker.createInstance<Print_statementContext>(_ctx, getState());
  enterRule(_localctx, 40, TSqlParser::RulePrint_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    match(TSqlParser::PRINT);
    setState(674);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(672);
      expression(0);
      break;
    }

    case 2: {
      setState(673);
      match(TSqlParser::DOUBLE_QUOTE_ID);
      break;
    }

    default:
      break;
    }
    setState(680);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(676);
      match(TSqlParser::COMMA);
      setState(677);
      match(TSqlParser::LOCAL_ID);
      setState(682);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(684);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      setState(683);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raiseerror_statementContext ------------------------------------------------------------------

TSqlParser::Raiseerror_statementContext::Raiseerror_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::RAISERROR() {
  return getToken(TSqlParser::RAISERROR, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Constant_LOCAL_IDContext *> TSqlParser::Raiseerror_statementContext::constant_LOCAL_ID() {
  return getRuleContexts<TSqlParser::Constant_LOCAL_IDContext>();
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::Raiseerror_statementContext::constant_LOCAL_ID(size_t i) {
  return getRuleContext<TSqlParser::Constant_LOCAL_IDContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Raiseerror_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::LOG() {
  return getToken(TSqlParser::LOG, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::SETERROR() {
  return getToken(TSqlParser::SETERROR, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::Raiseerror_statementContext::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}


size_t TSqlParser::Raiseerror_statementContext::getRuleIndex() const {
  return TSqlParser::RuleRaiseerror_statement;
}

void TSqlParser::Raiseerror_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaiseerror_statement(this);
}

void TSqlParser::Raiseerror_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaiseerror_statement(this);
}

TSqlParser::Raiseerror_statementContext* TSqlParser::raiseerror_statement() {
  Raiseerror_statementContext *_localctx = _tracker.createInstance<Raiseerror_statementContext>(_ctx, getState());
  enterRule(_localctx, 42, TSqlParser::RuleRaiseerror_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(718);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(686);
      match(TSqlParser::RAISERROR);
      setState(687);
      match(TSqlParser::LR_BRACKET);
      setState(688);
      antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->msg = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 399) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 399)) & 11) != 0))) {
        antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->msg = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(689);
      match(TSqlParser::COMMA);
      setState(690);
      antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->severity = constant_LOCAL_ID();
      setState(691);
      match(TSqlParser::COMMA);
      setState(692);
      antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->state = constant_LOCAL_ID();
      setState(697);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(693);
        match(TSqlParser::COMMA);
        setState(694);
        constant_LOCAL_ID();
        setState(699);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(700);
      match(TSqlParser::RR_BRACKET);
      setState(703);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
      case 1: {
        setState(701);
        match(TSqlParser::WITH);
        setState(702);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::NOWAIT

        || _la == TSqlParser::SETERROR || _la == TSqlParser::LOG)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      setState(706);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(705);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(708);
      match(TSqlParser::RAISERROR);
      setState(709);
      match(TSqlParser::DECIMAL);
      setState(710);
      antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->formatstring = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 396) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 396)) & 73) != 0))) {
        antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->formatstring = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(715);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(711);
        match(TSqlParser::COMMA);
        setState(712);
        antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->argument = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 399) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 399)) & 11) != 0))) {
          antlrcpp::downCast<Raiseerror_statementContext *>(_localctx)->argument = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(717);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Empty_statementContext ------------------------------------------------------------------

TSqlParser::Empty_statementContext::Empty_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Empty_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Empty_statementContext::getRuleIndex() const {
  return TSqlParser::RuleEmpty_statement;
}

void TSqlParser::Empty_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmpty_statement(this);
}

void TSqlParser::Empty_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmpty_statement(this);
}

TSqlParser::Empty_statementContext* TSqlParser::empty_statement() {
  Empty_statementContext *_localctx = _tracker.createInstance<Empty_statementContext>(_ctx, getState());
  enterRule(_localctx, 44, TSqlParser::RuleEmpty_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(720);
    match(TSqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Another_statementContext ------------------------------------------------------------------

TSqlParser::Another_statementContext::Another_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Declare_statementContext* TSqlParser::Another_statementContext::declare_statement() {
  return getRuleContext<TSqlParser::Declare_statementContext>(0);
}

TSqlParser::Execute_statementContext* TSqlParser::Another_statementContext::execute_statement() {
  return getRuleContext<TSqlParser::Execute_statementContext>(0);
}

TSqlParser::Cursor_statementContext* TSqlParser::Another_statementContext::cursor_statement() {
  return getRuleContext<TSqlParser::Cursor_statementContext>(0);
}

TSqlParser::Kill_statementContext* TSqlParser::Another_statementContext::kill_statement() {
  return getRuleContext<TSqlParser::Kill_statementContext>(0);
}

TSqlParser::Set_statementContext* TSqlParser::Another_statementContext::set_statement() {
  return getRuleContext<TSqlParser::Set_statementContext>(0);
}

TSqlParser::Transaction_statementContext* TSqlParser::Another_statementContext::transaction_statement() {
  return getRuleContext<TSqlParser::Transaction_statementContext>(0);
}

TSqlParser::Use_statementContext* TSqlParser::Another_statementContext::use_statement() {
  return getRuleContext<TSqlParser::Use_statementContext>(0);
}

TSqlParser::Shutdown_statementContext* TSqlParser::Another_statementContext::shutdown_statement() {
  return getRuleContext<TSqlParser::Shutdown_statementContext>(0);
}


size_t TSqlParser::Another_statementContext::getRuleIndex() const {
  return TSqlParser::RuleAnother_statement;
}

void TSqlParser::Another_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnother_statement(this);
}

void TSqlParser::Another_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnother_statement(this);
}

TSqlParser::Another_statementContext* TSqlParser::another_statement() {
  Another_statementContext *_localctx = _tracker.createInstance<Another_statementContext>(_ctx, getState());
  enterRule(_localctx, 46, TSqlParser::RuleAnother_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(730);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(722);
      declare_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(723);
      execute_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(724);
      cursor_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(725);
      kill_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(726);
      set_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(727);
      transaction_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(728);
      use_statement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(729);
      shutdown_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_toContext ------------------------------------------------------------------

TSqlParser::Entity_toContext::Entity_toContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Entity_toContext::TO() {
  return getToken(TSqlParser::TO, 0);
}


size_t TSqlParser::Entity_toContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_to;
}

void TSqlParser::Entity_toContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_to(this);
}

void TSqlParser::Entity_toContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_to(this);
}

TSqlParser::Entity_toContext* TSqlParser::entity_to() {
  Entity_toContext *_localctx = _tracker.createInstance<Entity_toContext>(_ctx, getState());
  enterRule(_localctx, 48, TSqlParser::RuleEntity_to);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(732);
    match(TSqlParser::TO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Colon_colonContext ------------------------------------------------------------------

TSqlParser::Colon_colonContext::Colon_colonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Colon_colonContext::DOUBLE_COLON() {
  return getToken(TSqlParser::DOUBLE_COLON, 0);
}


size_t TSqlParser::Colon_colonContext::getRuleIndex() const {
  return TSqlParser::RuleColon_colon;
}

void TSqlParser::Colon_colonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColon_colon(this);
}

void TSqlParser::Colon_colonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColon_colon(this);
}

TSqlParser::Colon_colonContext* TSqlParser::colon_colon() {
  Colon_colonContext *_localctx = _tracker.createInstance<Colon_colonContext>(_ctx, getState());
  enterRule(_localctx, 50, TSqlParser::RuleColon_colon);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(734);
    match(TSqlParser::DOUBLE_COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_typeContext ------------------------------------------------------------------

TSqlParser::Class_typeContext::Class_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_typeContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Class_typeContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Class_typeContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}


size_t TSqlParser::Class_typeContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type;
}

void TSqlParser::Class_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type(this);
}

void TSqlParser::Class_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type(this);
}

TSqlParser::Class_typeContext* TSqlParser::class_type() {
  Class_typeContext *_localctx = _tracker.createInstance<Class_typeContext>(_ctx, getState());
  enterRule(_localctx, 52, TSqlParser::RuleClass_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(736);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT || _la == TSqlParser::TYPE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_sql_databaseContext ------------------------------------------------------------------

TSqlParser::Class_type_for_sql_databaseContext::Class_type_for_sql_databaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_sql_databaseContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}


size_t TSqlParser::Class_type_for_sql_databaseContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_sql_database;
}

void TSqlParser::Class_type_for_sql_databaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_sql_database(this);
}

void TSqlParser::Class_type_for_sql_databaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_sql_database(this);
}

TSqlParser::Class_type_for_sql_databaseContext* TSqlParser::class_type_for_sql_database() {
  Class_type_for_sql_databaseContext *_localctx = _tracker.createInstance<Class_type_for_sql_databaseContext>(_ctx, getState());
  enterRule(_localctx, 54, TSqlParser::RuleClass_type_for_sql_database);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(738);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT || _la == TSqlParser::TYPE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_azure_dwContext ------------------------------------------------------------------

TSqlParser::Class_type_for_azure_dwContext::Class_type_for_azure_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_azure_dwContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_azure_dwContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}


size_t TSqlParser::Class_type_for_azure_dwContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_azure_dw;
}

void TSqlParser::Class_type_for_azure_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_azure_dw(this);
}

void TSqlParser::Class_type_for_azure_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_azure_dw(this);
}

TSqlParser::Class_type_for_azure_dwContext* TSqlParser::class_type_for_azure_dw() {
  Class_type_for_azure_dwContext *_localctx = _tracker.createInstance<Class_type_for_azure_dwContext>(_ctx, getState());
  enterRule(_localctx, 56, TSqlParser::RuleClass_type_for_azure_dw);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(740);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_type_for_parallel_dwContext ------------------------------------------------------------------

TSqlParser::Class_type_for_parallel_dwContext::Class_type_for_parallel_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::DATABASE() {
  return getToken(TSqlParser::DATABASE, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::SCHEMA() {
  return getToken(TSqlParser::SCHEMA, 0);
}

tree::TerminalNode* TSqlParser::Class_type_for_parallel_dwContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}


size_t TSqlParser::Class_type_for_parallel_dwContext::getRuleIndex() const {
  return TSqlParser::RuleClass_type_for_parallel_dw;
}

void TSqlParser::Class_type_for_parallel_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type_for_parallel_dw(this);
}

void TSqlParser::Class_type_for_parallel_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type_for_parallel_dw(this);
}

TSqlParser::Class_type_for_parallel_dwContext* TSqlParser::class_type_for_parallel_dw() {
  Class_type_for_parallel_dwContext *_localctx = _tracker.createInstance<Class_type_for_parallel_dwContext>(_ctx, getState());
  enterRule(_localctx, 58, TSqlParser::RuleClass_type_for_parallel_dw);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(742);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::DATABASE || _la == TSqlParser::SCHEMA || _la == TSqlParser::OBJECT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lock_tableContext ------------------------------------------------------------------

TSqlParser::Lock_tableContext::Lock_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Lock_tableContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Lock_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::MODE() {
  return getToken(TSqlParser::MODE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::SHARE() {
  return getToken(TSqlParser::SHARE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::EXCLUSIVE() {
  return getToken(TSqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::WAIT() {
  return getToken(TSqlParser::WAIT, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Lock_tableContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Lock_tableContext::getRuleIndex() const {
  return TSqlParser::RuleLock_table;
}

void TSqlParser::Lock_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLock_table(this);
}

void TSqlParser::Lock_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLock_table(this);
}

TSqlParser::Lock_tableContext* TSqlParser::lock_table() {
  Lock_tableContext *_localctx = _tracker.createInstance<Lock_tableContext>(_ctx, getState());
  enterRule(_localctx, 60, TSqlParser::RuleLock_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(744);
    match(TSqlParser::LOCK);
    setState(745);
    match(TSqlParser::TABLE);
    setState(746);
    table_name();
    setState(747);
    match(TSqlParser::IN);
    setState(748);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::EXCLUSIVE || _la == TSqlParser::SHARE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(749);
    match(TSqlParser::MODE);
    setState(753);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(750);
      match(TSqlParser::WAIT);
      setState(751);
      antlrcpp::downCast<Lock_tableContext *>(_localctx)->seconds = match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(752);
      match(TSqlParser::NOWAIT);
      break;
    }

    default:
      break;
    }
    setState(756);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(755);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Truncate_tableContext ------------------------------------------------------------------

TSqlParser::Truncate_tableContext::Truncate_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TRUNCATE() {
  return getToken(TSqlParser::TRUNCATE, 0);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Truncate_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::PARTITIONS() {
  return getToken(TSqlParser::PARTITIONS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::TO() {
  return getTokens(TSqlParser::TO);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::TO(size_t i) {
  return getToken(TSqlParser::TO, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Truncate_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Truncate_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Truncate_tableContext::getRuleIndex() const {
  return TSqlParser::RuleTruncate_table;
}

void TSqlParser::Truncate_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncate_table(this);
}

void TSqlParser::Truncate_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncate_table(this);
}

TSqlParser::Truncate_tableContext* TSqlParser::truncate_table() {
  Truncate_tableContext *_localctx = _tracker.createInstance<Truncate_tableContext>(_ctx, getState());
  enterRule(_localctx, 62, TSqlParser::RuleTruncate_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(758);
    match(TSqlParser::TRUNCATE);
    setState(759);
    match(TSqlParser::TABLE);
    setState(760);
    table_name();
    setState(780);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(761);
      match(TSqlParser::WITH);
      setState(762);
      match(TSqlParser::LR_BRACKET);
      setState(763);
      match(TSqlParser::PARTITIONS);
      setState(764);
      match(TSqlParser::LR_BRACKET);
      setState(774); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(766);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(765);
          match(TSqlParser::COMMA);
        }
        setState(772);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(768);
          match(TSqlParser::DECIMAL);
          break;
        }

        case 2: {
          setState(769);
          match(TSqlParser::DECIMAL);
          setState(770);
          match(TSqlParser::TO);
          setState(771);
          match(TSqlParser::DECIMAL);
          break;
        }

        default:
          break;
        }
        setState(776); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::DECIMAL

      || _la == TSqlParser::COMMA);
      setState(778);
      match(TSqlParser::RR_BRACKET);
      setState(779);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_sequenceContext ------------------------------------------------------------------

TSqlParser::Alter_sequenceContext::Alter_sequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::SEQUENCE() {
  return getToken(TSqlParser::SEQUENCE, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Alter_sequenceContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Alter_sequenceContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::RESTART() {
  return getToken(TSqlParser::RESTART, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::INCREMENT() {
  return getToken(TSqlParser::INCREMENT, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::MINVALUE() {
  return getToken(TSqlParser::MINVALUE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_sequenceContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_sequenceContext::NO() {
  return getTokens(TSqlParser::NO);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::NO(size_t i) {
  return getToken(TSqlParser::NO, i);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::MAXVALUE() {
  return getToken(TSqlParser::MAXVALUE, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::CYCLE() {
  return getToken(TSqlParser::CYCLE, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::CACHE() {
  return getToken(TSqlParser::CACHE, 0);
}

tree::TerminalNode* TSqlParser::Alter_sequenceContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}


size_t TSqlParser::Alter_sequenceContext::getRuleIndex() const {
  return TSqlParser::RuleAlter_sequence;
}

void TSqlParser::Alter_sequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_sequence(this);
}

void TSqlParser::Alter_sequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_sequence(this);
}

TSqlParser::Alter_sequenceContext* TSqlParser::alter_sequence() {
  Alter_sequenceContext *_localctx = _tracker.createInstance<Alter_sequenceContext>(_ctx, getState());
  enterRule(_localctx, 64, TSqlParser::RuleAlter_sequence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(782);
    match(TSqlParser::ALTER);
    setState(783);
    match(TSqlParser::SEQUENCE);
    setState(787);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(784);
      antlrcpp::downCast<Alter_sequenceContext *>(_localctx)->schema_name = id_();
      setState(785);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(789);
    antlrcpp::downCast<Alter_sequenceContext *>(_localctx)->sequence_name = id_();
    setState(795);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      setState(790);
      match(TSqlParser::RESTART);
      setState(793);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(791);
        match(TSqlParser::WITH);
        setState(792);
        match(TSqlParser::DECIMAL);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(800);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(797);
      match(TSqlParser::INCREMENT);
      setState(798);
      match(TSqlParser::BY);
      setState(799);
      antlrcpp::downCast<Alter_sequenceContext *>(_localctx)->sequnce_increment = match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(806);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      setState(802);
      match(TSqlParser::MINVALUE);
      setState(803);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(804);
      match(TSqlParser::NO);
      setState(805);
      match(TSqlParser::MINVALUE);
      break;
    }

    default:
      break;
    }
    setState(812);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      setState(808);
      match(TSqlParser::MAXVALUE);
      setState(809);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(810);
      match(TSqlParser::NO);
      setState(811);
      match(TSqlParser::MAXVALUE);
      break;
    }

    default:
      break;
    }
    setState(817);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(814);
      match(TSqlParser::CYCLE);
      break;
    }

    case 2: {
      setState(815);
      match(TSqlParser::NO);
      setState(816);
      match(TSqlParser::CYCLE);
      break;
    }

    default:
      break;
    }
    setState(823);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      setState(819);
      match(TSqlParser::CACHE);
      setState(820);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      setState(821);
      match(TSqlParser::NO);
      setState(822);
      match(TSqlParser::CACHE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_sequenceContext ------------------------------------------------------------------

TSqlParser::Create_sequenceContext::Create_sequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::SEQUENCE() {
  return getToken(TSqlParser::SEQUENCE, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Create_sequenceContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Create_sequenceContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Create_sequenceContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::START() {
  return getToken(TSqlParser::START, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_sequenceContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::INCREMENT() {
  return getToken(TSqlParser::INCREMENT, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::MINVALUE() {
  return getToken(TSqlParser::MINVALUE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_sequenceContext::NO() {
  return getTokens(TSqlParser::NO);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::NO(size_t i) {
  return getToken(TSqlParser::NO, i);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::MAXVALUE() {
  return getToken(TSqlParser::MAXVALUE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::CYCLE() {
  return getToken(TSqlParser::CYCLE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::CACHE() {
  return getToken(TSqlParser::CACHE, 0);
}

tree::TerminalNode* TSqlParser::Create_sequenceContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::Create_sequenceContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_sequence;
}

void TSqlParser::Create_sequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_sequence(this);
}

void TSqlParser::Create_sequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_sequence(this);
}

TSqlParser::Create_sequenceContext* TSqlParser::create_sequence() {
  Create_sequenceContext *_localctx = _tracker.createInstance<Create_sequenceContext>(_ctx, getState());
  enterRule(_localctx, 66, TSqlParser::RuleCreate_sequence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(825);
    match(TSqlParser::CREATE);
    setState(826);
    match(TSqlParser::SEQUENCE);
    setState(830);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(827);
      antlrcpp::downCast<Create_sequenceContext *>(_localctx)->schema_name = id_();
      setState(828);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(832);
    antlrcpp::downCast<Create_sequenceContext *>(_localctx)->sequence_name = id_();
    setState(835);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(833);
      match(TSqlParser::AS);
      setState(834);
      data_type();
    }
    setState(840);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(837);
      match(TSqlParser::START);
      setState(838);
      match(TSqlParser::WITH);
      setState(839);
      match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(848);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(842);
      match(TSqlParser::INCREMENT);
      setState(843);
      match(TSqlParser::BY);
      setState(845);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::MINUS) {
        setState(844);
        match(TSqlParser::MINUS);
      }
      setState(847);
      match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(856);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(850);
      match(TSqlParser::MINVALUE);
      setState(852);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DECIMAL) {
        setState(851);
        match(TSqlParser::DECIMAL);
      }
      break;
    }

    case 2: {
      setState(854);
      match(TSqlParser::NO);
      setState(855);
      match(TSqlParser::MINVALUE);
      break;
    }

    default:
      break;
    }
    setState(864);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(858);
      match(TSqlParser::MAXVALUE);
      setState(860);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DECIMAL) {
        setState(859);
        match(TSqlParser::DECIMAL);
      }
      break;
    }

    case 2: {
      setState(862);
      match(TSqlParser::NO);
      setState(863);
      match(TSqlParser::MAXVALUE);
      break;
    }

    default:
      break;
    }
    setState(869);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(866);
      match(TSqlParser::CYCLE);
      break;
    }

    case 2: {
      setState(867);
      match(TSqlParser::NO);
      setState(868);
      match(TSqlParser::CYCLE);
      break;
    }

    default:
      break;
    }
    setState(877);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(871);
      match(TSqlParser::CACHE);
      setState(873);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DECIMAL) {
        setState(872);
        match(TSqlParser::DECIMAL);
      }
      break;
    }

    case 2: {
      setState(875);
      match(TSqlParser::NO);
      setState(876);
      match(TSqlParser::CACHE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_statementContext ------------------------------------------------------------------

TSqlParser::Merge_statementContext::Merge_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_statementContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

TSqlParser::Ddl_objectContext* TSqlParser::Merge_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::USING() {
  return getToken(TSqlParser::USING, 0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Merge_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Merge_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::With_expressionContext* TSqlParser::Merge_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Merge_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Merge_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::Merge_statementContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}

std::vector<TSqlParser::When_matchesContext *> TSqlParser::Merge_statementContext::when_matches() {
  return getRuleContexts<TSqlParser::When_matchesContext>();
}

TSqlParser::When_matchesContext* TSqlParser::Merge_statementContext::when_matches(size_t i) {
  return getRuleContext<TSqlParser::When_matchesContext>(i);
}

TSqlParser::Output_clauseContext* TSqlParser::Merge_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Merge_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}


size_t TSqlParser::Merge_statementContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_statement;
}

void TSqlParser::Merge_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_statement(this);
}

void TSqlParser::Merge_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_statement(this);
}

TSqlParser::Merge_statementContext* TSqlParser::merge_statement() {
  Merge_statementContext *_localctx = _tracker.createInstance<Merge_statementContext>(_ctx, getState());
  enterRule(_localctx, 68, TSqlParser::RuleMerge_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(880);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(879);
      with_expression();
    }
    setState(882);
    match(TSqlParser::MERGE);
    setState(890);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(883);
      match(TSqlParser::TOP);
      setState(884);
      match(TSqlParser::LR_BRACKET);
      setState(885);
      expression(0);
      setState(886);
      match(TSqlParser::RR_BRACKET);
      setState(888);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(887);
        match(TSqlParser::PERCENT);
      }
    }
    setState(893);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(892);
      match(TSqlParser::INTO);
    }
    setState(895);
    ddl_object();
    setState(897);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(896);
      insert_with_table_hints();
    }
    setState(900);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
    case 1: {
      setState(899);
      as_table_alias();
      break;
    }

    default:
      break;
    }
    setState(902);
    match(TSqlParser::USING);
    setState(903);
    table_sources();
    setState(904);
    match(TSqlParser::ON);
    setState(905);
    search_condition(0);
    setState(907); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(906);
      when_matches();
      setState(909); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == TSqlParser::WHEN);
    setState(912);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OUTPUT) {
      setState(911);
      output_clause();
    }
    setState(915);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(914);
      option_clause();
    }
    setState(917);
    match(TSqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_matchesContext ------------------------------------------------------------------

TSqlParser::When_matchesContext::When_matchesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::WHEN() {
  return getTokens(TSqlParser::WHEN);
}

tree::TerminalNode* TSqlParser::When_matchesContext::WHEN(size_t i) {
  return getToken(TSqlParser::WHEN, i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::MATCHED() {
  return getTokens(TSqlParser::MATCHED);
}

tree::TerminalNode* TSqlParser::When_matchesContext::MATCHED(size_t i) {
  return getToken(TSqlParser::MATCHED, i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::THEN() {
  return getTokens(TSqlParser::THEN);
}

tree::TerminalNode* TSqlParser::When_matchesContext::THEN(size_t i) {
  return getToken(TSqlParser::THEN, i);
}

std::vector<TSqlParser::Merge_matchedContext *> TSqlParser::When_matchesContext::merge_matched() {
  return getRuleContexts<TSqlParser::Merge_matchedContext>();
}

TSqlParser::Merge_matchedContext* TSqlParser::When_matchesContext::merge_matched(size_t i) {
  return getRuleContext<TSqlParser::Merge_matchedContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::AND() {
  return getTokens(TSqlParser::AND);
}

tree::TerminalNode* TSqlParser::When_matchesContext::AND(size_t i) {
  return getToken(TSqlParser::AND, i);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::When_matchesContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::When_matchesContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::When_matchesContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

TSqlParser::Merge_not_matchedContext* TSqlParser::When_matchesContext::merge_not_matched() {
  return getRuleContext<TSqlParser::Merge_not_matchedContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::BY() {
  return getTokens(TSqlParser::BY);
}

tree::TerminalNode* TSqlParser::When_matchesContext::BY(size_t i) {
  return getToken(TSqlParser::BY, i);
}

tree::TerminalNode* TSqlParser::When_matchesContext::TARGET() {
  return getToken(TSqlParser::TARGET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::When_matchesContext::SOURCE() {
  return getTokens(TSqlParser::SOURCE);
}

tree::TerminalNode* TSqlParser::When_matchesContext::SOURCE(size_t i) {
  return getToken(TSqlParser::SOURCE, i);
}


size_t TSqlParser::When_matchesContext::getRuleIndex() const {
  return TSqlParser::RuleWhen_matches;
}

void TSqlParser::When_matchesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhen_matches(this);
}

void TSqlParser::When_matchesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhen_matches(this);
}

TSqlParser::When_matchesContext* TSqlParser::when_matches() {
  When_matchesContext *_localctx = _tracker.createInstance<When_matchesContext>(_ctx, getState());
  enterRule(_localctx, 70, TSqlParser::RuleWhen_matches);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(959);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(927); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(919);
                match(TSqlParser::WHEN);
                setState(920);
                match(TSqlParser::MATCHED);
                setState(923);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == TSqlParser::AND) {
                  setState(921);
                  match(TSqlParser::AND);
                  setState(922);
                  search_condition(0);
                }
                setState(925);
                match(TSqlParser::THEN);
                setState(926);
                merge_matched();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(929); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(931);
      match(TSqlParser::WHEN);
      setState(932);
      match(TSqlParser::NOT);
      setState(933);
      match(TSqlParser::MATCHED);
      setState(936);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::BY) {
        setState(934);
        match(TSqlParser::BY);
        setState(935);
        match(TSqlParser::TARGET);
      }
      setState(940);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AND) {
        setState(938);
        match(TSqlParser::AND);
        setState(939);
        search_condition(0);
      }
      setState(942);
      match(TSqlParser::THEN);
      setState(943);
      merge_not_matched();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(955); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(944);
                match(TSqlParser::WHEN);
                setState(945);
                match(TSqlParser::NOT);
                setState(946);
                match(TSqlParser::MATCHED);
                setState(947);
                match(TSqlParser::BY);
                setState(948);
                match(TSqlParser::SOURCE);
                setState(951);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == TSqlParser::AND) {
                  setState(949);
                  match(TSqlParser::AND);
                  setState(950);
                  search_condition(0);
                }
                setState(953);
                match(TSqlParser::THEN);
                setState(954);
                merge_matched();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(957); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_matchedContext ------------------------------------------------------------------

TSqlParser::Merge_matchedContext::Merge_matchedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Update_elem_mergeContext *> TSqlParser::Merge_matchedContext::update_elem_merge() {
  return getRuleContexts<TSqlParser::Update_elem_mergeContext>();
}

TSqlParser::Update_elem_mergeContext* TSqlParser::Merge_matchedContext::update_elem_merge(size_t i) {
  return getRuleContext<TSqlParser::Update_elem_mergeContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Merge_matchedContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Merge_matchedContext::DELETE() {
  return getToken(TSqlParser::DELETE, 0);
}


size_t TSqlParser::Merge_matchedContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_matched;
}

void TSqlParser::Merge_matchedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_matched(this);
}

void TSqlParser::Merge_matchedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_matched(this);
}

TSqlParser::Merge_matchedContext* TSqlParser::merge_matched() {
  Merge_matchedContext *_localctx = _tracker.createInstance<Merge_matchedContext>(_ctx, getState());
  enterRule(_localctx, 72, TSqlParser::RuleMerge_matched);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(972);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UPDATE: {
        enterOuterAlt(_localctx, 1);
        setState(961);
        match(TSqlParser::UPDATE);
        setState(962);
        match(TSqlParser::SET);
        setState(963);
        update_elem_merge();
        setState(968);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(964);
          match(TSqlParser::COMMA);
          setState(965);
          update_elem_merge();
          setState(970);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case TSqlParser::DELETE: {
        enterOuterAlt(_localctx, 2);
        setState(971);
        match(TSqlParser::DELETE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_not_matchedContext ------------------------------------------------------------------

TSqlParser::Merge_not_matchedContext::Merge_not_matchedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::INSERT() {
  return getToken(TSqlParser::INSERT, 0);
}

TSqlParser::Table_value_constructorContext* TSqlParser::Merge_not_matchedContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Merge_not_matchedContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Merge_not_matchedContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Merge_not_matchedContext::getRuleIndex() const {
  return TSqlParser::RuleMerge_not_matched;
}

void TSqlParser::Merge_not_matchedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_not_matched(this);
}

void TSqlParser::Merge_not_matchedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_not_matched(this);
}

TSqlParser::Merge_not_matchedContext* TSqlParser::merge_not_matched() {
  Merge_not_matchedContext *_localctx = _tracker.createInstance<Merge_not_matchedContext>(_ctx, getState());
  enterRule(_localctx, 74, TSqlParser::RuleMerge_not_matched);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(974);
    match(TSqlParser::INSERT);
    setState(979);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(975);
      match(TSqlParser::LR_BRACKET);
      setState(976);
      column_name_list();
      setState(977);
      match(TSqlParser::RR_BRACKET);
    }
    setState(984);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::VALUES: {
        setState(981);
        table_value_constructor();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(982);
        match(TSqlParser::DEFAULT);
        setState(983);
        match(TSqlParser::VALUES);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statementContext ------------------------------------------------------------------

TSqlParser::Delete_statementContext::Delete_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Delete_statementContext::DELETE() {
  return getToken(TSqlParser::DELETE, 0);
}

TSqlParser::Delete_statement_fromContext* TSqlParser::Delete_statementContext::delete_statement_from() {
  return getRuleContext<TSqlParser::Delete_statement_fromContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Delete_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Delete_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Delete_statementContext::FROM() {
  return getTokens(TSqlParser::FROM);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::FROM(size_t i) {
  return getToken(TSqlParser::FROM, i);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Delete_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::Output_clauseContext* TSqlParser::Delete_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Delete_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

TSqlParser::Option_clauseContext* TSqlParser::Delete_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Delete_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Delete_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Delete_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Delete_statementContext::getRuleIndex() const {
  return TSqlParser::RuleDelete_statement;
}

void TSqlParser::Delete_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_statement(this);
}

void TSqlParser::Delete_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_statement(this);
}

TSqlParser::Delete_statementContext* TSqlParser::delete_statement() {
  Delete_statementContext *_localctx = _tracker.createInstance<Delete_statementContext>(_ctx, getState());
  enterRule(_localctx, 76, TSqlParser::RuleDelete_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(987);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(986);
      with_expression();
    }
    setState(989);
    match(TSqlParser::DELETE);
    setState(999);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(990);
      match(TSqlParser::TOP);
      setState(991);
      match(TSqlParser::LR_BRACKET);
      setState(992);
      expression(0);
      setState(993);
      match(TSqlParser::RR_BRACKET);
      setState(995);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(994);
        match(TSqlParser::PERCENT);
      }
      break;
    }

    case 2: {
      setState(997);
      match(TSqlParser::TOP);
      setState(998);
      match(TSqlParser::DECIMAL);
      break;
    }

    default:
      break;
    }
    setState(1002);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1001);
      match(TSqlParser::FROM);
    }
    setState(1004);
    delete_statement_from();
    setState(1006);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(1005);
      insert_with_table_hints();
      break;
    }

    default:
      break;
    }
    setState(1009);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      setState(1008);
      output_clause();
      break;
    }

    default:
      break;
    }
    setState(1013);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1011);
      match(TSqlParser::FROM);
      setState(1012);
      table_sources();
    }
    setState(1028);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(1015);
      match(TSqlParser::WHERE);
      setState(1026);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::ABS:
        case TSqlParser::ASCII:
        case TSqlParser::CEILING:
        case TSqlParser::CHAR:
        case TSqlParser::CHARINDEX:
        case TSqlParser::DATALENGTH:
        case TSqlParser::DAY:
        case TSqlParser::FLOOR:
        case TSqlParser::ISDATE:
        case TSqlParser::ISNUMERIC:
        case TSqlParser::LEN:
        case TSqlParser::LOWER:
        case TSqlParser::LTRIM:
        case TSqlParser::MONTH:
        case TSqlParser::NCHAR:
        case TSqlParser::PATINDEX:
        case TSqlParser::RAND:
        case TSqlParser::REPLACE:
        case TSqlParser::ROUND:
        case TSqlParser::RTRIM:
        case TSqlParser::SIGN:
        case TSqlParser::STR:
        case TSqlParser::SUBSTRING:
        case TSqlParser::UPPER:
        case TSqlParser::USER_NAME:
        case TSqlParser::YEAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::CASE:
        case TSqlParser::COALESCE:
        case TSqlParser::CONVERT:
        case TSqlParser::CURRENT_TIMESTAMP:
        case TSqlParser::CURRENT_USER:
        case TSqlParser::DEFAULT:
        case TSqlParser::EXISTS:
        case TSqlParser::IDENTITY:
        case TSqlParser::LEFT:
        case TSqlParser::NOT:
        case TSqlParser::NULL_:
        case TSqlParser::NULLIF:
        case TSqlParser::OVER:
        case TSqlParser::PRECISION:
        case TSqlParser::RIGHT:
        case TSqlParser::SESSION_USER:
        case TSqlParser::SYSTEM_USER:
        case TSqlParser::USER:
        case TSqlParser::DOLLAR_PARTITION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::DOLLAR_ACTION:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::SPACE:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOT:
        case TSqlParser::DOLLAR:
        case TSqlParser::LR_BRACKET:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS:
        case TSqlParser::BIT_NOT: {
          setState(1016);
          search_condition(0);
          break;
        }

        case TSqlParser::CURRENT: {
          setState(1017);
          match(TSqlParser::CURRENT);
          setState(1018);
          match(TSqlParser::OF);
          setState(1024);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
          case 1: {
            setState(1020);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
            case 1: {
              setState(1019);
              match(TSqlParser::GLOBAL);
              break;
            }

            default:
              break;
            }
            setState(1022);
            cursor_name();
            break;
          }

          case 2: {
            setState(1023);
            antlrcpp::downCast<Delete_statementContext *>(_localctx)->cursor_var = match(TSqlParser::LOCAL_ID);
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(1031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1030);
      option_clause();
    }
    setState(1034);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      setState(1033);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_statement_fromContext ------------------------------------------------------------------

TSqlParser::Delete_statement_fromContext::Delete_statement_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Ddl_objectContext* TSqlParser::Delete_statement_fromContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::Table_aliasContext* TSqlParser::Delete_statement_fromContext::table_alias() {
  return getRuleContext<TSqlParser::Table_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Delete_statement_fromContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Delete_statement_fromContext::getRuleIndex() const {
  return TSqlParser::RuleDelete_statement_from;
}

void TSqlParser::Delete_statement_fromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_statement_from(this);
}

void TSqlParser::Delete_statement_fromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_statement_from(this);
}

TSqlParser::Delete_statement_fromContext* TSqlParser::delete_statement_from() {
  Delete_statement_fromContext *_localctx = _tracker.createInstance<Delete_statement_fromContext>(_ctx, getState());
  enterRule(_localctx, 78, TSqlParser::RuleDelete_statement_from);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1039);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1036);
      ddl_object();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1037);
      table_alias();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1038);
      antlrcpp::downCast<Delete_statement_fromContext *>(_localctx)->table_var = match(TSqlParser::LOCAL_ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statementContext ------------------------------------------------------------------

TSqlParser::Insert_statementContext::Insert_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Insert_statementContext::INSERT() {
  return getToken(TSqlParser::INSERT, 0);
}

TSqlParser::Insert_statement_valueContext* TSqlParser::Insert_statementContext::insert_statement_value() {
  return getRuleContext<TSqlParser::Insert_statement_valueContext>(0);
}

TSqlParser::Ddl_objectContext* TSqlParser::Insert_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Insert_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_statementContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::ExpressionContext* TSqlParser::Insert_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_statementContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::Insert_statementContext::insert_with_table_hints() {
  return getRuleContext<TSqlParser::Insert_with_table_hintsContext>(0);
}

TSqlParser::Insert_column_name_listContext* TSqlParser::Insert_statementContext::insert_column_name_list() {
  return getRuleContext<TSqlParser::Insert_column_name_listContext>(0);
}

TSqlParser::Output_clauseContext* TSqlParser::Insert_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}


size_t TSqlParser::Insert_statementContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_statement;
}

void TSqlParser::Insert_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_statement(this);
}

void TSqlParser::Insert_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_statement(this);
}

TSqlParser::Insert_statementContext* TSqlParser::insert_statement() {
  Insert_statementContext *_localctx = _tracker.createInstance<Insert_statementContext>(_ctx, getState());
  enterRule(_localctx, 80, TSqlParser::RuleInsert_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1042);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1041);
      with_expression();
    }
    setState(1044);
    match(TSqlParser::INSERT);
    setState(1052);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(1045);
      match(TSqlParser::TOP);
      setState(1046);
      match(TSqlParser::LR_BRACKET);
      setState(1047);
      expression(0);
      setState(1048);
      match(TSqlParser::RR_BRACKET);
      setState(1050);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1049);
        match(TSqlParser::PERCENT);
      }
    }
    setState(1055);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1054);
      match(TSqlParser::INTO);
    }

    setState(1057);
    ddl_object();
    setState(1059);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1058);
      insert_with_table_hints();
    }
    setState(1065);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(1061);
      match(TSqlParser::LR_BRACKET);
      setState(1062);
      insert_column_name_list();
      setState(1063);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1068);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OUTPUT) {
      setState(1067);
      output_clause();
    }
    setState(1070);
    insert_statement_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_statement_valueContext ------------------------------------------------------------------

TSqlParser::Insert_statement_valueContext::Insert_statement_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_value_constructorContext* TSqlParser::Insert_statement_valueContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}

TSqlParser::Derived_tableContext* TSqlParser::Insert_statement_valueContext::derived_table() {
  return getRuleContext<TSqlParser::Derived_tableContext>(0);
}

TSqlParser::Execute_statementContext* TSqlParser::Insert_statement_valueContext::execute_statement() {
  return getRuleContext<TSqlParser::Execute_statementContext>(0);
}

tree::TerminalNode* TSqlParser::Insert_statement_valueContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Insert_statement_valueContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}


size_t TSqlParser::Insert_statement_valueContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_statement_value;
}

void TSqlParser::Insert_statement_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_statement_value(this);
}

void TSqlParser::Insert_statement_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_statement_value(this);
}

TSqlParser::Insert_statement_valueContext* TSqlParser::insert_statement_value() {
  Insert_statement_valueContext *_localctx = _tracker.createInstance<Insert_statement_valueContext>(_ctx, getState());
  enterRule(_localctx, 82, TSqlParser::RuleInsert_statement_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1077);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1072);
      table_value_constructor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1073);
      derived_table();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1074);
      execute_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1075);
      match(TSqlParser::DEFAULT);
      setState(1076);
      match(TSqlParser::VALUES);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Receive_statementContext ------------------------------------------------------------------

TSqlParser::Receive_statementContext::Receive_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Receive_statementContext::RECEIVE() {
  return getToken(TSqlParser::RECEIVE, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Receive_statementContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}

TSqlParser::Top_clauseContext* TSqlParser::Receive_statementContext::top_clause() {
  return getRuleContext<TSqlParser::Top_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Receive_statementContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Receive_statementContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Id_Context* TSqlParser::Receive_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Receive_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Receive_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Search_conditionContext* TSqlParser::Receive_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}


size_t TSqlParser::Receive_statementContext::getRuleIndex() const {
  return TSqlParser::RuleReceive_statement;
}

void TSqlParser::Receive_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReceive_statement(this);
}

void TSqlParser::Receive_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReceive_statement(this);
}

TSqlParser::Receive_statementContext* TSqlParser::receive_statement() {
  Receive_statementContext *_localctx = _tracker.createInstance<Receive_statementContext>(_ctx, getState());
  enterRule(_localctx, 84, TSqlParser::RuleReceive_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1080);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(1079);
      match(TSqlParser::LR_BRACKET);
    }
    setState(1082);
    match(TSqlParser::RECEIVE);
    setState(1087);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ALL: {
        setState(1083);
        match(TSqlParser::ALL);
        break;
      }

      case TSqlParser::DISTINCT: {
        setState(1084);
        match(TSqlParser::DISTINCT);
        break;
      }

      case TSqlParser::TOP: {
        setState(1085);
        top_clause();
        break;
      }

      case TSqlParser::STAR: {
        setState(1086);
        match(TSqlParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1097);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::LOCAL_ID) {
      setState(1089);
      match(TSqlParser::LOCAL_ID);
      setState(1090);
      match(TSqlParser::EQUAL);
      setState(1091);
      expression(0);
      setState(1093);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(1092);
        match(TSqlParser::COMMA);
      }
      setState(1099);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1100);
    match(TSqlParser::FROM);
    setState(1101);
    full_table_name();
    setState(1107);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1102);
      match(TSqlParser::INTO);
      setState(1103);
      antlrcpp::downCast<Receive_statementContext *>(_localctx)->table_variable = id_();

      setState(1104);
      match(TSqlParser::WHERE);
      setState(1105);
      antlrcpp::downCast<Receive_statementContext *>(_localctx)->where = search_condition(0);
    }
    setState(1110);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::RR_BRACKET) {
      setState(1109);
      match(TSqlParser::RR_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_statement_standaloneContext ------------------------------------------------------------------

TSqlParser::Select_statement_standaloneContext::Select_statement_standaloneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Select_statementContext* TSqlParser::Select_statement_standaloneContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Select_statement_standaloneContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}


size_t TSqlParser::Select_statement_standaloneContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_statement_standalone;
}

void TSqlParser::Select_statement_standaloneContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_statement_standalone(this);
}

void TSqlParser::Select_statement_standaloneContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_statement_standalone(this);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::select_statement_standalone() {
  Select_statement_standaloneContext *_localctx = _tracker.createInstance<Select_statement_standaloneContext>(_ctx, getState());
  enterRule(_localctx, 86, TSqlParser::RuleSelect_statement_standalone);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1113);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1112);
      with_expression();
    }
    setState(1115);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_statementContext ------------------------------------------------------------------

TSqlParser::Select_statementContext::Select_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Query_expressionContext* TSqlParser::Select_statementContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Select_statementContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::Option_clauseContext* TSqlParser::Select_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Select_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Select_statementContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_statement;
}

void TSqlParser::Select_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_statement(this);
}

void TSqlParser::Select_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_statement(this);
}

TSqlParser::Select_statementContext* TSqlParser::select_statement() {
  Select_statementContext *_localctx = _tracker.createInstance<Select_statementContext>(_ctx, getState());
  enterRule(_localctx, 88, TSqlParser::RuleSelect_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1117);
    query_expression();
    setState(1119);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ORDER) {
      setState(1118);
      order_by_clause();
    }
    setState(1122);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1121);
      option_clause();
    }
    setState(1125);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      setState(1124);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeContext ------------------------------------------------------------------

TSqlParser::TimeContext::TimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::TimeContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ConstantContext* TSqlParser::TimeContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::TimeContext::getRuleIndex() const {
  return TSqlParser::RuleTime;
}

void TSqlParser::TimeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime(this);
}

void TSqlParser::TimeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime(this);
}

TSqlParser::TimeContext* TSqlParser::time() {
  TimeContext *_localctx = _tracker.createInstance<TimeContext>(_ctx, getState());
  enterRule(_localctx, 90, TSqlParser::RuleTime);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1129);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LOCAL_ID: {
        setState(1127);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        setState(1128);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_statementContext ------------------------------------------------------------------

TSqlParser::Update_statementContext::Update_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Update_statementContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Update_elemContext *> TSqlParser::Update_statementContext::update_elem() {
  return getRuleContexts<TSqlParser::Update_elemContext>();
}

TSqlParser::Update_elemContext* TSqlParser::Update_statementContext::update_elem(size_t i) {
  return getRuleContext<TSqlParser::Update_elemContext>(i);
}

TSqlParser::Ddl_objectContext* TSqlParser::Update_statementContext::ddl_object() {
  return getRuleContext<TSqlParser::Ddl_objectContext>(0);
}

TSqlParser::With_expressionContext* TSqlParser::Update_statementContext::with_expression() {
  return getRuleContext<TSqlParser::With_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Update_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Update_statementContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Update_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Update_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

TSqlParser::Output_clauseContext* TSqlParser::Update_statementContext::output_clause() {
  return getRuleContext<TSqlParser::Output_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Update_statementContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

TSqlParser::Option_clauseContext* TSqlParser::Update_statementContext::option_clause() {
  return getRuleContext<TSqlParser::Option_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Update_statementContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Update_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Update_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Update_statementContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_statement;
}

void TSqlParser::Update_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_statement(this);
}

void TSqlParser::Update_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_statement(this);
}

TSqlParser::Update_statementContext* TSqlParser::update_statement() {
  Update_statementContext *_localctx = _tracker.createInstance<Update_statementContext>(_ctx, getState());
  enterRule(_localctx, 92, TSqlParser::RuleUpdate_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1132);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1131);
      with_expression();
    }
    setState(1134);
    match(TSqlParser::UPDATE);
    setState(1142);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(1135);
      match(TSqlParser::TOP);
      setState(1136);
      match(TSqlParser::LR_BRACKET);
      setState(1137);
      expression(0);
      setState(1138);
      match(TSqlParser::RR_BRACKET);
      setState(1140);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PERCENT) {
        setState(1139);
        match(TSqlParser::PERCENT);
      }
    }

    setState(1144);
    ddl_object();
    setState(1146);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH || _la == TSqlParser::LR_BRACKET) {
      setState(1145);
      with_table_hints();
    }
    setState(1148);
    match(TSqlParser::SET);
    setState(1149);
    update_elem();
    setState(1154);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1150);
      match(TSqlParser::COMMA);
      setState(1151);
      update_elem();
      setState(1156);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1158);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      setState(1157);
      output_clause();
      break;
    }

    default:
      break;
    }
    setState(1162);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(1160);
      match(TSqlParser::FROM);
      setState(1161);
      table_sources();
    }
    setState(1177);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(1164);
      match(TSqlParser::WHERE);
      setState(1175);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::ABS:
        case TSqlParser::ASCII:
        case TSqlParser::CEILING:
        case TSqlParser::CHAR:
        case TSqlParser::CHARINDEX:
        case TSqlParser::DATALENGTH:
        case TSqlParser::DAY:
        case TSqlParser::FLOOR:
        case TSqlParser::ISDATE:
        case TSqlParser::ISNUMERIC:
        case TSqlParser::LEN:
        case TSqlParser::LOWER:
        case TSqlParser::LTRIM:
        case TSqlParser::MONTH:
        case TSqlParser::NCHAR:
        case TSqlParser::PATINDEX:
        case TSqlParser::RAND:
        case TSqlParser::REPLACE:
        case TSqlParser::ROUND:
        case TSqlParser::RTRIM:
        case TSqlParser::SIGN:
        case TSqlParser::STR:
        case TSqlParser::SUBSTRING:
        case TSqlParser::UPPER:
        case TSqlParser::USER_NAME:
        case TSqlParser::YEAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::CASE:
        case TSqlParser::COALESCE:
        case TSqlParser::CONVERT:
        case TSqlParser::CURRENT_TIMESTAMP:
        case TSqlParser::CURRENT_USER:
        case TSqlParser::DEFAULT:
        case TSqlParser::EXISTS:
        case TSqlParser::IDENTITY:
        case TSqlParser::LEFT:
        case TSqlParser::NOT:
        case TSqlParser::NULL_:
        case TSqlParser::NULLIF:
        case TSqlParser::OVER:
        case TSqlParser::PRECISION:
        case TSqlParser::RIGHT:
        case TSqlParser::SESSION_USER:
        case TSqlParser::SYSTEM_USER:
        case TSqlParser::USER:
        case TSqlParser::DOLLAR_PARTITION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MIN_ACTIVE_ROWVERSION:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::DOLLAR_ACTION:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::SPACE:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOT:
        case TSqlParser::DOLLAR:
        case TSqlParser::LR_BRACKET:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS:
        case TSqlParser::BIT_NOT: {
          setState(1165);
          search_condition(0);
          break;
        }

        case TSqlParser::CURRENT: {
          setState(1166);
          match(TSqlParser::CURRENT);
          setState(1167);
          match(TSqlParser::OF);
          setState(1173);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
          case 1: {
            setState(1169);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
            case 1: {
              setState(1168);
              match(TSqlParser::GLOBAL);
              break;
            }

            default:
              break;
            }
            setState(1171);
            cursor_name();
            break;
          }

          case 2: {
            setState(1172);
            antlrcpp::downCast<Update_statementContext *>(_localctx)->cursor_var = match(TSqlParser::LOCAL_ID);
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(1180);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::OPTION) {
      setState(1179);
      option_clause();
    }
    setState(1183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
    case 1: {
      setState(1182);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_clauseContext ------------------------------------------------------------------

TSqlParser::Output_clauseContext::Output_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Output_clauseContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

std::vector<TSqlParser::Output_dml_list_elemContext *> TSqlParser::Output_clauseContext::output_dml_list_elem() {
  return getRuleContexts<TSqlParser::Output_dml_list_elemContext>();
}

TSqlParser::Output_dml_list_elemContext* TSqlParser::Output_clauseContext::output_dml_list_elem(size_t i) {
  return getRuleContext<TSqlParser::Output_dml_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Output_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Output_clauseContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Output_clauseContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

tree::TerminalNode* TSqlParser::Output_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Output_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOutput_clause;
}

void TSqlParser::Output_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_clause(this);
}

void TSqlParser::Output_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_clause(this);
}

TSqlParser::Output_clauseContext* TSqlParser::output_clause() {
  Output_clauseContext *_localctx = _tracker.createInstance<Output_clauseContext>(_ctx, getState());
  enterRule(_localctx, 94, TSqlParser::RuleOutput_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1185);
    match(TSqlParser::OUTPUT);
    setState(1186);
    output_dml_list_elem();
    setState(1191);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1187);
      match(TSqlParser::COMMA);
      setState(1188);
      output_dml_list_elem();
      setState(1193);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1205);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(1194);
      match(TSqlParser::INTO);
      setState(1197);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
      case 1: {
        setState(1195);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case 2: {
        setState(1196);
        table_name();
        break;
      }

      default:
        break;
      }
      setState(1203);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
      case 1: {
        setState(1199);
        match(TSqlParser::LR_BRACKET);
        setState(1200);
        column_name_list();
        setState(1201);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_dml_list_elemContext ------------------------------------------------------------------

TSqlParser::Output_dml_list_elemContext::Output_dml_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Output_dml_list_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::AsteriskContext* TSqlParser::Output_dml_list_elemContext::asterisk() {
  return getRuleContext<TSqlParser::AsteriskContext>(0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Output_dml_list_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Output_dml_list_elemContext::getRuleIndex() const {
  return TSqlParser::RuleOutput_dml_list_elem;
}

void TSqlParser::Output_dml_list_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_dml_list_elem(this);
}

void TSqlParser::Output_dml_list_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_dml_list_elem(this);
}

TSqlParser::Output_dml_list_elemContext* TSqlParser::output_dml_list_elem() {
  Output_dml_list_elemContext *_localctx = _tracker.createInstance<Output_dml_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 96, TSqlParser::RuleOutput_dml_list_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1209);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
    case 1: {
      setState(1207);
      expression(0);
      break;
    }

    case 2: {
      setState(1208);
      asterisk();
      break;
    }

    default:
      break;
    }
    setState(1212);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1211);
      as_column_alias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_procedureContext ------------------------------------------------------------------

TSqlParser::Create_or_alter_procedureContext::Create_or_alter_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Create_or_alter_procedureContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::PROC() {
  return getToken(TSqlParser::PROC, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::PROCEDURE() {
  return getToken(TSqlParser::PROCEDURE, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

std::vector<TSqlParser::Procedure_paramContext *> TSqlParser::Create_or_alter_procedureContext::procedure_param() {
  return getRuleContexts<TSqlParser::Procedure_paramContext>();
}

TSqlParser::Procedure_paramContext* TSqlParser::Create_or_alter_procedureContext::procedure_param(size_t i) {
  return getRuleContext<TSqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Procedure_optionContext *> TSqlParser::Create_or_alter_procedureContext::procedure_option() {
  return getRuleContexts<TSqlParser::Procedure_optionContext>();
}

TSqlParser::Procedure_optionContext* TSqlParser::Create_or_alter_procedureContext::procedure_option(size_t i) {
  return getRuleContext<TSqlParser::Procedure_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Create_or_alter_procedureContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Create_or_alter_procedureContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_or_alter_procedureContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_procedureContext::OR() {
  return getToken(TSqlParser::OR, 0);
}


size_t TSqlParser::Create_or_alter_procedureContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_or_alter_procedure;
}

void TSqlParser::Create_or_alter_procedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_or_alter_procedure(this);
}

void TSqlParser::Create_or_alter_procedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_or_alter_procedure(this);
}

TSqlParser::Create_or_alter_procedureContext* TSqlParser::create_or_alter_procedure() {
  Create_or_alter_procedureContext *_localctx = _tracker.createInstance<Create_or_alter_procedureContext>(_ctx, getState());
  enterRule(_localctx, 98, TSqlParser::RuleCreate_or_alter_procedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1220);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CREATE: {
        setState(1214);
        match(TSqlParser::CREATE);
        setState(1217);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OR) {
          setState(1215);
          match(TSqlParser::OR);
          setState(1216);
          match(TSqlParser::ALTER);
        }
        break;
      }

      case TSqlParser::ALTER: {
        setState(1219);
        match(TSqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1222);
    antlrcpp::downCast<Create_or_alter_procedureContext *>(_localctx)->proc = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PROC

    || _la == TSqlParser::PROCEDURE)) {
      antlrcpp::downCast<Create_or_alter_procedureContext *>(_localctx)->proc = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1223);
    antlrcpp::downCast<Create_or_alter_procedureContext *>(_localctx)->procName = func_proc_name_schema();
    setState(1226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1224);
      match(TSqlParser::SEMI);
      setState(1225);
      match(TSqlParser::DECIMAL);
    }
    setState(1242);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::LR_BRACKET) {
      setState(1229);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LR_BRACKET) {
        setState(1228);
        match(TSqlParser::LR_BRACKET);
      }
      setState(1231);
      procedure_param();
      setState(1236);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1232);
        match(TSqlParser::COMMA);
        setState(1233);
        procedure_param();
        setState(1238);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1240);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::RR_BRACKET) {
        setState(1239);
        match(TSqlParser::RR_BRACKET);
      }
    }
    setState(1253);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1244);
      match(TSqlParser::WITH);
      setState(1245);
      procedure_option();
      setState(1250);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1246);
        match(TSqlParser::COMMA);
        setState(1247);
        procedure_option();
        setState(1252);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1257);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FOR) {
      setState(1255);
      match(TSqlParser::FOR);
      setState(1256);
      match(TSqlParser::REPLICATION);
    }
    setState(1259);
    match(TSqlParser::AS);

    setState(1263);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1260);
        sql_clauses(); 
      }
      setState(1265);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_or_alter_functionContext ------------------------------------------------------------------

TSqlParser::Create_or_alter_functionContext::Create_or_alter_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::FUNCTION() {
  return getToken(TSqlParser::FUNCTION, 0);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Create_or_alter_functionContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::ALTER() {
  return getToken(TSqlParser::ALTER, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Func_body_returns_selectContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_select() {
  return getRuleContext<TSqlParser::Func_body_returns_selectContext>(0);
}

TSqlParser::Func_body_returns_tableContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_table() {
  return getRuleContext<TSqlParser::Func_body_returns_tableContext>(0);
}

TSqlParser::Func_body_returns_scalarContext* TSqlParser::Create_or_alter_functionContext::func_body_returns_scalar() {
  return getRuleContext<TSqlParser::Func_body_returns_scalarContext>(0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

std::vector<TSqlParser::Procedure_paramContext *> TSqlParser::Create_or_alter_functionContext::procedure_param() {
  return getRuleContexts<TSqlParser::Procedure_paramContext>();
}

TSqlParser::Procedure_paramContext* TSqlParser::Create_or_alter_functionContext::procedure_param(size_t i) {
  return getRuleContext<TSqlParser::Procedure_paramContext>(i);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::OR() {
  return getToken(TSqlParser::OR, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_or_alter_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Create_or_alter_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Create_or_alter_functionContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_or_alter_function;
}

void TSqlParser::Create_or_alter_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_or_alter_function(this);
}

void TSqlParser::Create_or_alter_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_or_alter_function(this);
}

TSqlParser::Create_or_alter_functionContext* TSqlParser::create_or_alter_function() {
  Create_or_alter_functionContext *_localctx = _tracker.createInstance<Create_or_alter_functionContext>(_ctx, getState());
  enterRule(_localctx, 100, TSqlParser::RuleCreate_or_alter_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1272);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CREATE: {
        setState(1266);
        match(TSqlParser::CREATE);
        setState(1269);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OR) {
          setState(1267);
          match(TSqlParser::OR);
          setState(1268);
          match(TSqlParser::ALTER);
        }
        break;
      }

      case TSqlParser::ALTER: {
        setState(1271);
        match(TSqlParser::ALTER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1274);
    match(TSqlParser::FUNCTION);
    setState(1275);
    antlrcpp::downCast<Create_or_alter_functionContext *>(_localctx)->funcName = func_proc_name_schema();
    setState(1289);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      setState(1276);
      match(TSqlParser::LR_BRACKET);
      setState(1277);
      procedure_param();
      setState(1282);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1278);
        match(TSqlParser::COMMA);
        setState(1279);
        procedure_param();
        setState(1284);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1285);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1287);
      match(TSqlParser::LR_BRACKET);
      setState(1288);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1294);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
    case 1: {
      setState(1291);
      func_body_returns_select();
      break;
    }

    case 2: {
      setState(1292);
      func_body_returns_table();
      break;
    }

    case 3: {
      setState(1293);
      func_body_returns_scalar();
      break;
    }

    default:
      break;
    }
    setState(1297);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
    case 1: {
      setState(1296);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_selectContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_selectContext::Func_body_returns_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Func_body_returns_selectContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_selectContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_selectContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_selectContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_selectContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_selectContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_select;
}

void TSqlParser::Func_body_returns_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_select(this);
}

void TSqlParser::Func_body_returns_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_select(this);
}

TSqlParser::Func_body_returns_selectContext* TSqlParser::func_body_returns_select() {
  Func_body_returns_selectContext *_localctx = _tracker.createInstance<Func_body_returns_selectContext>(_ctx, getState());
  enterRule(_localctx, 102, TSqlParser::RuleFunc_body_returns_select);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1299);
    match(TSqlParser::RETURNS);
    setState(1300);
    match(TSqlParser::TABLE);
    setState(1310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1301);
      match(TSqlParser::WITH);
      setState(1302);
      function_option();
      setState(1307);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1303);
        match(TSqlParser::COMMA);
        setState(1304);
        function_option();
        setState(1309);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1313);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1312);
      match(TSqlParser::AS);
    }
    setState(1315);
    match(TSqlParser::RETURN);
    setState(1321);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      setState(1316);
      match(TSqlParser::LR_BRACKET);
      setState(1317);
      select_statement_standalone();
      setState(1318);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1320);
      select_statement_standalone();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_tableContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_tableContext::Func_body_returns_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_type_definitionContext* TSqlParser::Func_body_returns_tableContext::table_type_definition() {
  return getRuleContext<TSqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::END() {
  return getToken(TSqlParser::END, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_tableContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_tableContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Func_body_returns_tableContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Func_body_returns_tableContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_tableContext::SEMI() {
  return getTokens(TSqlParser::SEMI);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::SEMI(size_t i) {
  return getToken(TSqlParser::SEMI, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_tableContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_table;
}

void TSqlParser::Func_body_returns_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_table(this);
}

void TSqlParser::Func_body_returns_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_table(this);
}

TSqlParser::Func_body_returns_tableContext* TSqlParser::func_body_returns_table() {
  Func_body_returns_tableContext *_localctx = _tracker.createInstance<Func_body_returns_tableContext>(_ctx, getState());
  enterRule(_localctx, 104, TSqlParser::RuleFunc_body_returns_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1323);
    match(TSqlParser::RETURNS);
    setState(1324);
    match(TSqlParser::LOCAL_ID);
    setState(1325);
    table_type_definition();
    setState(1335);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1326);
      match(TSqlParser::WITH);
      setState(1327);
      function_option();
      setState(1332);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1328);
        match(TSqlParser::COMMA);
        setState(1329);
        function_option();
        setState(1334);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1338);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1337);
      match(TSqlParser::AS);
    }
    setState(1340);
    match(TSqlParser::BEGIN);
    setState(1344);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1341);
        sql_clauses(); 
      }
      setState(1346);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx);
    }
    setState(1347);
    match(TSqlParser::RETURN);
    setState(1349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1348);
      match(TSqlParser::SEMI);
    }
    setState(1351);
    match(TSqlParser::END);
    setState(1353);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      setState(1352);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_body_returns_scalarContext ------------------------------------------------------------------

TSqlParser::Func_body_returns_scalarContext::Func_body_returns_scalarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Func_body_returns_scalarContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::RETURN() {
  return getToken(TSqlParser::RETURN, 0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::END() {
  return getToken(TSqlParser::END, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Func_body_returns_scalarContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Function_optionContext *> TSqlParser::Func_body_returns_scalarContext::function_option() {
  return getRuleContexts<TSqlParser::Function_optionContext>();
}

TSqlParser::Function_optionContext* TSqlParser::Func_body_returns_scalarContext::function_option(size_t i) {
  return getRuleContext<TSqlParser::Function_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<TSqlParser::Sql_clausesContext *> TSqlParser::Func_body_returns_scalarContext::sql_clauses() {
  return getRuleContexts<TSqlParser::Sql_clausesContext>();
}

TSqlParser::Sql_clausesContext* TSqlParser::Func_body_returns_scalarContext::sql_clauses(size_t i) {
  return getRuleContext<TSqlParser::Sql_clausesContext>(i);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Func_body_returns_scalarContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Func_body_returns_scalarContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Func_body_returns_scalarContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_body_returns_scalar;
}

void TSqlParser::Func_body_returns_scalarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body_returns_scalar(this);
}

void TSqlParser::Func_body_returns_scalarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body_returns_scalar(this);
}

TSqlParser::Func_body_returns_scalarContext* TSqlParser::func_body_returns_scalar() {
  Func_body_returns_scalarContext *_localctx = _tracker.createInstance<Func_body_returns_scalarContext>(_ctx, getState());
  enterRule(_localctx, 106, TSqlParser::RuleFunc_body_returns_scalar);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1355);
    match(TSqlParser::RETURNS);
    setState(1356);
    data_type();
    setState(1366);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(1357);
      match(TSqlParser::WITH);
      setState(1358);
      function_option();
      setState(1363);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1359);
        match(TSqlParser::COMMA);
        setState(1360);
        function_option();
        setState(1365);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1369);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1368);
      match(TSqlParser::AS);
    }
    setState(1371);
    match(TSqlParser::BEGIN);
    setState(1375);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1372);
        sql_clauses(); 
      }
      setState(1377);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx);
    }
    setState(1378);
    match(TSqlParser::RETURN);
    setState(1379);
    antlrcpp::downCast<Func_body_returns_scalarContext *>(_localctx)->ret = expression(0);
    setState(1381);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::SEMI) {
      setState(1380);
      match(TSqlParser::SEMI);
    }
    setState(1383);
    match(TSqlParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_paramContext ------------------------------------------------------------------

TSqlParser::Procedure_paramContext::Procedure_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Procedure_paramContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::VARYING() {
  return getToken(TSqlParser::VARYING, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Id_Context* TSqlParser::Procedure_paramContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Default_valueContext* TSqlParser::Procedure_paramContext::default_value() {
  return getRuleContext<TSqlParser::Default_valueContext>(0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::Procedure_paramContext::READONLY() {
  return getToken(TSqlParser::READONLY, 0);
}


size_t TSqlParser::Procedure_paramContext::getRuleIndex() const {
  return TSqlParser::RuleProcedure_param;
}

void TSqlParser::Procedure_paramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedure_param(this);
}

void TSqlParser::Procedure_paramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedure_param(this);
}

TSqlParser::Procedure_paramContext* TSqlParser::procedure_param() {
  Procedure_paramContext *_localctx = _tracker.createInstance<Procedure_paramContext>(_ctx, getState());
  enterRule(_localctx, 108, TSqlParser::RuleProcedure_param);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1385);
    match(TSqlParser::LOCAL_ID);
    setState(1387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1386);
      match(TSqlParser::AS);
    }
    setState(1392);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {
    case 1: {
      setState(1389);
      antlrcpp::downCast<Procedure_paramContext *>(_localctx)->type_schema = id_();
      setState(1390);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1394);
    data_type();
    setState(1396);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::VARYING) {
      setState(1395);
      match(TSqlParser::VARYING);
    }
    setState(1400);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::EQUAL) {
      setState(1398);
      match(TSqlParser::EQUAL);
      setState(1399);
      antlrcpp::downCast<Procedure_paramContext *>(_localctx)->default_val = default_value();
    }
    setState(1403);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & 524291) != 0)) {
      setState(1402);
      _la = _input->LA(1);
      if (!(((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & 524291) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedure_optionContext ------------------------------------------------------------------

TSqlParser::Procedure_optionContext::Procedure_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Procedure_optionContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Procedure_optionContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

TSqlParser::Execute_clauseContext* TSqlParser::Procedure_optionContext::execute_clause() {
  return getRuleContext<TSqlParser::Execute_clauseContext>(0);
}


size_t TSqlParser::Procedure_optionContext::getRuleIndex() const {
  return TSqlParser::RuleProcedure_option;
}

void TSqlParser::Procedure_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedure_option(this);
}

void TSqlParser::Procedure_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedure_option(this);
}

TSqlParser::Procedure_optionContext* TSqlParser::procedure_option() {
  Procedure_optionContext *_localctx = _tracker.createInstance<Procedure_optionContext>(_ctx, getState());
  enterRule(_localctx, 110, TSqlParser::RuleProcedure_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1408);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(1405);
        match(TSqlParser::ENCRYPTION);
        break;
      }

      case TSqlParser::RECOMPILE: {
        enterOuterAlt(_localctx, 2);
        setState(1406);
        match(TSqlParser::RECOMPILE);
        break;
      }

      case TSqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 3);
        setState(1407);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_optionContext ------------------------------------------------------------------

TSqlParser::Function_optionContext::Function_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Function_optionContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::SCHEMABINDING() {
  return getToken(TSqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Function_optionContext::NULL_() {
  return getTokens(TSqlParser::NULL_);
}

tree::TerminalNode* TSqlParser::Function_optionContext::NULL_(size_t i) {
  return getToken(TSqlParser::NULL_, i);
}

tree::TerminalNode* TSqlParser::Function_optionContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::INPUT() {
  return getToken(TSqlParser::INPUT, 0);
}

tree::TerminalNode* TSqlParser::Function_optionContext::CALLED() {
  return getToken(TSqlParser::CALLED, 0);
}

TSqlParser::Execute_clauseContext* TSqlParser::Function_optionContext::execute_clause() {
  return getRuleContext<TSqlParser::Execute_clauseContext>(0);
}


size_t TSqlParser::Function_optionContext::getRuleIndex() const {
  return TSqlParser::RuleFunction_option;
}

void TSqlParser::Function_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_option(this);
}

void TSqlParser::Function_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_option(this);
}

TSqlParser::Function_optionContext* TSqlParser::function_option() {
  Function_optionContext *_localctx = _tracker.createInstance<Function_optionContext>(_ctx, getState());
  enterRule(_localctx, 112, TSqlParser::RuleFunction_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1422);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(1410);
        match(TSqlParser::ENCRYPTION);
        break;
      }

      case TSqlParser::SCHEMABINDING: {
        enterOuterAlt(_localctx, 2);
        setState(1411);
        match(TSqlParser::SCHEMABINDING);
        break;
      }

      case TSqlParser::RETURNS: {
        enterOuterAlt(_localctx, 3);
        setState(1412);
        match(TSqlParser::RETURNS);
        setState(1413);
        match(TSqlParser::NULL_);
        setState(1414);
        match(TSqlParser::ON);
        setState(1415);
        match(TSqlParser::NULL_);
        setState(1416);
        match(TSqlParser::INPUT);
        break;
      }

      case TSqlParser::CALLED: {
        enterOuterAlt(_localctx, 4);
        setState(1417);
        match(TSqlParser::CALLED);
        setState(1418);
        match(TSqlParser::ON);
        setState(1419);
        match(TSqlParser::NULL_);
        setState(1420);
        match(TSqlParser::INPUT);
        break;
      }

      case TSqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 5);
        setState(1421);
        execute_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_tableContext ------------------------------------------------------------------

TSqlParser::Create_tableContext::Create_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Create_tableContext::CREATE() {
  return getToken(TSqlParser::CREATE, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Create_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Create_tableContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

TSqlParser::Simple_idContext* TSqlParser::Create_tableContext::simple_id() {
  return getRuleContext<TSqlParser::Simple_idContext>(0);
}

std::vector<TSqlParser::Table_optionsContext *> TSqlParser::Create_tableContext::table_options() {
  return getRuleContexts<TSqlParser::Table_optionsContext>();
}

TSqlParser::Table_optionsContext* TSqlParser::Create_tableContext::table_options(size_t i) {
  return getRuleContext<TSqlParser::Table_optionsContext>(i);
}

tree::TerminalNode* TSqlParser::Create_tableContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Create_tableContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Create_tableContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Create_tableContext::DEFAULT() {
  return getTokens(TSqlParser::DEFAULT);
}

tree::TerminalNode* TSqlParser::Create_tableContext::DEFAULT(size_t i) {
  return getToken(TSqlParser::DEFAULT, i);
}

tree::TerminalNode* TSqlParser::Create_tableContext::TEXTIMAGE_ON() {
  return getToken(TSqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* TSqlParser::Create_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Create_tableContext::getRuleIndex() const {
  return TSqlParser::RuleCreate_table;
}

void TSqlParser::Create_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table(this);
}

void TSqlParser::Create_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table(this);
}

TSqlParser::Create_tableContext* TSqlParser::create_table() {
  Create_tableContext *_localctx = _tracker.createInstance<Create_tableContext>(_ctx, getState());
  enterRule(_localctx, 114, TSqlParser::RuleCreate_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1424);
    match(TSqlParser::CREATE);
    setState(1425);
    match(TSqlParser::TABLE);
    setState(1426);
    table_name();
    setState(1427);
    match(TSqlParser::LR_BRACKET);
    setState(1428);
    column_def_table_constraints();
    setState(1430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(1429);
      match(TSqlParser::COMMA);
    }
    setState(1432);
    match(TSqlParser::RR_BRACKET);
    setState(1435);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      setState(1433);
      match(TSqlParser::LOCK);
      setState(1434);
      simple_id();
      break;
    }

    default:
      break;
    }
    setState(1440);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1437);
        table_options(); 
      }
      setState(1442);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx);
    }
    setState(1446);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      setState(1443);
      match(TSqlParser::ON);
      setState(1444);
      id_();
      break;
    }

    case 2: {
      setState(1445);
      match(TSqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
    setState(1451);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(1448);
      match(TSqlParser::TEXTIMAGE_ON);
      setState(1449);
      id_();
      break;
    }

    case 2: {
      setState(1450);
      match(TSqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
    setState(1454);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
    case 1: {
      setState(1453);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_optionsContext ------------------------------------------------------------------

TSqlParser::Table_optionsContext::Table_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_optionsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Index_optionContext *> TSqlParser::Table_optionsContext::index_option() {
  return getRuleContexts<TSqlParser::Index_optionContext>();
}

TSqlParser::Index_optionContext* TSqlParser::Table_optionsContext::index_option(size_t i) {
  return getRuleContext<TSqlParser::Index_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_optionsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_optionsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleTable_options;
}

void TSqlParser::Table_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_options(this);
}

void TSqlParser::Table_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_options(this);
}

TSqlParser::Table_optionsContext* TSqlParser::table_options() {
  Table_optionsContext *_localctx = _tracker.createInstance<Table_optionsContext>(_ctx, getState());
  enterRule(_localctx, 116, TSqlParser::RuleTable_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1456);
    match(TSqlParser::WITH);
    setState(1476);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LR_BRACKET: {
        setState(1457);
        match(TSqlParser::LR_BRACKET);
        setState(1458);
        index_option();
        setState(1463);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(1459);
          match(TSqlParser::COMMA);
          setState(1460);
          index_option();
          setState(1465);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1466);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::ID: {
        setState(1468);
        index_option();
        setState(1473);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(1469);
          match(TSqlParser::COMMA);
          setState(1470);
          index_option();
          setState(1475);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_tableContext ------------------------------------------------------------------

TSqlParser::Alter_tableContext::Alter_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::ALTER() {
  return getTokens(TSqlParser::ALTER);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::ALTER(size_t i) {
  return getToken(TSqlParser::ALTER, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::TABLE() {
  return getTokens(TSqlParser::TABLE);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::TABLE(size_t i) {
  return getToken(TSqlParser::TABLE, i);
}

std::vector<TSqlParser::Table_nameContext *> TSqlParser::Alter_tableContext::table_name() {
  return getRuleContexts<TSqlParser::Table_nameContext>();
}

TSqlParser::Table_nameContext* TSqlParser::Alter_tableContext::table_name(size_t i) {
  return getRuleContext<TSqlParser::Table_nameContext>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::LOCK_ESCALATION() {
  return getToken(TSqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::ADD() {
  return getToken(TSqlParser::ADD, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Alter_tableContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::COLUMN() {
  return getToken(TSqlParser::COLUMN, 0);
}

TSqlParser::Column_definitionContext* TSqlParser::Alter_tableContext::column_definition() {
  return getRuleContext<TSqlParser::Column_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Alter_tableContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Alter_tableContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::REBUILD() {
  return getToken(TSqlParser::REBUILD, 0);
}

TSqlParser::Table_optionsContext* TSqlParser::Alter_tableContext::table_options() {
  return getRuleContext<TSqlParser::Table_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::AUTO() {
  return getToken(TSqlParser::AUTO, 0);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::DISABLE() {
  return getToken(TSqlParser::DISABLE, 0);
}

std::vector<TSqlParser::Column_name_listContext *> TSqlParser::Alter_tableContext::column_name_list() {
  return getRuleContexts<TSqlParser::Column_name_listContext>();
}

TSqlParser::Column_name_listContext* TSqlParser::Alter_tableContext::column_name_list(size_t i) {
  return getRuleContext<TSqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Alter_tableContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Alter_tableContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Alter_tableContext::getRuleIndex() const {
  return TSqlParser::RuleAlter_table;
}

void TSqlParser::Alter_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table(this);
}

void TSqlParser::Alter_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table(this);
}

TSqlParser::Alter_tableContext* TSqlParser::alter_table() {
  Alter_tableContext *_localctx = _tracker.createInstance<Alter_tableContext>(_ctx, getState());
  enterRule(_localctx, 118, TSqlParser::RuleAlter_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1478);
    match(TSqlParser::ALTER);
    setState(1479);
    match(TSqlParser::TABLE);
    setState(1480);
    table_name();
    setState(1526);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      setState(1481);
      match(TSqlParser::SET);
      setState(1482);
      match(TSqlParser::LR_BRACKET);
      setState(1483);
      match(TSqlParser::LOCK_ESCALATION);
      setState(1484);
      match(TSqlParser::EQUAL);
      setState(1485);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TABLE

      || _la == TSqlParser::AUTO || _la == TSqlParser::DISABLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1486);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1487);
      match(TSqlParser::ADD);
      setState(1488);
      column_def_table_constraints();
      break;
    }

    case 3: {
      setState(1489);
      match(TSqlParser::ALTER);
      setState(1490);
      match(TSqlParser::COLUMN);
      setState(1491);
      column_definition();
      break;
    }

    case 4: {
      setState(1492);
      match(TSqlParser::DROP);
      setState(1493);
      match(TSqlParser::COLUMN);
      setState(1494);
      id_();
      setState(1499);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1495);
        match(TSqlParser::COMMA);
        setState(1496);
        id_();
        setState(1501);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 5: {
      setState(1502);
      match(TSqlParser::DROP);
      setState(1503);
      match(TSqlParser::CONSTRAINT);
      setState(1504);
      antlrcpp::downCast<Alter_tableContext *>(_localctx)->constraint = id_();
      break;
    }

    case 6: {
      setState(1505);
      match(TSqlParser::WITH);
      setState(1506);
      match(TSqlParser::CHECK);
      setState(1507);
      match(TSqlParser::ADD);
      setState(1508);
      match(TSqlParser::CONSTRAINT);
      setState(1509);
      antlrcpp::downCast<Alter_tableContext *>(_localctx)->constraint = id_();
      setState(1510);
      match(TSqlParser::FOREIGN);
      setState(1511);
      match(TSqlParser::KEY);
      setState(1512);
      match(TSqlParser::LR_BRACKET);
      setState(1513);
      antlrcpp::downCast<Alter_tableContext *>(_localctx)->fk = column_name_list();
      setState(1514);
      match(TSqlParser::RR_BRACKET);
      setState(1515);
      match(TSqlParser::REFERENCES);
      setState(1516);
      table_name();
      setState(1517);
      match(TSqlParser::LR_BRACKET);
      setState(1518);
      antlrcpp::downCast<Alter_tableContext *>(_localctx)->pk = column_name_list();
      setState(1519);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 7: {
      setState(1521);
      match(TSqlParser::CHECK);
      setState(1522);
      match(TSqlParser::CONSTRAINT);
      setState(1523);
      antlrcpp::downCast<Alter_tableContext *>(_localctx)->constraint = id_();
      break;
    }

    case 8: {
      setState(1524);
      match(TSqlParser::REBUILD);
      setState(1525);
      table_options();
      break;
    }

    default:
      break;
    }
    setState(1529);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
    case 1: {
      setState(1528);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_optionspecContext ------------------------------------------------------------------

TSqlParser::Database_optionspecContext::Database_optionspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Cursor_optionContext* TSqlParser::Database_optionspecContext::cursor_option() {
  return getRuleContext<TSqlParser::Cursor_optionContext>(0);
}


size_t TSqlParser::Database_optionspecContext::getRuleIndex() const {
  return TSqlParser::RuleDatabase_optionspec;
}

void TSqlParser::Database_optionspecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatabase_optionspec(this);
}

void TSqlParser::Database_optionspecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatabase_optionspec(this);
}

TSqlParser::Database_optionspecContext* TSqlParser::database_optionspec() {
  Database_optionspecContext *_localctx = _tracker.createInstance<Database_optionspecContext>(_ctx, getState());
  enterRule(_localctx, 120, TSqlParser::RuleDatabase_optionspec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1531);
    cursor_option();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_optionContext ------------------------------------------------------------------

TSqlParser::Cursor_optionContext::Cursor_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

TSqlParser::On_offContext* TSqlParser::Cursor_optionContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::CURSOR_DEFAULT() {
  return getToken(TSqlParser::CURSOR_DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::Cursor_optionContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}


size_t TSqlParser::Cursor_optionContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_option;
}

void TSqlParser::Cursor_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_option(this);
}

void TSqlParser::Cursor_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_option(this);
}

TSqlParser::Cursor_optionContext* TSqlParser::cursor_option() {
  Cursor_optionContext *_localctx = _tracker.createInstance<Cursor_optionContext>(_ctx, getState());
  enterRule(_localctx, 122, TSqlParser::RuleCursor_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1537);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT: {
        enterOuterAlt(_localctx, 1);
        setState(1533);
        match(TSqlParser::CURSOR_CLOSE_ON_COMMIT);
        setState(1534);
        on_off();
        break;
      }

      case TSqlParser::CURSOR_DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(1535);
        match(TSqlParser::CURSOR_DEFAULT);
        setState(1536);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::GLOBAL

        || _la == TSqlParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_procedureContext ------------------------------------------------------------------

TSqlParser::Drop_procedureContext::Drop_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

std::vector<TSqlParser::Func_proc_name_schemaContext *> TSqlParser::Drop_procedureContext::func_proc_name_schema() {
  return getRuleContexts<TSqlParser::Func_proc_name_schemaContext>();
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Drop_procedureContext::func_proc_name_schema(size_t i) {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::PROC() {
  return getToken(TSqlParser::PROC, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::PROCEDURE() {
  return getToken(TSqlParser::PROCEDURE, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_procedureContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Drop_procedureContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_procedureContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_procedure;
}

void TSqlParser::Drop_procedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_procedure(this);
}

void TSqlParser::Drop_procedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_procedure(this);
}

TSqlParser::Drop_procedureContext* TSqlParser::drop_procedure() {
  Drop_procedureContext *_localctx = _tracker.createInstance<Drop_procedureContext>(_ctx, getState());
  enterRule(_localctx, 124, TSqlParser::RuleDrop_procedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1539);
    match(TSqlParser::DROP);
    setState(1540);
    antlrcpp::downCast<Drop_procedureContext *>(_localctx)->proc = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PROC

    || _la == TSqlParser::PROCEDURE)) {
      antlrcpp::downCast<Drop_procedureContext *>(_localctx)->proc = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1543);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(1541);
      match(TSqlParser::IF);
      setState(1542);
      match(TSqlParser::EXISTS);
    }
    setState(1545);
    func_proc_name_schema();
    setState(1550);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1546);
      match(TSqlParser::COMMA);
      setState(1547);
      func_proc_name_schema();
      setState(1552);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1554);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
    case 1: {
      setState(1553);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_functionContext ------------------------------------------------------------------

TSqlParser::Drop_functionContext::Drop_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_functionContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::FUNCTION() {
  return getToken(TSqlParser::FUNCTION, 0);
}

std::vector<TSqlParser::Func_proc_name_schemaContext *> TSqlParser::Drop_functionContext::func_proc_name_schema() {
  return getRuleContexts<TSqlParser::Func_proc_name_schemaContext>();
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Drop_functionContext::func_proc_name_schema(size_t i) {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(i);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Drop_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Drop_functionContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_functionContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_function;
}

void TSqlParser::Drop_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_function(this);
}

void TSqlParser::Drop_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_function(this);
}

TSqlParser::Drop_functionContext* TSqlParser::drop_function() {
  Drop_functionContext *_localctx = _tracker.createInstance<Drop_functionContext>(_ctx, getState());
  enterRule(_localctx, 126, TSqlParser::RuleDrop_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1556);
    match(TSqlParser::DROP);
    setState(1557);
    match(TSqlParser::FUNCTION);
    setState(1560);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(1558);
      match(TSqlParser::IF);
      setState(1559);
      match(TSqlParser::EXISTS);
    }
    setState(1562);
    func_proc_name_schema();
    setState(1567);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(1563);
      match(TSqlParser::COMMA);
      setState(1564);
      func_proc_name_schema();
      setState(1569);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1571);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
    case 1: {
      setState(1570);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_tableContext ------------------------------------------------------------------

TSqlParser::Drop_tableContext::Drop_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Drop_tableContext::DROP() {
  return getToken(TSqlParser::DROP, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Drop_tableContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::IF() {
  return getToken(TSqlParser::IF, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::Drop_tableContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Drop_tableContext::getRuleIndex() const {
  return TSqlParser::RuleDrop_table;
}

void TSqlParser::Drop_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_table(this);
}

void TSqlParser::Drop_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_table(this);
}

TSqlParser::Drop_tableContext* TSqlParser::drop_table() {
  Drop_tableContext *_localctx = _tracker.createInstance<Drop_tableContext>(_ctx, getState());
  enterRule(_localctx, 128, TSqlParser::RuleDrop_table);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1573);
    match(TSqlParser::DROP);
    setState(1574);
    match(TSqlParser::TABLE);
    setState(1577);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::IF) {
      setState(1575);
      match(TSqlParser::IF);
      setState(1576);
      match(TSqlParser::EXISTS);
    }
    setState(1579);
    table_name();
    setState(1581);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
    case 1: {
      setState(1580);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_statementContext ------------------------------------------------------------------

TSqlParser::Declare_statementContext::Declare_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_statementContext::DECLARE() {
  return getToken(TSqlParser::DECLARE, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Table_type_definitionContext* TSqlParser::Declare_statementContext::table_type_definition() {
  return getRuleContext<TSqlParser::Table_type_definitionContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<TSqlParser::Declare_localContext *> TSqlParser::Declare_statementContext::declare_local() {
  return getRuleContexts<TSqlParser::Declare_localContext>();
}

TSqlParser::Declare_localContext* TSqlParser::Declare_statementContext::declare_local(size_t i) {
  return getRuleContext<TSqlParser::Declare_localContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Declare_statementContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Declare_statementContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Declare_statementContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_statement;
}

void TSqlParser::Declare_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_statement(this);
}

void TSqlParser::Declare_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_statement(this);
}

TSqlParser::Declare_statementContext* TSqlParser::declare_statement() {
  Declare_statementContext *_localctx = _tracker.createInstance<Declare_statementContext>(_ctx, getState());
  enterRule(_localctx, 130, TSqlParser::RuleDeclare_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1604);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1583);
      match(TSqlParser::DECLARE);
      setState(1584);
      match(TSqlParser::LOCAL_ID);
      setState(1586);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::AS) {
        setState(1585);
        match(TSqlParser::AS);
      }
      setState(1588);
      table_type_definition();
      setState(1590);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx)) {
      case 1: {
        setState(1589);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1592);
      match(TSqlParser::DECLARE);
      setState(1593);
      antlrcpp::downCast<Declare_statementContext *>(_localctx)->declare_localContext = declare_local();
      antlrcpp::downCast<Declare_statementContext *>(_localctx)->loc.push_back(antlrcpp::downCast<Declare_statementContext *>(_localctx)->declare_localContext);
      setState(1598);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1594);
        match(TSqlParser::COMMA);
        setState(1595);
        antlrcpp::downCast<Declare_statementContext *>(_localctx)->declare_localContext = declare_local();
        antlrcpp::downCast<Declare_statementContext *>(_localctx)->loc.push_back(antlrcpp::downCast<Declare_statementContext *>(_localctx)->declare_localContext);
        setState(1600);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1602);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
      case 1: {
        setState(1601);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_statementContext ------------------------------------------------------------------

TSqlParser::Cursor_statementContext::Cursor_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::CLOSE() {
  return getToken(TSqlParser::CLOSE, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Cursor_statementContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::DEALLOCATE() {
  return getToken(TSqlParser::DEALLOCATE, 0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

TSqlParser::Declare_cursorContext* TSqlParser::Cursor_statementContext::declare_cursor() {
  return getRuleContext<TSqlParser::Declare_cursorContext>(0);
}

TSqlParser::Fetch_cursorContext* TSqlParser::Cursor_statementContext::fetch_cursor() {
  return getRuleContext<TSqlParser::Fetch_cursorContext>(0);
}

tree::TerminalNode* TSqlParser::Cursor_statementContext::OPEN() {
  return getToken(TSqlParser::OPEN, 0);
}


size_t TSqlParser::Cursor_statementContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_statement;
}

void TSqlParser::Cursor_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_statement(this);
}

void TSqlParser::Cursor_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_statement(this);
}

TSqlParser::Cursor_statementContext* TSqlParser::cursor_statement() {
  Cursor_statementContext *_localctx = _tracker.createInstance<Cursor_statementContext>(_ctx, getState());
  enterRule(_localctx, 132, TSqlParser::RuleCursor_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1635);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CLOSE: {
        enterOuterAlt(_localctx, 1);
        setState(1606);
        match(TSqlParser::CLOSE);
        setState(1608);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
        case 1: {
          setState(1607);
          match(TSqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1610);
        cursor_name();
        setState(1612);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
        case 1: {
          setState(1611);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::DEALLOCATE: {
        enterOuterAlt(_localctx, 2);
        setState(1614);
        match(TSqlParser::DEALLOCATE);
        setState(1616);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
        case 1: {
          setState(1615);
          match(TSqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1619);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::CURSOR) {
          setState(1618);
          match(TSqlParser::CURSOR);
        }
        setState(1621);
        cursor_name();
        setState(1623);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
        case 1: {
          setState(1622);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::DECLARE: {
        enterOuterAlt(_localctx, 3);
        setState(1625);
        declare_cursor();
        break;
      }

      case TSqlParser::FETCH: {
        enterOuterAlt(_localctx, 4);
        setState(1626);
        fetch_cursor();
        break;
      }

      case TSqlParser::OPEN: {
        enterOuterAlt(_localctx, 5);
        setState(1627);
        match(TSqlParser::OPEN);
        setState(1629);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
        case 1: {
          setState(1628);
          match(TSqlParser::GLOBAL);
          break;
        }

        default:
          break;
        }
        setState(1631);
        cursor_name();
        setState(1633);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx)) {
        case 1: {
          setState(1632);
          match(TSqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_statementContext ------------------------------------------------------------------

TSqlParser::Kill_statementContext::Kill_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_statementContext::KILL() {
  return getToken(TSqlParser::KILL, 0);
}

TSqlParser::Kill_processContext* TSqlParser::Kill_statementContext::kill_process() {
  return getRuleContext<TSqlParser::Kill_processContext>(0);
}

TSqlParser::Kill_query_notificationContext* TSqlParser::Kill_statementContext::kill_query_notification() {
  return getRuleContext<TSqlParser::Kill_query_notificationContext>(0);
}


size_t TSqlParser::Kill_statementContext::getRuleIndex() const {
  return TSqlParser::RuleKill_statement;
}

void TSqlParser::Kill_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_statement(this);
}

void TSqlParser::Kill_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_statement(this);
}

TSqlParser::Kill_statementContext* TSqlParser::kill_statement() {
  Kill_statementContext *_localctx = _tracker.createInstance<Kill_statementContext>(_ctx, getState());
  enterRule(_localctx, 134, TSqlParser::RuleKill_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1637);
    match(TSqlParser::KILL);
    setState(1640);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UOW:
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING: {
        setState(1638);
        kill_process();
        break;
      }

      case TSqlParser::QUERY: {
        setState(1639);
        kill_query_notification();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_processContext ------------------------------------------------------------------

TSqlParser::Kill_processContext::Kill_processContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_processContext::UOW() {
  return getToken(TSqlParser::UOW, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::STATUSONLY() {
  return getToken(TSqlParser::STATUSONLY, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Kill_processContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Kill_processContext::getRuleIndex() const {
  return TSqlParser::RuleKill_process;
}

void TSqlParser::Kill_processContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_process(this);
}

void TSqlParser::Kill_processContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_process(this);
}

TSqlParser::Kill_processContext* TSqlParser::kill_process() {
  Kill_processContext *_localctx = _tracker.createInstance<Kill_processContext>(_ctx, getState());
  enterRule(_localctx, 136, TSqlParser::RuleKill_process);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1644);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING: {
        setState(1642);
        antlrcpp::downCast<Kill_processContext *>(_localctx)->session_id = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DECIMAL

        || _la == TSqlParser::STRING)) {
          antlrcpp::downCast<Kill_processContext *>(_localctx)->session_id = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::UOW: {
        setState(1643);
        match(TSqlParser::UOW);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1648);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
    case 1: {
      setState(1646);
      match(TSqlParser::WITH);
      setState(1647);
      match(TSqlParser::STATUSONLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kill_query_notificationContext ------------------------------------------------------------------

TSqlParser::Kill_query_notificationContext::Kill_query_notificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::QUERY() {
  return getToken(TSqlParser::QUERY, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::NOTIFICATION() {
  return getToken(TSqlParser::NOTIFICATION, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::SUBSCRIPTION() {
  return getToken(TSqlParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::Kill_query_notificationContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Kill_query_notificationContext::getRuleIndex() const {
  return TSqlParser::RuleKill_query_notification;
}

void TSqlParser::Kill_query_notificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill_query_notification(this);
}

void TSqlParser::Kill_query_notificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill_query_notification(this);
}

TSqlParser::Kill_query_notificationContext* TSqlParser::kill_query_notification() {
  Kill_query_notificationContext *_localctx = _tracker.createInstance<Kill_query_notificationContext>(_ctx, getState());
  enterRule(_localctx, 138, TSqlParser::RuleKill_query_notification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1650);
    match(TSqlParser::QUERY);
    setState(1651);
    match(TSqlParser::NOTIFICATION);
    setState(1652);
    match(TSqlParser::SUBSCRIPTION);
    setState(1655);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ALL: {
        setState(1653);
        match(TSqlParser::ALL);
        break;
      }

      case TSqlParser::DECIMAL: {
        setState(1654);
        antlrcpp::downCast<Kill_query_notificationContext *>(_localctx)->subscription_id = match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statementContext ------------------------------------------------------------------

TSqlParser::Execute_statementContext::Execute_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_statementContext::EXECUTE() {
  return getToken(TSqlParser::EXECUTE, 0);
}

TSqlParser::Execute_bodyContext* TSqlParser::Execute_statementContext::execute_body() {
  return getRuleContext<TSqlParser::Execute_bodyContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Execute_statementContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement;
}

void TSqlParser::Execute_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement(this);
}

void TSqlParser::Execute_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement(this);
}

TSqlParser::Execute_statementContext* TSqlParser::execute_statement() {
  Execute_statementContext *_localctx = _tracker.createInstance<Execute_statementContext>(_ctx, getState());
  enterRule(_localctx, 140, TSqlParser::RuleExecute_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1657);
    match(TSqlParser::EXECUTE);
    setState(1658);
    execute_body();
    setState(1660);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
    case 1: {
      setState(1659);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_body_batchContext ------------------------------------------------------------------

TSqlParser::Execute_body_batchContext::Execute_body_batchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Execute_body_batchContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

std::vector<TSqlParser::Execute_statement_argContext *> TSqlParser::Execute_body_batchContext::execute_statement_arg() {
  return getRuleContexts<TSqlParser::Execute_statement_argContext>();
}

TSqlParser::Execute_statement_argContext* TSqlParser::Execute_body_batchContext::execute_statement_arg(size_t i) {
  return getRuleContext<TSqlParser::Execute_statement_argContext>(i);
}

tree::TerminalNode* TSqlParser::Execute_body_batchContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_body_batchContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Execute_body_batchContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Execute_body_batchContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_body_batch;
}

void TSqlParser::Execute_body_batchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_body_batch(this);
}

void TSqlParser::Execute_body_batchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_body_batch(this);
}

TSqlParser::Execute_body_batchContext* TSqlParser::execute_body_batch() {
  Execute_body_batchContext *_localctx = _tracker.createInstance<Execute_body_batchContext>(_ctx, getState());
  enterRule(_localctx, 142, TSqlParser::RuleExecute_body_batch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1662);
    func_proc_name_server_database_schema();
    setState(1671);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
    case 1: {
      setState(1663);
      execute_statement_arg();
      setState(1668);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(1664);
        match(TSqlParser::COMMA);
        setState(1665);
        execute_statement_arg();
        setState(1670);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(1674);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx)) {
    case 1: {
      setState(1673);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_bodyContext ------------------------------------------------------------------

TSqlParser::Execute_bodyContext::Execute_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Execute_bodyContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

std::vector<TSqlParser::Execute_var_stringContext *> TSqlParser::Execute_bodyContext::execute_var_string() {
  return getRuleContexts<TSqlParser::Execute_var_stringContext>();
}

TSqlParser::Execute_var_stringContext* TSqlParser::Execute_bodyContext::execute_var_string(size_t i) {
  return getRuleContext<TSqlParser::Execute_var_stringContext>(i);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Execute_statement_argContext* TSqlParser::Execute_bodyContext::execute_statement_arg() {
  return getRuleContext<TSqlParser::Execute_statement_argContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_bodyContext::PLUS() {
  return getTokens(TSqlParser::PLUS);
}

tree::TerminalNode* TSqlParser::Execute_bodyContext::PLUS(size_t i) {
  return getToken(TSqlParser::PLUS, i);
}


size_t TSqlParser::Execute_bodyContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_body;
}

void TSqlParser::Execute_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_body(this);
}

void TSqlParser::Execute_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_body(this);
}

TSqlParser::Execute_bodyContext* TSqlParser::execute_body() {
  Execute_bodyContext *_localctx = _tracker.createInstance<Execute_bodyContext>(_ctx, getState());
  enterRule(_localctx, 144, TSqlParser::RuleExecute_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1698);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::LOCAL_ID:
      case TSqlParser::ID:
      case TSqlParser::STRING:
      case TSqlParser::DOT: {
        enterOuterAlt(_localctx, 1);
        setState(1678);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
        case 1: {
          setState(1676);
          antlrcpp::downCast<Execute_bodyContext *>(_localctx)->return_status = match(TSqlParser::LOCAL_ID);
          setState(1677);
          match(TSqlParser::EQUAL);
          break;
        }

        default:
          break;
        }
        setState(1682);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CHAR:
          case TSqlParser::NCHAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::PRECISION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID:
          case TSqlParser::DOT: {
            setState(1680);
            func_proc_name_server_database_schema();
            break;
          }

          case TSqlParser::LOCAL_ID:
          case TSqlParser::STRING: {
            setState(1681);
            execute_var_string();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1685);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
        case 1: {
          setState(1684);
          execute_statement_arg();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(1687);
        match(TSqlParser::LR_BRACKET);
        setState(1688);
        execute_var_string();
        setState(1693);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::PLUS) {
          setState(1689);
          match(TSqlParser::PLUS);
          setState(1690);
          execute_var_string();
          setState(1695);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1696);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_argContext ------------------------------------------------------------------

TSqlParser::Execute_statement_argContext::Execute_statement_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Execute_statement_arg_unnamedContext* TSqlParser::Execute_statement_argContext::execute_statement_arg_unnamed() {
  return getRuleContext<TSqlParser::Execute_statement_arg_unnamedContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Execute_statement_argContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Execute_statement_argContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<TSqlParser::Execute_statement_argContext *> TSqlParser::Execute_statement_argContext::execute_statement_arg() {
  return getRuleContexts<TSqlParser::Execute_statement_argContext>();
}

TSqlParser::Execute_statement_argContext* TSqlParser::Execute_statement_argContext::execute_statement_arg(size_t i) {
  return getRuleContext<TSqlParser::Execute_statement_argContext>(i);
}

std::vector<TSqlParser::Execute_statement_arg_namedContext *> TSqlParser::Execute_statement_argContext::execute_statement_arg_named() {
  return getRuleContexts<TSqlParser::Execute_statement_arg_namedContext>();
}

TSqlParser::Execute_statement_arg_namedContext* TSqlParser::Execute_statement_argContext::execute_statement_arg_named(size_t i) {
  return getRuleContext<TSqlParser::Execute_statement_arg_namedContext>(i);
}


size_t TSqlParser::Execute_statement_argContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement_arg;
}

void TSqlParser::Execute_statement_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement_arg(this);
}

void TSqlParser::Execute_statement_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement_arg(this);
}

TSqlParser::Execute_statement_argContext* TSqlParser::execute_statement_arg() {
  Execute_statement_argContext *_localctx = _tracker.createInstance<Execute_statement_argContext>(_ctx, getState());
  enterRule(_localctx, 146, TSqlParser::RuleExecute_statement_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1716);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1700);
      execute_statement_arg_unnamed();
      setState(1705);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1701);
          match(TSqlParser::COMMA);
          setState(1702);
          execute_statement_arg(); 
        }
        setState(1707);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1708);
      execute_statement_arg_named();
      setState(1713);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1709);
          match(TSqlParser::COMMA);
          setState(1710);
          execute_statement_arg_named(); 
        }
        setState(1715);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_arg_namedContext ------------------------------------------------------------------

TSqlParser::Execute_statement_arg_namedContext::Execute_statement_arg_namedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_statement_arg_namedContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Execute_statement_arg_namedContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Execute_parameterContext* TSqlParser::Execute_statement_arg_namedContext::execute_parameter() {
  return getRuleContext<TSqlParser::Execute_parameterContext>(0);
}


size_t TSqlParser::Execute_statement_arg_namedContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement_arg_named;
}

void TSqlParser::Execute_statement_arg_namedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement_arg_named(this);
}

void TSqlParser::Execute_statement_arg_namedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement_arg_named(this);
}

TSqlParser::Execute_statement_arg_namedContext* TSqlParser::execute_statement_arg_named() {
  Execute_statement_arg_namedContext *_localctx = _tracker.createInstance<Execute_statement_arg_namedContext>(_ctx, getState());
  enterRule(_localctx, 148, TSqlParser::RuleExecute_statement_arg_named);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1718);
    antlrcpp::downCast<Execute_statement_arg_namedContext *>(_localctx)->name = match(TSqlParser::LOCAL_ID);
    setState(1719);
    match(TSqlParser::EQUAL);
    setState(1720);
    antlrcpp::downCast<Execute_statement_arg_namedContext *>(_localctx)->value = execute_parameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_statement_arg_unnamedContext ------------------------------------------------------------------

TSqlParser::Execute_statement_arg_unnamedContext::Execute_statement_arg_unnamedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Execute_parameterContext* TSqlParser::Execute_statement_arg_unnamedContext::execute_parameter() {
  return getRuleContext<TSqlParser::Execute_parameterContext>(0);
}


size_t TSqlParser::Execute_statement_arg_unnamedContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_statement_arg_unnamed;
}

void TSqlParser::Execute_statement_arg_unnamedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_statement_arg_unnamed(this);
}

void TSqlParser::Execute_statement_arg_unnamedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_statement_arg_unnamed(this);
}

TSqlParser::Execute_statement_arg_unnamedContext* TSqlParser::execute_statement_arg_unnamed() {
  Execute_statement_arg_unnamedContext *_localctx = _tracker.createInstance<Execute_statement_arg_unnamedContext>(_ctx, getState());
  enterRule(_localctx, 150, TSqlParser::RuleExecute_statement_arg_unnamed);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1722);
    antlrcpp::downCast<Execute_statement_arg_unnamedContext *>(_localctx)->value = execute_parameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_parameterContext ------------------------------------------------------------------

TSqlParser::Execute_parameterContext::Execute_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ConstantContext* TSqlParser::Execute_parameterContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Id_Context* TSqlParser::Execute_parameterContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::Execute_parameterContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}


size_t TSqlParser::Execute_parameterContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_parameter;
}

void TSqlParser::Execute_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_parameter(this);
}

void TSqlParser::Execute_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_parameter(this);
}

TSqlParser::Execute_parameterContext* TSqlParser::execute_parameter() {
  Execute_parameterContext *_localctx = _tracker.createInstance<Execute_parameterContext>(_ctx, getState());
  enterRule(_localctx, 152, TSqlParser::RuleExecute_parameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1732);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        setState(1724);
        constant();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        setState(1725);
        match(TSqlParser::LOCAL_ID);
        setState(1727);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
        case 1: {
          setState(1726);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::OUT

          || _la == TSqlParser::OUTPUT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(1729);
        id_();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(1730);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::NULL_: {
        setState(1731);
        match(TSqlParser::NULL_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_var_stringContext ------------------------------------------------------------------

TSqlParser::Execute_var_stringContext::Execute_var_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_var_stringContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Execute_var_stringContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Execute_var_stringContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_var_string;
}

void TSqlParser::Execute_var_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_var_string(this);
}

void TSqlParser::Execute_var_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_var_string(this);
}

TSqlParser::Execute_var_stringContext* TSqlParser::execute_var_string() {
  Execute_var_stringContext *_localctx = _tracker.createInstance<Execute_var_stringContext>(_ctx, getState());
  enterRule(_localctx, 154, TSqlParser::RuleExecute_var_string);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1734);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlgorithmContext ------------------------------------------------------------------

TSqlParser::AlgorithmContext::AlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::AlgorithmContext::DES() {
  return getToken(TSqlParser::DES, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::TRIPLE_DES() {
  return getToken(TSqlParser::TRIPLE_DES, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::TRIPLE_DES_3KEY() {
  return getToken(TSqlParser::TRIPLE_DES_3KEY, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::RC2() {
  return getToken(TSqlParser::RC2, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::RC4() {
  return getToken(TSqlParser::RC4, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::RC4_128() {
  return getToken(TSqlParser::RC4_128, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::DESX() {
  return getToken(TSqlParser::DESX, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::AES_128() {
  return getToken(TSqlParser::AES_128, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::AES_192() {
  return getToken(TSqlParser::AES_192, 0);
}

tree::TerminalNode* TSqlParser::AlgorithmContext::AES_256() {
  return getToken(TSqlParser::AES_256, 0);
}


size_t TSqlParser::AlgorithmContext::getRuleIndex() const {
  return TSqlParser::RuleAlgorithm;
}

void TSqlParser::AlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlgorithm(this);
}

void TSqlParser::AlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlgorithm(this);
}

TSqlParser::AlgorithmContext* TSqlParser::algorithm() {
  AlgorithmContext *_localctx = _tracker.createInstance<AlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 156, TSqlParser::RuleAlgorithm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1736);
    _la = _input->LA(1);
    if (!(((((_la - 169) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 169)) & 5497558138887) != 0) || ((((_la - 296) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 296)) & 52776558133255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_statementContext ------------------------------------------------------------------

TSqlParser::Set_statementContext::Set_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Set_statementContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Set_statementContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Id_Context* TSqlParser::Set_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Set_statementContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::Set_statementContext::declare_set_cursor_common() {
  return getRuleContext<TSqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Set_statementContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Set_statementContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

TSqlParser::Set_specialContext* TSqlParser::Set_statementContext::set_special() {
  return getRuleContext<TSqlParser::Set_specialContext>(0);
}


size_t TSqlParser::Set_statementContext::getRuleIndex() const {
  return TSqlParser::RuleSet_statement;
}

void TSqlParser::Set_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_statement(this);
}

void TSqlParser::Set_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_statement(this);
}

TSqlParser::Set_statementContext* TSqlParser::set_statement() {
  Set_statementContext *_localctx = _tracker.createInstance<Set_statementContext>(_ctx, getState());
  enterRule(_localctx, 158, TSqlParser::RuleSet_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1777);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1738);
      match(TSqlParser::SET);
      setState(1739);
      match(TSqlParser::LOCAL_ID);
      setState(1742);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::DOT) {
        setState(1740);
        match(TSqlParser::DOT);
        setState(1741);
        antlrcpp::downCast<Set_statementContext *>(_localctx)->member_name = id_();
      }
      setState(1744);
      match(TSqlParser::EQUAL);
      setState(1745);
      expression(0);
      setState(1747);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
      case 1: {
        setState(1746);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1749);
      match(TSqlParser::SET);
      setState(1750);
      match(TSqlParser::LOCAL_ID);
      setState(1751);
      assignment_operator();
      setState(1752);
      expression(0);
      setState(1754);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
      case 1: {
        setState(1753);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1756);
      match(TSqlParser::SET);
      setState(1757);
      match(TSqlParser::LOCAL_ID);
      setState(1758);
      match(TSqlParser::EQUAL);
      setState(1759);
      match(TSqlParser::CURSOR);
      setState(1760);
      declare_set_cursor_common();
      setState(1771);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::FOR) {
        setState(1761);
        match(TSqlParser::FOR);
        setState(1769);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::READ: {
            setState(1762);
            match(TSqlParser::READ);
            setState(1763);
            match(TSqlParser::ONLY);
            break;
          }

          case TSqlParser::UPDATE: {
            setState(1764);
            match(TSqlParser::UPDATE);
            setState(1767);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == TSqlParser::OF) {
              setState(1765);
              match(TSqlParser::OF);
              setState(1766);
              column_name_list();
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(1774);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        setState(1773);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1776);
      set_special();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_statementContext ------------------------------------------------------------------

TSqlParser::Transaction_statementContext::Transaction_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::BEGIN() {
  return getToken(TSqlParser::BEGIN, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::DISTRIBUTED() {
  return getToken(TSqlParser::DISTRIBUTED, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::TRAN() {
  return getToken(TSqlParser::TRAN, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::TRANSACTION() {
  return getToken(TSqlParser::TRANSACTION, 0);
}

TSqlParser::Id_Context* TSqlParser::Transaction_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::MARK() {
  return getToken(TSqlParser::MARK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::COMMIT() {
  return getToken(TSqlParser::COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::DELAYED_DURABILITY() {
  return getToken(TSqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::WORK() {
  return getToken(TSqlParser::WORK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::ROLLBACK() {
  return getToken(TSqlParser::ROLLBACK, 0);
}

tree::TerminalNode* TSqlParser::Transaction_statementContext::SAVE() {
  return getToken(TSqlParser::SAVE, 0);
}


size_t TSqlParser::Transaction_statementContext::getRuleIndex() const {
  return TSqlParser::RuleTransaction_statement;
}

void TSqlParser::Transaction_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_statement(this);
}

void TSqlParser::Transaction_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_statement(this);
}

TSqlParser::Transaction_statementContext* TSqlParser::transaction_statement() {
  Transaction_statementContext *_localctx = _tracker.createInstance<Transaction_statementContext>(_ctx, getState());
  enterRule(_localctx, 160, TSqlParser::RuleTransaction_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1860);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1779);
      match(TSqlParser::BEGIN);
      setState(1780);
      match(TSqlParser::DISTRIBUTED);
      setState(1781);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1784);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
      case 1: {
        setState(1782);
        id_();
        break;
      }

      case 2: {
        setState(1783);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1787);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
      case 1: {
        setState(1786);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1789);
      match(TSqlParser::BEGIN);
      setState(1790);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1800);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
      case 1: {
        setState(1793);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CHAR:
          case TSqlParser::NCHAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::PRECISION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(1791);
            id_();
            break;
          }

          case TSqlParser::LOCAL_ID: {
            setState(1792);
            match(TSqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1798);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, _ctx)) {
        case 1: {
          setState(1795);
          match(TSqlParser::WITH);
          setState(1796);
          match(TSqlParser::MARK);
          setState(1797);
          match(TSqlParser::STRING);
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(1803);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
      case 1: {
        setState(1802);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1805);
      match(TSqlParser::COMMIT);
      setState(1806);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1819);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
      case 1: {
        setState(1809);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::CHAR:
          case TSqlParser::NCHAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::PRECISION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::ID: {
            setState(1807);
            id_();
            break;
          }

          case TSqlParser::LOCAL_ID: {
            setState(1808);
            match(TSqlParser::LOCAL_ID);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1817);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
        case 1: {
          setState(1811);
          match(TSqlParser::WITH);
          setState(1812);
          match(TSqlParser::LR_BRACKET);
          setState(1813);
          match(TSqlParser::DELAYED_DURABILITY);
          setState(1814);
          match(TSqlParser::EQUAL);
          setState(1815);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::OFF

          || _la == TSqlParser::ON)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1816);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(1822);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
      case 1: {
        setState(1821);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1824);
      match(TSqlParser::COMMIT);
      setState(1826);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
      case 1: {
        setState(1825);
        match(TSqlParser::WORK);
        break;
      }

      default:
        break;
      }
      setState(1829);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
      case 1: {
        setState(1828);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1831);
      match(TSqlParser::COMMIT);
      setState(1832);
      id_();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1833);
      match(TSqlParser::ROLLBACK);
      setState(1834);
      id_();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1835);
      match(TSqlParser::ROLLBACK);
      setState(1836);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1839);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
      case 1: {
        setState(1837);
        id_();
        break;
      }

      case 2: {
        setState(1838);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1842);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
      case 1: {
        setState(1841);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1844);
      match(TSqlParser::ROLLBACK);
      setState(1846);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx)) {
      case 1: {
        setState(1845);
        match(TSqlParser::WORK);
        break;
      }

      default:
        break;
      }
      setState(1849);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
      case 1: {
        setState(1848);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1851);
      match(TSqlParser::SAVE);
      setState(1852);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::TRAN

      || _la == TSqlParser::TRANSACTION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1855);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
      case 1: {
        setState(1853);
        id_();
        break;
      }

      case 2: {
        setState(1854);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      default:
        break;
      }
      setState(1858);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
      case 1: {
        setState(1857);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Go_batch_statementContext ------------------------------------------------------------------

TSqlParser::Go_batch_statementContext::Go_batch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Go_batch_statementContext::GO_BATCH() {
  return getToken(TSqlParser::GO_BATCH, 0);
}

tree::TerminalNode* TSqlParser::Go_batch_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Go_batch_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGo_batch_statement;
}

void TSqlParser::Go_batch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGo_batch_statement(this);
}

void TSqlParser::Go_batch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGo_batch_statement(this);
}

TSqlParser::Go_batch_statementContext* TSqlParser::go_batch_statement() {
  Go_batch_statementContext *_localctx = _tracker.createInstance<Go_batch_statementContext>(_ctx, getState());
  enterRule(_localctx, 162, TSqlParser::RuleGo_batch_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1862);
    match(TSqlParser::GO_BATCH);
    setState(1864);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::DECIMAL) {
      setState(1863);
      antlrcpp::downCast<Go_batch_statementContext *>(_localctx)->count = match(TSqlParser::DECIMAL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Go_statementContext ------------------------------------------------------------------

TSqlParser::Go_statementContext::Go_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Go_statementContext::GO() {
  return getToken(TSqlParser::GO, 0);
}

tree::TerminalNode* TSqlParser::Go_statementContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Go_statementContext::getRuleIndex() const {
  return TSqlParser::RuleGo_statement;
}

void TSqlParser::Go_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGo_statement(this);
}

void TSqlParser::Go_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGo_statement(this);
}

TSqlParser::Go_statementContext* TSqlParser::go_statement() {
  Go_statementContext *_localctx = _tracker.createInstance<Go_statementContext>(_ctx, getState());
  enterRule(_localctx, 164, TSqlParser::RuleGo_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1866);
    match(TSqlParser::GO);
    setState(1868);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::DECIMAL) {
      setState(1867);
      antlrcpp::downCast<Go_statementContext *>(_localctx)->count = match(TSqlParser::DECIMAL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_statementContext ------------------------------------------------------------------

TSqlParser::Use_statementContext::Use_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Use_statementContext::USE() {
  return getToken(TSqlParser::USE, 0);
}

TSqlParser::Id_Context* TSqlParser::Use_statementContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Use_statementContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Use_statementContext::getRuleIndex() const {
  return TSqlParser::RuleUse_statement;
}

void TSqlParser::Use_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse_statement(this);
}

void TSqlParser::Use_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse_statement(this);
}

TSqlParser::Use_statementContext* TSqlParser::use_statement() {
  Use_statementContext *_localctx = _tracker.createInstance<Use_statementContext>(_ctx, getState());
  enterRule(_localctx, 166, TSqlParser::RuleUse_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1870);
    match(TSqlParser::USE);
    setState(1871);
    antlrcpp::downCast<Use_statementContext *>(_localctx)->database = id_();
    setState(1873);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      setState(1872);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Shutdown_statementContext ------------------------------------------------------------------

TSqlParser::Shutdown_statementContext::Shutdown_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::SHUTDOWN() {
  return getToken(TSqlParser::SHUTDOWN, 0);
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Shutdown_statementContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}


size_t TSqlParser::Shutdown_statementContext::getRuleIndex() const {
  return TSqlParser::RuleShutdown_statement;
}

void TSqlParser::Shutdown_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShutdown_statement(this);
}

void TSqlParser::Shutdown_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShutdown_statement(this);
}

TSqlParser::Shutdown_statementContext* TSqlParser::shutdown_statement() {
  Shutdown_statementContext *_localctx = _tracker.createInstance<Shutdown_statementContext>(_ctx, getState());
  enterRule(_localctx, 168, TSqlParser::RuleShutdown_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1875);
    match(TSqlParser::SHUTDOWN);
    setState(1878);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      setState(1876);
      match(TSqlParser::WITH);
      setState(1877);
      match(TSqlParser::NOWAIT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_specialContext ------------------------------------------------------------------

TSqlParser::Dbcc_specialContext::Dbcc_specialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::DBCC() {
  return getToken(TSqlParser::DBCC, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::SHRINKLOG() {
  return getToken(TSqlParser::SHRINKLOG, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::SIZE() {
  return getToken(TSqlParser::SIZE, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Dbcc_specialContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

TSqlParser::Id_Context* TSqlParser::Dbcc_specialContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_specialContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}


size_t TSqlParser::Dbcc_specialContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_special;
}

void TSqlParser::Dbcc_specialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_special(this);
}

void TSqlParser::Dbcc_specialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_special(this);
}

TSqlParser::Dbcc_specialContext* TSqlParser::dbcc_special() {
  Dbcc_specialContext *_localctx = _tracker.createInstance<Dbcc_specialContext>(_ctx, getState());
  enterRule(_localctx, 170, TSqlParser::RuleDbcc_special);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1880);
    match(TSqlParser::DBCC);
    setState(1881);
    match(TSqlParser::SHRINKLOG);
    setState(1891);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      setState(1882);
      match(TSqlParser::LR_BRACKET);
      setState(1883);
      match(TSqlParser::SIZE);
      setState(1884);
      match(TSqlParser::EQUAL);
      setState(1888);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
      case 1: {
        setState(1885);
        constant_expression();
        break;
      }

      case 2: {
        setState(1886);
        id_();
        break;
      }

      case 3: {
        setState(1887);
        match(TSqlParser::DEFAULT);
        break;
      }

      default:
        break;
      }
      setState(1890);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1894);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
    case 1: {
      setState(1893);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_clauseContext ------------------------------------------------------------------

TSqlParser::Dbcc_clauseContext::Dbcc_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::DBCC() {
  return getToken(TSqlParser::DBCC, 0);
}

TSqlParser::Dbcc_commandContext* TSqlParser::Dbcc_clauseContext::dbcc_command() {
  return getRuleContext<TSqlParser::Dbcc_commandContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Dbcc_clauseContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

TSqlParser::Dbcc_optionsContext* TSqlParser::Dbcc_clauseContext::dbcc_options() {
  return getRuleContext<TSqlParser::Dbcc_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Dbcc_clauseContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}


size_t TSqlParser::Dbcc_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_clause;
}

void TSqlParser::Dbcc_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_clause(this);
}

void TSqlParser::Dbcc_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_clause(this);
}

TSqlParser::Dbcc_clauseContext* TSqlParser::dbcc_clause() {
  Dbcc_clauseContext *_localctx = _tracker.createInstance<Dbcc_clauseContext>(_ctx, getState());
  enterRule(_localctx, 172, TSqlParser::RuleDbcc_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1896);
    match(TSqlParser::DBCC);
    setState(1897);
    antlrcpp::downCast<Dbcc_clauseContext *>(_localctx)->name = dbcc_command();
    setState(1902);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
    case 1: {
      setState(1898);
      match(TSqlParser::LR_BRACKET);
      setState(1899);
      expression_list();
      setState(1900);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(1906);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
    case 1: {
      setState(1904);
      match(TSqlParser::WITH);
      setState(1905);
      dbcc_options();
      break;
    }

    default:
      break;
    }
    setState(1909);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
    case 1: {
      setState(1908);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_commandContext ------------------------------------------------------------------

TSqlParser::Dbcc_commandContext::Dbcc_commandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Simple_idContext* TSqlParser::Dbcc_commandContext::simple_id() {
  return getRuleContext<TSqlParser::Simple_idContext>(0);
}

TSqlParser::KeywordContext* TSqlParser::Dbcc_commandContext::keyword() {
  return getRuleContext<TSqlParser::KeywordContext>(0);
}


size_t TSqlParser::Dbcc_commandContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_command;
}

void TSqlParser::Dbcc_commandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_command(this);
}

void TSqlParser::Dbcc_commandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_command(this);
}

TSqlParser::Dbcc_commandContext* TSqlParser::dbcc_command() {
  Dbcc_commandContext *_localctx = _tracker.createInstance<Dbcc_commandContext>(_ctx, getState());
  enterRule(_localctx, 174, TSqlParser::RuleDbcc_command);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1913);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1911);
        simple_id();
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        enterOuterAlt(_localctx, 2);
        setState(1912);
        keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dbcc_optionsContext ------------------------------------------------------------------

TSqlParser::Dbcc_optionsContext::Dbcc_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Simple_idContext *> TSqlParser::Dbcc_optionsContext::simple_id() {
  return getRuleContexts<TSqlParser::Simple_idContext>();
}

TSqlParser::Simple_idContext* TSqlParser::Dbcc_optionsContext::simple_id(size_t i) {
  return getRuleContext<TSqlParser::Simple_idContext>(i);
}

tree::TerminalNode* TSqlParser::Dbcc_optionsContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}


size_t TSqlParser::Dbcc_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleDbcc_options;
}

void TSqlParser::Dbcc_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDbcc_options(this);
}

void TSqlParser::Dbcc_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDbcc_options(this);
}

TSqlParser::Dbcc_optionsContext* TSqlParser::dbcc_options() {
  Dbcc_optionsContext *_localctx = _tracker.createInstance<Dbcc_optionsContext>(_ctx, getState());
  enterRule(_localctx, 176, TSqlParser::RuleDbcc_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1915);
    simple_id();
    setState(1918);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COMMA) {
      setState(1916);
      match(TSqlParser::COMMA);
      setState(1917);
      simple_id();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_clauseContext ------------------------------------------------------------------

TSqlParser::Execute_clauseContext::Execute_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::EXECUTE() {
  return getToken(TSqlParser::EXECUTE, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::CALLER() {
  return getToken(TSqlParser::CALLER, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::SELF() {
  return getToken(TSqlParser::SELF, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::OWNER() {
  return getToken(TSqlParser::OWNER, 0);
}

tree::TerminalNode* TSqlParser::Execute_clauseContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Execute_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleExecute_clause;
}

void TSqlParser::Execute_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_clause(this);
}

void TSqlParser::Execute_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_clause(this);
}

TSqlParser::Execute_clauseContext* TSqlParser::execute_clause() {
  Execute_clauseContext *_localctx = _tracker.createInstance<Execute_clauseContext>(_ctx, getState());
  enterRule(_localctx, 178, TSqlParser::RuleExecute_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1920);
    match(TSqlParser::EXECUTE);
    setState(1921);
    match(TSqlParser::AS);
    setState(1922);
    antlrcpp::downCast<Execute_clauseContext *>(_localctx)->clause = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::CALLER || _la == TSqlParser::OWNER

    || _la == TSqlParser::SELF || _la == TSqlParser::STRING)) {
      antlrcpp::downCast<Execute_clauseContext *>(_localctx)->clause = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_localContext ------------------------------------------------------------------

TSqlParser::Declare_localContext::Declare_localContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_localContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Data_typeContext* TSqlParser::Declare_localContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_localContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

tree::TerminalNode* TSqlParser::Declare_localContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Declare_localContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Declare_localContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_local;
}

void TSqlParser::Declare_localContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_local(this);
}

void TSqlParser::Declare_localContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_local(this);
}

TSqlParser::Declare_localContext* TSqlParser::declare_local() {
  Declare_localContext *_localctx = _tracker.createInstance<Declare_localContext>(_ctx, getState());
  enterRule(_localctx, 180, TSqlParser::RuleDeclare_local);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1924);
    match(TSqlParser::LOCAL_ID);
    setState(1926);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(1925);
      match(TSqlParser::AS);
    }
    setState(1928);
    data_type();
    setState(1931);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::EQUAL) {
      setState(1929);
      match(TSqlParser::EQUAL);
      setState(1930);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_type_definitionContext ------------------------------------------------------------------

TSqlParser::Table_type_definitionContext::Table_type_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::TABLE() {
  return getToken(TSqlParser::TABLE, 0);
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::Table_type_definitionContext::column_def_table_constraints() {
  return getRuleContext<TSqlParser::Column_def_table_constraintsContext>(0);
}

tree::TerminalNode* TSqlParser::Table_type_definitionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_type_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleTable_type_definition;
}

void TSqlParser::Table_type_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_type_definition(this);
}

void TSqlParser::Table_type_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_type_definition(this);
}

TSqlParser::Table_type_definitionContext* TSqlParser::table_type_definition() {
  Table_type_definitionContext *_localctx = _tracker.createInstance<Table_type_definitionContext>(_ctx, getState());
  enterRule(_localctx, 182, TSqlParser::RuleTable_type_definition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1933);
    match(TSqlParser::TABLE);
    setState(1934);
    match(TSqlParser::LR_BRACKET);
    setState(1935);
    column_def_table_constraints();
    setState(1936);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintsContext ------------------------------------------------------------------

TSqlParser::Column_def_table_constraintsContext::Column_def_table_constraintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Column_def_table_constraintContext *> TSqlParser::Column_def_table_constraintsContext::column_def_table_constraint() {
  return getRuleContexts<TSqlParser::Column_def_table_constraintContext>();
}

TSqlParser::Column_def_table_constraintContext* TSqlParser::Column_def_table_constraintsContext::column_def_table_constraint(size_t i) {
  return getRuleContext<TSqlParser::Column_def_table_constraintContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_def_table_constraintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_def_table_constraintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_def_table_constraintsContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_def_table_constraints;
}

void TSqlParser::Column_def_table_constraintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def_table_constraints(this);
}

void TSqlParser::Column_def_table_constraintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def_table_constraints(this);
}

TSqlParser::Column_def_table_constraintsContext* TSqlParser::column_def_table_constraints() {
  Column_def_table_constraintsContext *_localctx = _tracker.createInstance<Column_def_table_constraintsContext>(_ctx, getState());
  enterRule(_localctx, 184, TSqlParser::RuleColumn_def_table_constraints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1938);
    column_def_table_constraint();
    setState(1945);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1940);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(1939);
          match(TSqlParser::COMMA);
        }
        setState(1942);
        column_def_table_constraint(); 
      }
      setState(1947);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_def_table_constraintContext ------------------------------------------------------------------

TSqlParser::Column_def_table_constraintContext::Column_def_table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_definitionContext* TSqlParser::Column_def_table_constraintContext::column_definition() {
  return getRuleContext<TSqlParser::Column_definitionContext>(0);
}

TSqlParser::Table_constraintContext* TSqlParser::Column_def_table_constraintContext::table_constraint() {
  return getRuleContext<TSqlParser::Table_constraintContext>(0);
}


size_t TSqlParser::Column_def_table_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_def_table_constraint;
}

void TSqlParser::Column_def_table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def_table_constraint(this);
}

void TSqlParser::Column_def_table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def_table_constraint(this);
}

TSqlParser::Column_def_table_constraintContext* TSqlParser::column_def_table_constraint() {
  Column_def_table_constraintContext *_localctx = _tracker.createInstance<Column_def_table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 186, TSqlParser::RuleColumn_def_table_constraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1950);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1948);
        column_definition();
        break;
      }

      case TSqlParser::CHECK:
      case TSqlParser::CONSTRAINT:
      case TSqlParser::DEFAULT:
      case TSqlParser::FOREIGN:
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        enterOuterAlt(_localctx, 2);
        setState(1949);
        table_constraint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_definitionContext ------------------------------------------------------------------

TSqlParser::Column_definitionContext::Column_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Column_definitionContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Column_definitionContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Data_typeContext* TSqlParser::Column_definitionContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Column_definitionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::Null_notnullContext* TSqlParser::Column_definitionContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

std::vector<TSqlParser::Null_or_defaultContext *> TSqlParser::Column_definitionContext::null_or_default() {
  return getRuleContexts<TSqlParser::Null_or_defaultContext>();
}

TSqlParser::Null_or_defaultContext* TSqlParser::Column_definitionContext::null_or_default(size_t i) {
  return getRuleContext<TSqlParser::Null_or_defaultContext>(i);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::ROWGUIDCOL() {
  return getToken(TSqlParser::ROWGUIDCOL, 0);
}

std::vector<TSqlParser::Column_constraintContext *> TSqlParser::Column_definitionContext::column_constraint() {
  return getRuleContexts<TSqlParser::Column_constraintContext>();
}

TSqlParser::Column_constraintContext* TSqlParser::Column_definitionContext::column_constraint(size_t i) {
  return getRuleContext<TSqlParser::Column_constraintContext>(i);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::PERSISTED() {
  return getToken(TSqlParser::PERSISTED, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_definitionContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Column_definitionContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}


size_t TSqlParser::Column_definitionContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_definition;
}

void TSqlParser::Column_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_definition(this);
}

void TSqlParser::Column_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_definition(this);
}

TSqlParser::Column_definitionContext* TSqlParser::column_definition() {
  Column_definitionContext *_localctx = _tracker.createInstance<Column_definitionContext>(_ctx, getState());
  enterRule(_localctx, 188, TSqlParser::RuleColumn_definition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1952);
    id_();
    setState(1959);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::DOUBLE:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(1953);
        data_type();
        break;
      }

      case TSqlParser::AS: {
        setState(1954);
        match(TSqlParser::AS);
        setState(1955);
        expression(0);
        setState(1957);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
        case 1: {
          setState(1956);
          match(TSqlParser::PERSISTED);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1963);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::COLLATE) {
      setState(1961);
      match(TSqlParser::COLLATE);
      setState(1962);
      id_();
    }
    setState(1966);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
    case 1: {
      setState(1965);
      null_notnull();
      break;
    }

    default:
      break;
    }
    setState(1989);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      setState(1970);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::CONSTRAINT) {
        setState(1968);
        match(TSqlParser::CONSTRAINT);
        setState(1969);
        antlrcpp::downCast<Column_definitionContext *>(_localctx)->constraint = id_();
      }
      setState(1972);
      null_or_default();
      setState(1974);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
      case 1: {
        setState(1973);
        null_or_default();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(1976);
      match(TSqlParser::IDENTITY);
      setState(1982);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
      case 1: {
        setState(1977);
        match(TSqlParser::LR_BRACKET);
        setState(1978);
        antlrcpp::downCast<Column_definitionContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
        setState(1979);
        match(TSqlParser::COMMA);
        setState(1980);
        antlrcpp::downCast<Column_definitionContext *>(_localctx)->increment = match(TSqlParser::DECIMAL);
        setState(1981);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      setState(1987);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
      case 1: {
        setState(1984);
        match(TSqlParser::NOT);
        setState(1985);
        match(TSqlParser::FOR);
        setState(1986);
        match(TSqlParser::REPLICATION);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(1992);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ROWGUIDCOL) {
      setState(1991);
      match(TSqlParser::ROWGUIDCOL);
    }
    setState(1997);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1994);
        column_constraint(); 
      }
      setState(1999);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_constraintContext ------------------------------------------------------------------

TSqlParser::Column_constraintContext::Column_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_constraintContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Column_constraintContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Column_constraintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::Null_notnullContext* TSqlParser::Column_constraintContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Column_constraintContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}

TSqlParser::Id_Context* TSqlParser::Column_constraintContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::PRIMARY() {
  return getToken(TSqlParser::PRIMARY, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::UNIQUE() {
  return getToken(TSqlParser::UNIQUE, 0);
}

TSqlParser::Index_optionsContext* TSqlParser::Column_constraintContext::index_options() {
  return getRuleContext<TSqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

tree::TerminalNode* TSqlParser::Column_constraintContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}


size_t TSqlParser::Column_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_constraint;
}

void TSqlParser::Column_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_constraint(this);
}

void TSqlParser::Column_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_constraint(this);
}

TSqlParser::Column_constraintContext* TSqlParser::column_constraint() {
  Column_constraintContext *_localctx = _tracker.createInstance<Column_constraintContext>(_ctx, getState());
  enterRule(_localctx, 190, TSqlParser::RuleColumn_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2002);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONSTRAINT) {
      setState(2000);
      match(TSqlParser::CONSTRAINT);
      setState(2001);
      antlrcpp::downCast<Column_constraintContext *>(_localctx)->constraint = id_();
    }
    setState(2033);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        setState(2007);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::PRIMARY: {
            setState(2004);
            match(TSqlParser::PRIMARY);
            setState(2005);
            match(TSqlParser::KEY);
            break;
          }

          case TSqlParser::UNIQUE: {
            setState(2006);
            match(TSqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2010);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
        case 1: {
          setState(2009);
          index_options();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHECK: {
        setState(2012);
        match(TSqlParser::CHECK);
        setState(2016);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::NOT) {
          setState(2013);
          match(TSqlParser::NOT);
          setState(2014);
          match(TSqlParser::FOR);
          setState(2015);
          match(TSqlParser::REPLICATION);
        }
        setState(2018);
        match(TSqlParser::LR_BRACKET);
        setState(2019);
        search_condition(0);
        setState(2020);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::FOREIGN:
      case TSqlParser::REFERENCES: {
        setState(2024);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::FOREIGN) {
          setState(2022);
          match(TSqlParser::FOREIGN);
          setState(2023);
          match(TSqlParser::KEY);
        }
        setState(2026);
        match(TSqlParser::REFERENCES);
        setState(2027);
        table_name();
        setState(2028);
        match(TSqlParser::LR_BRACKET);
        setState(2029);
        antlrcpp::downCast<Column_constraintContext *>(_localctx)->pk = column_name_list();
        setState(2030);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::NOT:
      case TSqlParser::NULL_: {
        setState(2032);
        null_notnull();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

TSqlParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

TSqlParser::Column_name_list_with_orderContext* TSqlParser::Table_constraintContext::column_name_list_with_order() {
  return getRuleContext<TSqlParser::Column_name_list_with_orderContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::CHECK() {
  return getToken(TSqlParser::CHECK, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Table_constraintContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Table_constraintContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Table_constraintContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::FOREIGN() {
  return getToken(TSqlParser::FOREIGN, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::KEY() {
  return getToken(TSqlParser::KEY, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::REFERENCES() {
  return getToken(TSqlParser::REFERENCES, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Table_constraintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::CONSTRAINT() {
  return getToken(TSqlParser::CONSTRAINT, 0);
}

std::vector<TSqlParser::Column_name_listContext *> TSqlParser::Table_constraintContext::column_name_list() {
  return getRuleContexts<TSqlParser::Column_name_listContext>();
}

TSqlParser::Column_name_listContext* TSqlParser::Table_constraintContext::column_name_list(size_t i) {
  return getRuleContext<TSqlParser::Column_name_listContext>(i);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::PRIMARY() {
  return getToken(TSqlParser::PRIMARY, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::UNIQUE() {
  return getToken(TSqlParser::UNIQUE, 0);
}

TSqlParser::Index_optionsContext* TSqlParser::Table_constraintContext::index_options() {
  return getRuleContext<TSqlParser::Index_optionsContext>(0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::REPLICATION() {
  return getToken(TSqlParser::REPLICATION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::STRING() {
  return getTokens(TSqlParser::STRING);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::STRING(size_t i) {
  return getToken(TSqlParser::STRING, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::PLUS() {
  return getTokens(TSqlParser::PLUS);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::PLUS(size_t i) {
  return getToken(TSqlParser::PLUS, i);
}

std::vector<TSqlParser::Function_callContext *> TSqlParser::Table_constraintContext::function_call() {
  return getRuleContexts<TSqlParser::Function_callContext>();
}

TSqlParser::Function_callContext* TSqlParser::Table_constraintContext::function_call(size_t i) {
  return getRuleContext<TSqlParser::Function_callContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_constraintContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Table_constraintContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}


size_t TSqlParser::Table_constraintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_constraint;
}

void TSqlParser::Table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_constraint(this);
}

void TSqlParser::Table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_constraint(this);
}

TSqlParser::Table_constraintContext* TSqlParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 192, TSqlParser::RuleTable_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2037);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::CONSTRAINT) {
      setState(2035);
      match(TSqlParser::CONSTRAINT);
      setState(2036);
      antlrcpp::downCast<Table_constraintContext *>(_localctx)->constraint = id_();
    }
    setState(2094);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::PRIMARY:
      case TSqlParser::UNIQUE: {
        setState(2042);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::PRIMARY: {
            setState(2039);
            match(TSqlParser::PRIMARY);
            setState(2040);
            match(TSqlParser::KEY);
            break;
          }

          case TSqlParser::UNIQUE: {
            setState(2041);
            match(TSqlParser::UNIQUE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2044);
        match(TSqlParser::LR_BRACKET);
        setState(2045);
        column_name_list_with_order();
        setState(2046);
        match(TSqlParser::RR_BRACKET);
        setState(2048);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
        case 1: {
          setState(2047);
          index_options();
          break;
        }

        default:
          break;
        }
        setState(2052);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ON) {
          setState(2050);
          match(TSqlParser::ON);
          setState(2051);
          id_();
        }
        break;
      }

      case TSqlParser::CHECK: {
        setState(2054);
        match(TSqlParser::CHECK);
        setState(2058);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::NOT) {
          setState(2055);
          match(TSqlParser::NOT);
          setState(2056);
          match(TSqlParser::FOR);
          setState(2057);
          match(TSqlParser::REPLICATION);
        }
        setState(2060);
        match(TSqlParser::LR_BRACKET);
        setState(2061);
        search_condition(0);
        setState(2062);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(2064);
        match(TSqlParser::DEFAULT);
        setState(2066);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::LR_BRACKET) {
          setState(2065);
          match(TSqlParser::LR_BRACKET);
        }
        setState(2072); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2072);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case TSqlParser::STRING: {
              setState(2068);
              match(TSqlParser::STRING);
              break;
            }

            case TSqlParser::PLUS: {
              setState(2069);
              match(TSqlParser::PLUS);
              break;
            }

            case TSqlParser::ABS:
            case TSqlParser::ASCII:
            case TSqlParser::CEILING:
            case TSqlParser::CHAR:
            case TSqlParser::CHARINDEX:
            case TSqlParser::DATALENGTH:
            case TSqlParser::DAY:
            case TSqlParser::FLOOR:
            case TSqlParser::ISDATE:
            case TSqlParser::ISNUMERIC:
            case TSqlParser::LEN:
            case TSqlParser::LOWER:
            case TSqlParser::LTRIM:
            case TSqlParser::MONTH:
            case TSqlParser::NCHAR:
            case TSqlParser::PATINDEX:
            case TSqlParser::RAND:
            case TSqlParser::REPLACE:
            case TSqlParser::ROUND:
            case TSqlParser::RTRIM:
            case TSqlParser::SIGN:
            case TSqlParser::STR:
            case TSqlParser::SUBSTRING:
            case TSqlParser::UPPER:
            case TSqlParser::USER_NAME:
            case TSqlParser::YEAR:
            case TSqlParser::TEXT:
            case TSqlParser::NTEXT:
            case TSqlParser::COALESCE:
            case TSqlParser::CONVERT:
            case TSqlParser::CURRENT_TIMESTAMP:
            case TSqlParser::CURRENT_USER:
            case TSqlParser::IDENTITY:
            case TSqlParser::LEFT:
            case TSqlParser::NULLIF:
            case TSqlParser::PRECISION:
            case TSqlParser::RIGHT:
            case TSqlParser::SESSION_USER:
            case TSqlParser::SYSTEM_USER:
            case TSqlParser::USER:
            case TSqlParser::DOLLAR_PARTITION:
            case TSqlParser::ABSOLUTE:
            case TSqlParser::AT_KEYWORD:
            case TSqlParser::ACTION:
            case TSqlParser::AES_128:
            case TSqlParser::AES_192:
            case TSqlParser::AES_256:
            case TSqlParser::ALGORITHM:
            case TSqlParser::ANSI_NULLS:
            case TSqlParser::ANSI_PADDING:
            case TSqlParser::ANSI_WARNINGS:
            case TSqlParser::APPLY:
            case TSqlParser::ARITHABORT:
            case TSqlParser::AUTO:
            case TSqlParser::AVG:
            case TSqlParser::BIGINT:
            case TSqlParser::BINARY_KEYWORD:
            case TSqlParser::BINARY_BASE64:
            case TSqlParser::BINARY_CHECKSUM:
            case TSqlParser::CALLER:
            case TSqlParser::CAST:
            case TSqlParser::TRY_CAST:
            case TSqlParser::CATCH:
            case TSqlParser::CHECKSUM:
            case TSqlParser::CHECKSUM_AGG:
            case TSqlParser::COMMITTED:
            case TSqlParser::CONCAT:
            case TSqlParser::CONCAT_NULL_YIELDS_NULL:
            case TSqlParser::COUNT:
            case TSqlParser::COUNT_BIG:
            case TSqlParser::CUME_DIST:
            case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
            case TSqlParser::CURSOR_DEFAULT:
            case TSqlParser::DATA:
            case TSqlParser::DATEADD:
            case TSqlParser::DATEDIFF:
            case TSqlParser::DATENAME:
            case TSqlParser::DATEPART:
            case TSqlParser::DAYS:
            case TSqlParser::DEFAULT_DOUBLE_QUOTE:
            case TSqlParser::DELAY:
            case TSqlParser::DELAYED_DURABILITY:
            case TSqlParser::DELETED:
            case TSqlParser::DENSE_RANK:
            case TSqlParser::DES:
            case TSqlParser::DESCRIPTION:
            case TSqlParser::DESX:
            case TSqlParser::DISABLE:
            case TSqlParser::DYNAMIC:
            case TSqlParser::ELEMENTS:
            case TSqlParser::EMPTY:
            case TSqlParser::ENCRYPTION:
            case TSqlParser::EXCLUSIVE:
            case TSqlParser::FAST:
            case TSqlParser::FAST_FORWARD:
            case TSqlParser::FIRST:
            case TSqlParser::FIRST_VALUE:
            case TSqlParser::FOLLOWING:
            case TSqlParser::FORCE:
            case TSqlParser::FORCED:
            case TSqlParser::FORWARD_ONLY:
            case TSqlParser::GETDATE:
            case TSqlParser::GETUTCDATE:
            case TSqlParser::GLOBAL:
            case TSqlParser::GO_BATCH:
            case TSqlParser::GO:
            case TSqlParser::GROUPING:
            case TSqlParser::GROUPING_ID:
            case TSqlParser::HASH:
            case TSqlParser::HIGH:
            case TSqlParser::HOURS:
            case TSqlParser::IDENTITY_VALUE:
            case TSqlParser::INCLUDE_NULL_VALUES:
            case TSqlParser::INPUT:
            case TSqlParser::INSENSITIVE:
            case TSqlParser::INSERTED:
            case TSqlParser::INT:
            case TSqlParser::ISOLATION:
            case TSqlParser::KEEP:
            case TSqlParser::KEEPFIXED:
            case TSqlParser::KEYSET:
            case TSqlParser::LAG:
            case TSqlParser::LAST:
            case TSqlParser::LAST_VALUE:
            case TSqlParser::LEAD:
            case TSqlParser::LEVEL:
            case TSqlParser::LOCAL:
            case TSqlParser::LOCATION:
            case TSqlParser::LOCK:
            case TSqlParser::LOCK_ESCALATION:
            case TSqlParser::LOOP:
            case TSqlParser::LOW:
            case TSqlParser::MANUAL:
            case TSqlParser::MARK:
            case TSqlParser::MAX:
            case TSqlParser::MAXDOP:
            case TSqlParser::MAXRECURSION:
            case TSqlParser::MIN:
            case TSqlParser::MIN_ACTIVE_ROWVERSION:
            case TSqlParser::MINUTES:
            case TSqlParser::MODE:
            case TSqlParser::NEXT:
            case TSqlParser::NO:
            case TSqlParser::NOCOUNT:
            case TSqlParser::NODES:
            case TSqlParser::NOEXPAND:
            case TSqlParser::NOWAIT:
            case TSqlParser::NTILE:
            case TSqlParser::NUMANODE:
            case TSqlParser::NUMERIC_ROUNDABORT:
            case TSqlParser::OBJECT:
            case TSqlParser::OFFSET:
            case TSqlParser::ONLINE:
            case TSqlParser::ONLY:
            case TSqlParser::OPTIMISTIC:
            case TSqlParser::OPTIMIZE:
            case TSqlParser::OUT:
            case TSqlParser::OUTPUT:
            case TSqlParser::OWNER:
            case TSqlParser::PARAMETERIZATION:
            case TSqlParser::PARTITION:
            case TSqlParser::PARTITIONS:
            case TSqlParser::PERCENT_RANK:
            case TSqlParser::PERCENTILE_CONT:
            case TSqlParser::PERCENTILE_DISC:
            case TSqlParser::PRECEDING:
            case TSqlParser::PRIOR:
            case TSqlParser::QUERY:
            case TSqlParser::QUOTED_IDENTIFIER:
            case TSqlParser::RANGE:
            case TSqlParser::RANK:
            case TSqlParser::RC2:
            case TSqlParser::RC4:
            case TSqlParser::RC4_128:
            case TSqlParser::READ_ONLY:
            case TSqlParser::READONLY:
            case TSqlParser::REBUILD:
            case TSqlParser::RECOMPILE:
            case TSqlParser::RELATIVE:
            case TSqlParser::REMOTE:
            case TSqlParser::REPEATABLE:
            case TSqlParser::ROBUST:
            case TSqlParser::ROW:
            case TSqlParser::ROW_NUMBER:
            case TSqlParser::ROWGUID:
            case TSqlParser::ROWS:
            case TSqlParser::SCHEMABINDING:
            case TSqlParser::SCROLL:
            case TSqlParser::SCROLL_LOCKS:
            case TSqlParser::SECONDS:
            case TSqlParser::SELF:
            case TSqlParser::SEMI_SENSITIVE:
            case TSqlParser::SEQUENCE:
            case TSqlParser::SERIALIZABLE:
            case TSqlParser::SETERROR:
            case TSqlParser::SHARE:
            case TSqlParser::SIMPLE:
            case TSqlParser::SIZE:
            case TSqlParser::SMALLINT:
            case TSqlParser::SNAPSHOT:
            case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
            case TSqlParser::STATIC:
            case TSqlParser::STATUSONLY:
            case TSqlParser::STDEV:
            case TSqlParser::STDEVP:
            case TSqlParser::STRING_AGG:
            case TSqlParser::STUFF:
            case TSqlParser::SUBSCRIPTION:
            case TSqlParser::SUM:
            case TSqlParser::TEXTIMAGE_ON:
            case TSqlParser::THROW:
            case TSqlParser::TIES:
            case TSqlParser::TIME:
            case TSqlParser::TIMEOUT:
            case TSqlParser::TINYINT:
            case TSqlParser::TRIPLE_DES:
            case TSqlParser::TRIPLE_DES_3KEY:
            case TSqlParser::TRY:
            case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
            case TSqlParser::TYPE:
            case TSqlParser::TYPE_WARNING:
            case TSqlParser::UNBOUNDED:
            case TSqlParser::UNCOMMITTED:
            case TSqlParser::UNKNOWN:
            case TSqlParser::UOW:
            case TSqlParser::USING:
            case TSqlParser::VAR:
            case TSqlParser::VARBINARY_KEYWORD:
            case TSqlParser::VARP:
            case TSqlParser::WAIT:
            case TSqlParser::WORK:
            case TSqlParser::ZONE:
            case TSqlParser::BLOCKING_HIERARCHY:
            case TSqlParser::CACHE:
            case TSqlParser::CALLED:
            case TSqlParser::CHANGETABLE:
            case TSqlParser::CHANGES:
            case TSqlParser::CYCLE:
            case TSqlParser::DATA_COMPRESSION:
            case TSqlParser::ERROR:
            case TSqlParser::FORCESEEK:
            case TSqlParser::IIF:
            case TSqlParser::INCREMENT:
            case TSqlParser::ISNULL:
            case TSqlParser::LOG:
            case TSqlParser::MATCHED:
            case TSqlParser::MAXVALUE:
            case TSqlParser::MINVALUE:
            case TSqlParser::NOTIFICATION:
            case TSqlParser::PERSISTED:
            case TSqlParser::PREDICATE:
            case TSqlParser::RESTART:
            case TSqlParser::RETURNS:
            case TSqlParser::SOURCE:
            case TSqlParser::STATE:
            case TSqlParser::START:
            case TSqlParser::TARGET:
            case TSqlParser::VARCHAR:
            case TSqlParser::NVARCHAR:
            case TSqlParser::SPACE:
            case TSqlParser::DOUBLE_QUOTE_ID:
            case TSqlParser::SQUARE_BRACKET_ID:
            case TSqlParser::ID:
            case TSqlParser::DOT: {
              setState(2070);
              function_call();
              break;
            }

            case TSqlParser::DECIMAL: {
              setState(2071);
              match(TSqlParser::DECIMAL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(2074); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1738459825978736638) != 0) || ((((_la - 91) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 91)) & 9574549402427393) != 0) || ((((_la - 157) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 157)) & -255) != 0) || ((((_la - 221) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 221)) & -1) != 0) || ((((_la - 285) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 285)) & -1) != 0) || ((((_la - 349) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 349)) & 16499099684994495) != 0) || _la == TSqlParser::DOT

        || _la == TSqlParser::PLUS);
        setState(2077);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::RR_BRACKET) {
          setState(2076);
          match(TSqlParser::RR_BRACKET);
        }
        setState(2079);
        match(TSqlParser::FOR);
        setState(2080);
        id_();
        break;
      }

      case TSqlParser::FOREIGN: {
        setState(2081);
        match(TSqlParser::FOREIGN);
        setState(2082);
        match(TSqlParser::KEY);
        setState(2083);
        match(TSqlParser::LR_BRACKET);
        setState(2084);
        antlrcpp::downCast<Table_constraintContext *>(_localctx)->fk = column_name_list();
        setState(2085);
        match(TSqlParser::RR_BRACKET);
        setState(2086);
        match(TSqlParser::REFERENCES);
        setState(2087);
        table_name();
        setState(2092);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
        case 1: {
          setState(2088);
          match(TSqlParser::LR_BRACKET);
          setState(2089);
          antlrcpp::downCast<Table_constraintContext *>(_localctx)->pk = column_name_list();
          setState(2090);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionsContext ------------------------------------------------------------------

TSqlParser::Index_optionsContext::Index_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Index_optionsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Index_optionContext *> TSqlParser::Index_optionsContext::index_option() {
  return getRuleContexts<TSqlParser::Index_optionContext>();
}

TSqlParser::Index_optionContext* TSqlParser::Index_optionsContext::index_option(size_t i) {
  return getRuleContext<TSqlParser::Index_optionContext>(i);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Index_optionsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Index_optionsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Index_optionsContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_options;
}

void TSqlParser::Index_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_options(this);
}

void TSqlParser::Index_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_options(this);
}

TSqlParser::Index_optionsContext* TSqlParser::index_options() {
  Index_optionsContext *_localctx = _tracker.createInstance<Index_optionsContext>(_ctx, getState());
  enterRule(_localctx, 194, TSqlParser::RuleIndex_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2096);
    match(TSqlParser::WITH);
    setState(2097);
    match(TSqlParser::LR_BRACKET);
    setState(2098);
    index_option();
    setState(2103);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2099);
      match(TSqlParser::COMMA);
      setState(2100);
      index_option();
      setState(2105);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2106);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_optionContext ------------------------------------------------------------------

TSqlParser::Index_optionContext::Index_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Index_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<TSqlParser::Simple_idContext *> TSqlParser::Index_optionContext::simple_id() {
  return getRuleContexts<TSqlParser::Simple_idContext>();
}

TSqlParser::Simple_idContext* TSqlParser::Index_optionContext::simple_id(size_t i) {
  return getRuleContext<TSqlParser::Simple_idContext>(i);
}

std::vector<TSqlParser::KeywordContext *> TSqlParser::Index_optionContext::keyword() {
  return getRuleContexts<TSqlParser::KeywordContext>();
}

TSqlParser::KeywordContext* TSqlParser::Index_optionContext::keyword(size_t i) {
  return getRuleContext<TSqlParser::KeywordContext>(i);
}

TSqlParser::On_offContext* TSqlParser::Index_optionContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Index_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Index_optionContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_option;
}

void TSqlParser::Index_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_option(this);
}

void TSqlParser::Index_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_option(this);
}

TSqlParser::Index_optionContext* TSqlParser::index_option() {
  Index_optionContext *_localctx = _tracker.createInstance<Index_optionContext>(_ctx, getState());
  enterRule(_localctx, 196, TSqlParser::RuleIndex_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2110);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        setState(2108);
        simple_id();
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        setState(2109);
        keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2112);
    match(TSqlParser::EQUAL);
    setState(2117);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        setState(2113);
        simple_id();
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        setState(2114);
        keyword();
        break;
      }

      case TSqlParser::OFF:
      case TSqlParser::ON: {
        setState(2115);
        on_off();
        break;
      }

      case TSqlParser::DECIMAL: {
        setState(2116);
        match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_cursorContext ------------------------------------------------------------------

TSqlParser::Declare_cursorContext::Declare_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::DECLARE() {
  return getToken(TSqlParser::DECLARE, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Declare_cursorContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::CURSOR() {
  return getToken(TSqlParser::CURSOR, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Declare_cursorContext::FOR() {
  return getTokens(TSqlParser::FOR);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::FOR(size_t i) {
  return getToken(TSqlParser::FOR, i);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Declare_cursorContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::Declare_cursorContext::declare_set_cursor_common() {
  return getRuleContext<TSqlParser::Declare_set_cursor_commonContext>(0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::SEMI_SENSITIVE() {
  return getToken(TSqlParser::SEMI_SENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::INSENSITIVE() {
  return getToken(TSqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::UPDATE() {
  return getToken(TSqlParser::UPDATE, 0);
}

tree::TerminalNode* TSqlParser::Declare_cursorContext::OF() {
  return getToken(TSqlParser::OF, 0);
}

TSqlParser::Column_name_listContext* TSqlParser::Declare_cursorContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}


size_t TSqlParser::Declare_cursorContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_cursor;
}

void TSqlParser::Declare_cursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_cursor(this);
}

void TSqlParser::Declare_cursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_cursor(this);
}

TSqlParser::Declare_cursorContext* TSqlParser::declare_cursor() {
  Declare_cursorContext *_localctx = _tracker.createInstance<Declare_cursorContext>(_ctx, getState());
  enterRule(_localctx, 198, TSqlParser::RuleDeclare_cursor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2119);
    match(TSqlParser::DECLARE);
    setState(2120);
    cursor_name();
    setState(2152);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
    case 1: {
      setState(2121);
      match(TSqlParser::CURSOR);
      setState(2131);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx)) {
      case 1: {
        setState(2122);
        declare_set_cursor_common();
        setState(2129);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::FOR) {
          setState(2123);
          match(TSqlParser::FOR);
          setState(2124);
          match(TSqlParser::UPDATE);
          setState(2127);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::OF) {
            setState(2125);
            match(TSqlParser::OF);
            setState(2126);
            column_name_list();
          }
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(2134);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::INSENSITIVE || _la == TSqlParser::SEMI_SENSITIVE) {
        setState(2133);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::INSENSITIVE || _la == TSqlParser::SEMI_SENSITIVE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2137);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::SCROLL) {
        setState(2136);
        match(TSqlParser::SCROLL);
      }
      setState(2139);
      match(TSqlParser::CURSOR);
      setState(2140);
      match(TSqlParser::FOR);
      setState(2141);
      select_statement_standalone();
      setState(2150);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::FOR) {
        setState(2142);
        match(TSqlParser::FOR);
        setState(2148);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::READ: {
            setState(2143);
            match(TSqlParser::READ);
            setState(2144);
            match(TSqlParser::ONLY);
            break;
          }

          case TSqlParser::UPDATE: {
            setState(2145);
            match(TSqlParser::UPDATE);
            break;
          }

          case TSqlParser::OF: {
            setState(2146);
            match(TSqlParser::OF);
            setState(2147);
            column_name_list();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      break;
    }

    default:
      break;
    }
    setState(2155);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
    case 1: {
      setState(2154);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_set_cursor_commonContext ------------------------------------------------------------------

TSqlParser::Declare_set_cursor_commonContext::Declare_set_cursor_commonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_commonContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Select_statement_standaloneContext* TSqlParser::Declare_set_cursor_commonContext::select_statement_standalone() {
  return getRuleContext<TSqlParser::Select_statement_standaloneContext>(0);
}

std::vector<TSqlParser::Declare_set_cursor_common_partialContext *> TSqlParser::Declare_set_cursor_commonContext::declare_set_cursor_common_partial() {
  return getRuleContexts<TSqlParser::Declare_set_cursor_common_partialContext>();
}

TSqlParser::Declare_set_cursor_common_partialContext* TSqlParser::Declare_set_cursor_commonContext::declare_set_cursor_common_partial(size_t i) {
  return getRuleContext<TSqlParser::Declare_set_cursor_common_partialContext>(i);
}


size_t TSqlParser::Declare_set_cursor_commonContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_set_cursor_common;
}

void TSqlParser::Declare_set_cursor_commonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_set_cursor_common(this);
}

void TSqlParser::Declare_set_cursor_commonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_set_cursor_common(this);
}

TSqlParser::Declare_set_cursor_commonContext* TSqlParser::declare_set_cursor_common() {
  Declare_set_cursor_commonContext *_localctx = _tracker.createInstance<Declare_set_cursor_commonContext>(_ctx, getState());
  enterRule(_localctx, 200, TSqlParser::RuleDeclare_set_cursor_common);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2160);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 213) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 213)) & 279172911169) != 0) || ((((_la - 279) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 279)) & 140763259207681) != 0) || _la == TSqlParser::TYPE_WARNING) {
      setState(2157);
      declare_set_cursor_common_partial();
      setState(2162);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2163);
    match(TSqlParser::FOR);
    setState(2164);
    select_statement_standalone();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_set_cursor_common_partialContext ------------------------------------------------------------------

TSqlParser::Declare_set_cursor_common_partialContext::Declare_set_cursor_common_partialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::FORWARD_ONLY() {
  return getToken(TSqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::STATIC() {
  return getToken(TSqlParser::STATIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::KEYSET() {
  return getToken(TSqlParser::KEYSET, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::DYNAMIC() {
  return getToken(TSqlParser::DYNAMIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::FAST_FORWARD() {
  return getToken(TSqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::READ_ONLY() {
  return getToken(TSqlParser::READ_ONLY, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::SCROLL_LOCKS() {
  return getToken(TSqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::OPTIMISTIC() {
  return getToken(TSqlParser::OPTIMISTIC, 0);
}

tree::TerminalNode* TSqlParser::Declare_set_cursor_common_partialContext::TYPE_WARNING() {
  return getToken(TSqlParser::TYPE_WARNING, 0);
}


size_t TSqlParser::Declare_set_cursor_common_partialContext::getRuleIndex() const {
  return TSqlParser::RuleDeclare_set_cursor_common_partial;
}

void TSqlParser::Declare_set_cursor_common_partialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_set_cursor_common_partial(this);
}

void TSqlParser::Declare_set_cursor_common_partialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_set_cursor_common_partial(this);
}

TSqlParser::Declare_set_cursor_common_partialContext* TSqlParser::declare_set_cursor_common_partial() {
  Declare_set_cursor_common_partialContext *_localctx = _tracker.createInstance<Declare_set_cursor_common_partialContext>(_ctx, getState());
  enterRule(_localctx, 202, TSqlParser::RuleDeclare_set_cursor_common_partial);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2171);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::GLOBAL:
      case TSqlParser::LOCAL: {
        enterOuterAlt(_localctx, 1);
        setState(2166);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::GLOBAL

        || _la == TSqlParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::SCROLL: {
        enterOuterAlt(_localctx, 2);
        setState(2167);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FORWARD_ONLY || _la == TSqlParser::SCROLL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::DYNAMIC:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::KEYSET:
      case TSqlParser::STATIC: {
        enterOuterAlt(_localctx, 3);
        setState(2168);
        _la = _input->LA(1);
        if (!(((((_la - 213) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 213)) & 4294967361) != 0) || _la == TSqlParser::STATIC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::OPTIMISTIC:
      case TSqlParser::READ_ONLY:
      case TSqlParser::SCROLL_LOCKS: {
        enterOuterAlt(_localctx, 4);
        setState(2169);
        _la = _input->LA(1);
        if (!(((((_la - 279) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 279)) & 17180917761) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case TSqlParser::TYPE_WARNING: {
        enterOuterAlt(_localctx, 5);
        setState(2170);
        match(TSqlParser::TYPE_WARNING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_cursorContext ------------------------------------------------------------------

TSqlParser::Fetch_cursorContext::Fetch_cursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FETCH() {
  return getToken(TSqlParser::FETCH, 0);
}

TSqlParser::Cursor_nameContext* TSqlParser::Fetch_cursorContext::cursor_name() {
  return getRuleContext<TSqlParser::Cursor_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Fetch_cursorContext::LOCAL_ID() {
  return getTokens(TSqlParser::LOCAL_ID);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::LOCAL_ID(size_t i) {
  return getToken(TSqlParser::LOCAL_ID, i);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::PRIOR() {
  return getToken(TSqlParser::PRIOR, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::LAST() {
  return getToken(TSqlParser::LAST, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Fetch_cursorContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Fetch_cursorContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::ABSOLUTE() {
  return getToken(TSqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* TSqlParser::Fetch_cursorContext::RELATIVE() {
  return getToken(TSqlParser::RELATIVE, 0);
}


size_t TSqlParser::Fetch_cursorContext::getRuleIndex() const {
  return TSqlParser::RuleFetch_cursor;
}

void TSqlParser::Fetch_cursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFetch_cursor(this);
}

void TSqlParser::Fetch_cursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFetch_cursor(this);
}

TSqlParser::Fetch_cursorContext* TSqlParser::fetch_cursor() {
  Fetch_cursorContext *_localctx = _tracker.createInstance<Fetch_cursorContext>(_ctx, getState());
  enterRule(_localctx, 204, TSqlParser::RuleFetch_cursor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2173);
    match(TSqlParser::FETCH);
    setState(2183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
    case 1: {
      setState(2180);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::NEXT: {
          setState(2174);
          match(TSqlParser::NEXT);
          break;
        }

        case TSqlParser::PRIOR: {
          setState(2175);
          match(TSqlParser::PRIOR);
          break;
        }

        case TSqlParser::FIRST: {
          setState(2176);
          match(TSqlParser::FIRST);
          break;
        }

        case TSqlParser::LAST: {
          setState(2177);
          match(TSqlParser::LAST);
          break;
        }

        case TSqlParser::ABSOLUTE:
        case TSqlParser::RELATIVE: {
          setState(2178);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::ABSOLUTE || _la == TSqlParser::RELATIVE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2179);
          expression(0);
          break;
        }

        case TSqlParser::FROM: {
          break;
        }

      default:
        break;
      }
      setState(2182);
      match(TSqlParser::FROM);
      break;
    }

    default:
      break;
    }
    setState(2186);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx)) {
    case 1: {
      setState(2185);
      match(TSqlParser::GLOBAL);
      break;
    }

    default:
      break;
    }
    setState(2188);
    cursor_name();
    setState(2198);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(2189);
      match(TSqlParser::INTO);
      setState(2190);
      match(TSqlParser::LOCAL_ID);
      setState(2195);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2191);
        match(TSqlParser::COMMA);
        setState(2192);
        match(TSqlParser::LOCAL_ID);
        setState(2197);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2201);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
    case 1: {
      setState(2200);
      match(TSqlParser::SEMI);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_specialContext ------------------------------------------------------------------

TSqlParser::Set_specialContext::Set_specialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Set_specialContext::SET() {
  return getToken(TSqlParser::SET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Set_specialContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Set_specialContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::Set_specialContext::constant_LOCAL_ID() {
  return getRuleContext<TSqlParser::Constant_LOCAL_IDContext>(0);
}

TSqlParser::On_offContext* TSqlParser::Set_specialContext::on_off() {
  return getRuleContext<TSqlParser::On_offContext>(0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SEMI() {
  return getToken(TSqlParser::SEMI, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ROWCOUNT() {
  return getToken(TSqlParser::ROWCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::TRANSACTION() {
  return getToken(TSqlParser::TRANSACTION, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ISOLATION() {
  return getToken(TSqlParser::ISOLATION, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::LEVEL() {
  return getToken(TSqlParser::LEVEL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::READ() {
  return getToken(TSqlParser::READ, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::UNCOMMITTED() {
  return getToken(TSqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::COMMITTED() {
  return getToken(TSqlParser::COMMITTED, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::REPEATABLE() {
  return getToken(TSqlParser::REPEATABLE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::IDENTITY_INSERT() {
  return getToken(TSqlParser::IDENTITY_INSERT, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Set_specialContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_NULLS() {
  return getToken(TSqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::QUOTED_IDENTIFIER() {
  return getToken(TSqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_PADDING() {
  return getToken(TSqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_WARNINGS() {
  return getToken(TSqlParser::ANSI_WARNINGS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_DEFAULTS() {
  return getToken(TSqlParser::ANSI_DEFAULTS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_NULL_DFLT_OFF() {
  return getToken(TSqlParser::ANSI_NULL_DFLT_OFF, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ANSI_NULL_DFLT_ON() {
  return getToken(TSqlParser::ANSI_NULL_DFLT_ON, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ARITHABORT() {
  return getToken(TSqlParser::ARITHABORT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::ARITHIGNORE() {
  return getToken(TSqlParser::ARITHIGNORE, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::CONCAT_NULL_YIELDS_NULL() {
  return getToken(TSqlParser::CONCAT_NULL_YIELDS_NULL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::FMTONLY() {
  return getToken(TSqlParser::FMTONLY, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::FORCEPLAN() {
  return getToken(TSqlParser::FORCEPLAN, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::IMPLICIT_TRANSACTIONS() {
  return getToken(TSqlParser::IMPLICIT_TRANSACTIONS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::NOCOUNT() {
  return getToken(TSqlParser::NOCOUNT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::NOEXEC() {
  return getToken(TSqlParser::NOEXEC, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::NUMERIC_ROUNDABORT() {
  return getToken(TSqlParser::NUMERIC_ROUNDABORT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::PARSEONLY() {
  return getToken(TSqlParser::PARSEONLY, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::REMOTE_PROC_TRANSACTIONS() {
  return getToken(TSqlParser::REMOTE_PROC_TRANSACTIONS, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SHOWPLAN_ALL() {
  return getToken(TSqlParser::SHOWPLAN_ALL, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SHOWPLAN_TEXT() {
  return getToken(TSqlParser::SHOWPLAN_TEXT, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::SHOWPLAN_XML() {
  return getToken(TSqlParser::SHOWPLAN_XML, 0);
}

tree::TerminalNode* TSqlParser::Set_specialContext::XACT_ABORT() {
  return getToken(TSqlParser::XACT_ABORT, 0);
}


size_t TSqlParser::Set_specialContext::getRuleIndex() const {
  return TSqlParser::RuleSet_special;
}

void TSqlParser::Set_specialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_special(this);
}

void TSqlParser::Set_specialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_special(this);
}

TSqlParser::Set_specialContext* TSqlParser::set_special() {
  Set_specialContext *_localctx = _tracker.createInstance<Set_specialContext>(_ctx, getState());
  enterRule(_localctx, 206, TSqlParser::RuleSet_special);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2247);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2203);
      match(TSqlParser::SET);
      setState(2204);
      id_();
      setState(2208);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID: {
          setState(2205);
          id_();
          break;
        }

        case TSqlParser::LOCAL_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::STRING:
        case TSqlParser::BINARY:
        case TSqlParser::FLOAT:
        case TSqlParser::REAL:
        case TSqlParser::DOLLAR:
        case TSqlParser::PLUS:
        case TSqlParser::MINUS: {
          setState(2206);
          constant_LOCAL_ID();
          break;
        }

        case TSqlParser::OFF:
        case TSqlParser::ON: {
          setState(2207);
          on_off();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2211);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
      case 1: {
        setState(2210);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2213);
      match(TSqlParser::SET);
      setState(2214);
      match(TSqlParser::ROWCOUNT);
      setState(2215);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::LOCAL_ID

      || _la == TSqlParser::DECIMAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2217);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
      case 1: {
        setState(2216);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2219);
      match(TSqlParser::SET);
      setState(2220);
      match(TSqlParser::TRANSACTION);
      setState(2221);
      match(TSqlParser::ISOLATION);
      setState(2222);
      match(TSqlParser::LEVEL);
      setState(2232);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
      case 1: {
        setState(2223);
        match(TSqlParser::READ);
        setState(2224);
        match(TSqlParser::UNCOMMITTED);
        break;
      }

      case 2: {
        setState(2225);
        match(TSqlParser::READ);
        setState(2226);
        match(TSqlParser::COMMITTED);
        break;
      }

      case 3: {
        setState(2227);
        match(TSqlParser::REPEATABLE);
        setState(2228);
        match(TSqlParser::READ);
        break;
      }

      case 4: {
        setState(2229);
        match(TSqlParser::SNAPSHOT);
        break;
      }

      case 5: {
        setState(2230);
        match(TSqlParser::SERIALIZABLE);
        break;
      }

      case 6: {
        setState(2231);
        match(TSqlParser::DECIMAL);
        break;
      }

      default:
        break;
      }
      setState(2235);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
      case 1: {
        setState(2234);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2237);
      match(TSqlParser::SET);
      setState(2238);
      match(TSqlParser::IDENTITY_INSERT);
      setState(2239);
      table_name();
      setState(2240);
      on_off();
      setState(2242);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
      case 1: {
        setState(2241);
        match(TSqlParser::SEMI);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2244);
      match(TSqlParser::SET);
      setState(2245);
      _la = _input->LA(1);
      if (!(((((_la - 173) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 173)) & 8912919) != 0) || ((((_la - 268) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 268)) & 33554497) != 0) || ((((_la - 440) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 440)) & 16383) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2246);
      on_off();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_LOCAL_IDContext ------------------------------------------------------------------

TSqlParser::Constant_LOCAL_IDContext::Constant_LOCAL_IDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ConstantContext* TSqlParser::Constant_LOCAL_IDContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_LOCAL_IDContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Constant_LOCAL_IDContext::getRuleIndex() const {
  return TSqlParser::RuleConstant_LOCAL_ID;
}

void TSqlParser::Constant_LOCAL_IDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_LOCAL_ID(this);
}

void TSqlParser::Constant_LOCAL_IDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_LOCAL_ID(this);
}

TSqlParser::Constant_LOCAL_IDContext* TSqlParser::constant_LOCAL_ID() {
  Constant_LOCAL_IDContext *_localctx = _tracker.createInstance<Constant_LOCAL_IDContext>(_ctx, getState());
  enterRule(_localctx, 208, TSqlParser::RuleConstant_LOCAL_ID);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2251);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 1);
        setState(2249);
        constant();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(2250);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

TSqlParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Primitive_expressionContext* TSqlParser::ExpressionContext::primitive_expression() {
  return getRuleContext<TSqlParser::Primitive_expressionContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::ExpressionContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

TSqlParser::Case_expressionContext* TSqlParser::ExpressionContext::case_expression() {
  return getRuleContext<TSqlParser::Case_expressionContext>(0);
}

TSqlParser::Full_column_nameContext* TSqlParser::ExpressionContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

TSqlParser::Bracket_expressionContext* TSqlParser::ExpressionContext::bracket_expression() {
  return getRuleContext<TSqlParser::Bracket_expressionContext>(0);
}

TSqlParser::Unary_operator_expressionContext* TSqlParser::ExpressionContext::unary_operator_expression() {
  return getRuleContext<TSqlParser::Unary_operator_expressionContext>(0);
}

TSqlParser::Over_clauseContext* TSqlParser::ExpressionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DOLLAR_ACTION() {
  return getToken(TSqlParser::DOLLAR_ACTION, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::ExpressionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::ExpressionContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DIVIDE() {
  return getToken(TSqlParser::DIVIDE, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::MODULE() {
  return getToken(TSqlParser::MODULE, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_AND() {
  return getToken(TSqlParser::BIT_AND, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_XOR() {
  return getToken(TSqlParser::BIT_XOR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::BIT_OR() {
  return getToken(TSqlParser::BIT_OR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::DOUBLE_BAR() {
  return getToken(TSqlParser::DOUBLE_BAR, 0);
}

tree::TerminalNode* TSqlParser::ExpressionContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::Id_Context* TSqlParser::ExpressionContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Time_zoneContext* TSqlParser::ExpressionContext::time_zone() {
  return getRuleContext<TSqlParser::Time_zoneContext>(0);
}


size_t TSqlParser::ExpressionContext::getRuleIndex() const {
  return TSqlParser::RuleExpression;
}

void TSqlParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void TSqlParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


TSqlParser::ExpressionContext* TSqlParser::expression() {
   return expression(0);
}

TSqlParser::ExpressionContext* TSqlParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TSqlParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  TSqlParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 210;
  enterRecursionRule(_localctx, 210, TSqlParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2262);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
    case 1: {
      setState(2254);
      primitive_expression();
      break;
    }

    case 2: {
      setState(2255);
      function_call();
      break;
    }

    case 3: {
      setState(2256);
      case_expression();
      break;
    }

    case 4: {
      setState(2257);
      full_column_name();
      break;
    }

    case 5: {
      setState(2258);
      bracket_expression();
      break;
    }

    case 6: {
      setState(2259);
      unary_operator_expression();
      break;
    }

    case 7: {
      setState(2260);
      over_clause();
      break;
    }

    case 8: {
      setState(2261);
      match(TSqlParser::DOLLAR_ACTION);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2277);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2275);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2264);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(2265);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 430) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 430)) & 7) != 0))) {
            antlrcpp::downCast<ExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2266);
          expression(6);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2267);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(2268);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 418) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 418)) & 1933313) != 0))) {
            antlrcpp::downCast<ExpressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2269);
          expression(5);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2270);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(2271);
          match(TSqlParser::COLLATE);
          setState(2272);
          id_();
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(2273);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(2274);
          time_zone();
          break;
        }

        default:
          break;
        } 
      }
      setState(2279);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Time_zoneContext ------------------------------------------------------------------

TSqlParser::Time_zoneContext::Time_zoneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Time_zoneContext::AT_KEYWORD() {
  return getToken(TSqlParser::AT_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::Time_zoneContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::Time_zoneContext::ZONE() {
  return getToken(TSqlParser::ZONE, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Time_zoneContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Time_zoneContext::getRuleIndex() const {
  return TSqlParser::RuleTime_zone;
}

void TSqlParser::Time_zoneContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime_zone(this);
}

void TSqlParser::Time_zoneContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime_zone(this);
}

TSqlParser::Time_zoneContext* TSqlParser::time_zone() {
  Time_zoneContext *_localctx = _tracker.createInstance<Time_zoneContext>(_ctx, getState());
  enterRule(_localctx, 212, TSqlParser::RuleTime_zone);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2280);
    match(TSqlParser::AT_KEYWORD);
    setState(2281);
    match(TSqlParser::TIME);
    setState(2282);
    match(TSqlParser::ZONE);
    setState(2283);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Primitive_expressionContext ------------------------------------------------------------------

TSqlParser::Primitive_expressionContext::Primitive_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Primitive_expressionContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ConstantContext* TSqlParser::Primitive_expressionContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::Primitive_expressionContext::getRuleIndex() const {
  return TSqlParser::RulePrimitive_expression;
}

void TSqlParser::Primitive_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimitive_expression(this);
}

void TSqlParser::Primitive_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimitive_expression(this);
}

TSqlParser::Primitive_expressionContext* TSqlParser::primitive_expression() {
  Primitive_expressionContext *_localctx = _tracker.createInstance<Primitive_expressionContext>(_ctx, getState());
  enterRule(_localctx, 214, TSqlParser::RulePrimitive_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2289);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(2285);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::NULL_: {
        enterOuterAlt(_localctx, 2);
        setState(2286);
        match(TSqlParser::NULL_);
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 3);
        setState(2287);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 4);
        setState(2288);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_expressionContext ------------------------------------------------------------------

TSqlParser::Case_expressionContext::Case_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Case_expressionContext::CASE() {
  return getToken(TSqlParser::CASE, 0);
}

tree::TerminalNode* TSqlParser::Case_expressionContext::END() {
  return getToken(TSqlParser::END, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Case_expressionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Case_expressionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<TSqlParser::Switch_sectionContext *> TSqlParser::Case_expressionContext::switch_section() {
  return getRuleContexts<TSqlParser::Switch_sectionContext>();
}

TSqlParser::Switch_sectionContext* TSqlParser::Case_expressionContext::switch_section(size_t i) {
  return getRuleContext<TSqlParser::Switch_sectionContext>(i);
}

tree::TerminalNode* TSqlParser::Case_expressionContext::ELSE() {
  return getToken(TSqlParser::ELSE, 0);
}

std::vector<TSqlParser::Switch_search_condition_sectionContext *> TSqlParser::Case_expressionContext::switch_search_condition_section() {
  return getRuleContexts<TSqlParser::Switch_search_condition_sectionContext>();
}

TSqlParser::Switch_search_condition_sectionContext* TSqlParser::Case_expressionContext::switch_search_condition_section(size_t i) {
  return getRuleContext<TSqlParser::Switch_search_condition_sectionContext>(i);
}


size_t TSqlParser::Case_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleCase_expression;
}

void TSqlParser::Case_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_expression(this);
}

void TSqlParser::Case_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_expression(this);
}

TSqlParser::Case_expressionContext* TSqlParser::case_expression() {
  Case_expressionContext *_localctx = _tracker.createInstance<Case_expressionContext>(_ctx, getState());
  enterRule(_localctx, 216, TSqlParser::RuleCase_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2316);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2291);
      match(TSqlParser::CASE);
      setState(2292);
      antlrcpp::downCast<Case_expressionContext *>(_localctx)->caseExpr = expression(0);
      setState(2294); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2293);
        switch_section();
        setState(2296); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::WHEN);
      setState(2300);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ELSE) {
        setState(2298);
        match(TSqlParser::ELSE);
        setState(2299);
        antlrcpp::downCast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2302);
      match(TSqlParser::END);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2304);
      match(TSqlParser::CASE);
      setState(2306); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2305);
        switch_search_condition_section();
        setState(2308); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::WHEN);
      setState(2312);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ELSE) {
        setState(2310);
        match(TSqlParser::ELSE);
        setState(2311);
        antlrcpp::downCast<Case_expressionContext *>(_localctx)->elseExpr = expression(0);
      }
      setState(2314);
      match(TSqlParser::END);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operator_expressionContext ------------------------------------------------------------------

TSqlParser::Unary_operator_expressionContext::Unary_operator_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::BIT_NOT() {
  return getToken(TSqlParser::BIT_NOT, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Unary_operator_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::Unary_operator_expressionContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::Unary_operator_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleUnary_operator_expression;
}

void TSqlParser::Unary_operator_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_operator_expression(this);
}

void TSqlParser::Unary_operator_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_operator_expression(this);
}

TSqlParser::Unary_operator_expressionContext* TSqlParser::unary_operator_expression() {
  Unary_operator_expressionContext *_localctx = _tracker.createInstance<Unary_operator_expressionContext>(_ctx, getState());
  enterRule(_localctx, 218, TSqlParser::RuleUnary_operator_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2322);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BIT_NOT: {
        enterOuterAlt(_localctx, 1);
        setState(2318);
        match(TSqlParser::BIT_NOT);
        setState(2319);
        expression(0);
        break;
      }

      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(2320);
        antlrcpp::downCast<Unary_operator_expressionContext *>(_localctx)->op = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::PLUS

        || _la == TSqlParser::MINUS)) {
          antlrcpp::downCast<Unary_operator_expressionContext *>(_localctx)->op = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2321);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bracket_expressionContext ------------------------------------------------------------------

TSqlParser::Bracket_expressionContext::Bracket_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Bracket_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Bracket_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Bracket_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::SubqueryContext* TSqlParser::Bracket_expressionContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}


size_t TSqlParser::Bracket_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleBracket_expression;
}

void TSqlParser::Bracket_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBracket_expression(this);
}

void TSqlParser::Bracket_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBracket_expression(this);
}

TSqlParser::Bracket_expressionContext* TSqlParser::bracket_expression() {
  Bracket_expressionContext *_localctx = _tracker.createInstance<Bracket_expressionContext>(_ctx, getState());
  enterRule(_localctx, 220, TSqlParser::RuleBracket_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2332);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2324);
      match(TSqlParser::LR_BRACKET);
      setState(2325);
      expression(0);
      setState(2326);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2328);
      match(TSqlParser::LR_BRACKET);
      setState(2329);
      subquery();
      setState(2330);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

TSqlParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

TSqlParser::ConstantContext* TSqlParser::Constant_expressionContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::Constant_expressionContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Constant_expressionContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Constant_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Constant_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleConstant_expression;
}

void TSqlParser::Constant_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_expression(this);
}

void TSqlParser::Constant_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_expression(this);
}

TSqlParser::Constant_expressionContext* TSqlParser::constant_expression() {
  Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 222, TSqlParser::RuleConstant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2342);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(2334);
        match(TSqlParser::NULL_);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(2335);
        constant();
        break;
      }

      case TSqlParser::ABS:
      case TSqlParser::ASCII:
      case TSqlParser::CEILING:
      case TSqlParser::CHAR:
      case TSqlParser::CHARINDEX:
      case TSqlParser::DATALENGTH:
      case TSqlParser::DAY:
      case TSqlParser::FLOOR:
      case TSqlParser::ISDATE:
      case TSqlParser::ISNUMERIC:
      case TSqlParser::LEN:
      case TSqlParser::LOWER:
      case TSqlParser::LTRIM:
      case TSqlParser::MONTH:
      case TSqlParser::NCHAR:
      case TSqlParser::PATINDEX:
      case TSqlParser::RAND:
      case TSqlParser::REPLACE:
      case TSqlParser::ROUND:
      case TSqlParser::RTRIM:
      case TSqlParser::SIGN:
      case TSqlParser::STR:
      case TSqlParser::SUBSTRING:
      case TSqlParser::UPPER:
      case TSqlParser::USER_NAME:
      case TSqlParser::YEAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::COALESCE:
      case TSqlParser::CONVERT:
      case TSqlParser::CURRENT_TIMESTAMP:
      case TSqlParser::CURRENT_USER:
      case TSqlParser::IDENTITY:
      case TSqlParser::LEFT:
      case TSqlParser::NULLIF:
      case TSqlParser::PRECISION:
      case TSqlParser::RIGHT:
      case TSqlParser::SESSION_USER:
      case TSqlParser::SYSTEM_USER:
      case TSqlParser::USER:
      case TSqlParser::DOLLAR_PARTITION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MIN_ACTIVE_ROWVERSION:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::SPACE:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID:
      case TSqlParser::DOT: {
        enterOuterAlt(_localctx, 3);
        setState(2336);
        function_call();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 4);
        setState(2337);
        match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 5);
        setState(2338);
        match(TSqlParser::LR_BRACKET);
        setState(2339);
        constant_expression();
        setState(2340);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

TSqlParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Select_statementContext* TSqlParser::SubqueryContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}


size_t TSqlParser::SubqueryContext::getRuleIndex() const {
  return TSqlParser::RuleSubquery;
}

void TSqlParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}

void TSqlParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}

TSqlParser::SubqueryContext* TSqlParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 224, TSqlParser::RuleSubquery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2344);
    select_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_expressionContext ------------------------------------------------------------------

TSqlParser::With_expressionContext::With_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::With_expressionContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<TSqlParser::Common_table_expressionContext *> TSqlParser::With_expressionContext::common_table_expression() {
  return getRuleContexts<TSqlParser::Common_table_expressionContext>();
}

TSqlParser::Common_table_expressionContext* TSqlParser::With_expressionContext::common_table_expression(size_t i) {
  return getRuleContext<TSqlParser::Common_table_expressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::With_expressionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::With_expressionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::With_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleWith_expression;
}

void TSqlParser::With_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_expression(this);
}

void TSqlParser::With_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_expression(this);
}

TSqlParser::With_expressionContext* TSqlParser::with_expression() {
  With_expressionContext *_localctx = _tracker.createInstance<With_expressionContext>(_ctx, getState());
  enterRule(_localctx, 226, TSqlParser::RuleWith_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2346);
    match(TSqlParser::WITH);
    setState(2347);
    antlrcpp::downCast<With_expressionContext *>(_localctx)->common_table_expressionContext = common_table_expression();
    antlrcpp::downCast<With_expressionContext *>(_localctx)->ctes.push_back(antlrcpp::downCast<With_expressionContext *>(_localctx)->common_table_expressionContext);
    setState(2352);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2348);
      match(TSqlParser::COMMA);
      setState(2349);
      antlrcpp::downCast<With_expressionContext *>(_localctx)->common_table_expressionContext = common_table_expression();
      antlrcpp::downCast<With_expressionContext *>(_localctx)->ctes.push_back(antlrcpp::downCast<With_expressionContext *>(_localctx)->common_table_expressionContext);
      setState(2354);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_expressionContext ------------------------------------------------------------------

TSqlParser::Common_table_expressionContext::Common_table_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Common_table_expressionContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Common_table_expressionContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Common_table_expressionContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::Id_Context* TSqlParser::Common_table_expressionContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Select_statementContext* TSqlParser::Common_table_expressionContext::select_statement() {
  return getRuleContext<TSqlParser::Select_statementContext>(0);
}

TSqlParser::Column_name_listContext* TSqlParser::Common_table_expressionContext::column_name_list() {
  return getRuleContext<TSqlParser::Column_name_listContext>(0);
}


size_t TSqlParser::Common_table_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleCommon_table_expression;
}

void TSqlParser::Common_table_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_expression(this);
}

void TSqlParser::Common_table_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_expression(this);
}

TSqlParser::Common_table_expressionContext* TSqlParser::common_table_expression() {
  Common_table_expressionContext *_localctx = _tracker.createInstance<Common_table_expressionContext>(_ctx, getState());
  enterRule(_localctx, 228, TSqlParser::RuleCommon_table_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2355);
    antlrcpp::downCast<Common_table_expressionContext *>(_localctx)->expression_name = id_();
    setState(2360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::LR_BRACKET) {
      setState(2356);
      match(TSqlParser::LR_BRACKET);
      setState(2357);
      antlrcpp::downCast<Common_table_expressionContext *>(_localctx)->columns = column_name_list();
      setState(2358);
      match(TSqlParser::RR_BRACKET);
    }
    setState(2362);
    match(TSqlParser::AS);
    setState(2363);
    match(TSqlParser::LR_BRACKET);
    setState(2364);
    antlrcpp::downCast<Common_table_expressionContext *>(_localctx)->cte_query = select_statement();
    setState(2365);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_elemContext ------------------------------------------------------------------

TSqlParser::Update_elemContext::Update_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Update_elemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Update_elemContext::EQUAL() {
  return getTokens(TSqlParser::EQUAL);
}

tree::TerminalNode* TSqlParser::Update_elemContext::EQUAL(size_t i) {
  return getToken(TSqlParser::EQUAL, i);
}

TSqlParser::Full_column_nameContext* TSqlParser::Update_elemContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

TSqlParser::ExpressionContext* TSqlParser::Update_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Update_elemContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Update_elemContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elemContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Update_elemContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Update_elemContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Update_elemContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_elem;
}

void TSqlParser::Update_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_elem(this);
}

void TSqlParser::Update_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_elem(this);
}

TSqlParser::Update_elemContext* TSqlParser::update_elem() {
  Update_elemContext *_localctx = _tracker.createInstance<Update_elemContext>(_ctx, getState());
  enterRule(_localctx, 230, TSqlParser::RuleUpdate_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2392);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2367);
      match(TSqlParser::LOCAL_ID);
      setState(2368);
      match(TSqlParser::EQUAL);
      setState(2369);
      full_column_name();
      setState(2372);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EQUAL: {
          setState(2370);
          match(TSqlParser::EQUAL);
          break;
        }

        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2371);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2374);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2378);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID:
        case TSqlParser::DOT: {
          setState(2376);
          full_column_name();
          break;
        }

        case TSqlParser::LOCAL_ID: {
          setState(2377);
          match(TSqlParser::LOCAL_ID);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2382);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EQUAL: {
          setState(2380);
          match(TSqlParser::EQUAL);
          break;
        }

        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2381);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2384);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2385);
      antlrcpp::downCast<Update_elemContext *>(_localctx)->udt_column_name = id_();
      setState(2386);
      match(TSqlParser::DOT);
      setState(2387);
      antlrcpp::downCast<Update_elemContext *>(_localctx)->method_name = id_();
      setState(2388);
      match(TSqlParser::LR_BRACKET);
      setState(2389);
      expression_list();
      setState(2390);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_elem_mergeContext ------------------------------------------------------------------

TSqlParser::Update_elem_mergeContext::Update_elem_mergeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Update_elem_mergeContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Update_elem_mergeContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Update_elem_mergeContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Update_elem_mergeContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Update_elem_mergeContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Update_elem_mergeContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Update_elem_mergeContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Update_elem_mergeContext::getRuleIndex() const {
  return TSqlParser::RuleUpdate_elem_merge;
}

void TSqlParser::Update_elem_mergeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_elem_merge(this);
}

void TSqlParser::Update_elem_mergeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_elem_merge(this);
}

TSqlParser::Update_elem_mergeContext* TSqlParser::update_elem_merge() {
  Update_elem_mergeContext *_localctx = _tracker.createInstance<Update_elem_mergeContext>(_ctx, getState());
  enterRule(_localctx, 232, TSqlParser::RuleUpdate_elem_merge);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2410);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2396);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::ID:
        case TSqlParser::DOT: {
          setState(2394);
          full_column_name();
          break;
        }

        case TSqlParser::LOCAL_ID: {
          setState(2395);
          match(TSqlParser::LOCAL_ID);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2400);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::EQUAL: {
          setState(2398);
          match(TSqlParser::EQUAL);
          break;
        }

        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2399);
          assignment_operator();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2402);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2403);
      antlrcpp::downCast<Update_elem_mergeContext *>(_localctx)->udt_column_name = id_();
      setState(2404);
      match(TSqlParser::DOT);
      setState(2405);
      antlrcpp::downCast<Update_elem_mergeContext *>(_localctx)->method_name = id_();
      setState(2406);
      match(TSqlParser::LR_BRACKET);
      setState(2407);
      expression_list();
      setState(2408);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_conditionContext ------------------------------------------------------------------

TSqlParser::Search_conditionContext::Search_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::PredicateContext* TSqlParser::Search_conditionContext::predicate() {
  return getRuleContext<TSqlParser::PredicateContext>(0);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::Search_conditionContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::Search_conditionContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Search_conditionContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::AND() {
  return getToken(TSqlParser::AND, 0);
}

tree::TerminalNode* TSqlParser::Search_conditionContext::OR() {
  return getToken(TSqlParser::OR, 0);
}


size_t TSqlParser::Search_conditionContext::getRuleIndex() const {
  return TSqlParser::RuleSearch_condition;
}

void TSqlParser::Search_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_condition(this);
}

void TSqlParser::Search_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_condition(this);
}


TSqlParser::Search_conditionContext* TSqlParser::search_condition() {
   return search_condition(0);
}

TSqlParser::Search_conditionContext* TSqlParser::search_condition(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  TSqlParser::Search_conditionContext *_localctx = _tracker.createInstance<Search_conditionContext>(_ctx, parentState);
  TSqlParser::Search_conditionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 234;
  enterRecursionRule(_localctx, 234, TSqlParser::RuleSearch_condition, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2416);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::NOT) {
      setState(2413);
      match(TSqlParser::NOT);
      setState(2418);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2424);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      setState(2419);
      predicate();
      break;
    }

    case 2: {
      setState(2420);
      match(TSqlParser::LR_BRACKET);
      setState(2421);
      search_condition(0);
      setState(2422);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2434);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2432);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Search_conditionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSearch_condition);
          setState(2426);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(2427);
          match(TSqlParser::AND);
          setState(2428);
          search_condition(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Search_conditionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSearch_condition);
          setState(2429);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(2430);
          match(TSqlParser::OR);
          setState(2431);
          search_condition(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(2436);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

TSqlParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::PredicateContext::EXISTS() {
  return getToken(TSqlParser::EXISTS, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::SubqueryContext* TSqlParser::PredicateContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::PredicateContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::PredicateContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::Comparison_operatorContext* TSqlParser::PredicateContext::comparison_operator() {
  return getRuleContext<TSqlParser::Comparison_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::SOME() {
  return getToken(TSqlParser::SOME, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ANY() {
  return getToken(TSqlParser::ANY, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::BETWEEN() {
  return getToken(TSqlParser::BETWEEN, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::AND() {
  return getToken(TSqlParser::AND, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::PredicateContext::NOT() {
  return getTokens(TSqlParser::NOT);
}

tree::TerminalNode* TSqlParser::PredicateContext::NOT(size_t i) {
  return getToken(TSqlParser::NOT, i);
}

tree::TerminalNode* TSqlParser::PredicateContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Expression_listContext* TSqlParser::PredicateContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::PredicateContext::LIKE() {
  return getToken(TSqlParser::LIKE, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::ESCAPE() {
  return getToken(TSqlParser::ESCAPE, 0);
}

tree::TerminalNode* TSqlParser::PredicateContext::IS() {
  return getToken(TSqlParser::IS, 0);
}

TSqlParser::Null_notnullContext* TSqlParser::PredicateContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}


size_t TSqlParser::PredicateContext::getRuleIndex() const {
  return TSqlParser::RulePredicate;
}

void TSqlParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void TSqlParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

TSqlParser::PredicateContext* TSqlParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 236, TSqlParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2497);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2437);
      match(TSqlParser::EXISTS);
      setState(2438);
      match(TSqlParser::LR_BRACKET);
      setState(2439);
      subquery();
      setState(2440);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2442);
      expression(0);
      setState(2443);
      comparison_operator();
      setState(2444);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2446);
      expression(0);
      setState(2447);
      comparison_operator();
      setState(2448);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL

      || _la == TSqlParser::ANY || _la == TSqlParser::SOME)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2449);
      match(TSqlParser::LR_BRACKET);
      setState(2450);
      subquery();
      setState(2451);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2453);
      expression(0);
      setState(2457);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::NOT) {
        setState(2454);
        match(TSqlParser::NOT);
        setState(2459);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2460);
      match(TSqlParser::BETWEEN);
      setState(2461);
      expression(0);
      setState(2462);
      match(TSqlParser::AND);
      setState(2463);
      expression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2465);
      expression(0);
      setState(2469);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::NOT) {
        setState(2466);
        match(TSqlParser::NOT);
        setState(2471);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2472);
      match(TSqlParser::IN);
      setState(2473);
      match(TSqlParser::LR_BRACKET);
      setState(2476);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx)) {
      case 1: {
        setState(2474);
        subquery();
        break;
      }

      case 2: {
        setState(2475);
        expression_list();
        break;
      }

      default:
        break;
      }
      setState(2478);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2480);
      expression(0);
      setState(2484);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::NOT) {
        setState(2481);
        match(TSqlParser::NOT);
        setState(2486);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2487);
      match(TSqlParser::LIKE);
      setState(2488);
      expression(0);
      setState(2491);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx)) {
      case 1: {
        setState(2489);
        match(TSqlParser::ESCAPE);
        setState(2490);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2493);
      expression(0);
      setState(2494);
      match(TSqlParser::IS);
      setState(2495);
      null_notnull();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_expressionContext ------------------------------------------------------------------

TSqlParser::Query_expressionContext::Query_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Query_specificationContext* TSqlParser::Query_expressionContext::query_specification() {
  return getRuleContext<TSqlParser::Query_specificationContext>(0);
}

tree::TerminalNode* TSqlParser::Query_expressionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Query_expressionContext* TSqlParser::Query_expressionContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Query_expressionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Query_expressionContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

std::vector<TSqlParser::Sql_unionContext *> TSqlParser::Query_expressionContext::sql_union() {
  return getRuleContexts<TSqlParser::Sql_unionContext>();
}

TSqlParser::Sql_unionContext* TSqlParser::Query_expressionContext::sql_union(size_t i) {
  return getRuleContext<TSqlParser::Sql_unionContext>(i);
}


size_t TSqlParser::Query_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleQuery_expression;
}

void TSqlParser::Query_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery_expression(this);
}

void TSqlParser::Query_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery_expression(this);
}

TSqlParser::Query_expressionContext* TSqlParser::query_expression() {
  Query_expressionContext *_localctx = _tracker.createInstance<Query_expressionContext>(_ctx, getState());
  enterRule(_localctx, 238, TSqlParser::RuleQuery_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2515);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2504);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::SELECT: {
          setState(2499);
          query_specification();
          break;
        }

        case TSqlParser::LR_BRACKET: {
          setState(2500);
          match(TSqlParser::LR_BRACKET);
          setState(2501);
          query_expression();
          setState(2502);
          match(TSqlParser::RR_BRACKET);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2506);
      query_specification();
      setState(2508);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ORDER) {
        setState(2507);
        order_by_clause();
      }
      setState(2511); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2510);
        antlrcpp::downCast<Query_expressionContext *>(_localctx)->sql_unionContext = sql_union();
        antlrcpp::downCast<Query_expressionContext *>(_localctx)->unions.push_back(antlrcpp::downCast<Query_expressionContext *>(_localctx)->sql_unionContext);
        setState(2513); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == TSqlParser::EXCEPT

      || _la == TSqlParser::INTERSECT || _la == TSqlParser::UNION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_unionContext ------------------------------------------------------------------

TSqlParser::Sql_unionContext::Sql_unionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Sql_unionContext::UNION() {
  return getToken(TSqlParser::UNION, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::EXCEPT() {
  return getToken(TSqlParser::EXCEPT, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::INTERSECT() {
  return getToken(TSqlParser::INTERSECT, 0);
}

TSqlParser::Query_specificationContext* TSqlParser::Sql_unionContext::query_specification() {
  return getRuleContext<TSqlParser::Query_specificationContext>(0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Sql_unionContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

TSqlParser::Query_expressionContext* TSqlParser::Sql_unionContext::query_expression() {
  return getRuleContext<TSqlParser::Query_expressionContext>(0);
}


size_t TSqlParser::Sql_unionContext::getRuleIndex() const {
  return TSqlParser::RuleSql_union;
}

void TSqlParser::Sql_unionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_union(this);
}

void TSqlParser::Sql_unionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_union(this);
}

TSqlParser::Sql_unionContext* TSqlParser::sql_union() {
  Sql_unionContext *_localctx = _tracker.createInstance<Sql_unionContext>(_ctx, getState());
  enterRule(_localctx, 240, TSqlParser::RuleSql_union);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2523);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNION: {
        setState(2517);
        match(TSqlParser::UNION);
        setState(2519);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ALL) {
          setState(2518);
          match(TSqlParser::ALL);
        }
        break;
      }

      case TSqlParser::EXCEPT: {
        setState(2521);
        match(TSqlParser::EXCEPT);
        break;
      }

      case TSqlParser::INTERSECT: {
        setState(2522);
        match(TSqlParser::INTERSECT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2530);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::SELECT: {
        setState(2525);
        antlrcpp::downCast<Sql_unionContext *>(_localctx)->spec = query_specification();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        setState(2526);
        match(TSqlParser::LR_BRACKET);
        setState(2527);
        antlrcpp::downCast<Sql_unionContext *>(_localctx)->op = query_expression();
        setState(2528);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Query_specificationContext ------------------------------------------------------------------

TSqlParser::Query_specificationContext::Query_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Query_specificationContext::SELECT() {
  return getToken(TSqlParser::SELECT, 0);
}

TSqlParser::Select_listContext* TSqlParser::Query_specificationContext::select_list() {
  return getRuleContext<TSqlParser::Select_listContext>(0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::INTO() {
  return getToken(TSqlParser::INTO, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::FROM() {
  return getToken(TSqlParser::FROM, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::WHERE() {
  return getToken(TSqlParser::WHERE, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::HAVING() {
  return getToken(TSqlParser::HAVING, 0);
}

TSqlParser::Top_clauseContext* TSqlParser::Query_specificationContext::top_clause() {
  return getRuleContext<TSqlParser::Top_clauseContext>(0);
}

TSqlParser::Table_nameContext* TSqlParser::Query_specificationContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::Table_sourcesContext* TSqlParser::Query_specificationContext::table_sources() {
  return getRuleContext<TSqlParser::Table_sourcesContext>(0);
}

std::vector<TSqlParser::Search_conditionContext *> TSqlParser::Query_specificationContext::search_condition() {
  return getRuleContexts<TSqlParser::Search_conditionContext>();
}

TSqlParser::Search_conditionContext* TSqlParser::Query_specificationContext::search_condition(size_t i) {
  return getRuleContext<TSqlParser::Search_conditionContext>(i);
}

std::vector<TSqlParser::Group_by_itemContext *> TSqlParser::Query_specificationContext::group_by_item() {
  return getRuleContexts<TSqlParser::Group_by_itemContext>();
}

TSqlParser::Group_by_itemContext* TSqlParser::Query_specificationContext::group_by_item(size_t i) {
  return getRuleContext<TSqlParser::Group_by_itemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Query_specificationContext::ALL() {
  return getTokens(TSqlParser::ALL);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::ALL(size_t i) {
  return getToken(TSqlParser::ALL, i);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Query_specificationContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Query_specificationContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Query_specificationContext::getRuleIndex() const {
  return TSqlParser::RuleQuery_specification;
}

void TSqlParser::Query_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery_specification(this);
}

void TSqlParser::Query_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery_specification(this);
}

TSqlParser::Query_specificationContext* TSqlParser::query_specification() {
  Query_specificationContext *_localctx = _tracker.createInstance<Query_specificationContext>(_ctx, getState());
  enterRule(_localctx, 242, TSqlParser::RuleQuery_specification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2532);
    match(TSqlParser::SELECT);
    setState(2534);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ALL

    || _la == TSqlParser::DISTINCT) {
      setState(2533);
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->allOrDistinct = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL

      || _la == TSqlParser::DISTINCT)) {
        antlrcpp::downCast<Query_specificationContext *>(_localctx)->allOrDistinct = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::TOP) {
      setState(2536);
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->top = top_clause();
    }
    setState(2539);
    antlrcpp::downCast<Query_specificationContext *>(_localctx)->columns = select_list();
    setState(2542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::INTO) {
      setState(2540);
      match(TSqlParser::INTO);
      setState(2541);
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->into = table_name();
    }
    setState(2546);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::FROM) {
      setState(2544);
      match(TSqlParser::FROM);
      setState(2545);
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->from = table_sources();
    }
    setState(2550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WHERE) {
      setState(2548);
      match(TSqlParser::WHERE);
      setState(2549);
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->where = search_condition(0);
    }
    setState(2565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::GROUP) {
      setState(2552);
      match(TSqlParser::GROUP);
      setState(2553);
      match(TSqlParser::BY);
      setState(2555);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ALL) {
        setState(2554);
        antlrcpp::downCast<Query_specificationContext *>(_localctx)->groupByAll = match(TSqlParser::ALL);
      }
      setState(2557);
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->group_by_itemContext = group_by_item();
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->groupBys.push_back(antlrcpp::downCast<Query_specificationContext *>(_localctx)->group_by_itemContext);
      setState(2562);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2558);
        match(TSqlParser::COMMA);
        setState(2559);
        antlrcpp::downCast<Query_specificationContext *>(_localctx)->group_by_itemContext = group_by_item();
        antlrcpp::downCast<Query_specificationContext *>(_localctx)->groupBys.push_back(antlrcpp::downCast<Query_specificationContext *>(_localctx)->group_by_itemContext);
        setState(2564);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::HAVING) {
      setState(2567);
      match(TSqlParser::HAVING);
      setState(2568);
      antlrcpp::downCast<Query_specificationContext *>(_localctx)->having = search_condition(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_clauseContext ------------------------------------------------------------------

TSqlParser::Top_clauseContext::Top_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_clauseContext::TOP() {
  return getToken(TSqlParser::TOP, 0);
}

TSqlParser::Top_percentContext* TSqlParser::Top_clauseContext::top_percent() {
  return getRuleContext<TSqlParser::Top_percentContext>(0);
}

TSqlParser::Top_countContext* TSqlParser::Top_clauseContext::top_count() {
  return getRuleContext<TSqlParser::Top_countContext>(0);
}

tree::TerminalNode* TSqlParser::Top_clauseContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Top_clauseContext::TIES() {
  return getToken(TSqlParser::TIES, 0);
}


size_t TSqlParser::Top_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleTop_clause;
}

void TSqlParser::Top_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_clause(this);
}

void TSqlParser::Top_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_clause(this);
}

TSqlParser::Top_clauseContext* TSqlParser::top_clause() {
  Top_clauseContext *_localctx = _tracker.createInstance<Top_clauseContext>(_ctx, getState());
  enterRule(_localctx, 244, TSqlParser::RuleTop_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2571);
    match(TSqlParser::TOP);
    setState(2574);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      setState(2572);
      top_percent();
      break;
    }

    case 2: {
      setState(2573);
      top_count();
      break;
    }

    default:
      break;
    }
    setState(2578);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(2576);
      match(TSqlParser::WITH);
      setState(2577);
      match(TSqlParser::TIES);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_percentContext ------------------------------------------------------------------

TSqlParser::Top_percentContext::Top_percentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_percentContext::PERCENT() {
  return getToken(TSqlParser::PERCENT, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::REAL() {
  return getToken(TSqlParser::REAL, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::FLOAT() {
  return getToken(TSqlParser::FLOAT, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Top_percentContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Top_percentContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Top_percentContext::getRuleIndex() const {
  return TSqlParser::RuleTop_percent;
}

void TSqlParser::Top_percentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_percent(this);
}

void TSqlParser::Top_percentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_percent(this);
}

TSqlParser::Top_percentContext* TSqlParser::top_percent() {
  Top_percentContext *_localctx = _tracker.createInstance<Top_percentContext>(_ctx, getState());
  enterRule(_localctx, 246, TSqlParser::RuleTop_percent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2587);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL: {
        enterOuterAlt(_localctx, 1);
        setState(2580);
        antlrcpp::downCast<Top_percentContext *>(_localctx)->percent_constant = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 400) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 400)) & 49) != 0))) {
          antlrcpp::downCast<Top_percentContext *>(_localctx)->percent_constant = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2581);
        match(TSqlParser::PERCENT);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(2582);
        match(TSqlParser::LR_BRACKET);
        setState(2583);
        antlrcpp::downCast<Top_percentContext *>(_localctx)->topper_expression = expression(0);
        setState(2584);
        match(TSqlParser::RR_BRACKET);
        setState(2585);
        match(TSqlParser::PERCENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_countContext ------------------------------------------------------------------

TSqlParser::Top_countContext::Top_countContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Top_countContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Top_countContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Top_countContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Top_countContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Top_countContext::getRuleIndex() const {
  return TSqlParser::RuleTop_count;
}

void TSqlParser::Top_countContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_count(this);
}

void TSqlParser::Top_countContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_count(this);
}

TSqlParser::Top_countContext* TSqlParser::top_count() {
  Top_countContext *_localctx = _tracker.createInstance<Top_countContext>(_ctx, getState());
  enterRule(_localctx, 248, TSqlParser::RuleTop_count);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2594);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(2589);
        antlrcpp::downCast<Top_countContext *>(_localctx)->count_constant = match(TSqlParser::DECIMAL);
        break;
      }

      case TSqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(2590);
        match(TSqlParser::LR_BRACKET);
        setState(2591);
        antlrcpp::downCast<Top_countContext *>(_localctx)->topcount_expression = expression(0);
        setState(2592);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_clauseContext ------------------------------------------------------------------

TSqlParser::Order_by_clauseContext::Order_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

std::vector<TSqlParser::Order_by_expressionContext *> TSqlParser::Order_by_clauseContext::order_by_expression() {
  return getRuleContexts<TSqlParser::Order_by_expressionContext>();
}

TSqlParser::Order_by_expressionContext* TSqlParser::Order_by_clauseContext::order_by_expression(size_t i) {
  return getRuleContext<TSqlParser::Order_by_expressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::OFFSET() {
  return getToken(TSqlParser::OFFSET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Order_by_clauseContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Order_by_clauseContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::ROW() {
  return getTokens(TSqlParser::ROW);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ROW(size_t i) {
  return getToken(TSqlParser::ROW, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Order_by_clauseContext::ROWS() {
  return getTokens(TSqlParser::ROWS);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ROWS(size_t i) {
  return getToken(TSqlParser::ROWS, i);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::FETCH() {
  return getToken(TSqlParser::FETCH, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::Order_by_clauseContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}


size_t TSqlParser::Order_by_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOrder_by_clause;
}

void TSqlParser::Order_by_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_clause(this);
}

void TSqlParser::Order_by_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_clause(this);
}

TSqlParser::Order_by_clauseContext* TSqlParser::order_by_clause() {
  Order_by_clauseContext *_localctx = _tracker.createInstance<Order_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 250, TSqlParser::RuleOrder_by_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2596);
    match(TSqlParser::ORDER);
    setState(2597);
    match(TSqlParser::BY);
    setState(2598);
    antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext = order_by_expression();
    antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->order_bys.push_back(antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext);
    setState(2603);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2599);
      match(TSqlParser::COMMA);
      setState(2600);
      antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext = order_by_expression();
      antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->order_bys.push_back(antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->order_by_expressionContext);
      setState(2605);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2617);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
    case 1: {
      setState(2606);
      match(TSqlParser::OFFSET);
      setState(2607);
      antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->offset_exp = expression(0);
      setState(2608);
      antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->offset_rows = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ROW

      || _la == TSqlParser::ROWS)) {
        antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->offset_rows = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2615);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx)) {
      case 1: {
        setState(2609);
        match(TSqlParser::FETCH);
        setState(2610);
        antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->fetch_offset = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FIRST

        || _la == TSqlParser::NEXT)) {
          antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->fetch_offset = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2611);
        antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->fetch_exp = expression(0);
        setState(2612);
        antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->fetch_rows = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ROW

        || _la == TSqlParser::ROWS)) {
          antlrcpp::downCast<Order_by_clauseContext *>(_localctx)->fetch_rows = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2613);
        match(TSqlParser::ONLY);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_expressionContext ------------------------------------------------------------------

TSqlParser::Order_by_expressionContext::Order_by_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Order_by_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Order_by_expressionContext::ASC() {
  return getToken(TSqlParser::ASC, 0);
}

tree::TerminalNode* TSqlParser::Order_by_expressionContext::DESC() {
  return getToken(TSqlParser::DESC, 0);
}


size_t TSqlParser::Order_by_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleOrder_by_expression;
}

void TSqlParser::Order_by_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_expression(this);
}

void TSqlParser::Order_by_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_expression(this);
}

TSqlParser::Order_by_expressionContext* TSqlParser::order_by_expression() {
  Order_by_expressionContext *_localctx = _tracker.createInstance<Order_by_expressionContext>(_ctx, getState());
  enterRule(_localctx, 252, TSqlParser::RuleOrder_by_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2619);
    antlrcpp::downCast<Order_by_expressionContext *>(_localctx)->order_by = expression(0);
    setState(2622);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ASC: {
        setState(2620);
        antlrcpp::downCast<Order_by_expressionContext *>(_localctx)->ascending = match(TSqlParser::ASC);
        break;
      }

      case TSqlParser::DESC: {
        setState(2621);
        antlrcpp::downCast<Order_by_expressionContext *>(_localctx)->descending = match(TSqlParser::DESC);
        break;
      }

      case TSqlParser::EOF:
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::ALTER:
      case TSqlParser::BEGIN:
      case TSqlParser::BREAK:
      case TSqlParser::CLOSE:
      case TSqlParser::COMMIT:
      case TSqlParser::CONTINUE:
      case TSqlParser::CREATE:
      case TSqlParser::DBCC:
      case TSqlParser::DEALLOCATE:
      case TSqlParser::DECLARE:
      case TSqlParser::DELETE:
      case TSqlParser::DROP:
      case TSqlParser::ELSE:
      case TSqlParser::END:
      case TSqlParser::EXCEPT:
      case TSqlParser::EXECUTE:
      case TSqlParser::FETCH:
      case TSqlParser::FOR:
      case TSqlParser::GOTO:
      case TSqlParser::IF:
      case TSqlParser::INSERT:
      case TSqlParser::INTERSECT:
      case TSqlParser::KILL:
      case TSqlParser::MERGE:
      case TSqlParser::OPEN:
      case TSqlParser::OPTION:
      case TSqlParser::PRECISION:
      case TSqlParser::PRINT:
      case TSqlParser::RAISERROR:
      case TSqlParser::RETURN:
      case TSqlParser::ROLLBACK:
      case TSqlParser::SAVE:
      case TSqlParser::SELECT:
      case TSqlParser::SET:
      case TSqlParser::SHUTDOWN:
      case TSqlParser::TRUNCATE:
      case TSqlParser::UNION:
      case TSqlParser::UPDATE:
      case TSqlParser::USE:
      case TSqlParser::WHILE:
      case TSqlParser::WITH:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WAITFOR:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID:
      case TSqlParser::DOT:
      case TSqlParser::LR_BRACKET:
      case TSqlParser::RR_BRACKET:
      case TSqlParser::COMMA:
      case TSqlParser::SEMI: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_itemContext ------------------------------------------------------------------

TSqlParser::Group_by_itemContext::Group_by_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::Group_by_itemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Group_by_itemContext::getRuleIndex() const {
  return TSqlParser::RuleGroup_by_item;
}

void TSqlParser::Group_by_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_by_item(this);
}

void TSqlParser::Group_by_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_by_item(this);
}

TSqlParser::Group_by_itemContext* TSqlParser::group_by_item() {
  Group_by_itemContext *_localctx = _tracker.createInstance<Group_by_itemContext>(_ctx, getState());
  enterRule(_localctx, 254, TSqlParser::RuleGroup_by_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2624);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Option_clauseContext ------------------------------------------------------------------

TSqlParser::Option_clauseContext::Option_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Option_clauseContext::OPTION() {
  return getToken(TSqlParser::OPTION, 0);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::OptionContext *> TSqlParser::Option_clauseContext::option() {
  return getRuleContexts<TSqlParser::OptionContext>();
}

TSqlParser::OptionContext* TSqlParser::Option_clauseContext::option(size_t i) {
  return getRuleContext<TSqlParser::OptionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Option_clauseContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Option_clauseContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Option_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOption_clause;
}

void TSqlParser::Option_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption_clause(this);
}

void TSqlParser::Option_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption_clause(this);
}

TSqlParser::Option_clauseContext* TSqlParser::option_clause() {
  Option_clauseContext *_localctx = _tracker.createInstance<Option_clauseContext>(_ctx, getState());
  enterRule(_localctx, 256, TSqlParser::RuleOption_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2626);
    match(TSqlParser::OPTION);
    setState(2627);
    match(TSqlParser::LR_BRACKET);
    setState(2628);
    antlrcpp::downCast<Option_clauseContext *>(_localctx)->optionContext = option();
    antlrcpp::downCast<Option_clauseContext *>(_localctx)->options.push_back(antlrcpp::downCast<Option_clauseContext *>(_localctx)->optionContext);
    setState(2633);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2629);
      match(TSqlParser::COMMA);
      setState(2630);
      antlrcpp::downCast<Option_clauseContext *>(_localctx)->optionContext = option();
      antlrcpp::downCast<Option_clauseContext *>(_localctx)->options.push_back(antlrcpp::downCast<Option_clauseContext *>(_localctx)->optionContext);
      setState(2635);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2636);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext ------------------------------------------------------------------

TSqlParser::OptionContext::OptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::OptionContext::FAST() {
  return getToken(TSqlParser::FAST, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::UNION() {
  return getToken(TSqlParser::UNION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::CONCAT() {
  return getToken(TSqlParser::CONCAT, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FORCE() {
  return getToken(TSqlParser::FORCE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::KEEP() {
  return getToken(TSqlParser::KEEP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::PLAN() {
  return getToken(TSqlParser::PLAN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::KEEPFIXED() {
  return getToken(TSqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MAXDOP() {
  return getToken(TSqlParser::MAXDOP, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::MAXRECURSION() {
  return getToken(TSqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::OPTIMIZE() {
  return getToken(TSqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<TSqlParser::Optimize_for_argContext *> TSqlParser::OptionContext::optimize_for_arg() {
  return getRuleContexts<TSqlParser::Optimize_for_argContext>();
}

TSqlParser::Optimize_for_argContext* TSqlParser::OptionContext::optimize_for_arg(size_t i) {
  return getRuleContext<TSqlParser::Optimize_for_argContext>(i);
}

tree::TerminalNode* TSqlParser::OptionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::OptionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::OptionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::OptionContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::PARAMETERIZATION() {
  return getToken(TSqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::SIMPLE() {
  return getToken(TSqlParser::SIMPLE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::FORCED() {
  return getToken(TSqlParser::FORCED, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::ROBUST() {
  return getToken(TSqlParser::ROBUST, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::USE() {
  return getToken(TSqlParser::USE, 0);
}

tree::TerminalNode* TSqlParser::OptionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::OptionContext::getRuleIndex() const {
  return TSqlParser::RuleOption;
}

void TSqlParser::OptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption(this);
}

void TSqlParser::OptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption(this);
}

TSqlParser::OptionContext* TSqlParser::option() {
  OptionContext *_localctx = _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 258, TSqlParser::RuleOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2680);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2638);
      match(TSqlParser::FAST);
      setState(2639);
      antlrcpp::downCast<OptionContext *>(_localctx)->number_rows = match(TSqlParser::DECIMAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2640);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ORDER || _la == TSqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2641);
      match(TSqlParser::GROUP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2642);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::CONCAT

      || _la == TSqlParser::HASH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2643);
      match(TSqlParser::UNION);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2644);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::HASH

      || _la == TSqlParser::LOOP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2645);
      match(TSqlParser::JOIN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2646);
      match(TSqlParser::FORCE);
      setState(2647);
      match(TSqlParser::ORDER);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2648);
      match(TSqlParser::KEEP);
      setState(2649);
      match(TSqlParser::PLAN);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2650);
      match(TSqlParser::KEEPFIXED);
      setState(2651);
      match(TSqlParser::PLAN);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2652);
      match(TSqlParser::MAXDOP);
      setState(2653);
      antlrcpp::downCast<OptionContext *>(_localctx)->number_of_processors = match(TSqlParser::DECIMAL);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2654);
      match(TSqlParser::MAXRECURSION);
      setState(2655);
      antlrcpp::downCast<OptionContext *>(_localctx)->number_recursion = match(TSqlParser::DECIMAL);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2656);
      match(TSqlParser::OPTIMIZE);
      setState(2657);
      match(TSqlParser::FOR);
      setState(2658);
      match(TSqlParser::LR_BRACKET);
      setState(2659);
      optimize_for_arg();
      setState(2664);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == TSqlParser::COMMA) {
        setState(2660);
        match(TSqlParser::COMMA);
        setState(2661);
        optimize_for_arg();
        setState(2666);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2667);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2669);
      match(TSqlParser::OPTIMIZE);
      setState(2670);
      match(TSqlParser::FOR);
      setState(2671);
      match(TSqlParser::UNKNOWN);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2672);
      match(TSqlParser::PARAMETERIZATION);
      setState(2673);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::FORCED || _la == TSqlParser::SIMPLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2674);
      match(TSqlParser::RECOMPILE);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2675);
      match(TSqlParser::ROBUST);
      setState(2676);
      match(TSqlParser::PLAN);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2677);
      match(TSqlParser::USE);
      setState(2678);
      match(TSqlParser::PLAN);
      setState(2679);
      match(TSqlParser::STRING);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optimize_for_argContext ------------------------------------------------------------------

TSqlParser::Optimize_for_argContext::Optimize_for_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ConstantContext* TSqlParser::Optimize_for_argContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}

tree::TerminalNode* TSqlParser::Optimize_for_argContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}


size_t TSqlParser::Optimize_for_argContext::getRuleIndex() const {
  return TSqlParser::RuleOptimize_for_arg;
}

void TSqlParser::Optimize_for_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptimize_for_arg(this);
}

void TSqlParser::Optimize_for_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptimize_for_arg(this);
}

TSqlParser::Optimize_for_argContext* TSqlParser::optimize_for_arg() {
  Optimize_for_argContext *_localctx = _tracker.createInstance<Optimize_for_argContext>(_ctx, getState());
  enterRule(_localctx, 260, TSqlParser::RuleOptimize_for_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2682);
    match(TSqlParser::LOCAL_ID);
    setState(2689);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNKNOWN: {
        setState(2683);
        match(TSqlParser::UNKNOWN);
        break;
      }

      case TSqlParser::EQUAL: {
        setState(2684);
        match(TSqlParser::EQUAL);
        setState(2687);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::DECIMAL:
          case TSqlParser::STRING:
          case TSqlParser::BINARY:
          case TSqlParser::FLOAT:
          case TSqlParser::REAL:
          case TSqlParser::DOLLAR:
          case TSqlParser::PLUS:
          case TSqlParser::MINUS: {
            setState(2685);
            constant();
            break;
          }

          case TSqlParser::NULL_: {
            setState(2686);
            match(TSqlParser::NULL_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_listContext ------------------------------------------------------------------

TSqlParser::Select_listContext::Select_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Select_list_elemContext *> TSqlParser::Select_listContext::select_list_elem() {
  return getRuleContexts<TSqlParser::Select_list_elemContext>();
}

TSqlParser::Select_list_elemContext* TSqlParser::Select_listContext::select_list_elem(size_t i) {
  return getRuleContext<TSqlParser::Select_list_elemContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Select_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Select_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Select_listContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_list;
}

void TSqlParser::Select_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list(this);
}

void TSqlParser::Select_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list(this);
}

TSqlParser::Select_listContext* TSqlParser::select_list() {
  Select_listContext *_localctx = _tracker.createInstance<Select_listContext>(_ctx, getState());
  enterRule(_localctx, 262, TSqlParser::RuleSelect_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2691);
    antlrcpp::downCast<Select_listContext *>(_localctx)->select_list_elemContext = select_list_elem();
    antlrcpp::downCast<Select_listContext *>(_localctx)->selectElement.push_back(antlrcpp::downCast<Select_listContext *>(_localctx)->select_list_elemContext);
    setState(2696);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2692);
      match(TSqlParser::COMMA);
      setState(2693);
      antlrcpp::downCast<Select_listContext *>(_localctx)->select_list_elemContext = select_list_elem();
      antlrcpp::downCast<Select_listContext *>(_localctx)->selectElement.push_back(antlrcpp::downCast<Select_listContext *>(_localctx)->select_list_elemContext);
      setState(2698);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udt_method_argumentsContext ------------------------------------------------------------------

TSqlParser::Udt_method_argumentsContext::Udt_method_argumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Execute_var_stringContext *> TSqlParser::Udt_method_argumentsContext::execute_var_string() {
  return getRuleContexts<TSqlParser::Execute_var_stringContext>();
}

TSqlParser::Execute_var_stringContext* TSqlParser::Udt_method_argumentsContext::execute_var_string(size_t i) {
  return getRuleContext<TSqlParser::Execute_var_stringContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Udt_method_argumentsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Udt_method_argumentsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Udt_method_argumentsContext::getRuleIndex() const {
  return TSqlParser::RuleUdt_method_arguments;
}

void TSqlParser::Udt_method_argumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdt_method_arguments(this);
}

void TSqlParser::Udt_method_argumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdt_method_arguments(this);
}

TSqlParser::Udt_method_argumentsContext* TSqlParser::udt_method_arguments() {
  Udt_method_argumentsContext *_localctx = _tracker.createInstance<Udt_method_argumentsContext>(_ctx, getState());
  enterRule(_localctx, 264, TSqlParser::RuleUdt_method_arguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2699);
    match(TSqlParser::LR_BRACKET);
    setState(2700);
    antlrcpp::downCast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext = execute_var_string();
    antlrcpp::downCast<Udt_method_argumentsContext *>(_localctx)->argument.push_back(antlrcpp::downCast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext);
    setState(2705);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2701);
      match(TSqlParser::COMMA);
      setState(2702);
      antlrcpp::downCast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext = execute_var_string();
      antlrcpp::downCast<Udt_method_argumentsContext *>(_localctx)->argument.push_back(antlrcpp::downCast<Udt_method_argumentsContext *>(_localctx)->execute_var_stringContext);
      setState(2707);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2708);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsteriskContext ------------------------------------------------------------------

TSqlParser::AsteriskContext::AsteriskContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::AsteriskContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

TSqlParser::Table_nameContext* TSqlParser::AsteriskContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::AsteriskContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::AsteriskContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

tree::TerminalNode* TSqlParser::AsteriskContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}


size_t TSqlParser::AsteriskContext::getRuleIndex() const {
  return TSqlParser::RuleAsterisk;
}

void TSqlParser::AsteriskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsterisk(this);
}

void TSqlParser::AsteriskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsterisk(this);
}

TSqlParser::AsteriskContext* TSqlParser::asterisk() {
  AsteriskContext *_localctx = _tracker.createInstance<AsteriskContext>(_ctx, getState());
  enterRule(_localctx, 266, TSqlParser::RuleAsterisk);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2719);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2713);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 11824831) != 0)) {
        setState(2710);
        table_name();
        setState(2711);
        match(TSqlParser::DOT);
      }
      setState(2715);
      match(TSqlParser::STAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2716);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DELETED

      || _la == TSqlParser::INSERTED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2717);
      match(TSqlParser::DOT);
      setState(2718);
      match(TSqlParser::STAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_elemContext ------------------------------------------------------------------

TSqlParser::Column_elemContext::Column_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Full_column_nameContext* TSqlParser::Column_elemContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::DOLLAR() {
  return getToken(TSqlParser::DOLLAR, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::ROWGUID() {
  return getToken(TSqlParser::ROWGUID, 0);
}

tree::TerminalNode* TSqlParser::Column_elemContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Column_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Column_elemContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_elem;
}

void TSqlParser::Column_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_elem(this);
}

void TSqlParser::Column_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_elem(this);
}

TSqlParser::Column_elemContext* TSqlParser::column_elem() {
  Column_elemContext *_localctx = _tracker.createInstance<Column_elemContext>(_ctx, getState());
  enterRule(_localctx, 268, TSqlParser::RuleColumn_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2727);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx)) {
    case 1: {
      setState(2721);
      full_column_name();
      break;
    }

    case 2: {
      setState(2722);
      match(TSqlParser::DOLLAR);
      setState(2723);
      match(TSqlParser::IDENTITY);
      break;
    }

    case 3: {
      setState(2724);
      match(TSqlParser::DOLLAR);
      setState(2725);
      match(TSqlParser::ROWGUID);
      break;
    }

    case 4: {
      setState(2726);
      match(TSqlParser::NULL_);
      break;
    }

    default:
      break;
    }
    setState(2730);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
    case 1: {
      setState(2729);
      as_column_alias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udt_elemContext ------------------------------------------------------------------

TSqlParser::Udt_elemContext::Udt_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Udt_elemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

TSqlParser::Udt_method_argumentsContext* TSqlParser::Udt_elemContext::udt_method_arguments() {
  return getRuleContext<TSqlParser::Udt_method_argumentsContext>(0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Udt_elemContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Udt_elemContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::As_column_aliasContext* TSqlParser::Udt_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Udt_elemContext::DOUBLE_COLON() {
  return getToken(TSqlParser::DOUBLE_COLON, 0);
}


size_t TSqlParser::Udt_elemContext::getRuleIndex() const {
  return TSqlParser::RuleUdt_elem;
}

void TSqlParser::Udt_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdt_elem(this);
}

void TSqlParser::Udt_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdt_elem(this);
}

TSqlParser::Udt_elemContext* TSqlParser::udt_elem() {
  Udt_elemContext *_localctx = _tracker.createInstance<Udt_elemContext>(_ctx, getState());
  enterRule(_localctx, 270, TSqlParser::RuleUdt_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2748);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2732);
      antlrcpp::downCast<Udt_elemContext *>(_localctx)->udt_column_name = id_();
      setState(2733);
      match(TSqlParser::DOT);
      setState(2734);
      antlrcpp::downCast<Udt_elemContext *>(_localctx)->non_static_attr = id_();
      setState(2735);
      udt_method_arguments();
      setState(2737);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 412, _ctx)) {
      case 1: {
        setState(2736);
        as_column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2739);
      antlrcpp::downCast<Udt_elemContext *>(_localctx)->udt_column_name = id_();
      setState(2740);
      match(TSqlParser::DOUBLE_COLON);
      setState(2741);
      antlrcpp::downCast<Udt_elemContext *>(_localctx)->static_attr = id_();
      setState(2743);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx)) {
      case 1: {
        setState(2742);
        udt_method_arguments();
        break;
      }

      default:
        break;
      }
      setState(2746);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
      case 1: {
        setState(2745);
        as_column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_elemContext ------------------------------------------------------------------

TSqlParser::Expression_elemContext::Expression_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_aliasContext* TSqlParser::Expression_elemContext::column_alias() {
  return getRuleContext<TSqlParser::Column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::Expression_elemContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Expression_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::As_column_aliasContext* TSqlParser::Expression_elemContext::as_column_alias() {
  return getRuleContext<TSqlParser::As_column_aliasContext>(0);
}


size_t TSqlParser::Expression_elemContext::getRuleIndex() const {
  return TSqlParser::RuleExpression_elem;
}

void TSqlParser::Expression_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_elem(this);
}

void TSqlParser::Expression_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_elem(this);
}

TSqlParser::Expression_elemContext* TSqlParser::expression_elem() {
  Expression_elemContext *_localctx = _tracker.createInstance<Expression_elemContext>(_ctx, getState());
  enterRule(_localctx, 272, TSqlParser::RuleExpression_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2758);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2750);
      antlrcpp::downCast<Expression_elemContext *>(_localctx)->leftAlias = column_alias();
      setState(2751);
      antlrcpp::downCast<Expression_elemContext *>(_localctx)->eq = match(TSqlParser::EQUAL);
      setState(2752);
      antlrcpp::downCast<Expression_elemContext *>(_localctx)->leftAssignment = expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2754);
      antlrcpp::downCast<Expression_elemContext *>(_localctx)->expressionAs = expression(0);
      setState(2756);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
      case 1: {
        setState(2755);
        as_column_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_elemContext ------------------------------------------------------------------

TSqlParser::Select_list_elemContext::Select_list_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::AsteriskContext* TSqlParser::Select_list_elemContext::asterisk() {
  return getRuleContext<TSqlParser::AsteriskContext>(0);
}

TSqlParser::Column_elemContext* TSqlParser::Select_list_elemContext::column_elem() {
  return getRuleContext<TSqlParser::Column_elemContext>(0);
}

TSqlParser::Udt_elemContext* TSqlParser::Select_list_elemContext::udt_elem() {
  return getRuleContext<TSqlParser::Udt_elemContext>(0);
}

tree::TerminalNode* TSqlParser::Select_list_elemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Select_list_elemContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::Assignment_operatorContext* TSqlParser::Select_list_elemContext::assignment_operator() {
  return getRuleContext<TSqlParser::Assignment_operatorContext>(0);
}

tree::TerminalNode* TSqlParser::Select_list_elemContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

TSqlParser::Expression_elemContext* TSqlParser::Select_list_elemContext::expression_elem() {
  return getRuleContext<TSqlParser::Expression_elemContext>(0);
}


size_t TSqlParser::Select_list_elemContext::getRuleIndex() const {
  return TSqlParser::RuleSelect_list_elem;
}

void TSqlParser::Select_list_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_elem(this);
}

void TSqlParser::Select_list_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_elem(this);
}

TSqlParser::Select_list_elemContext* TSqlParser::select_list_elem() {
  Select_list_elemContext *_localctx = _tracker.createInstance<Select_list_elemContext>(_ctx, getState());
  enterRule(_localctx, 274, TSqlParser::RuleSelect_list_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2770);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2760);
      asterisk();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2761);
      column_elem();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2762);
      udt_elem();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2763);
      match(TSqlParser::LOCAL_ID);
      setState(2766);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::PLUS_ASSIGN:
        case TSqlParser::MINUS_ASSIGN:
        case TSqlParser::MULT_ASSIGN:
        case TSqlParser::DIV_ASSIGN:
        case TSqlParser::MOD_ASSIGN:
        case TSqlParser::AND_ASSIGN:
        case TSqlParser::XOR_ASSIGN:
        case TSqlParser::OR_ASSIGN: {
          setState(2764);
          assignment_operator();
          break;
        }

        case TSqlParser::EQUAL: {
          setState(2765);
          match(TSqlParser::EQUAL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2768);
      expression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2769);
      expression_elem();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourcesContext ------------------------------------------------------------------

TSqlParser::Table_sourcesContext::Table_sourcesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Table_sourceContext *> TSqlParser::Table_sourcesContext::table_source() {
  return getRuleContexts<TSqlParser::Table_sourceContext>();
}

TSqlParser::Table_sourceContext* TSqlParser::Table_sourcesContext::table_source(size_t i) {
  return getRuleContext<TSqlParser::Table_sourceContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_sourcesContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_sourcesContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_sourcesContext::getRuleIndex() const {
  return TSqlParser::RuleTable_sources;
}

void TSqlParser::Table_sourcesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_sources(this);
}

void TSqlParser::Table_sourcesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_sources(this);
}

TSqlParser::Table_sourcesContext* TSqlParser::table_sources() {
  Table_sourcesContext *_localctx = _tracker.createInstance<Table_sourcesContext>(_ctx, getState());
  enterRule(_localctx, 276, TSqlParser::RuleTable_sources);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2772);
    antlrcpp::downCast<Table_sourcesContext *>(_localctx)->table_sourceContext = table_source();
    antlrcpp::downCast<Table_sourcesContext *>(_localctx)->source.push_back(antlrcpp::downCast<Table_sourcesContext *>(_localctx)->table_sourceContext);
    setState(2777);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2773);
      match(TSqlParser::COMMA);
      setState(2774);
      antlrcpp::downCast<Table_sourcesContext *>(_localctx)->table_sourceContext = table_source();
      antlrcpp::downCast<Table_sourcesContext *>(_localctx)->source.push_back(antlrcpp::downCast<Table_sourcesContext *>(_localctx)->table_sourceContext);
      setState(2779);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_sourceContext ------------------------------------------------------------------

TSqlParser::Table_sourceContext::Table_sourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::Table_sourceContext::table_source_item_joined() {
  return getRuleContext<TSqlParser::Table_source_item_joinedContext>(0);
}

tree::TerminalNode* TSqlParser::Table_sourceContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Table_sourceContext::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}

tree::TerminalNode* TSqlParser::Table_sourceContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_sourceContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source;
}

void TSqlParser::Table_sourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source(this);
}

void TSqlParser::Table_sourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source(this);
}

TSqlParser::Table_sourceContext* TSqlParser::table_source() {
  Table_sourceContext *_localctx = _tracker.createInstance<Table_sourceContext>(_ctx, getState());
  enterRule(_localctx, 278, TSqlParser::RuleTable_source);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2780);
      table_source_item_joined();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2781);
      match(TSqlParser::LR_BRACKET);
      setState(2782);
      table_source();
      setState(2783);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_source_item_joinedContext ------------------------------------------------------------------

TSqlParser::Table_source_item_joinedContext::Table_source_item_joinedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_source_itemContext* TSqlParser::Table_source_item_joinedContext::table_source_item() {
  return getRuleContext<TSqlParser::Table_source_itemContext>(0);
}

std::vector<TSqlParser::Join_partContext *> TSqlParser::Table_source_item_joinedContext::join_part() {
  return getRuleContexts<TSqlParser::Join_partContext>();
}

TSqlParser::Join_partContext* TSqlParser::Table_source_item_joinedContext::join_part(size_t i) {
  return getRuleContext<TSqlParser::Join_partContext>(i);
}

tree::TerminalNode* TSqlParser::Table_source_item_joinedContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::Table_source_item_joinedContext::table_source_item_joined() {
  return getRuleContext<TSqlParser::Table_source_item_joinedContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_item_joinedContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Table_source_item_joinedContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source_item_joined;
}

void TSqlParser::Table_source_item_joinedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source_item_joined(this);
}

void TSqlParser::Table_source_item_joinedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source_item_joined(this);
}

TSqlParser::Table_source_item_joinedContext* TSqlParser::table_source_item_joined() {
  Table_source_item_joinedContext *_localctx = _tracker.createInstance<Table_source_item_joinedContext>(_ctx, getState());
  enterRule(_localctx, 280, TSqlParser::RuleTable_source_item_joined);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2787);
      table_source_item();
      setState(2791);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2788);
          antlrcpp::downCast<Table_source_item_joinedContext *>(_localctx)->join_partContext = join_part();
          antlrcpp::downCast<Table_source_item_joinedContext *>(_localctx)->joins.push_back(antlrcpp::downCast<Table_source_item_joinedContext *>(_localctx)->join_partContext); 
        }
        setState(2793);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2794);
      match(TSqlParser::LR_BRACKET);
      setState(2795);
      table_source_item_joined();
      setState(2796);
      match(TSqlParser::RR_BRACKET);
      setState(2800);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2797);
          antlrcpp::downCast<Table_source_item_joinedContext *>(_localctx)->join_partContext = join_part();
          antlrcpp::downCast<Table_source_item_joinedContext *>(_localctx)->joins.push_back(antlrcpp::downCast<Table_source_item_joinedContext *>(_localctx)->join_partContext); 
        }
        setState(2802);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_source_itemContext ------------------------------------------------------------------

TSqlParser::Table_source_itemContext::Table_source_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::As_table_aliasContext* TSqlParser::Table_source_itemContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}

TSqlParser::Table_name_with_hintContext* TSqlParser::Table_source_itemContext::table_name_with_hint() {
  return getRuleContext<TSqlParser::Table_name_with_hintContext>(0);
}

TSqlParser::Full_table_nameContext* TSqlParser::Table_source_itemContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Derived_tableContext* TSqlParser::Table_source_itemContext::derived_table() {
  return getRuleContext<TSqlParser::Derived_tableContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Column_alias_listContext* TSqlParser::Table_source_itemContext::column_alias_list() {
  return getRuleContext<TSqlParser::Column_alias_listContext>(0);
}

TSqlParser::Change_tableContext* TSqlParser::Table_source_itemContext::change_table() {
  return getRuleContext<TSqlParser::Change_tableContext>(0);
}

TSqlParser::Function_callContext* TSqlParser::Table_source_itemContext::function_call() {
  return getRuleContext<TSqlParser::Function_callContext>(0);
}

TSqlParser::Nodes_methodContext* TSqlParser::Table_source_itemContext::nodes_method() {
  return getRuleContext<TSqlParser::Nodes_methodContext>(0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Table_source_itemContext::DOUBLE_COLON() {
  return getToken(TSqlParser::DOUBLE_COLON, 0);
}


size_t TSqlParser::Table_source_itemContext::getRuleIndex() const {
  return TSqlParser::RuleTable_source_item;
}

void TSqlParser::Table_source_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_source_item(this);
}

void TSqlParser::Table_source_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_source_item(this);
}

TSqlParser::Table_source_itemContext* TSqlParser::table_source_item() {
  Table_source_itemContext *_localctx = _tracker.createInstance<Table_source_itemContext>(_ctx, getState());
  enterRule(_localctx, 282, TSqlParser::RuleTable_source_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2858);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2805);
      antlrcpp::downCast<Table_source_itemContext *>(_localctx)->loc_id = match(TSqlParser::LOCAL_ID);
      setState(2807);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx)) {
      case 1: {
        setState(2806);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2809);
      table_name_with_hint();
      setState(2811);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx)) {
      case 1: {
        setState(2810);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2813);
      full_table_name();
      setState(2815);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx)) {
      case 1: {
        setState(2814);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2817);
      match(TSqlParser::LR_BRACKET);
      setState(2818);
      derived_table();
      setState(2819);
      match(TSqlParser::RR_BRACKET);
      setState(2824);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx)) {
      case 1: {
        setState(2820);
        as_table_alias();
        setState(2822);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx)) {
        case 1: {
          setState(2821);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2826);
      change_table();
      setState(2828);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx)) {
      case 1: {
        setState(2827);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2830);
      function_call();
      setState(2835);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx)) {
      case 1: {
        setState(2831);
        as_table_alias();
        setState(2833);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx)) {
        case 1: {
          setState(2832);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2837);
      nodes_method();
      setState(2842);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx)) {
      case 1: {
        setState(2838);
        as_table_alias();
        setState(2840);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx)) {
        case 1: {
          setState(2839);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2844);
      antlrcpp::downCast<Table_source_itemContext *>(_localctx)->loc_id_call = match(TSqlParser::LOCAL_ID);
      setState(2845);
      match(TSqlParser::DOT);
      setState(2846);
      antlrcpp::downCast<Table_source_itemContext *>(_localctx)->loc_fcall = function_call();
      setState(2851);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx)) {
      case 1: {
        setState(2847);
        as_table_alias();
        setState(2849);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
        case 1: {
          setState(2848);
          column_alias_list();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2853);
      match(TSqlParser::DOUBLE_COLON);
      setState(2854);
      antlrcpp::downCast<Table_source_itemContext *>(_localctx)->oldstyle_fcall = function_call();
      setState(2856);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
      case 1: {
        setState(2855);
        as_table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_declarationContext ------------------------------------------------------------------

TSqlParser::Schema_declarationContext::Schema_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Column_declarationContext *> TSqlParser::Schema_declarationContext::column_declaration() {
  return getRuleContexts<TSqlParser::Column_declarationContext>();
}

TSqlParser::Column_declarationContext* TSqlParser::Schema_declarationContext::column_declaration(size_t i) {
  return getRuleContext<TSqlParser::Column_declarationContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Schema_declarationContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Schema_declarationContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Schema_declarationContext::getRuleIndex() const {
  return TSqlParser::RuleSchema_declaration;
}

void TSqlParser::Schema_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_declaration(this);
}

void TSqlParser::Schema_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_declaration(this);
}

TSqlParser::Schema_declarationContext* TSqlParser::schema_declaration() {
  Schema_declarationContext *_localctx = _tracker.createInstance<Schema_declarationContext>(_ctx, getState());
  enterRule(_localctx, 284, TSqlParser::RuleSchema_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2860);
    antlrcpp::downCast<Schema_declarationContext *>(_localctx)->column_declarationContext = column_declaration();
    antlrcpp::downCast<Schema_declarationContext *>(_localctx)->xml_col.push_back(antlrcpp::downCast<Schema_declarationContext *>(_localctx)->column_declarationContext);
    setState(2865);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(2861);
      match(TSqlParser::COMMA);
      setState(2862);
      antlrcpp::downCast<Schema_declarationContext *>(_localctx)->column_declarationContext = column_declaration();
      antlrcpp::downCast<Schema_declarationContext *>(_localctx)->xml_col.push_back(antlrcpp::downCast<Schema_declarationContext *>(_localctx)->column_declarationContext);
      setState(2867);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_declarationContext ------------------------------------------------------------------

TSqlParser::Column_declarationContext::Column_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Column_declarationContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::Data_typeContext* TSqlParser::Column_declarationContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::Column_declarationContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Column_declarationContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_declaration;
}

void TSqlParser::Column_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_declaration(this);
}

void TSqlParser::Column_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_declaration(this);
}

TSqlParser::Column_declarationContext* TSqlParser::column_declaration() {
  Column_declarationContext *_localctx = _tracker.createInstance<Column_declarationContext>(_ctx, getState());
  enterRule(_localctx, 286, TSqlParser::RuleColumn_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2868);
    id_();
    setState(2869);
    data_type();
    setState(2871);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::STRING) {
      setState(2870);
      match(TSqlParser::STRING);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_tableContext ------------------------------------------------------------------

TSqlParser::Change_tableContext::Change_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Change_table_changesContext* TSqlParser::Change_tableContext::change_table_changes() {
  return getRuleContext<TSqlParser::Change_table_changesContext>(0);
}

TSqlParser::Change_table_versionContext* TSqlParser::Change_tableContext::change_table_version() {
  return getRuleContext<TSqlParser::Change_table_versionContext>(0);
}


size_t TSqlParser::Change_tableContext::getRuleIndex() const {
  return TSqlParser::RuleChange_table;
}

void TSqlParser::Change_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange_table(this);
}

void TSqlParser::Change_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange_table(this);
}

TSqlParser::Change_tableContext* TSqlParser::change_table() {
  Change_tableContext *_localctx = _tracker.createInstance<Change_tableContext>(_ctx, getState());
  enterRule(_localctx, 288, TSqlParser::RuleChange_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2875);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2873);
      change_table_changes();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2874);
      change_table_version();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_table_changesContext ------------------------------------------------------------------

TSqlParser::Change_table_changesContext::Change_table_changesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::CHANGETABLE() {
  return getToken(TSqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::CHANGES() {
  return getToken(TSqlParser::CHANGES, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Change_table_changesContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Change_table_changesContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Change_table_changesContext::getRuleIndex() const {
  return TSqlParser::RuleChange_table_changes;
}

void TSqlParser::Change_table_changesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange_table_changes(this);
}

void TSqlParser::Change_table_changesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange_table_changes(this);
}

TSqlParser::Change_table_changesContext* TSqlParser::change_table_changes() {
  Change_table_changesContext *_localctx = _tracker.createInstance<Change_table_changesContext>(_ctx, getState());
  enterRule(_localctx, 290, TSqlParser::RuleChange_table_changes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2877);
    match(TSqlParser::CHANGETABLE);
    setState(2878);
    match(TSqlParser::LR_BRACKET);
    setState(2879);
    match(TSqlParser::CHANGES);
    setState(2880);
    antlrcpp::downCast<Change_table_changesContext *>(_localctx)->changetable = table_name();
    setState(2881);
    match(TSqlParser::COMMA);
    setState(2882);
    antlrcpp::downCast<Change_table_changesContext *>(_localctx)->changesid = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::NULL_ || _la == TSqlParser::LOCAL_ID

    || _la == TSqlParser::DECIMAL)) {
      antlrcpp::downCast<Change_table_changesContext *>(_localctx)->changesid = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2883);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Change_table_versionContext ------------------------------------------------------------------

TSqlParser::Change_table_versionContext::Change_table_versionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::CHANGETABLE() {
  return getToken(TSqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::VERSION() {
  return getToken(TSqlParser::VERSION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Change_table_versionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Change_table_versionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Table_nameContext* TSqlParser::Change_table_versionContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::Full_column_name_listContext* TSqlParser::Change_table_versionContext::full_column_name_list() {
  return getRuleContext<TSqlParser::Full_column_name_listContext>(0);
}

TSqlParser::Select_listContext* TSqlParser::Change_table_versionContext::select_list() {
  return getRuleContext<TSqlParser::Select_listContext>(0);
}


size_t TSqlParser::Change_table_versionContext::getRuleIndex() const {
  return TSqlParser::RuleChange_table_version;
}

void TSqlParser::Change_table_versionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange_table_version(this);
}

void TSqlParser::Change_table_versionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange_table_version(this);
}

TSqlParser::Change_table_versionContext* TSqlParser::change_table_version() {
  Change_table_versionContext *_localctx = _tracker.createInstance<Change_table_versionContext>(_ctx, getState());
  enterRule(_localctx, 292, TSqlParser::RuleChange_table_version);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2885);
    match(TSqlParser::CHANGETABLE);
    setState(2886);
    match(TSqlParser::LR_BRACKET);
    setState(2887);
    match(TSqlParser::VERSION);
    setState(2888);
    antlrcpp::downCast<Change_table_versionContext *>(_localctx)->versiontable = table_name();
    setState(2889);
    match(TSqlParser::COMMA);
    setState(2890);
    antlrcpp::downCast<Change_table_versionContext *>(_localctx)->pk_columns = full_column_name_list();
    setState(2891);
    match(TSqlParser::COMMA);
    setState(2892);
    antlrcpp::downCast<Change_table_versionContext *>(_localctx)->pk_values = select_list();
    setState(2893);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_partContext ------------------------------------------------------------------

TSqlParser::Join_partContext::Join_partContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Join_onContext* TSqlParser::Join_partContext::join_on() {
  return getRuleContext<TSqlParser::Join_onContext>(0);
}

TSqlParser::Cross_joinContext* TSqlParser::Join_partContext::cross_join() {
  return getRuleContext<TSqlParser::Cross_joinContext>(0);
}

TSqlParser::Apply_Context* TSqlParser::Join_partContext::apply_() {
  return getRuleContext<TSqlParser::Apply_Context>(0);
}

TSqlParser::PivotContext* TSqlParser::Join_partContext::pivot() {
  return getRuleContext<TSqlParser::PivotContext>(0);
}

TSqlParser::UnpivotContext* TSqlParser::Join_partContext::unpivot() {
  return getRuleContext<TSqlParser::UnpivotContext>(0);
}


size_t TSqlParser::Join_partContext::getRuleIndex() const {
  return TSqlParser::RuleJoin_part;
}

void TSqlParser::Join_partContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_part(this);
}

void TSqlParser::Join_partContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_part(this);
}

TSqlParser::Join_partContext* TSqlParser::join_part() {
  Join_partContext *_localctx = _tracker.createInstance<Join_partContext>(_ctx, getState());
  enterRule(_localctx, 294, TSqlParser::RuleJoin_part);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2900);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2895);
      join_on();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2896);
      cross_join();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2897);
      apply_();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2898);
      pivot();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2899);
      unpivot();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_onContext ------------------------------------------------------------------

TSqlParser::Join_onContext::Join_onContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Join_onContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Join_onContext::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}

TSqlParser::Search_conditionContext* TSqlParser::Join_onContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Join_onContext::LEFT() {
  return getToken(TSqlParser::LEFT, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::RIGHT() {
  return getToken(TSqlParser::RIGHT, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::FULL() {
  return getToken(TSqlParser::FULL, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::MERGE() {
  return getToken(TSqlParser::MERGE, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::REMOTE() {
  return getToken(TSqlParser::REMOTE, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::INNER() {
  return getToken(TSqlParser::INNER, 0);
}

tree::TerminalNode* TSqlParser::Join_onContext::OUTER() {
  return getToken(TSqlParser::OUTER, 0);
}


size_t TSqlParser::Join_onContext::getRuleIndex() const {
  return TSqlParser::RuleJoin_on;
}

void TSqlParser::Join_onContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_on(this);
}

void TSqlParser::Join_onContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_on(this);
}

TSqlParser::Join_onContext* TSqlParser::join_on() {
  Join_onContext *_localctx = _tracker.createInstance<Join_onContext>(_ctx, getState());
  enterRule(_localctx, 296, TSqlParser::RuleJoin_on);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2909);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::INNER:
      case TSqlParser::JOIN:
      case TSqlParser::MERGE:
      case TSqlParser::HASH:
      case TSqlParser::LOOP:
      case TSqlParser::REMOTE: {
        setState(2903);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::INNER) {
          setState(2902);
          antlrcpp::downCast<Join_onContext *>(_localctx)->inner = match(TSqlParser::INNER);
        }
        break;
      }

      case TSqlParser::FULL:
      case TSqlParser::LEFT:
      case TSqlParser::RIGHT: {
        setState(2905);
        antlrcpp::downCast<Join_onContext *>(_localctx)->join_type = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & 281474977234945) != 0))) {
          antlrcpp::downCast<Join_onContext *>(_localctx)->join_type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2907);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::OUTER) {
          setState(2906);
          antlrcpp::downCast<Join_onContext *>(_localctx)->outer = match(TSqlParser::OUTER);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2912);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::MERGE || _la == TSqlParser::HASH

    || _la == TSqlParser::LOOP || _la == TSqlParser::REMOTE) {
      setState(2911);
      antlrcpp::downCast<Join_onContext *>(_localctx)->join_hint = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::MERGE || _la == TSqlParser::HASH

      || _la == TSqlParser::LOOP || _la == TSqlParser::REMOTE)) {
        antlrcpp::downCast<Join_onContext *>(_localctx)->join_hint = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2914);
    match(TSqlParser::JOIN);
    setState(2915);
    antlrcpp::downCast<Join_onContext *>(_localctx)->source = table_source();
    setState(2916);
    match(TSqlParser::ON);
    setState(2917);
    antlrcpp::downCast<Join_onContext *>(_localctx)->cond = search_condition(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cross_joinContext ------------------------------------------------------------------

TSqlParser::Cross_joinContext::Cross_joinContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Cross_joinContext::CROSS() {
  return getToken(TSqlParser::CROSS, 0);
}

tree::TerminalNode* TSqlParser::Cross_joinContext::JOIN() {
  return getToken(TSqlParser::JOIN, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Cross_joinContext::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}


size_t TSqlParser::Cross_joinContext::getRuleIndex() const {
  return TSqlParser::RuleCross_join;
}

void TSqlParser::Cross_joinContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCross_join(this);
}

void TSqlParser::Cross_joinContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCross_join(this);
}

TSqlParser::Cross_joinContext* TSqlParser::cross_join() {
  Cross_joinContext *_localctx = _tracker.createInstance<Cross_joinContext>(_ctx, getState());
  enterRule(_localctx, 298, TSqlParser::RuleCross_join);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2919);
    match(TSqlParser::CROSS);
    setState(2920);
    match(TSqlParser::JOIN);
    setState(2921);
    table_source();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Apply_Context ------------------------------------------------------------------

TSqlParser::Apply_Context::Apply_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Apply_Context::APPLY() {
  return getToken(TSqlParser::APPLY, 0);
}

TSqlParser::Table_sourceContext* TSqlParser::Apply_Context::table_source() {
  return getRuleContext<TSqlParser::Table_sourceContext>(0);
}

tree::TerminalNode* TSqlParser::Apply_Context::CROSS() {
  return getToken(TSqlParser::CROSS, 0);
}

tree::TerminalNode* TSqlParser::Apply_Context::OUTER() {
  return getToken(TSqlParser::OUTER, 0);
}


size_t TSqlParser::Apply_Context::getRuleIndex() const {
  return TSqlParser::RuleApply_;
}

void TSqlParser::Apply_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_(this);
}

void TSqlParser::Apply_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_(this);
}

TSqlParser::Apply_Context* TSqlParser::apply_() {
  Apply_Context *_localctx = _tracker.createInstance<Apply_Context>(_ctx, getState());
  enterRule(_localctx, 300, TSqlParser::RuleApply_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2923);
    antlrcpp::downCast<Apply_Context *>(_localctx)->apply_style = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::CROSS

    || _la == TSqlParser::OUTER)) {
      antlrcpp::downCast<Apply_Context *>(_localctx)->apply_style = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2924);
    match(TSqlParser::APPLY);
    setState(2925);
    antlrcpp::downCast<Apply_Context *>(_localctx)->source = table_source();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PivotContext ------------------------------------------------------------------

TSqlParser::PivotContext::PivotContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::PivotContext::PIVOT() {
  return getToken(TSqlParser::PIVOT, 0);
}

TSqlParser::Pivot_clauseContext* TSqlParser::PivotContext::pivot_clause() {
  return getRuleContext<TSqlParser::Pivot_clauseContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::PivotContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}


size_t TSqlParser::PivotContext::getRuleIndex() const {
  return TSqlParser::RulePivot;
}

void TSqlParser::PivotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPivot(this);
}

void TSqlParser::PivotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPivot(this);
}

TSqlParser::PivotContext* TSqlParser::pivot() {
  PivotContext *_localctx = _tracker.createInstance<PivotContext>(_ctx, getState());
  enterRule(_localctx, 302, TSqlParser::RulePivot);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2927);
    match(TSqlParser::PIVOT);
    setState(2928);
    pivot_clause();
    setState(2929);
    as_table_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnpivotContext ------------------------------------------------------------------

TSqlParser::UnpivotContext::UnpivotContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::UnpivotContext::UNPIVOT() {
  return getToken(TSqlParser::UNPIVOT, 0);
}

TSqlParser::Unpivot_clauseContext* TSqlParser::UnpivotContext::unpivot_clause() {
  return getRuleContext<TSqlParser::Unpivot_clauseContext>(0);
}

TSqlParser::As_table_aliasContext* TSqlParser::UnpivotContext::as_table_alias() {
  return getRuleContext<TSqlParser::As_table_aliasContext>(0);
}


size_t TSqlParser::UnpivotContext::getRuleIndex() const {
  return TSqlParser::RuleUnpivot;
}

void TSqlParser::UnpivotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnpivot(this);
}

void TSqlParser::UnpivotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnpivot(this);
}

TSqlParser::UnpivotContext* TSqlParser::unpivot() {
  UnpivotContext *_localctx = _tracker.createInstance<UnpivotContext>(_ctx, getState());
  enterRule(_localctx, 304, TSqlParser::RuleUnpivot);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2931);
    match(TSqlParser::UNPIVOT);
    setState(2932);
    unpivot_clause();
    setState(2933);
    as_table_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pivot_clauseContext ------------------------------------------------------------------

TSqlParser::Pivot_clauseContext::Pivot_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::Pivot_clauseContext::aggregate_windowed_function() {
  return getRuleContext<TSqlParser::Aggregate_windowed_functionContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Pivot_clauseContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Column_alias_listContext* TSqlParser::Pivot_clauseContext::column_alias_list() {
  return getRuleContext<TSqlParser::Column_alias_listContext>(0);
}

tree::TerminalNode* TSqlParser::Pivot_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}


size_t TSqlParser::Pivot_clauseContext::getRuleIndex() const {
  return TSqlParser::RulePivot_clause;
}

void TSqlParser::Pivot_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPivot_clause(this);
}

void TSqlParser::Pivot_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPivot_clause(this);
}

TSqlParser::Pivot_clauseContext* TSqlParser::pivot_clause() {
  Pivot_clauseContext *_localctx = _tracker.createInstance<Pivot_clauseContext>(_ctx, getState());
  enterRule(_localctx, 306, TSqlParser::RulePivot_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2935);
    match(TSqlParser::LR_BRACKET);
    setState(2936);
    aggregate_windowed_function();
    setState(2937);
    match(TSqlParser::FOR);
    setState(2938);
    full_column_name();
    setState(2939);
    match(TSqlParser::IN);
    setState(2940);
    column_alias_list();
    setState(2941);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unpivot_clauseContext ------------------------------------------------------------------

TSqlParser::Unpivot_clauseContext::Unpivot_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Unpivot_clauseContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::FOR() {
  return getToken(TSqlParser::FOR, 0);
}

TSqlParser::Full_column_nameContext* TSqlParser::Unpivot_clauseContext::full_column_name() {
  return getRuleContext<TSqlParser::Full_column_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::IN() {
  return getToken(TSqlParser::IN, 0);
}

TSqlParser::Full_column_name_listContext* TSqlParser::Unpivot_clauseContext::full_column_name_list() {
  return getRuleContext<TSqlParser::Full_column_name_listContext>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Unpivot_clauseContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Unpivot_clauseContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::ExpressionContext* TSqlParser::Unpivot_clauseContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Unpivot_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleUnpivot_clause;
}

void TSqlParser::Unpivot_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnpivot_clause(this);
}

void TSqlParser::Unpivot_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnpivot_clause(this);
}

TSqlParser::Unpivot_clauseContext* TSqlParser::unpivot_clause() {
  Unpivot_clauseContext *_localctx = _tracker.createInstance<Unpivot_clauseContext>(_ctx, getState());
  enterRule(_localctx, 308, TSqlParser::RuleUnpivot_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2943);
    match(TSqlParser::LR_BRACKET);
    setState(2944);
    antlrcpp::downCast<Unpivot_clauseContext *>(_localctx)->unpivot_exp = expression(0);
    setState(2945);
    match(TSqlParser::FOR);
    setState(2946);
    full_column_name();
    setState(2947);
    match(TSqlParser::IN);
    setState(2948);
    match(TSqlParser::LR_BRACKET);
    setState(2949);
    full_column_name_list();
    setState(2950);
    match(TSqlParser::RR_BRACKET);
    setState(2951);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_column_name_listContext ------------------------------------------------------------------

TSqlParser::Full_column_name_listContext::Full_column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Full_column_nameContext *> TSqlParser::Full_column_name_listContext::full_column_name() {
  return getRuleContexts<TSqlParser::Full_column_nameContext>();
}

TSqlParser::Full_column_nameContext* TSqlParser::Full_column_name_listContext::full_column_name(size_t i) {
  return getRuleContext<TSqlParser::Full_column_nameContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Full_column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Full_column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Full_column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleFull_column_name_list;
}

void TSqlParser::Full_column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_column_name_list(this);
}

void TSqlParser::Full_column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_column_name_list(this);
}

TSqlParser::Full_column_name_listContext* TSqlParser::full_column_name_list() {
  Full_column_name_listContext *_localctx = _tracker.createInstance<Full_column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 310, TSqlParser::RuleFull_column_name_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2953);
    antlrcpp::downCast<Full_column_name_listContext *>(_localctx)->full_column_nameContext = full_column_name();
    antlrcpp::downCast<Full_column_name_listContext *>(_localctx)->column.push_back(antlrcpp::downCast<Full_column_name_listContext *>(_localctx)->full_column_nameContext);
    setState(2958);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2954);
        match(TSqlParser::COMMA);
        setState(2955);
        antlrcpp::downCast<Full_column_name_listContext *>(_localctx)->full_column_nameContext = full_column_name();
        antlrcpp::downCast<Full_column_name_listContext *>(_localctx)->column.push_back(antlrcpp::downCast<Full_column_name_listContext *>(_localctx)->full_column_nameContext); 
      }
      setState(2960);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_name_with_hintContext ------------------------------------------------------------------

TSqlParser::Table_name_with_hintContext::Table_name_with_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_nameContext* TSqlParser::Table_name_with_hintContext::table_name() {
  return getRuleContext<TSqlParser::Table_nameContext>(0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Table_name_with_hintContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}


size_t TSqlParser::Table_name_with_hintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_name_with_hint;
}

void TSqlParser::Table_name_with_hintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name_with_hint(this);
}

void TSqlParser::Table_name_with_hintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name_with_hint(this);
}

TSqlParser::Table_name_with_hintContext* TSqlParser::table_name_with_hint() {
  Table_name_with_hintContext *_localctx = _tracker.createInstance<Table_name_with_hintContext>(_ctx, getState());
  enterRule(_localctx, 312, TSqlParser::RuleTable_name_with_hint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2961);
    table_name();
    setState(2963);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
    case 1: {
      setState(2962);
      with_table_hints();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bulk_optionContext ------------------------------------------------------------------

TSqlParser::Bulk_optionContext::Bulk_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Bulk_optionContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Bulk_optionContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Bulk_optionContext::getRuleIndex() const {
  return TSqlParser::RuleBulk_option;
}

void TSqlParser::Bulk_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBulk_option(this);
}

void TSqlParser::Bulk_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBulk_option(this);
}

TSqlParser::Bulk_optionContext* TSqlParser::bulk_option() {
  Bulk_optionContext *_localctx = _tracker.createInstance<Bulk_optionContext>(_ctx, getState());
  enterRule(_localctx, 314, TSqlParser::RuleBulk_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2965);
    id_();
    setState(2966);
    match(TSqlParser::EQUAL);
    setState(2967);
    antlrcpp::downCast<Bulk_optionContext *>(_localctx)->bulk_option_value = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::DECIMAL

    || _la == TSqlParser::STRING)) {
      antlrcpp::downCast<Bulk_optionContext *>(_localctx)->bulk_option_value = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Derived_tableContext ------------------------------------------------------------------

TSqlParser::Derived_tableContext::Derived_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::SubqueryContext* TSqlParser::Derived_tableContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::Derived_tableContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Derived_tableContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Table_value_constructorContext* TSqlParser::Derived_tableContext::table_value_constructor() {
  return getRuleContext<TSqlParser::Table_value_constructorContext>(0);
}


size_t TSqlParser::Derived_tableContext::getRuleIndex() const {
  return TSqlParser::RuleDerived_table;
}

void TSqlParser::Derived_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerived_table(this);
}

void TSqlParser::Derived_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerived_table(this);
}

TSqlParser::Derived_tableContext* TSqlParser::derived_table() {
  Derived_tableContext *_localctx = _tracker.createInstance<Derived_tableContext>(_ctx, getState());
  enterRule(_localctx, 316, TSqlParser::RuleDerived_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2979);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 449, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2969);
      subquery();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2970);
      match(TSqlParser::LR_BRACKET);
      setState(2971);
      subquery();
      setState(2972);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2974);
      table_value_constructor();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2975);
      match(TSqlParser::LR_BRACKET);
      setState(2976);
      table_value_constructor();
      setState(2977);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

TSqlParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TSqlParser::Function_callContext::getRuleIndex() const {
  return TSqlParser::RuleFunction_call;
}

void TSqlParser::Function_callContext::copyFrom(Function_callContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- RANKING_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Ranking_windowed_functionContext* TSqlParser::RANKING_WINDOWED_FUNCContext::ranking_windowed_function() {
  return getRuleContext<TSqlParser::Ranking_windowed_functionContext>(0);
}

TSqlParser::RANKING_WINDOWED_FUNCContext::RANKING_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::RANKING_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRANKING_WINDOWED_FUNC(this);
}
void TSqlParser::RANKING_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRANKING_WINDOWED_FUNC(this);
}
//----------------- BUILT_IN_FUNCContext ------------------------------------------------------------------

TSqlParser::Built_in_functionsContext* TSqlParser::BUILT_IN_FUNCContext::built_in_functions() {
  return getRuleContext<TSqlParser::Built_in_functionsContext>(0);
}

TSqlParser::BUILT_IN_FUNCContext::BUILT_IN_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::BUILT_IN_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBUILT_IN_FUNC(this);
}
void TSqlParser::BUILT_IN_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBUILT_IN_FUNC(this);
}
//----------------- ANALYTIC_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Analytic_windowed_functionContext* TSqlParser::ANALYTIC_WINDOWED_FUNCContext::analytic_windowed_function() {
  return getRuleContext<TSqlParser::Analytic_windowed_functionContext>(0);
}

TSqlParser::ANALYTIC_WINDOWED_FUNCContext::ANALYTIC_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::ANALYTIC_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterANALYTIC_WINDOWED_FUNC(this);
}
void TSqlParser::ANALYTIC_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitANALYTIC_WINDOWED_FUNC(this);
}
//----------------- SCALAR_FUNCTIONContext ------------------------------------------------------------------

TSqlParser::Scalar_function_nameContext* TSqlParser::SCALAR_FUNCTIONContext::scalar_function_name() {
  return getRuleContext<TSqlParser::Scalar_function_nameContext>(0);
}

tree::TerminalNode* TSqlParser::SCALAR_FUNCTIONContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::SCALAR_FUNCTIONContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::SCALAR_FUNCTIONContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

TSqlParser::SCALAR_FUNCTIONContext::SCALAR_FUNCTIONContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::SCALAR_FUNCTIONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSCALAR_FUNCTION(this);
}
void TSqlParser::SCALAR_FUNCTIONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSCALAR_FUNCTION(this);
}
//----------------- PARTITION_FUNCContext ------------------------------------------------------------------

TSqlParser::Partition_functionContext* TSqlParser::PARTITION_FUNCContext::partition_function() {
  return getRuleContext<TSqlParser::Partition_functionContext>(0);
}

TSqlParser::PARTITION_FUNCContext::PARTITION_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::PARTITION_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPARTITION_FUNC(this);
}
void TSqlParser::PARTITION_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPARTITION_FUNC(this);
}
//----------------- AGGREGATE_WINDOWED_FUNCContext ------------------------------------------------------------------

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::AGGREGATE_WINDOWED_FUNCContext::aggregate_windowed_function() {
  return getRuleContext<TSqlParser::Aggregate_windowed_functionContext>(0);
}

TSqlParser::AGGREGATE_WINDOWED_FUNCContext::AGGREGATE_WINDOWED_FUNCContext(Function_callContext *ctx) { copyFrom(ctx); }

void TSqlParser::AGGREGATE_WINDOWED_FUNCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAGGREGATE_WINDOWED_FUNC(this);
}
void TSqlParser::AGGREGATE_WINDOWED_FUNCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAGGREGATE_WINDOWED_FUNC(this);
}
TSqlParser::Function_callContext* TSqlParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 318, TSqlParser::RuleFunction_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2993);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 451, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<TSqlParser::RANKING_WINDOWED_FUNCContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2981);
      ranking_windowed_function();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<TSqlParser::AGGREGATE_WINDOWED_FUNCContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2982);
      aggregate_windowed_function();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<TSqlParser::ANALYTIC_WINDOWED_FUNCContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(2983);
      analytic_windowed_function();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<TSqlParser::BUILT_IN_FUNCContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(2984);
      built_in_functions();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<TSqlParser::SCALAR_FUNCTIONContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(2985);
      scalar_function_name();
      setState(2986);
      match(TSqlParser::LR_BRACKET);
      setState(2988);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1738468622071758846) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 76574662716293121) != 0) || ((((_la - 133) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 133)) & -4278187903) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 197)) & -1) != 0) || ((((_la - 261) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 261)) & -1) != 0) || ((((_la - 325) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 325)) & -2882349392323411969) != 0) || ((((_la - 389) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 389)) & 123197915791005) != 0)) {
        setState(2987);
        expression_list();
      }
      setState(2990);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<TSqlParser::PARTITION_FUNCContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(2992);
      partition_function();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_functionContext ------------------------------------------------------------------

TSqlParser::Partition_functionContext::Partition_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Partition_functionContext::DOLLAR_PARTITION() {
  return getToken(TSqlParser::DOLLAR_PARTITION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Partition_functionContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Partition_functionContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Partition_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Partition_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Partition_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Partition_functionContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Partition_functionContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Partition_functionContext::getRuleIndex() const {
  return TSqlParser::RulePartition_function;
}

void TSqlParser::Partition_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartition_function(this);
}

void TSqlParser::Partition_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartition_function(this);
}

TSqlParser::Partition_functionContext* TSqlParser::partition_function() {
  Partition_functionContext *_localctx = _tracker.createInstance<Partition_functionContext>(_ctx, getState());
  enterRule(_localctx, 320, TSqlParser::RulePartition_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2998);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 378)) & 9727679) != 0)) {
      setState(2995);
      antlrcpp::downCast<Partition_functionContext *>(_localctx)->database = id_();
      setState(2996);
      match(TSqlParser::DOT);
    }
    setState(3000);
    match(TSqlParser::DOLLAR_PARTITION);
    setState(3001);
    match(TSqlParser::DOT);
    setState(3002);
    antlrcpp::downCast<Partition_functionContext *>(_localctx)->func_name = id_();
    setState(3003);
    match(TSqlParser::LR_BRACKET);
    setState(3004);
    expression(0);
    setState(3005);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Built_in_functionsContext ------------------------------------------------------------------

TSqlParser::Built_in_functionsContext::Built_in_functionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t TSqlParser::Built_in_functionsContext::getRuleIndex() const {
  return TSqlParser::RuleBuilt_in_functions;
}

void TSqlParser::Built_in_functionsContext::copyFrom(Built_in_functionsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CASTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CASTContext::CAST() {
  return getToken(TSqlParser::CAST, 0);
}

tree::TerminalNode* TSqlParser::CASTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::CASTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::CASTContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::CASTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::CASTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::CASTContext::CASTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CASTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCAST(this);
}
void TSqlParser::CASTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCAST(this);
}
//----------------- CURRENT_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CURRENT_USERContext::CURRENT_USER() {
  return getToken(TSqlParser::CURRENT_USER, 0);
}

TSqlParser::CURRENT_USERContext::CURRENT_USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CURRENT_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCURRENT_USER(this);
}
void TSqlParser::CURRENT_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCURRENT_USER(this);
}
//----------------- DATEADDContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEADDContext::DATEADD() {
  return getToken(TSqlParser::DATEADD, 0);
}

tree::TerminalNode* TSqlParser::DATEADDContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::DATEADDContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::DATEADDContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::DATEADDContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEADDContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::DATEADDContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::DATEADDContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::DATEADDContext::DATEADDContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEADDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEADD(this);
}
void TSqlParser::DATEADDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEADD(this);
}
//----------------- CHECKSUMContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CHECKSUMContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::CHECKSUMContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::CHECKSUMContext::CHECKSUMContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CHECKSUMContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCHECKSUM(this);
}
void TSqlParser::CHECKSUMContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCHECKSUM(this);
}
//----------------- CURRENT_TIMESTAMPContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CURRENT_TIMESTAMPContext::CURRENT_TIMESTAMP() {
  return getToken(TSqlParser::CURRENT_TIMESTAMP, 0);
}

TSqlParser::CURRENT_TIMESTAMPContext::CURRENT_TIMESTAMPContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CURRENT_TIMESTAMPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCURRENT_TIMESTAMP(this);
}
void TSqlParser::CURRENT_TIMESTAMPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCURRENT_TIMESTAMP(this);
}
//----------------- MIN_ACTIVE_ROWVERSIONContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::MIN_ACTIVE_ROWVERSIONContext::MIN_ACTIVE_ROWVERSION() {
  return getToken(TSqlParser::MIN_ACTIVE_ROWVERSION, 0);
}

tree::TerminalNode* TSqlParser::MIN_ACTIVE_ROWVERSIONContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::MIN_ACTIVE_ROWVERSIONContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::MIN_ACTIVE_ROWVERSIONContext::MIN_ACTIVE_ROWVERSIONContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::MIN_ACTIVE_ROWVERSIONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMIN_ACTIVE_ROWVERSION(this);
}
void TSqlParser::MIN_ACTIVE_ROWVERSIONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMIN_ACTIVE_ROWVERSION(this);
}
//----------------- BINARY_CHECKSUMContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::BINARY_CHECKSUMContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::BINARY_CHECKSUMContext::BINARY_CHECKSUMContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::BINARY_CHECKSUMContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBINARY_CHECKSUM(this);
}
void TSqlParser::BINARY_CHECKSUMContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBINARY_CHECKSUM(this);
}
//----------------- IIFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::IIFContext::IIF() {
  return getToken(TSqlParser::IIF, 0);
}

tree::TerminalNode* TSqlParser::IIFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::IIFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::IIFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::IIFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::IIFContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::IIFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::IIFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::IIFContext::IIFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::IIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIIF(this);
}
void TSqlParser::IIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIIF(this);
}
//----------------- DATEPARTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEPARTContext::DATEPART() {
  return getToken(TSqlParser::DATEPART, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEPARTContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

TSqlParser::ExpressionContext* TSqlParser::DATEPARTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::DATEPARTContext::DATEPARTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEPARTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEPART(this);
}
void TSqlParser::DATEPARTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEPART(this);
}
//----------------- USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::USERContext::USER() {
  return getToken(TSqlParser::USER, 0);
}

TSqlParser::USERContext::USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUSER(this);
}
void TSqlParser::USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUSER(this);
}
//----------------- STUFFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::STUFFContext::STUFF() {
  return getToken(TSqlParser::STUFF, 0);
}

tree::TerminalNode* TSqlParser::STUFFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STUFFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::STUFFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::STUFFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::STUFFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::STUFFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::STUFFContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::STUFFContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

TSqlParser::STUFFContext::STUFFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::STUFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSTUFF(this);
}
void TSqlParser::STUFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSTUFF(this);
}
//----------------- SYSTEM_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::SYSTEM_USERContext::SYSTEM_USER() {
  return getToken(TSqlParser::SYSTEM_USER, 0);
}

TSqlParser::SYSTEM_USERContext::SYSTEM_USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::SYSTEM_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSYSTEM_USER(this);
}
void TSqlParser::SYSTEM_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSYSTEM_USER(this);
}
//----------------- NULLIFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::NULLIFContext::NULLIF() {
  return getToken(TSqlParser::NULLIF, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::NULLIFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::NULLIFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::NULLIFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::NULLIFContext::NULLIFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::NULLIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNULLIF(this);
}
void TSqlParser::NULLIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNULLIF(this);
}
//----------------- SESSION_USERContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::SESSION_USERContext::SESSION_USER() {
  return getToken(TSqlParser::SESSION_USER, 0);
}

TSqlParser::SESSION_USERContext::SESSION_USERContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::SESSION_USERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSESSION_USER(this);
}
void TSqlParser::SESSION_USERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSESSION_USER(this);
}
//----------------- CONVERTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::CONVERTContext::CONVERT() {
  return getToken(TSqlParser::CONVERT, 0);
}

tree::TerminalNode* TSqlParser::CONVERTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::CONVERTContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::CONVERTContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::CONVERTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Data_typeContext* TSqlParser::CONVERTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::CONVERTContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::CONVERTContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::CONVERTContext::CONVERTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::CONVERTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCONVERT(this);
}
void TSqlParser::CONVERTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCONVERT(this);
}
//----------------- IDENTITYContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::IDENTITYContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Data_typeContext* TSqlParser::IDENTITYContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::IDENTITYContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::IDENTITYContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::IDENTITYContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

TSqlParser::IDENTITYContext::IDENTITYContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::IDENTITYContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIDENTITY(this);
}
void TSqlParser::IDENTITYContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIDENTITY(this);
}
//----------------- COALESCEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::COALESCEContext::COALESCE() {
  return getToken(TSqlParser::COALESCE, 0);
}

tree::TerminalNode* TSqlParser::COALESCEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::Expression_listContext* TSqlParser::COALESCEContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::COALESCEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::COALESCEContext::COALESCEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::COALESCEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCOALESCE(this);
}
void TSqlParser::COALESCEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCOALESCE(this);
}
//----------------- DATENAMEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATENAMEContext::DATENAME() {
  return getToken(TSqlParser::DATENAME, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATENAMEContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

TSqlParser::ExpressionContext* TSqlParser::DATENAMEContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

TSqlParser::DATENAMEContext::DATENAMEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATENAMEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATENAME(this);
}
void TSqlParser::DATENAMEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATENAME(this);
}
//----------------- GETUTCDATEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::GETUTCDATEContext::GETUTCDATE() {
  return getToken(TSqlParser::GETUTCDATE, 0);
}

tree::TerminalNode* TSqlParser::GETUTCDATEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::GETUTCDATEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::GETUTCDATEContext::GETUTCDATEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::GETUTCDATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGETUTCDATE(this);
}
void TSqlParser::GETUTCDATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGETUTCDATE(this);
}
//----------------- TRY_CASTContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::TRY_CASTContext::TRY_CAST() {
  return getToken(TSqlParser::TRY_CAST, 0);
}

tree::TerminalNode* TSqlParser::TRY_CASTContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::ExpressionContext* TSqlParser::TRY_CASTContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::TRY_CASTContext::AS() {
  return getToken(TSqlParser::AS, 0);
}

TSqlParser::Data_typeContext* TSqlParser::TRY_CASTContext::data_type() {
  return getRuleContext<TSqlParser::Data_typeContext>(0);
}

tree::TerminalNode* TSqlParser::TRY_CASTContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::TRY_CASTContext::TRY_CASTContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::TRY_CASTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTRY_CAST(this);
}
void TSqlParser::TRY_CASTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTRY_CAST(this);
}
//----------------- ISNULLContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::ISNULLContext::ISNULL() {
  return getToken(TSqlParser::ISNULL, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

tree::TerminalNode* TSqlParser::ISNULLContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::ISNULLContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::ISNULLContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::ISNULLContext::ISNULLContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::ISNULLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterISNULL(this);
}
void TSqlParser::ISNULLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitISNULL(this);
}
//----------------- DATEDIFFContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::DATEDIFFContext::DATEDIFF() {
  return getToken(TSqlParser::DATEDIFF, 0);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::DATEDIFFContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::DATEDIFFContext::ID() {
  return getToken(TSqlParser::ID, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::DATEDIFFContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::DATEDIFFContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

TSqlParser::DATEDIFFContext::DATEDIFFContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::DATEDIFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDATEDIFF(this);
}
void TSqlParser::DATEDIFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDATEDIFF(this);
}
//----------------- GETDATEContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::GETDATEContext::GETDATE() {
  return getToken(TSqlParser::GETDATE, 0);
}

tree::TerminalNode* TSqlParser::GETDATEContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::GETDATEContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::GETDATEContext::GETDATEContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::GETDATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGETDATE(this);
}
void TSqlParser::GETDATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGETDATE(this);
}
//----------------- STRINGAGGContext ------------------------------------------------------------------

tree::TerminalNode* TSqlParser::STRINGAGGContext::STRING_AGG() {
  return getToken(TSqlParser::STRING_AGG, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STRINGAGGContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::STRINGAGGContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::STRINGAGGContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::STRINGAGGContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::WITHIN() {
  return getToken(TSqlParser::WITHIN, 0);
}

tree::TerminalNode* TSqlParser::STRINGAGGContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::STRINGAGGContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::STRINGAGGContext::STRINGAGGContext(Built_in_functionsContext *ctx) { copyFrom(ctx); }

void TSqlParser::STRINGAGGContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSTRINGAGG(this);
}
void TSqlParser::STRINGAGGContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSTRINGAGG(this);
}
TSqlParser::Built_in_functionsContext* TSqlParser::built_in_functions() {
  Built_in_functionsContext *_localctx = _tracker.createInstance<Built_in_functionsContext>(_ctx, getState());
  enterRule(_localctx, 322, TSqlParser::RuleBuilt_in_functions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3152);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::BINARY_CHECKSUM: {
        _localctx = _tracker.createInstance<TSqlParser::BINARY_CHECKSUMContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(3007);
        match(TSqlParser::BINARY_CHECKSUM);
        setState(3008);
        match(TSqlParser::LR_BRACKET);
        setState(3009);
        match(TSqlParser::STAR);
        setState(3010);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CAST: {
        _localctx = _tracker.createInstance<TSqlParser::CASTContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(3011);
        match(TSqlParser::CAST);
        setState(3012);
        match(TSqlParser::LR_BRACKET);
        setState(3013);
        expression(0);
        setState(3014);
        match(TSqlParser::AS);
        setState(3015);
        data_type();
        setState(3016);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::TRY_CAST: {
        _localctx = _tracker.createInstance<TSqlParser::TRY_CASTContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(3018);
        match(TSqlParser::TRY_CAST);
        setState(3019);
        match(TSqlParser::LR_BRACKET);
        setState(3020);
        expression(0);
        setState(3021);
        match(TSqlParser::AS);
        setState(3022);
        data_type();
        setState(3023);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CONVERT: {
        _localctx = _tracker.createInstance<TSqlParser::CONVERTContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(3025);
        match(TSqlParser::CONVERT);
        setState(3026);
        match(TSqlParser::LR_BRACKET);
        setState(3027);
        antlrcpp::downCast<CONVERTContext *>(_localctx)->convert_data_type = data_type();
        setState(3028);
        match(TSqlParser::COMMA);
        setState(3029);
        antlrcpp::downCast<CONVERTContext *>(_localctx)->convert_expression = expression(0);
        setState(3032);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(3030);
          match(TSqlParser::COMMA);
          setState(3031);
          antlrcpp::downCast<CONVERTContext *>(_localctx)->style = expression(0);
        }
        setState(3034);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CHECKSUM: {
        _localctx = _tracker.createInstance<TSqlParser::CHECKSUMContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(3036);
        match(TSqlParser::CHECKSUM);
        setState(3037);
        match(TSqlParser::LR_BRACKET);
        setState(3038);
        match(TSqlParser::STAR);
        setState(3039);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::COALESCE: {
        _localctx = _tracker.createInstance<TSqlParser::COALESCEContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(3040);
        match(TSqlParser::COALESCE);
        setState(3041);
        match(TSqlParser::LR_BRACKET);
        setState(3042);
        expression_list();
        setState(3043);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::CURRENT_TIMESTAMP: {
        _localctx = _tracker.createInstance<TSqlParser::CURRENT_TIMESTAMPContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(3045);
        match(TSqlParser::CURRENT_TIMESTAMP);
        break;
      }

      case TSqlParser::CURRENT_USER: {
        _localctx = _tracker.createInstance<TSqlParser::CURRENT_USERContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(3046);
        match(TSqlParser::CURRENT_USER);
        break;
      }

      case TSqlParser::DATEADD: {
        _localctx = _tracker.createInstance<TSqlParser::DATEADDContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(3047);
        match(TSqlParser::DATEADD);
        setState(3048);
        match(TSqlParser::LR_BRACKET);
        setState(3049);
        antlrcpp::downCast<DATEADDContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3050);
        match(TSqlParser::COMMA);
        setState(3051);
        antlrcpp::downCast<DATEADDContext *>(_localctx)->number = expression(0);
        setState(3052);
        match(TSqlParser::COMMA);
        setState(3053);
        antlrcpp::downCast<DATEADDContext *>(_localctx)->date = expression(0);
        setState(3054);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DATEDIFF: {
        _localctx = _tracker.createInstance<TSqlParser::DATEDIFFContext>(_localctx);
        enterOuterAlt(_localctx, 10);
        setState(3056);
        match(TSqlParser::DATEDIFF);
        setState(3057);
        match(TSqlParser::LR_BRACKET);
        setState(3058);
        antlrcpp::downCast<DATEDIFFContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3059);
        match(TSqlParser::COMMA);
        setState(3060);
        antlrcpp::downCast<DATEDIFFContext *>(_localctx)->date_first = expression(0);
        setState(3061);
        match(TSqlParser::COMMA);
        setState(3062);
        antlrcpp::downCast<DATEDIFFContext *>(_localctx)->date_second = expression(0);
        setState(3063);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DATENAME: {
        _localctx = _tracker.createInstance<TSqlParser::DATENAMEContext>(_localctx);
        enterOuterAlt(_localctx, 11);
        setState(3065);
        match(TSqlParser::DATENAME);
        setState(3066);
        match(TSqlParser::LR_BRACKET);
        setState(3067);
        antlrcpp::downCast<DATENAMEContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3068);
        match(TSqlParser::COMMA);
        setState(3069);
        antlrcpp::downCast<DATENAMEContext *>(_localctx)->date = expression(0);
        setState(3070);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::DATEPART: {
        _localctx = _tracker.createInstance<TSqlParser::DATEPARTContext>(_localctx);
        enterOuterAlt(_localctx, 12);
        setState(3072);
        match(TSqlParser::DATEPART);
        setState(3073);
        match(TSqlParser::LR_BRACKET);
        setState(3074);
        antlrcpp::downCast<DATEPARTContext *>(_localctx)->datepart = match(TSqlParser::ID);
        setState(3075);
        match(TSqlParser::COMMA);
        setState(3076);
        antlrcpp::downCast<DATEPARTContext *>(_localctx)->date = expression(0);
        setState(3077);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GETDATE: {
        _localctx = _tracker.createInstance<TSqlParser::GETDATEContext>(_localctx);
        enterOuterAlt(_localctx, 13);
        setState(3079);
        match(TSqlParser::GETDATE);
        setState(3080);
        match(TSqlParser::LR_BRACKET);
        setState(3081);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GETUTCDATE: {
        _localctx = _tracker.createInstance<TSqlParser::GETUTCDATEContext>(_localctx);
        enterOuterAlt(_localctx, 14);
        setState(3082);
        match(TSqlParser::GETUTCDATE);
        setState(3083);
        match(TSqlParser::LR_BRACKET);
        setState(3084);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::IDENTITY: {
        _localctx = _tracker.createInstance<TSqlParser::IDENTITYContext>(_localctx);
        enterOuterAlt(_localctx, 15);
        setState(3085);
        match(TSqlParser::IDENTITY);
        setState(3086);
        match(TSqlParser::LR_BRACKET);
        setState(3087);
        data_type();
        setState(3090);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 454, _ctx)) {
        case 1: {
          setState(3088);
          match(TSqlParser::COMMA);
          setState(3089);
          antlrcpp::downCast<IDENTITYContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
          break;
        }

        default:
          break;
        }
        setState(3094);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(3092);
          match(TSqlParser::COMMA);
          setState(3093);
          antlrcpp::downCast<IDENTITYContext *>(_localctx)->increment = match(TSqlParser::DECIMAL);
        }
        setState(3096);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::MIN_ACTIVE_ROWVERSION: {
        _localctx = _tracker.createInstance<TSqlParser::MIN_ACTIVE_ROWVERSIONContext>(_localctx);
        enterOuterAlt(_localctx, 16);
        setState(3098);
        match(TSqlParser::MIN_ACTIVE_ROWVERSION);
        setState(3099);
        match(TSqlParser::LR_BRACKET);
        setState(3100);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::NULLIF: {
        _localctx = _tracker.createInstance<TSqlParser::NULLIFContext>(_localctx);
        enterOuterAlt(_localctx, 17);
        setState(3101);
        match(TSqlParser::NULLIF);
        setState(3102);
        match(TSqlParser::LR_BRACKET);
        setState(3103);
        antlrcpp::downCast<NULLIFContext *>(_localctx)->left = expression(0);
        setState(3104);
        match(TSqlParser::COMMA);
        setState(3105);
        antlrcpp::downCast<NULLIFContext *>(_localctx)->right = expression(0);
        setState(3106);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::STUFF: {
        _localctx = _tracker.createInstance<TSqlParser::STUFFContext>(_localctx);
        enterOuterAlt(_localctx, 18);
        setState(3108);
        match(TSqlParser::STUFF);
        setState(3109);
        match(TSqlParser::LR_BRACKET);
        setState(3110);
        antlrcpp::downCast<STUFFContext *>(_localctx)->str = expression(0);
        setState(3111);
        match(TSqlParser::COMMA);
        setState(3112);
        antlrcpp::downCast<STUFFContext *>(_localctx)->from = match(TSqlParser::DECIMAL);
        setState(3113);
        match(TSqlParser::COMMA);
        setState(3114);
        antlrcpp::downCast<STUFFContext *>(_localctx)->to = match(TSqlParser::DECIMAL);
        setState(3115);
        match(TSqlParser::COMMA);
        setState(3116);
        antlrcpp::downCast<STUFFContext *>(_localctx)->str_with = expression(0);
        setState(3117);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::SESSION_USER: {
        _localctx = _tracker.createInstance<TSqlParser::SESSION_USERContext>(_localctx);
        enterOuterAlt(_localctx, 19);
        setState(3119);
        match(TSqlParser::SESSION_USER);
        break;
      }

      case TSqlParser::SYSTEM_USER: {
        _localctx = _tracker.createInstance<TSqlParser::SYSTEM_USERContext>(_localctx);
        enterOuterAlt(_localctx, 20);
        setState(3120);
        match(TSqlParser::SYSTEM_USER);
        break;
      }

      case TSqlParser::USER: {
        _localctx = _tracker.createInstance<TSqlParser::USERContext>(_localctx);
        enterOuterAlt(_localctx, 21);
        setState(3121);
        match(TSqlParser::USER);
        break;
      }

      case TSqlParser::ISNULL: {
        _localctx = _tracker.createInstance<TSqlParser::ISNULLContext>(_localctx);
        enterOuterAlt(_localctx, 22);
        setState(3122);
        match(TSqlParser::ISNULL);
        setState(3123);
        match(TSqlParser::LR_BRACKET);
        setState(3124);
        antlrcpp::downCast<ISNULLContext *>(_localctx)->left = expression(0);
        setState(3125);
        match(TSqlParser::COMMA);
        setState(3126);
        antlrcpp::downCast<ISNULLContext *>(_localctx)->right = expression(0);
        setState(3127);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::IIF: {
        _localctx = _tracker.createInstance<TSqlParser::IIFContext>(_localctx);
        enterOuterAlt(_localctx, 23);
        setState(3129);
        match(TSqlParser::IIF);
        setState(3130);
        match(TSqlParser::LR_BRACKET);
        setState(3131);
        antlrcpp::downCast<IIFContext *>(_localctx)->cond = search_condition(0);
        setState(3132);
        match(TSqlParser::COMMA);
        setState(3133);
        antlrcpp::downCast<IIFContext *>(_localctx)->left = expression(0);
        setState(3134);
        match(TSqlParser::COMMA);
        setState(3135);
        antlrcpp::downCast<IIFContext *>(_localctx)->right = expression(0);
        setState(3136);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::STRING_AGG: {
        _localctx = _tracker.createInstance<TSqlParser::STRINGAGGContext>(_localctx);
        enterOuterAlt(_localctx, 24);
        setState(3138);
        match(TSqlParser::STRING_AGG);
        setState(3139);
        match(TSqlParser::LR_BRACKET);
        setState(3140);
        antlrcpp::downCast<STRINGAGGContext *>(_localctx)->expr = expression(0);
        setState(3141);
        match(TSqlParser::COMMA);
        setState(3142);
        antlrcpp::downCast<STRINGAGGContext *>(_localctx)->separator = expression(0);
        setState(3143);
        match(TSqlParser::RR_BRACKET);
        setState(3150);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 456, _ctx)) {
        case 1: {
          setState(3144);
          match(TSqlParser::WITHIN);
          setState(3145);
          match(TSqlParser::GROUP);
          setState(3146);
          match(TSqlParser::LR_BRACKET);
          setState(3147);
          order_by_clause();
          setState(3148);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nodes_methodContext ------------------------------------------------------------------

TSqlParser::Nodes_methodContext::Nodes_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::NODES() {
  return getToken(TSqlParser::NODES, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Nodes_methodContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Nodes_methodContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

TSqlParser::SubqueryContext* TSqlParser::Nodes_methodContext::subquery() {
  return getRuleContext<TSqlParser::SubqueryContext>(0);
}

tree::TerminalNode* TSqlParser::Nodes_methodContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

TSqlParser::Id_Context* TSqlParser::Nodes_methodContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}


size_t TSqlParser::Nodes_methodContext::getRuleIndex() const {
  return TSqlParser::RuleNodes_method;
}

void TSqlParser::Nodes_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodes_method(this);
}

void TSqlParser::Nodes_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodes_method(this);
}

TSqlParser::Nodes_methodContext* TSqlParser::nodes_method() {
  Nodes_methodContext *_localctx = _tracker.createInstance<Nodes_methodContext>(_ctx, getState());
  enterRule(_localctx, 324, TSqlParser::RuleNodes_method);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3160);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::LOCAL_ID: {
        setState(3154);
        antlrcpp::downCast<Nodes_methodContext *>(_localctx)->loc_id = match(TSqlParser::LOCAL_ID);
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        setState(3155);
        antlrcpp::downCast<Nodes_methodContext *>(_localctx)->value_id = id_();
        break;
      }

      case TSqlParser::LR_BRACKET: {
        setState(3156);
        match(TSqlParser::LR_BRACKET);
        setState(3157);
        subquery();
        setState(3158);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3162);
    match(TSqlParser::DOT);
    setState(3163);
    match(TSqlParser::NODES);
    setState(3164);
    match(TSqlParser::LR_BRACKET);
    setState(3165);
    antlrcpp::downCast<Nodes_methodContext *>(_localctx)->xquery = match(TSqlParser::STRING);
    setState(3166);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_sectionContext ------------------------------------------------------------------

TSqlParser::Switch_sectionContext::Switch_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Switch_sectionContext::WHEN() {
  return getToken(TSqlParser::WHEN, 0);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Switch_sectionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Switch_sectionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

tree::TerminalNode* TSqlParser::Switch_sectionContext::THEN() {
  return getToken(TSqlParser::THEN, 0);
}


size_t TSqlParser::Switch_sectionContext::getRuleIndex() const {
  return TSqlParser::RuleSwitch_section;
}

void TSqlParser::Switch_sectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_section(this);
}

void TSqlParser::Switch_sectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_section(this);
}

TSqlParser::Switch_sectionContext* TSqlParser::switch_section() {
  Switch_sectionContext *_localctx = _tracker.createInstance<Switch_sectionContext>(_ctx, getState());
  enterRule(_localctx, 326, TSqlParser::RuleSwitch_section);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3168);
    match(TSqlParser::WHEN);
    setState(3169);
    expression(0);
    setState(3170);
    match(TSqlParser::THEN);
    setState(3171);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_search_condition_sectionContext ------------------------------------------------------------------

TSqlParser::Switch_search_condition_sectionContext::Switch_search_condition_sectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Switch_search_condition_sectionContext::WHEN() {
  return getToken(TSqlParser::WHEN, 0);
}

TSqlParser::Search_conditionContext* TSqlParser::Switch_search_condition_sectionContext::search_condition() {
  return getRuleContext<TSqlParser::Search_conditionContext>(0);
}

tree::TerminalNode* TSqlParser::Switch_search_condition_sectionContext::THEN() {
  return getToken(TSqlParser::THEN, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Switch_search_condition_sectionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Switch_search_condition_sectionContext::getRuleIndex() const {
  return TSqlParser::RuleSwitch_search_condition_section;
}

void TSqlParser::Switch_search_condition_sectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_search_condition_section(this);
}

void TSqlParser::Switch_search_condition_sectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_search_condition_section(this);
}

TSqlParser::Switch_search_condition_sectionContext* TSqlParser::switch_search_condition_section() {
  Switch_search_condition_sectionContext *_localctx = _tracker.createInstance<Switch_search_condition_sectionContext>(_ctx, getState());
  enterRule(_localctx, 328, TSqlParser::RuleSwitch_search_condition_section);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3173);
    match(TSqlParser::WHEN);
    setState(3174);
    search_condition(0);
    setState(3175);
    match(TSqlParser::THEN);
    setState(3176);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_column_aliasContext ------------------------------------------------------------------

TSqlParser::As_column_aliasContext::As_column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Column_aliasContext* TSqlParser::As_column_aliasContext::column_alias() {
  return getRuleContext<TSqlParser::Column_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::As_column_aliasContext::AS() {
  return getToken(TSqlParser::AS, 0);
}


size_t TSqlParser::As_column_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleAs_column_alias;
}

void TSqlParser::As_column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAs_column_alias(this);
}

void TSqlParser::As_column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAs_column_alias(this);
}

TSqlParser::As_column_aliasContext* TSqlParser::as_column_alias() {
  As_column_aliasContext *_localctx = _tracker.createInstance<As_column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 330, TSqlParser::RuleAs_column_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3179);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(3178);
      match(TSqlParser::AS);
    }
    setState(3181);
    column_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_table_aliasContext ------------------------------------------------------------------

TSqlParser::As_table_aliasContext::As_table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Table_aliasContext* TSqlParser::As_table_aliasContext::table_alias() {
  return getRuleContext<TSqlParser::Table_aliasContext>(0);
}

tree::TerminalNode* TSqlParser::As_table_aliasContext::AS() {
  return getToken(TSqlParser::AS, 0);
}


size_t TSqlParser::As_table_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleAs_table_alias;
}

void TSqlParser::As_table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAs_table_alias(this);
}

void TSqlParser::As_table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAs_table_alias(this);
}

TSqlParser::As_table_aliasContext* TSqlParser::as_table_alias() {
  As_table_aliasContext *_localctx = _tracker.createInstance<As_table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 332, TSqlParser::RuleAs_table_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3184);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::AS) {
      setState(3183);
      match(TSqlParser::AS);
    }
    setState(3186);
    table_alias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_aliasContext ------------------------------------------------------------------

TSqlParser::Table_aliasContext::Table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Table_aliasContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

TSqlParser::With_table_hintsContext* TSqlParser::Table_aliasContext::with_table_hints() {
  return getRuleContext<TSqlParser::With_table_hintsContext>(0);
}


size_t TSqlParser::Table_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleTable_alias;
}

void TSqlParser::Table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_alias(this);
}

void TSqlParser::Table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_alias(this);
}

TSqlParser::Table_aliasContext* TSqlParser::table_alias() {
  Table_aliasContext *_localctx = _tracker.createInstance<Table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 334, TSqlParser::RuleTable_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3188);
    id_();
    setState(3190);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
    case 1: {
      setState(3189);
      with_table_hints();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_table_hintsContext ------------------------------------------------------------------

TSqlParser::With_table_hintsContext::With_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Table_hintContext *> TSqlParser::With_table_hintsContext::table_hint() {
  return getRuleContexts<TSqlParser::Table_hintContext>();
}

TSqlParser::Table_hintContext* TSqlParser::With_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<TSqlParser::Table_hintContext>(i);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::With_table_hintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::With_table_hintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::With_table_hintsContext::getRuleIndex() const {
  return TSqlParser::RuleWith_table_hints;
}

void TSqlParser::With_table_hintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_table_hints(this);
}

void TSqlParser::With_table_hintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_table_hints(this);
}

TSqlParser::With_table_hintsContext* TSqlParser::with_table_hints() {
  With_table_hintsContext *_localctx = _tracker.createInstance<With_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 336, TSqlParser::RuleWith_table_hints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3193);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::WITH) {
      setState(3192);
      match(TSqlParser::WITH);
    }
    setState(3195);
    match(TSqlParser::LR_BRACKET);
    setState(3196);
    antlrcpp::downCast<With_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
    antlrcpp::downCast<With_table_hintsContext *>(_localctx)->hint.push_back(antlrcpp::downCast<With_table_hintsContext *>(_localctx)->table_hintContext);
    setState(3203);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::HOLDLOCK

    || _la == TSqlParser::INDEX || ((((_la - 270) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 270)) & 54324670505156609) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 371)) & 36028798092705793) != 0)) {
      setState(3198);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3197);
        match(TSqlParser::COMMA);
      }
      setState(3200);
      antlrcpp::downCast<With_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
      antlrcpp::downCast<With_table_hintsContext *>(_localctx)->hint.push_back(antlrcpp::downCast<With_table_hintsContext *>(_localctx)->table_hintContext);
      setState(3205);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3206);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_with_table_hintsContext ------------------------------------------------------------------

TSqlParser::Insert_with_table_hintsContext::Insert_with_table_hintsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Table_hintContext *> TSqlParser::Insert_with_table_hintsContext::table_hint() {
  return getRuleContexts<TSqlParser::Table_hintContext>();
}

TSqlParser::Table_hintContext* TSqlParser::Insert_with_table_hintsContext::table_hint(size_t i) {
  return getRuleContext<TSqlParser::Table_hintContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_with_table_hintsContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Insert_with_table_hintsContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Insert_with_table_hintsContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_with_table_hints;
}

void TSqlParser::Insert_with_table_hintsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_with_table_hints(this);
}

void TSqlParser::Insert_with_table_hintsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_with_table_hints(this);
}

TSqlParser::Insert_with_table_hintsContext* TSqlParser::insert_with_table_hints() {
  Insert_with_table_hintsContext *_localctx = _tracker.createInstance<Insert_with_table_hintsContext>(_ctx, getState());
  enterRule(_localctx, 338, TSqlParser::RuleInsert_with_table_hints);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3208);
    match(TSqlParser::WITH);
    setState(3209);
    match(TSqlParser::LR_BRACKET);
    setState(3210);
    antlrcpp::downCast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
    antlrcpp::downCast<Insert_with_table_hintsContext *>(_localctx)->hint.push_back(antlrcpp::downCast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext);
    setState(3217);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::HOLDLOCK

    || _la == TSqlParser::INDEX || ((((_la - 270) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 270)) & 54324670505156609) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 371)) & 36028798092705793) != 0)) {
      setState(3212);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::COMMA) {
        setState(3211);
        match(TSqlParser::COMMA);
      }
      setState(3214);
      antlrcpp::downCast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext = table_hint();
      antlrcpp::downCast<Insert_with_table_hintsContext *>(_localctx)->hint.push_back(antlrcpp::downCast<Insert_with_table_hintsContext *>(_localctx)->table_hintContext);
      setState(3219);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3220);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_hintContext ------------------------------------------------------------------

TSqlParser::Table_hintContext::Table_hintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_hintContext::INDEX() {
  return getToken(TSqlParser::INDEX, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

std::vector<TSqlParser::Index_valueContext *> TSqlParser::Table_hintContext::index_value() {
  return getRuleContexts<TSqlParser::Index_valueContext>();
}

TSqlParser::Index_valueContext* TSqlParser::Table_hintContext::index_value(size_t i) {
  return getRuleContext<TSqlParser::Index_valueContext>(i);
}

tree::TerminalNode* TSqlParser::Table_hintContext::FORCESEEK() {
  return getToken(TSqlParser::FORCESEEK, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(TSqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Table_hintContext::HOLDLOCK() {
  return getToken(TSqlParser::HOLDLOCK, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::ID() {
  return getTokens(TSqlParser::ID);
}

tree::TerminalNode* TSqlParser::Table_hintContext::ID(size_t i) {
  return getToken(TSqlParser::ID, i);
}

tree::TerminalNode* TSqlParser::Table_hintContext::NOEXPAND() {
  return getToken(TSqlParser::NOEXPAND, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_hintContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_hintContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_hintContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_hintContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_hintContext::getRuleIndex() const {
  return TSqlParser::RuleTable_hint;
}

void TSqlParser::Table_hintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_hint(this);
}

void TSqlParser::Table_hintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_hint(this);
}

TSqlParser::Table_hintContext* TSqlParser::table_hint() {
  Table_hintContext *_localctx = _tracker.createInstance<Table_hintContext>(_ctx, getState());
  enterRule(_localctx, 340, TSqlParser::RuleTable_hint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::NOEXPAND) {
      setState(3222);
      match(TSqlParser::NOEXPAND);
    }
    setState(3274);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx)) {
    case 1: {
      setState(3225);
      match(TSqlParser::INDEX);
      setState(3245);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case TSqlParser::LR_BRACKET: {
          setState(3226);
          match(TSqlParser::LR_BRACKET);
          setState(3227);
          index_value();
          setState(3232);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == TSqlParser::COMMA) {
            setState(3228);
            match(TSqlParser::COMMA);
            setState(3229);
            index_value();
            setState(3234);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(3235);
          match(TSqlParser::RR_BRACKET);
          break;
        }

        case TSqlParser::CHAR:
        case TSqlParser::NCHAR:
        case TSqlParser::TEXT:
        case TSqlParser::NTEXT:
        case TSqlParser::PRECISION:
        case TSqlParser::ABSOLUTE:
        case TSqlParser::AT_KEYWORD:
        case TSqlParser::ACTION:
        case TSqlParser::AES_128:
        case TSqlParser::AES_192:
        case TSqlParser::AES_256:
        case TSqlParser::ALGORITHM:
        case TSqlParser::ANSI_NULLS:
        case TSqlParser::ANSI_PADDING:
        case TSqlParser::ANSI_WARNINGS:
        case TSqlParser::APPLY:
        case TSqlParser::ARITHABORT:
        case TSqlParser::AUTO:
        case TSqlParser::AVG:
        case TSqlParser::BIGINT:
        case TSqlParser::BINARY_KEYWORD:
        case TSqlParser::BINARY_BASE64:
        case TSqlParser::BINARY_CHECKSUM:
        case TSqlParser::CALLER:
        case TSqlParser::CAST:
        case TSqlParser::TRY_CAST:
        case TSqlParser::CATCH:
        case TSqlParser::CHECKSUM:
        case TSqlParser::CHECKSUM_AGG:
        case TSqlParser::COMMITTED:
        case TSqlParser::CONCAT:
        case TSqlParser::CONCAT_NULL_YIELDS_NULL:
        case TSqlParser::COUNT:
        case TSqlParser::COUNT_BIG:
        case TSqlParser::CUME_DIST:
        case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
        case TSqlParser::CURSOR_DEFAULT:
        case TSqlParser::DATA:
        case TSqlParser::DATEADD:
        case TSqlParser::DATEDIFF:
        case TSqlParser::DATENAME:
        case TSqlParser::DATEPART:
        case TSqlParser::DAYS:
        case TSqlParser::DEFAULT_DOUBLE_QUOTE:
        case TSqlParser::DELAY:
        case TSqlParser::DELAYED_DURABILITY:
        case TSqlParser::DELETED:
        case TSqlParser::DENSE_RANK:
        case TSqlParser::DES:
        case TSqlParser::DESCRIPTION:
        case TSqlParser::DESX:
        case TSqlParser::DISABLE:
        case TSqlParser::DYNAMIC:
        case TSqlParser::ELEMENTS:
        case TSqlParser::EMPTY:
        case TSqlParser::ENCRYPTION:
        case TSqlParser::EXCLUSIVE:
        case TSqlParser::FAST:
        case TSqlParser::FAST_FORWARD:
        case TSqlParser::FIRST:
        case TSqlParser::FIRST_VALUE:
        case TSqlParser::FOLLOWING:
        case TSqlParser::FORCE:
        case TSqlParser::FORCED:
        case TSqlParser::FORWARD_ONLY:
        case TSqlParser::GETDATE:
        case TSqlParser::GETUTCDATE:
        case TSqlParser::GLOBAL:
        case TSqlParser::GO_BATCH:
        case TSqlParser::GO:
        case TSqlParser::GROUPING:
        case TSqlParser::GROUPING_ID:
        case TSqlParser::HASH:
        case TSqlParser::HIGH:
        case TSqlParser::HOURS:
        case TSqlParser::IDENTITY_VALUE:
        case TSqlParser::INCLUDE_NULL_VALUES:
        case TSqlParser::INPUT:
        case TSqlParser::INSENSITIVE:
        case TSqlParser::INSERTED:
        case TSqlParser::INT:
        case TSqlParser::ISOLATION:
        case TSqlParser::KEEP:
        case TSqlParser::KEEPFIXED:
        case TSqlParser::KEYSET:
        case TSqlParser::LAG:
        case TSqlParser::LAST:
        case TSqlParser::LAST_VALUE:
        case TSqlParser::LEAD:
        case TSqlParser::LEVEL:
        case TSqlParser::LOCAL:
        case TSqlParser::LOCATION:
        case TSqlParser::LOCK:
        case TSqlParser::LOCK_ESCALATION:
        case TSqlParser::LOOP:
        case TSqlParser::LOW:
        case TSqlParser::MANUAL:
        case TSqlParser::MARK:
        case TSqlParser::MAX:
        case TSqlParser::MAXDOP:
        case TSqlParser::MAXRECURSION:
        case TSqlParser::MIN:
        case TSqlParser::MINUTES:
        case TSqlParser::MODE:
        case TSqlParser::NEXT:
        case TSqlParser::NO:
        case TSqlParser::NOCOUNT:
        case TSqlParser::NODES:
        case TSqlParser::NOEXPAND:
        case TSqlParser::NOWAIT:
        case TSqlParser::NTILE:
        case TSqlParser::NUMANODE:
        case TSqlParser::NUMERIC_ROUNDABORT:
        case TSqlParser::OBJECT:
        case TSqlParser::OFFSET:
        case TSqlParser::ONLINE:
        case TSqlParser::ONLY:
        case TSqlParser::OPTIMISTIC:
        case TSqlParser::OPTIMIZE:
        case TSqlParser::OUT:
        case TSqlParser::OUTPUT:
        case TSqlParser::OWNER:
        case TSqlParser::PARAMETERIZATION:
        case TSqlParser::PARTITION:
        case TSqlParser::PARTITIONS:
        case TSqlParser::PERCENT_RANK:
        case TSqlParser::PERCENTILE_CONT:
        case TSqlParser::PERCENTILE_DISC:
        case TSqlParser::PRECEDING:
        case TSqlParser::PRIOR:
        case TSqlParser::QUERY:
        case TSqlParser::QUOTED_IDENTIFIER:
        case TSqlParser::RANGE:
        case TSqlParser::RANK:
        case TSqlParser::RC2:
        case TSqlParser::RC4:
        case TSqlParser::RC4_128:
        case TSqlParser::READ_ONLY:
        case TSqlParser::READONLY:
        case TSqlParser::REBUILD:
        case TSqlParser::RECOMPILE:
        case TSqlParser::RELATIVE:
        case TSqlParser::REMOTE:
        case TSqlParser::REPEATABLE:
        case TSqlParser::ROBUST:
        case TSqlParser::ROW:
        case TSqlParser::ROW_NUMBER:
        case TSqlParser::ROWGUID:
        case TSqlParser::ROWS:
        case TSqlParser::SCHEMABINDING:
        case TSqlParser::SCROLL:
        case TSqlParser::SCROLL_LOCKS:
        case TSqlParser::SECONDS:
        case TSqlParser::SELF:
        case TSqlParser::SEMI_SENSITIVE:
        case TSqlParser::SEQUENCE:
        case TSqlParser::SERIALIZABLE:
        case TSqlParser::SETERROR:
        case TSqlParser::SHARE:
        case TSqlParser::SIMPLE:
        case TSqlParser::SIZE:
        case TSqlParser::SMALLINT:
        case TSqlParser::SNAPSHOT:
        case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
        case TSqlParser::STATIC:
        case TSqlParser::STATUSONLY:
        case TSqlParser::STDEV:
        case TSqlParser::STDEVP:
        case TSqlParser::STRING_AGG:
        case TSqlParser::STUFF:
        case TSqlParser::SUBSCRIPTION:
        case TSqlParser::SUM:
        case TSqlParser::TEXTIMAGE_ON:
        case TSqlParser::THROW:
        case TSqlParser::TIES:
        case TSqlParser::TIME:
        case TSqlParser::TIMEOUT:
        case TSqlParser::TINYINT:
        case TSqlParser::TRIPLE_DES:
        case TSqlParser::TRIPLE_DES_3KEY:
        case TSqlParser::TRY:
        case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
        case TSqlParser::TYPE:
        case TSqlParser::TYPE_WARNING:
        case TSqlParser::UNBOUNDED:
        case TSqlParser::UNCOMMITTED:
        case TSqlParser::UNKNOWN:
        case TSqlParser::UOW:
        case TSqlParser::USING:
        case TSqlParser::VAR:
        case TSqlParser::VARBINARY_KEYWORD:
        case TSqlParser::VARP:
        case TSqlParser::WAIT:
        case TSqlParser::WORK:
        case TSqlParser::ZONE:
        case TSqlParser::BLOCKING_HIERARCHY:
        case TSqlParser::CACHE:
        case TSqlParser::CALLED:
        case TSqlParser::CHANGETABLE:
        case TSqlParser::CHANGES:
        case TSqlParser::CYCLE:
        case TSqlParser::DATA_COMPRESSION:
        case TSqlParser::ERROR:
        case TSqlParser::FORCESEEK:
        case TSqlParser::IIF:
        case TSqlParser::INCREMENT:
        case TSqlParser::ISNULL:
        case TSqlParser::LOG:
        case TSqlParser::MATCHED:
        case TSqlParser::MAXVALUE:
        case TSqlParser::MINVALUE:
        case TSqlParser::NOTIFICATION:
        case TSqlParser::PERSISTED:
        case TSqlParser::PREDICATE:
        case TSqlParser::RESTART:
        case TSqlParser::RETURNS:
        case TSqlParser::SOURCE:
        case TSqlParser::STATE:
        case TSqlParser::START:
        case TSqlParser::TARGET:
        case TSqlParser::VARCHAR:
        case TSqlParser::NVARCHAR:
        case TSqlParser::DOUBLE_QUOTE_ID:
        case TSqlParser::SQUARE_BRACKET_ID:
        case TSqlParser::DECIMAL:
        case TSqlParser::ID: {
          setState(3237);
          index_value();
          setState(3242);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3238);
              match(TSqlParser::COMMA);
              setState(3239);
              index_value(); 
            }
            setState(3244);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(3247);
      match(TSqlParser::INDEX);
      setState(3248);
      match(TSqlParser::EQUAL);
      setState(3249);
      index_value();
      break;
    }

    case 3: {
      setState(3250);
      match(TSqlParser::FORCESEEK);
      setState(3265);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::LR_BRACKET) {
        setState(3251);
        match(TSqlParser::LR_BRACKET);
        setState(3252);
        index_value();
        setState(3253);
        match(TSqlParser::LR_BRACKET);
        setState(3254);
        match(TSqlParser::ID);
        setState(3259);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == TSqlParser::COMMA) {
          setState(3255);
          match(TSqlParser::COMMA);
          setState(3256);
          match(TSqlParser::ID);
          setState(3261);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3262);
        match(TSqlParser::RR_BRACKET);
        setState(3263);
        match(TSqlParser::RR_BRACKET);
      }
      break;
    }

    case 4: {
      setState(3267);
      match(TSqlParser::SERIALIZABLE);
      break;
    }

    case 5: {
      setState(3268);
      match(TSqlParser::SNAPSHOT);
      break;
    }

    case 6: {
      setState(3269);
      match(TSqlParser::SPATIAL_WINDOW_MAX_CELLS);
      setState(3270);
      match(TSqlParser::EQUAL);
      setState(3271);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 7: {
      setState(3272);
      match(TSqlParser::HOLDLOCK);
      break;
    }

    case 8: {
      setState(3273);
      match(TSqlParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_valueContext ------------------------------------------------------------------

TSqlParser::Index_valueContext::Index_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Index_valueContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Index_valueContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Index_valueContext::getRuleIndex() const {
  return TSqlParser::RuleIndex_value;
}

void TSqlParser::Index_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_value(this);
}

void TSqlParser::Index_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_value(this);
}

TSqlParser::Index_valueContext* TSqlParser::index_value() {
  Index_valueContext *_localctx = _tracker.createInstance<Index_valueContext>(_ctx, getState());
  enterRule(_localctx, 342, TSqlParser::RuleIndex_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3278);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3276);
        id_();
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3277);
        match(TSqlParser::DECIMAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_alias_listContext ------------------------------------------------------------------

TSqlParser::Column_alias_listContext::Column_alias_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

std::vector<TSqlParser::Column_aliasContext *> TSqlParser::Column_alias_listContext::column_alias() {
  return getRuleContexts<TSqlParser::Column_aliasContext>();
}

TSqlParser::Column_aliasContext* TSqlParser::Column_alias_listContext::column_alias(size_t i) {
  return getRuleContext<TSqlParser::Column_aliasContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_alias_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_alias_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_alias_listContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_alias_list;
}

void TSqlParser::Column_alias_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias_list(this);
}

void TSqlParser::Column_alias_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias_list(this);
}

TSqlParser::Column_alias_listContext* TSqlParser::column_alias_list() {
  Column_alias_listContext *_localctx = _tracker.createInstance<Column_alias_listContext>(_ctx, getState());
  enterRule(_localctx, 344, TSqlParser::RuleColumn_alias_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3280);
    match(TSqlParser::LR_BRACKET);
    setState(3281);
    antlrcpp::downCast<Column_alias_listContext *>(_localctx)->column_aliasContext = column_alias();
    antlrcpp::downCast<Column_alias_listContext *>(_localctx)->alias.push_back(antlrcpp::downCast<Column_alias_listContext *>(_localctx)->column_aliasContext);
    setState(3286);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3282);
      match(TSqlParser::COMMA);
      setState(3283);
      antlrcpp::downCast<Column_alias_listContext *>(_localctx)->column_aliasContext = column_alias();
      antlrcpp::downCast<Column_alias_listContext *>(_localctx)->alias.push_back(antlrcpp::downCast<Column_alias_listContext *>(_localctx)->column_aliasContext);
      setState(3288);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3289);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_aliasContext ------------------------------------------------------------------

TSqlParser::Column_aliasContext::Column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Column_aliasContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Column_aliasContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Column_aliasContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_alias;
}

void TSqlParser::Column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias(this);
}

void TSqlParser::Column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias(this);
}

TSqlParser::Column_aliasContext* TSqlParser::column_alias() {
  Column_aliasContext *_localctx = _tracker.createInstance<Column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 346, TSqlParser::RuleColumn_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3293);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3291);
        id_();
        break;
      }

      case TSqlParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(3292);
        match(TSqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_value_constructorContext ------------------------------------------------------------------

TSqlParser::Table_value_constructorContext::Table_value_constructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

std::vector<TSqlParser::Expression_listContext *> TSqlParser::Table_value_constructorContext::expression_list() {
  return getRuleContexts<TSqlParser::Expression_listContext>();
}

TSqlParser::Expression_listContext* TSqlParser::Table_value_constructorContext::expression_list(size_t i) {
  return getRuleContext<TSqlParser::Expression_listContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_value_constructorContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Table_value_constructorContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Table_value_constructorContext::getRuleIndex() const {
  return TSqlParser::RuleTable_value_constructor;
}

void TSqlParser::Table_value_constructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_value_constructor(this);
}

void TSqlParser::Table_value_constructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_value_constructor(this);
}

TSqlParser::Table_value_constructorContext* TSqlParser::table_value_constructor() {
  Table_value_constructorContext *_localctx = _tracker.createInstance<Table_value_constructorContext>(_ctx, getState());
  enterRule(_localctx, 348, TSqlParser::RuleTable_value_constructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3295);
    match(TSqlParser::VALUES);
    setState(3296);
    match(TSqlParser::LR_BRACKET);
    setState(3297);
    antlrcpp::downCast<Table_value_constructorContext *>(_localctx)->expression_listContext = expression_list();
    antlrcpp::downCast<Table_value_constructorContext *>(_localctx)->exps.push_back(antlrcpp::downCast<Table_value_constructorContext *>(_localctx)->expression_listContext);
    setState(3298);
    match(TSqlParser::RR_BRACKET);
    setState(3306);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3299);
      match(TSqlParser::COMMA);
      setState(3300);
      match(TSqlParser::LR_BRACKET);
      setState(3301);
      antlrcpp::downCast<Table_value_constructorContext *>(_localctx)->expression_listContext = expression_list();
      antlrcpp::downCast<Table_value_constructorContext *>(_localctx)->exps.push_back(antlrcpp::downCast<Table_value_constructorContext *>(_localctx)->expression_listContext);
      setState(3302);
      match(TSqlParser::RR_BRACKET);
      setState(3308);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_listContext ------------------------------------------------------------------

TSqlParser::Expression_listContext::Expression_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Expression_listContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Expression_listContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Expression_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Expression_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Expression_listContext::getRuleIndex() const {
  return TSqlParser::RuleExpression_list;
}

void TSqlParser::Expression_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_list(this);
}

void TSqlParser::Expression_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_list(this);
}

TSqlParser::Expression_listContext* TSqlParser::expression_list() {
  Expression_listContext *_localctx = _tracker.createInstance<Expression_listContext>(_ctx, getState());
  enterRule(_localctx, 350, TSqlParser::RuleExpression_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3309);
    antlrcpp::downCast<Expression_listContext *>(_localctx)->expressionContext = expression(0);
    antlrcpp::downCast<Expression_listContext *>(_localctx)->exp.push_back(antlrcpp::downCast<Expression_listContext *>(_localctx)->expressionContext);
    setState(3314);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3310);
      match(TSqlParser::COMMA);
      setState(3311);
      antlrcpp::downCast<Expression_listContext *>(_localctx)->expressionContext = expression(0);
      antlrcpp::downCast<Expression_listContext *>(_localctx)->exp.push_back(antlrcpp::downCast<Expression_listContext *>(_localctx)->expressionContext);
      setState(3316);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ranking_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Ranking_windowed_functionContext::Ranking_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

TSqlParser::Over_clauseContext* TSqlParser::Ranking_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::RANK() {
  return getToken(TSqlParser::RANK, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::DENSE_RANK() {
  return getToken(TSqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::ROW_NUMBER() {
  return getToken(TSqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* TSqlParser::Ranking_windowed_functionContext::NTILE() {
  return getToken(TSqlParser::NTILE, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Ranking_windowed_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}


size_t TSqlParser::Ranking_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleRanking_windowed_function;
}

void TSqlParser::Ranking_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRanking_windowed_function(this);
}

void TSqlParser::Ranking_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRanking_windowed_function(this);
}

TSqlParser::Ranking_windowed_functionContext* TSqlParser::ranking_windowed_function() {
  Ranking_windowed_functionContext *_localctx = _tracker.createInstance<Ranking_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 352, TSqlParser::RuleRanking_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3327);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::DENSE_RANK:
      case TSqlParser::RANK:
      case TSqlParser::ROW_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(3317);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::DENSE_RANK || _la == TSqlParser::RANK

        || _la == TSqlParser::ROW_NUMBER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3318);
        match(TSqlParser::LR_BRACKET);
        setState(3319);
        match(TSqlParser::RR_BRACKET);
        setState(3320);
        over_clause();
        break;
      }

      case TSqlParser::NTILE: {
        enterOuterAlt(_localctx, 2);
        setState(3321);
        match(TSqlParser::NTILE);
        setState(3322);
        match(TSqlParser::LR_BRACKET);
        setState(3323);
        expression(0);
        setState(3324);
        match(TSqlParser::RR_BRACKET);
        setState(3325);
        over_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Aggregate_windowed_functionContext::Aggregate_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

TSqlParser::All_distinct_expressionContext* TSqlParser::Aggregate_windowed_functionContext::all_distinct_expression() {
  return getRuleContext<TSqlParser::All_distinct_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::AVG() {
  return getToken(TSqlParser::AVG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::MIN() {
  return getToken(TSqlParser::MIN, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::SUM() {
  return getToken(TSqlParser::SUM, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STDEV() {
  return getToken(TSqlParser::STDEV, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STDEVP() {
  return getToken(TSqlParser::STDEVP, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::VAR() {
  return getToken(TSqlParser::VAR, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::VARP() {
  return getToken(TSqlParser::VARP, 0);
}

TSqlParser::Over_clauseContext* TSqlParser::Aggregate_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::COUNT() {
  return getToken(TSqlParser::COUNT, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::COUNT_BIG() {
  return getToken(TSqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::STAR() {
  return getToken(TSqlParser::STAR, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::CHECKSUM_AGG() {
  return getToken(TSqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::GROUPING() {
  return getToken(TSqlParser::GROUPING, 0);
}

TSqlParser::ExpressionContext* TSqlParser::Aggregate_windowed_functionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::Aggregate_windowed_functionContext::GROUPING_ID() {
  return getToken(TSqlParser::GROUPING_ID, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Aggregate_windowed_functionContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}


size_t TSqlParser::Aggregate_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleAggregate_windowed_function;
}

void TSqlParser::Aggregate_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_windowed_function(this);
}

void TSqlParser::Aggregate_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_windowed_function(this);
}

TSqlParser::Aggregate_windowed_functionContext* TSqlParser::aggregate_windowed_function() {
  Aggregate_windowed_functionContext *_localctx = _tracker.createInstance<Aggregate_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 354, TSqlParser::RuleAggregate_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3361);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::AVG:
      case TSqlParser::MAX:
      case TSqlParser::MIN:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::SUM:
      case TSqlParser::VAR:
      case TSqlParser::VARP: {
        enterOuterAlt(_localctx, 1);
        setState(3329);
        antlrcpp::downCast<Aggregate_windowed_functionContext *>(_localctx)->agg_func = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::AVG || _la == TSqlParser::MAX

        || _la == TSqlParser::MIN || ((((_la - 328) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 328)) & 41943075) != 0))) {
          antlrcpp::downCast<Aggregate_windowed_functionContext *>(_localctx)->agg_func = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3330);
        match(TSqlParser::LR_BRACKET);
        setState(3331);
        all_distinct_expression();
        setState(3332);
        match(TSqlParser::RR_BRACKET);
        setState(3334);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx)) {
        case 1: {
          setState(3333);
          over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG: {
        enterOuterAlt(_localctx, 2);
        setState(3336);
        antlrcpp::downCast<Aggregate_windowed_functionContext *>(_localctx)->cnt = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::COUNT

        || _la == TSqlParser::COUNT_BIG)) {
          antlrcpp::downCast<Aggregate_windowed_functionContext *>(_localctx)->cnt = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3337);
        match(TSqlParser::LR_BRACKET);
        setState(3340);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case TSqlParser::STAR: {
            setState(3338);
            match(TSqlParser::STAR);
            break;
          }

          case TSqlParser::ABS:
          case TSqlParser::ASCII:
          case TSqlParser::CEILING:
          case TSqlParser::CHAR:
          case TSqlParser::CHARINDEX:
          case TSqlParser::DATALENGTH:
          case TSqlParser::DAY:
          case TSqlParser::FLOOR:
          case TSqlParser::ISDATE:
          case TSqlParser::ISNUMERIC:
          case TSqlParser::LEN:
          case TSqlParser::LOWER:
          case TSqlParser::LTRIM:
          case TSqlParser::MONTH:
          case TSqlParser::NCHAR:
          case TSqlParser::PATINDEX:
          case TSqlParser::RAND:
          case TSqlParser::REPLACE:
          case TSqlParser::ROUND:
          case TSqlParser::RTRIM:
          case TSqlParser::SIGN:
          case TSqlParser::STR:
          case TSqlParser::SUBSTRING:
          case TSqlParser::UPPER:
          case TSqlParser::USER_NAME:
          case TSqlParser::YEAR:
          case TSqlParser::TEXT:
          case TSqlParser::NTEXT:
          case TSqlParser::ALL:
          case TSqlParser::CASE:
          case TSqlParser::COALESCE:
          case TSqlParser::CONVERT:
          case TSqlParser::CURRENT_TIMESTAMP:
          case TSqlParser::CURRENT_USER:
          case TSqlParser::DEFAULT:
          case TSqlParser::DISTINCT:
          case TSqlParser::IDENTITY:
          case TSqlParser::LEFT:
          case TSqlParser::NULL_:
          case TSqlParser::NULLIF:
          case TSqlParser::OVER:
          case TSqlParser::PRECISION:
          case TSqlParser::RIGHT:
          case TSqlParser::SESSION_USER:
          case TSqlParser::SYSTEM_USER:
          case TSqlParser::USER:
          case TSqlParser::DOLLAR_PARTITION:
          case TSqlParser::ABSOLUTE:
          case TSqlParser::AT_KEYWORD:
          case TSqlParser::ACTION:
          case TSqlParser::AES_128:
          case TSqlParser::AES_192:
          case TSqlParser::AES_256:
          case TSqlParser::ALGORITHM:
          case TSqlParser::ANSI_NULLS:
          case TSqlParser::ANSI_PADDING:
          case TSqlParser::ANSI_WARNINGS:
          case TSqlParser::APPLY:
          case TSqlParser::ARITHABORT:
          case TSqlParser::AUTO:
          case TSqlParser::AVG:
          case TSqlParser::BIGINT:
          case TSqlParser::BINARY_KEYWORD:
          case TSqlParser::BINARY_BASE64:
          case TSqlParser::BINARY_CHECKSUM:
          case TSqlParser::CALLER:
          case TSqlParser::CAST:
          case TSqlParser::TRY_CAST:
          case TSqlParser::CATCH:
          case TSqlParser::CHECKSUM:
          case TSqlParser::CHECKSUM_AGG:
          case TSqlParser::COMMITTED:
          case TSqlParser::CONCAT:
          case TSqlParser::CONCAT_NULL_YIELDS_NULL:
          case TSqlParser::COUNT:
          case TSqlParser::COUNT_BIG:
          case TSqlParser::CUME_DIST:
          case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
          case TSqlParser::CURSOR_DEFAULT:
          case TSqlParser::DATA:
          case TSqlParser::DATEADD:
          case TSqlParser::DATEDIFF:
          case TSqlParser::DATENAME:
          case TSqlParser::DATEPART:
          case TSqlParser::DAYS:
          case TSqlParser::DEFAULT_DOUBLE_QUOTE:
          case TSqlParser::DELAY:
          case TSqlParser::DELAYED_DURABILITY:
          case TSqlParser::DELETED:
          case TSqlParser::DENSE_RANK:
          case TSqlParser::DES:
          case TSqlParser::DESCRIPTION:
          case TSqlParser::DESX:
          case TSqlParser::DISABLE:
          case TSqlParser::DYNAMIC:
          case TSqlParser::ELEMENTS:
          case TSqlParser::EMPTY:
          case TSqlParser::ENCRYPTION:
          case TSqlParser::EXCLUSIVE:
          case TSqlParser::FAST:
          case TSqlParser::FAST_FORWARD:
          case TSqlParser::FIRST:
          case TSqlParser::FIRST_VALUE:
          case TSqlParser::FOLLOWING:
          case TSqlParser::FORCE:
          case TSqlParser::FORCED:
          case TSqlParser::FORWARD_ONLY:
          case TSqlParser::GETDATE:
          case TSqlParser::GETUTCDATE:
          case TSqlParser::GLOBAL:
          case TSqlParser::GO_BATCH:
          case TSqlParser::GO:
          case TSqlParser::GROUPING:
          case TSqlParser::GROUPING_ID:
          case TSqlParser::HASH:
          case TSqlParser::HIGH:
          case TSqlParser::HOURS:
          case TSqlParser::IDENTITY_VALUE:
          case TSqlParser::INCLUDE_NULL_VALUES:
          case TSqlParser::INPUT:
          case TSqlParser::INSENSITIVE:
          case TSqlParser::INSERTED:
          case TSqlParser::INT:
          case TSqlParser::ISOLATION:
          case TSqlParser::KEEP:
          case TSqlParser::KEEPFIXED:
          case TSqlParser::KEYSET:
          case TSqlParser::LAG:
          case TSqlParser::LAST:
          case TSqlParser::LAST_VALUE:
          case TSqlParser::LEAD:
          case TSqlParser::LEVEL:
          case TSqlParser::LOCAL:
          case TSqlParser::LOCATION:
          case TSqlParser::LOCK:
          case TSqlParser::LOCK_ESCALATION:
          case TSqlParser::LOOP:
          case TSqlParser::LOW:
          case TSqlParser::MANUAL:
          case TSqlParser::MARK:
          case TSqlParser::MAX:
          case TSqlParser::MAXDOP:
          case TSqlParser::MAXRECURSION:
          case TSqlParser::MIN:
          case TSqlParser::MIN_ACTIVE_ROWVERSION:
          case TSqlParser::MINUTES:
          case TSqlParser::MODE:
          case TSqlParser::NEXT:
          case TSqlParser::NO:
          case TSqlParser::NOCOUNT:
          case TSqlParser::NODES:
          case TSqlParser::NOEXPAND:
          case TSqlParser::NOWAIT:
          case TSqlParser::NTILE:
          case TSqlParser::NUMANODE:
          case TSqlParser::NUMERIC_ROUNDABORT:
          case TSqlParser::OBJECT:
          case TSqlParser::OFFSET:
          case TSqlParser::ONLINE:
          case TSqlParser::ONLY:
          case TSqlParser::OPTIMISTIC:
          case TSqlParser::OPTIMIZE:
          case TSqlParser::OUT:
          case TSqlParser::OUTPUT:
          case TSqlParser::OWNER:
          case TSqlParser::PARAMETERIZATION:
          case TSqlParser::PARTITION:
          case TSqlParser::PARTITIONS:
          case TSqlParser::PERCENT_RANK:
          case TSqlParser::PERCENTILE_CONT:
          case TSqlParser::PERCENTILE_DISC:
          case TSqlParser::PRECEDING:
          case TSqlParser::PRIOR:
          case TSqlParser::QUERY:
          case TSqlParser::QUOTED_IDENTIFIER:
          case TSqlParser::RANGE:
          case TSqlParser::RANK:
          case TSqlParser::RC2:
          case TSqlParser::RC4:
          case TSqlParser::RC4_128:
          case TSqlParser::READ_ONLY:
          case TSqlParser::READONLY:
          case TSqlParser::REBUILD:
          case TSqlParser::RECOMPILE:
          case TSqlParser::RELATIVE:
          case TSqlParser::REMOTE:
          case TSqlParser::REPEATABLE:
          case TSqlParser::ROBUST:
          case TSqlParser::ROW:
          case TSqlParser::ROW_NUMBER:
          case TSqlParser::ROWGUID:
          case TSqlParser::ROWS:
          case TSqlParser::SCHEMABINDING:
          case TSqlParser::SCROLL:
          case TSqlParser::SCROLL_LOCKS:
          case TSqlParser::SECONDS:
          case TSqlParser::SELF:
          case TSqlParser::SEMI_SENSITIVE:
          case TSqlParser::SEQUENCE:
          case TSqlParser::SERIALIZABLE:
          case TSqlParser::SETERROR:
          case TSqlParser::SHARE:
          case TSqlParser::SIMPLE:
          case TSqlParser::SIZE:
          case TSqlParser::SMALLINT:
          case TSqlParser::SNAPSHOT:
          case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
          case TSqlParser::STATIC:
          case TSqlParser::STATUSONLY:
          case TSqlParser::STDEV:
          case TSqlParser::STDEVP:
          case TSqlParser::STRING_AGG:
          case TSqlParser::STUFF:
          case TSqlParser::SUBSCRIPTION:
          case TSqlParser::SUM:
          case TSqlParser::TEXTIMAGE_ON:
          case TSqlParser::THROW:
          case TSqlParser::TIES:
          case TSqlParser::TIME:
          case TSqlParser::TIMEOUT:
          case TSqlParser::TINYINT:
          case TSqlParser::TRIPLE_DES:
          case TSqlParser::TRIPLE_DES_3KEY:
          case TSqlParser::TRY:
          case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
          case TSqlParser::TYPE:
          case TSqlParser::TYPE_WARNING:
          case TSqlParser::UNBOUNDED:
          case TSqlParser::UNCOMMITTED:
          case TSqlParser::UNKNOWN:
          case TSqlParser::UOW:
          case TSqlParser::USING:
          case TSqlParser::VAR:
          case TSqlParser::VARBINARY_KEYWORD:
          case TSqlParser::VARP:
          case TSqlParser::WAIT:
          case TSqlParser::WORK:
          case TSqlParser::ZONE:
          case TSqlParser::DOLLAR_ACTION:
          case TSqlParser::BLOCKING_HIERARCHY:
          case TSqlParser::CACHE:
          case TSqlParser::CALLED:
          case TSqlParser::CHANGETABLE:
          case TSqlParser::CHANGES:
          case TSqlParser::CYCLE:
          case TSqlParser::DATA_COMPRESSION:
          case TSqlParser::ERROR:
          case TSqlParser::FORCESEEK:
          case TSqlParser::IIF:
          case TSqlParser::INCREMENT:
          case TSqlParser::ISNULL:
          case TSqlParser::LOG:
          case TSqlParser::MATCHED:
          case TSqlParser::MAXVALUE:
          case TSqlParser::MINVALUE:
          case TSqlParser::NOTIFICATION:
          case TSqlParser::PERSISTED:
          case TSqlParser::PREDICATE:
          case TSqlParser::RESTART:
          case TSqlParser::RETURNS:
          case TSqlParser::SOURCE:
          case TSqlParser::STATE:
          case TSqlParser::START:
          case TSqlParser::TARGET:
          case TSqlParser::VARCHAR:
          case TSqlParser::NVARCHAR:
          case TSqlParser::SPACE:
          case TSqlParser::DOUBLE_QUOTE_ID:
          case TSqlParser::SQUARE_BRACKET_ID:
          case TSqlParser::LOCAL_ID:
          case TSqlParser::DECIMAL:
          case TSqlParser::ID:
          case TSqlParser::STRING:
          case TSqlParser::BINARY:
          case TSqlParser::FLOAT:
          case TSqlParser::REAL:
          case TSqlParser::DOT:
          case TSqlParser::DOLLAR:
          case TSqlParser::LR_BRACKET:
          case TSqlParser::PLUS:
          case TSqlParser::MINUS:
          case TSqlParser::BIT_NOT: {
            setState(3339);
            all_distinct_expression();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(3342);
        match(TSqlParser::RR_BRACKET);
        setState(3344);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 482, _ctx)) {
        case 1: {
          setState(3343);
          over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case TSqlParser::CHECKSUM_AGG: {
        enterOuterAlt(_localctx, 3);
        setState(3346);
        match(TSqlParser::CHECKSUM_AGG);
        setState(3347);
        match(TSqlParser::LR_BRACKET);
        setState(3348);
        all_distinct_expression();
        setState(3349);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GROUPING: {
        enterOuterAlt(_localctx, 4);
        setState(3351);
        match(TSqlParser::GROUPING);
        setState(3352);
        match(TSqlParser::LR_BRACKET);
        setState(3353);
        expression(0);
        setState(3354);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::GROUPING_ID: {
        enterOuterAlt(_localctx, 5);
        setState(3356);
        match(TSqlParser::GROUPING_ID);
        setState(3357);
        match(TSqlParser::LR_BRACKET);
        setState(3358);
        expression_list();
        setState(3359);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analytic_windowed_functionContext ------------------------------------------------------------------

TSqlParser::Analytic_windowed_functionContext::Analytic_windowed_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::LR_BRACKET() {
  return getTokens(TSqlParser::LR_BRACKET);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LR_BRACKET(size_t i) {
  return getToken(TSqlParser::LR_BRACKET, i);
}

std::vector<TSqlParser::ExpressionContext *> TSqlParser::Analytic_windowed_functionContext::expression() {
  return getRuleContexts<TSqlParser::ExpressionContext>();
}

TSqlParser::ExpressionContext* TSqlParser::Analytic_windowed_functionContext::expression(size_t i) {
  return getRuleContext<TSqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::RR_BRACKET() {
  return getTokens(TSqlParser::RR_BRACKET);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::RR_BRACKET(size_t i) {
  return getToken(TSqlParser::RR_BRACKET, i);
}

TSqlParser::Over_clauseContext* TSqlParser::Analytic_windowed_functionContext::over_clause() {
  return getRuleContext<TSqlParser::Over_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::FIRST_VALUE() {
  return getToken(TSqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LAST_VALUE() {
  return getToken(TSqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LAG() {
  return getToken(TSqlParser::LAG, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::LEAD() {
  return getToken(TSqlParser::LEAD, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::OVER() {
  return getToken(TSqlParser::OVER, 0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Analytic_windowed_functionContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::CUME_DIST() {
  return getToken(TSqlParser::CUME_DIST, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PERCENT_RANK() {
  return getToken(TSqlParser::PERCENT_RANK, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> TSqlParser::Analytic_windowed_functionContext::BY() {
  return getTokens(TSqlParser::BY);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::BY(size_t i) {
  return getToken(TSqlParser::BY, i);
}

TSqlParser::Expression_listContext* TSqlParser::Analytic_windowed_functionContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::WITHIN() {
  return getToken(TSqlParser::WITHIN, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::GROUP() {
  return getToken(TSqlParser::GROUP, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::ORDER() {
  return getToken(TSqlParser::ORDER, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PERCENTILE_CONT() {
  return getToken(TSqlParser::PERCENTILE_CONT, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::PERCENTILE_DISC() {
  return getToken(TSqlParser::PERCENTILE_DISC, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::ASC() {
  return getToken(TSqlParser::ASC, 0);
}

tree::TerminalNode* TSqlParser::Analytic_windowed_functionContext::DESC() {
  return getToken(TSqlParser::DESC, 0);
}


size_t TSqlParser::Analytic_windowed_functionContext::getRuleIndex() const {
  return TSqlParser::RuleAnalytic_windowed_function;
}

void TSqlParser::Analytic_windowed_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalytic_windowed_function(this);
}

void TSqlParser::Analytic_windowed_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalytic_windowed_function(this);
}

TSqlParser::Analytic_windowed_functionContext* TSqlParser::analytic_windowed_function() {
  Analytic_windowed_functionContext *_localctx = _tracker.createInstance<Analytic_windowed_functionContext>(_ctx, getState());
  enterRule(_localctx, 356, TSqlParser::RuleAnalytic_windowed_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3419);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::LAST_VALUE: {
        enterOuterAlt(_localctx, 1);
        setState(3363);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::FIRST_VALUE

        || _la == TSqlParser::LAST_VALUE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3364);
        match(TSqlParser::LR_BRACKET);
        setState(3365);
        expression(0);
        setState(3366);
        match(TSqlParser::RR_BRACKET);
        setState(3367);
        over_clause();
        break;
      }

      case TSqlParser::LAG:
      case TSqlParser::LEAD: {
        enterOuterAlt(_localctx, 2);
        setState(3369);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::LAG

        || _la == TSqlParser::LEAD)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3370);
        match(TSqlParser::LR_BRACKET);
        setState(3371);
        expression(0);
        setState(3378);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COMMA) {
          setState(3372);
          match(TSqlParser::COMMA);
          setState(3373);
          expression(0);
          setState(3376);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == TSqlParser::COMMA) {
            setState(3374);
            match(TSqlParser::COMMA);
            setState(3375);
            expression(0);
          }
        }
        setState(3380);
        match(TSqlParser::RR_BRACKET);
        setState(3381);
        over_clause();
        break;
      }

      case TSqlParser::CUME_DIST:
      case TSqlParser::PERCENT_RANK: {
        enterOuterAlt(_localctx, 3);
        setState(3383);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::CUME_DIST || _la == TSqlParser::PERCENT_RANK)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3384);
        match(TSqlParser::LR_BRACKET);
        setState(3385);
        match(TSqlParser::RR_BRACKET);
        setState(3386);
        match(TSqlParser::OVER);
        setState(3387);
        match(TSqlParser::LR_BRACKET);
        setState(3391);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::PARTITION) {
          setState(3388);
          match(TSqlParser::PARTITION);
          setState(3389);
          match(TSqlParser::BY);
          setState(3390);
          expression_list();
        }
        setState(3393);
        order_by_clause();
        setState(3394);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC: {
        enterOuterAlt(_localctx, 4);
        setState(3396);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::PERCENTILE_CONT

        || _la == TSqlParser::PERCENTILE_DISC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3397);
        match(TSqlParser::LR_BRACKET);
        setState(3398);
        expression(0);
        setState(3399);
        match(TSqlParser::RR_BRACKET);
        setState(3400);
        match(TSqlParser::WITHIN);
        setState(3401);
        match(TSqlParser::GROUP);
        setState(3402);
        match(TSqlParser::LR_BRACKET);
        setState(3403);
        match(TSqlParser::ORDER);
        setState(3404);
        match(TSqlParser::BY);
        setState(3405);
        expression(0);
        setState(3407);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::ASC

        || _la == TSqlParser::DESC) {
          setState(3406);
          _la = _input->LA(1);
          if (!(_la == TSqlParser::ASC

          || _la == TSqlParser::DESC)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3409);
        match(TSqlParser::RR_BRACKET);
        setState(3410);
        match(TSqlParser::OVER);
        setState(3411);
        match(TSqlParser::LR_BRACKET);
        setState(3415);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::PARTITION) {
          setState(3412);
          match(TSqlParser::PARTITION);
          setState(3413);
          match(TSqlParser::BY);
          setState(3414);
          expression_list();
        }
        setState(3417);
        match(TSqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_distinct_expressionContext ------------------------------------------------------------------

TSqlParser::All_distinct_expressionContext::All_distinct_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::ExpressionContext* TSqlParser::All_distinct_expressionContext::expression() {
  return getRuleContext<TSqlParser::ExpressionContext>(0);
}

tree::TerminalNode* TSqlParser::All_distinct_expressionContext::ALL() {
  return getToken(TSqlParser::ALL, 0);
}

tree::TerminalNode* TSqlParser::All_distinct_expressionContext::DISTINCT() {
  return getToken(TSqlParser::DISTINCT, 0);
}


size_t TSqlParser::All_distinct_expressionContext::getRuleIndex() const {
  return TSqlParser::RuleAll_distinct_expression;
}

void TSqlParser::All_distinct_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAll_distinct_expression(this);
}

void TSqlParser::All_distinct_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAll_distinct_expression(this);
}

TSqlParser::All_distinct_expressionContext* TSqlParser::all_distinct_expression() {
  All_distinct_expressionContext *_localctx = _tracker.createInstance<All_distinct_expressionContext>(_ctx, getState());
  enterRule(_localctx, 358, TSqlParser::RuleAll_distinct_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ALL

    || _la == TSqlParser::DISTINCT) {
      setState(3421);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ALL

      || _la == TSqlParser::DISTINCT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3424);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

TSqlParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Over_clauseContext::OVER() {
  return getToken(TSqlParser::OVER, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

tree::TerminalNode* TSqlParser::Over_clauseContext::BY() {
  return getToken(TSqlParser::BY, 0);
}

TSqlParser::Expression_listContext* TSqlParser::Over_clauseContext::expression_list() {
  return getRuleContext<TSqlParser::Expression_listContext>(0);
}

TSqlParser::Order_by_clauseContext* TSqlParser::Over_clauseContext::order_by_clause() {
  return getRuleContext<TSqlParser::Order_by_clauseContext>(0);
}

TSqlParser::Row_or_range_clauseContext* TSqlParser::Over_clauseContext::row_or_range_clause() {
  return getRuleContext<TSqlParser::Row_or_range_clauseContext>(0);
}


size_t TSqlParser::Over_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleOver_clause;
}

void TSqlParser::Over_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOver_clause(this);
}

void TSqlParser::Over_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOver_clause(this);
}

TSqlParser::Over_clauseContext* TSqlParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 360, TSqlParser::RuleOver_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3426);
    match(TSqlParser::OVER);
    setState(3427);
    match(TSqlParser::LR_BRACKET);
    setState(3431);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::PARTITION) {
      setState(3428);
      match(TSqlParser::PARTITION);
      setState(3429);
      match(TSqlParser::BY);
      setState(3430);
      expression_list();
    }
    setState(3434);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ORDER) {
      setState(3433);
      order_by_clause();
    }
    setState(3437);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::RANGE

    || _la == TSqlParser::ROWS) {
      setState(3436);
      row_or_range_clause();
    }
    setState(3439);
    match(TSqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Row_or_range_clauseContext ------------------------------------------------------------------

TSqlParser::Row_or_range_clauseContext::Row_or_range_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_extentContext* TSqlParser::Row_or_range_clauseContext::window_frame_extent() {
  return getRuleContext<TSqlParser::Window_frame_extentContext>(0);
}

tree::TerminalNode* TSqlParser::Row_or_range_clauseContext::ROWS() {
  return getToken(TSqlParser::ROWS, 0);
}

tree::TerminalNode* TSqlParser::Row_or_range_clauseContext::RANGE() {
  return getToken(TSqlParser::RANGE, 0);
}


size_t TSqlParser::Row_or_range_clauseContext::getRuleIndex() const {
  return TSqlParser::RuleRow_or_range_clause;
}

void TSqlParser::Row_or_range_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRow_or_range_clause(this);
}

void TSqlParser::Row_or_range_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRow_or_range_clause(this);
}

TSqlParser::Row_or_range_clauseContext* TSqlParser::row_or_range_clause() {
  Row_or_range_clauseContext *_localctx = _tracker.createInstance<Row_or_range_clauseContext>(_ctx, getState());
  enterRule(_localctx, 362, TSqlParser::RuleRow_or_range_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3441);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::RANGE

    || _la == TSqlParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3442);
    window_frame_extent();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_extentContext ------------------------------------------------------------------

TSqlParser::Window_frame_extentContext::Window_frame_extentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_precedingContext* TSqlParser::Window_frame_extentContext::window_frame_preceding() {
  return getRuleContext<TSqlParser::Window_frame_precedingContext>(0);
}

tree::TerminalNode* TSqlParser::Window_frame_extentContext::BETWEEN() {
  return getToken(TSqlParser::BETWEEN, 0);
}

std::vector<TSqlParser::Window_frame_boundContext *> TSqlParser::Window_frame_extentContext::window_frame_bound() {
  return getRuleContexts<TSqlParser::Window_frame_boundContext>();
}

TSqlParser::Window_frame_boundContext* TSqlParser::Window_frame_extentContext::window_frame_bound(size_t i) {
  return getRuleContext<TSqlParser::Window_frame_boundContext>(i);
}

tree::TerminalNode* TSqlParser::Window_frame_extentContext::AND() {
  return getToken(TSqlParser::AND, 0);
}


size_t TSqlParser::Window_frame_extentContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_extent;
}

void TSqlParser::Window_frame_extentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_extent(this);
}

void TSqlParser::Window_frame_extentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_extent(this);
}

TSqlParser::Window_frame_extentContext* TSqlParser::window_frame_extent() {
  Window_frame_extentContext *_localctx = _tracker.createInstance<Window_frame_extentContext>(_ctx, getState());
  enterRule(_localctx, 364, TSqlParser::RuleWindow_frame_extent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3450);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CURRENT:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 1);
        setState(3444);
        window_frame_preceding();
        break;
      }

      case TSqlParser::BETWEEN: {
        enterOuterAlt(_localctx, 2);
        setState(3445);
        match(TSqlParser::BETWEEN);
        setState(3446);
        window_frame_bound();
        setState(3447);
        match(TSqlParser::AND);
        setState(3448);
        window_frame_bound();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_boundContext ------------------------------------------------------------------

TSqlParser::Window_frame_boundContext::Window_frame_boundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Window_frame_precedingContext* TSqlParser::Window_frame_boundContext::window_frame_preceding() {
  return getRuleContext<TSqlParser::Window_frame_precedingContext>(0);
}

TSqlParser::Window_frame_followingContext* TSqlParser::Window_frame_boundContext::window_frame_following() {
  return getRuleContext<TSqlParser::Window_frame_followingContext>(0);
}


size_t TSqlParser::Window_frame_boundContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_bound;
}

void TSqlParser::Window_frame_boundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_bound(this);
}

void TSqlParser::Window_frame_boundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_bound(this);
}

TSqlParser::Window_frame_boundContext* TSqlParser::window_frame_bound() {
  Window_frame_boundContext *_localctx = _tracker.createInstance<Window_frame_boundContext>(_ctx, getState());
  enterRule(_localctx, 366, TSqlParser::RuleWindow_frame_bound);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3454);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3452);
      window_frame_preceding();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3453);
      window_frame_following();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_precedingContext ------------------------------------------------------------------

TSqlParser::Window_frame_precedingContext::Window_frame_precedingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::PRECEDING() {
  return getToken(TSqlParser::PRECEDING, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::CURRENT() {
  return getToken(TSqlParser::CURRENT, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_precedingContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}


size_t TSqlParser::Window_frame_precedingContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_preceding;
}

void TSqlParser::Window_frame_precedingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_preceding(this);
}

void TSqlParser::Window_frame_precedingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_preceding(this);
}

TSqlParser::Window_frame_precedingContext* TSqlParser::window_frame_preceding() {
  Window_frame_precedingContext *_localctx = _tracker.createInstance<Window_frame_precedingContext>(_ctx, getState());
  enterRule(_localctx, 368, TSqlParser::RuleWindow_frame_preceding);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3462);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(3456);
        match(TSqlParser::UNBOUNDED);
        setState(3457);
        match(TSqlParser::PRECEDING);
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3458);
        match(TSqlParser::DECIMAL);
        setState(3459);
        match(TSqlParser::PRECEDING);
        break;
      }

      case TSqlParser::CURRENT: {
        enterOuterAlt(_localctx, 3);
        setState(3460);
        match(TSqlParser::CURRENT);
        setState(3461);
        match(TSqlParser::ROW);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_followingContext ------------------------------------------------------------------

TSqlParser::Window_frame_followingContext::Window_frame_followingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::FOLLOWING() {
  return getToken(TSqlParser::FOLLOWING, 0);
}

tree::TerminalNode* TSqlParser::Window_frame_followingContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}


size_t TSqlParser::Window_frame_followingContext::getRuleIndex() const {
  return TSqlParser::RuleWindow_frame_following;
}

void TSqlParser::Window_frame_followingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_following(this);
}

void TSqlParser::Window_frame_followingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_following(this);
}

TSqlParser::Window_frame_followingContext* TSqlParser::window_frame_following() {
  Window_frame_followingContext *_localctx = _tracker.createInstance<Window_frame_followingContext>(_ctx, getState());
  enterRule(_localctx, 370, TSqlParser::RuleWindow_frame_following);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3468);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::UNBOUNDED: {
        enterOuterAlt(_localctx, 1);
        setState(3464);
        match(TSqlParser::UNBOUNDED);
        setState(3465);
        match(TSqlParser::FOLLOWING);
        break;
      }

      case TSqlParser::DECIMAL: {
        enterOuterAlt(_localctx, 2);
        setState(3466);
        match(TSqlParser::DECIMAL);
        setState(3467);
        match(TSqlParser::FOLLOWING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_nameContext ------------------------------------------------------------------

TSqlParser::Entity_nameContext::Entity_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Entity_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Entity_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Entity_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Entity_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Entity_nameContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name;
}

void TSqlParser::Entity_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name(this);
}

void TSqlParser::Entity_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name(this);
}

TSqlParser::Entity_nameContext* TSqlParser::entity_name() {
  Entity_nameContext *_localctx = _tracker.createInstance<Entity_nameContext>(_ctx, getState());
  enterRule(_localctx, 372, TSqlParser::RuleEntity_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3487);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 499, _ctx)) {
    case 1: {
      setState(3470);
      antlrcpp::downCast<Entity_nameContext *>(_localctx)->server = id_();
      setState(3471);
      match(TSqlParser::DOT);
      setState(3472);
      antlrcpp::downCast<Entity_nameContext *>(_localctx)->database = id_();
      setState(3473);
      match(TSqlParser::DOT);
      setState(3474);
      antlrcpp::downCast<Entity_nameContext *>(_localctx)->schema = id_();
      setState(3475);
      match(TSqlParser::DOT);
      break;
    }

    case 2: {
      setState(3477);
      antlrcpp::downCast<Entity_nameContext *>(_localctx)->database = id_();
      setState(3478);
      match(TSqlParser::DOT);
      setState(3480);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3479);
        antlrcpp::downCast<Entity_nameContext *>(_localctx)->schema = id_();
      }
      setState(3482);
      match(TSqlParser::DOT);
      break;
    }

    case 3: {
      setState(3484);
      antlrcpp::downCast<Entity_nameContext *>(_localctx)->schema = id_();
      setState(3485);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3489);
    antlrcpp::downCast<Entity_nameContext *>(_localctx)->table = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_name_for_azure_dwContext ------------------------------------------------------------------

TSqlParser::Entity_name_for_azure_dwContext::Entity_name_for_azure_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Entity_name_for_azure_dwContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Entity_name_for_azure_dwContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Entity_name_for_azure_dwContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Entity_name_for_azure_dwContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name_for_azure_dw;
}

void TSqlParser::Entity_name_for_azure_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name_for_azure_dw(this);
}

void TSqlParser::Entity_name_for_azure_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name_for_azure_dw(this);
}

TSqlParser::Entity_name_for_azure_dwContext* TSqlParser::entity_name_for_azure_dw() {
  Entity_name_for_azure_dwContext *_localctx = _tracker.createInstance<Entity_name_for_azure_dwContext>(_ctx, getState());
  enterRule(_localctx, 374, TSqlParser::RuleEntity_name_for_azure_dw);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3496);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3491);
      antlrcpp::downCast<Entity_name_for_azure_dwContext *>(_localctx)->schema = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3492);
      antlrcpp::downCast<Entity_name_for_azure_dwContext *>(_localctx)->schema = id_();
      setState(3493);
      match(TSqlParser::DOT);
      setState(3494);
      antlrcpp::downCast<Entity_name_for_azure_dwContext *>(_localctx)->object_name = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Entity_name_for_parallel_dwContext ------------------------------------------------------------------

TSqlParser::Entity_name_for_parallel_dwContext::Entity_name_for_parallel_dwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Entity_name_for_parallel_dwContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Entity_name_for_parallel_dwContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Entity_name_for_parallel_dwContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Entity_name_for_parallel_dwContext::getRuleIndex() const {
  return TSqlParser::RuleEntity_name_for_parallel_dw;
}

void TSqlParser::Entity_name_for_parallel_dwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntity_name_for_parallel_dw(this);
}

void TSqlParser::Entity_name_for_parallel_dwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntity_name_for_parallel_dw(this);
}

TSqlParser::Entity_name_for_parallel_dwContext* TSqlParser::entity_name_for_parallel_dw() {
  Entity_name_for_parallel_dwContext *_localctx = _tracker.createInstance<Entity_name_for_parallel_dwContext>(_ctx, getState());
  enterRule(_localctx, 376, TSqlParser::RuleEntity_name_for_parallel_dw);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3503);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 501, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3498);
      antlrcpp::downCast<Entity_name_for_parallel_dwContext *>(_localctx)->schema_database = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3499);
      antlrcpp::downCast<Entity_name_for_parallel_dwContext *>(_localctx)->schema = id_();
      setState(3500);
      match(TSqlParser::DOT);
      setState(3501);
      antlrcpp::downCast<Entity_name_for_parallel_dwContext *>(_localctx)->object_name = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_table_nameContext ------------------------------------------------------------------

TSqlParser::Full_table_nameContext::Full_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Full_table_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Full_table_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Full_table_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Full_table_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Full_table_nameContext::getRuleIndex() const {
  return TSqlParser::RuleFull_table_name;
}

void TSqlParser::Full_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_table_name(this);
}

void TSqlParser::Full_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_table_name(this);
}

TSqlParser::Full_table_nameContext* TSqlParser::full_table_name() {
  Full_table_nameContext *_localctx = _tracker.createInstance<Full_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 378, TSqlParser::RuleFull_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3522);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 503, _ctx)) {
    case 1: {
      setState(3505);
      antlrcpp::downCast<Full_table_nameContext *>(_localctx)->server = id_();
      setState(3506);
      match(TSqlParser::DOT);
      setState(3507);
      antlrcpp::downCast<Full_table_nameContext *>(_localctx)->database = id_();
      setState(3508);
      match(TSqlParser::DOT);
      setState(3509);
      antlrcpp::downCast<Full_table_nameContext *>(_localctx)->schema = id_();
      setState(3510);
      match(TSqlParser::DOT);
      break;
    }

    case 2: {
      setState(3512);
      antlrcpp::downCast<Full_table_nameContext *>(_localctx)->database = id_();
      setState(3513);
      match(TSqlParser::DOT);
      setState(3515);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3514);
        antlrcpp::downCast<Full_table_nameContext *>(_localctx)->schema = id_();
      }
      setState(3517);
      match(TSqlParser::DOT);
      break;
    }

    case 3: {
      setState(3519);
      antlrcpp::downCast<Full_table_nameContext *>(_localctx)->schema = id_();
      setState(3520);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3524);
    antlrcpp::downCast<Full_table_nameContext *>(_localctx)->table = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

TSqlParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Table_nameContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Table_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Table_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Table_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Table_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Table_nameContext::BLOCKING_HIERARCHY() {
  return getToken(TSqlParser::BLOCKING_HIERARCHY, 0);
}


size_t TSqlParser::Table_nameContext::getRuleIndex() const {
  return TSqlParser::RuleTable_name;
}

void TSqlParser::Table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name(this);
}

void TSqlParser::Table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name(this);
}

TSqlParser::Table_nameContext* TSqlParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 380, TSqlParser::RuleTable_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3553);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 508, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3526);
      antlrcpp::downCast<Table_nameContext *>(_localctx)->loc_id = match(TSqlParser::LOCAL_ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3537);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx)) {
      case 1: {
        setState(3527);
        antlrcpp::downCast<Table_nameContext *>(_localctx)->database = id_();
        setState(3528);
        match(TSqlParser::DOT);
        setState(3530);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 378)) & 9727679) != 0)) {
          setState(3529);
          antlrcpp::downCast<Table_nameContext *>(_localctx)->schema = id_();
        }
        setState(3532);
        match(TSqlParser::DOT);
        break;
      }

      case 2: {
        setState(3534);
        antlrcpp::downCast<Table_nameContext *>(_localctx)->schema = id_();
        setState(3535);
        match(TSqlParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(3539);
      antlrcpp::downCast<Table_nameContext *>(_localctx)->table = id_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3550);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
      case 1: {
        setState(3540);
        antlrcpp::downCast<Table_nameContext *>(_localctx)->database = id_();
        setState(3541);
        match(TSqlParser::DOT);
        setState(3543);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 378)) & 9727679) != 0)) {
          setState(3542);
          antlrcpp::downCast<Table_nameContext *>(_localctx)->schema = id_();
        }
        setState(3545);
        match(TSqlParser::DOT);
        break;
      }

      case 2: {
        setState(3547);
        antlrcpp::downCast<Table_nameContext *>(_localctx)->schema = id_();
        setState(3548);
        match(TSqlParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(3552);
      antlrcpp::downCast<Table_nameContext *>(_localctx)->blocking_hierarchy = match(TSqlParser::BLOCKING_HIERARCHY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_nameContext ------------------------------------------------------------------

TSqlParser::Simple_nameContext::Simple_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Simple_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Simple_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Simple_nameContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Simple_nameContext::getRuleIndex() const {
  return TSqlParser::RuleSimple_name;
}

void TSqlParser::Simple_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_name(this);
}

void TSqlParser::Simple_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_name(this);
}

TSqlParser::Simple_nameContext* TSqlParser::simple_name() {
  Simple_nameContext *_localctx = _tracker.createInstance<Simple_nameContext>(_ctx, getState());
  enterRule(_localctx, 382, TSqlParser::RuleSimple_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3558);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 509, _ctx)) {
    case 1: {
      setState(3555);
      antlrcpp::downCast<Simple_nameContext *>(_localctx)->schema = id_();
      setState(3556);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3560);
    antlrcpp::downCast<Simple_nameContext *>(_localctx)->name = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_schemaContext::Func_proc_name_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Func_proc_name_schemaContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Func_proc_name_schemaContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

tree::TerminalNode* TSqlParser::Func_proc_name_schemaContext::DOT() {
  return getToken(TSqlParser::DOT, 0);
}


size_t TSqlParser::Func_proc_name_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_schema;
}

void TSqlParser::Func_proc_name_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_schema(this);
}

void TSqlParser::Func_proc_name_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_schema(this);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::func_proc_name_schema() {
  Func_proc_name_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_schemaContext>(_ctx, getState());
  enterRule(_localctx, 384, TSqlParser::RuleFunc_proc_name_schema);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3565);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx)) {
    case 1: {
      setState(3562);
      antlrcpp::downCast<Func_proc_name_schemaContext *>(_localctx)->schema = id_();
      setState(3563);
      match(TSqlParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(3567);
    antlrcpp::downCast<Func_proc_name_schemaContext *>(_localctx)->procedure = id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_database_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_database_schemaContext::Func_proc_name_database_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Func_proc_name_database_schemaContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Func_proc_name_database_schemaContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Func_proc_name_database_schemaContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Func_proc_name_database_schemaContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Func_proc_name_schemaContext* TSqlParser::Func_proc_name_database_schemaContext::func_proc_name_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_schemaContext>(0);
}


size_t TSqlParser::Func_proc_name_database_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_database_schema;
}

void TSqlParser::Func_proc_name_database_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_database_schema(this);
}

void TSqlParser::Func_proc_name_database_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_database_schema(this);
}

TSqlParser::Func_proc_name_database_schemaContext* TSqlParser::func_proc_name_database_schema() {
  Func_proc_name_database_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_database_schemaContext>(_ctx, getState());
  enterRule(_localctx, 386, TSqlParser::RuleFunc_proc_name_database_schema);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3579);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3570);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3569);
        antlrcpp::downCast<Func_proc_name_database_schemaContext *>(_localctx)->database = id_();
      }
      setState(3572);
      match(TSqlParser::DOT);
      setState(3574);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3573);
        antlrcpp::downCast<Func_proc_name_database_schemaContext *>(_localctx)->schema = id_();
      }
      setState(3576);
      match(TSqlParser::DOT);
      setState(3577);
      antlrcpp::downCast<Func_proc_name_database_schemaContext *>(_localctx)->procedure = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3578);
      func_proc_name_schema();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_proc_name_server_database_schemaContext ------------------------------------------------------------------

TSqlParser::Func_proc_name_server_database_schemaContext::Func_proc_name_server_database_schemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Func_proc_name_server_database_schemaContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Func_proc_name_server_database_schemaContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Func_proc_name_server_database_schemaContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Func_proc_name_server_database_schemaContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

TSqlParser::Func_proc_name_database_schemaContext* TSqlParser::Func_proc_name_server_database_schemaContext::func_proc_name_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_database_schemaContext>(0);
}


size_t TSqlParser::Func_proc_name_server_database_schemaContext::getRuleIndex() const {
  return TSqlParser::RuleFunc_proc_name_server_database_schema;
}

void TSqlParser::Func_proc_name_server_database_schemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_proc_name_server_database_schema(this);
}

void TSqlParser::Func_proc_name_server_database_schemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_proc_name_server_database_schema(this);
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::func_proc_name_server_database_schema() {
  Func_proc_name_server_database_schemaContext *_localctx = _tracker.createInstance<Func_proc_name_server_database_schemaContext>(_ctx, getState());
  enterRule(_localctx, 388, TSqlParser::RuleFunc_proc_name_server_database_schema);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3595);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3582);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3581);
        antlrcpp::downCast<Func_proc_name_server_database_schemaContext *>(_localctx)->server = id_();
      }
      setState(3584);
      match(TSqlParser::DOT);
      setState(3586);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3585);
        antlrcpp::downCast<Func_proc_name_server_database_schemaContext *>(_localctx)->database = id_();
      }
      setState(3588);
      match(TSqlParser::DOT);
      setState(3590);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3589);
        antlrcpp::downCast<Func_proc_name_server_database_schemaContext *>(_localctx)->schema = id_();
      }
      setState(3592);
      match(TSqlParser::DOT);
      setState(3593);
      antlrcpp::downCast<Func_proc_name_server_database_schemaContext *>(_localctx)->procedure = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3594);
      func_proc_name_database_schema();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ddl_objectContext ------------------------------------------------------------------

TSqlParser::Ddl_objectContext::Ddl_objectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Full_table_nameContext* TSqlParser::Ddl_objectContext::full_table_name() {
  return getRuleContext<TSqlParser::Full_table_nameContext>(0);
}

tree::TerminalNode* TSqlParser::Ddl_objectContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Ddl_objectContext::getRuleIndex() const {
  return TSqlParser::RuleDdl_object;
}

void TSqlParser::Ddl_objectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDdl_object(this);
}

void TSqlParser::Ddl_objectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDdl_object(this);
}

TSqlParser::Ddl_objectContext* TSqlParser::ddl_object() {
  Ddl_objectContext *_localctx = _tracker.createInstance<Ddl_objectContext>(_ctx, getState());
  enterRule(_localctx, 390, TSqlParser::RuleDdl_object);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3599);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3597);
        full_table_name();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3598);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_column_nameContext ------------------------------------------------------------------

TSqlParser::Full_column_nameContext::Full_column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> TSqlParser::Full_column_nameContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}

tree::TerminalNode* TSqlParser::Full_column_nameContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Full_column_nameContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Full_column_nameContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}


size_t TSqlParser::Full_column_nameContext::getRuleIndex() const {
  return TSqlParser::RuleFull_column_name;
}

void TSqlParser::Full_column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_column_name(this);
}

void TSqlParser::Full_column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_column_name(this);
}

TSqlParser::Full_column_nameContext* TSqlParser::full_column_name() {
  Full_column_nameContext *_localctx = _tracker.createInstance<Full_column_nameContext>(_ctx, getState());
  enterRule(_localctx, 392, TSqlParser::RuleFull_column_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3632);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3601);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DELETED

      || _la == TSqlParser::INSERTED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3602);
      match(TSqlParser::DOT);
      setState(3603);
      antlrcpp::downCast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3605);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3604);
        antlrcpp::downCast<Full_column_nameContext *>(_localctx)->server = id_();
      }
      setState(3607);
      match(TSqlParser::DOT);
      setState(3609);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3608);
        antlrcpp::downCast<Full_column_nameContext *>(_localctx)->schema = id_();
      }
      setState(3611);
      match(TSqlParser::DOT);
      setState(3613);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3612);
        antlrcpp::downCast<Full_column_nameContext *>(_localctx)->tablename = id_();
      }
      setState(3615);
      match(TSqlParser::DOT);
      setState(3616);
      antlrcpp::downCast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3618);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3617);
        antlrcpp::downCast<Full_column_nameContext *>(_localctx)->schema = id_();
      }
      setState(3620);
      match(TSqlParser::DOT);
      setState(3622);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3621);
        antlrcpp::downCast<Full_column_nameContext *>(_localctx)->tablename = id_();
      }
      setState(3624);
      match(TSqlParser::DOT);
      setState(3625);
      antlrcpp::downCast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 378)) & 9727679) != 0)) {
        setState(3626);
        antlrcpp::downCast<Full_column_nameContext *>(_localctx)->tablename = id_();
      }
      setState(3629);
      match(TSqlParser::DOT);
      setState(3630);
      antlrcpp::downCast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3631);
      antlrcpp::downCast<Full_column_nameContext *>(_localctx)->column_name = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_list_with_orderContext ------------------------------------------------------------------

TSqlParser::Column_name_list_with_orderContext::Column_name_list_with_orderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Column_name_list_with_orderContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Column_name_list_with_orderContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::ASC() {
  return getTokens(TSqlParser::ASC);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::ASC(size_t i) {
  return getToken(TSqlParser::ASC, i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_list_with_orderContext::DESC() {
  return getTokens(TSqlParser::DESC);
}

tree::TerminalNode* TSqlParser::Column_name_list_with_orderContext::DESC(size_t i) {
  return getToken(TSqlParser::DESC, i);
}


size_t TSqlParser::Column_name_list_with_orderContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_name_list_with_order;
}

void TSqlParser::Column_name_list_with_orderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list_with_order(this);
}

void TSqlParser::Column_name_list_with_orderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list_with_order(this);
}

TSqlParser::Column_name_list_with_orderContext* TSqlParser::column_name_list_with_order() {
  Column_name_list_with_orderContext *_localctx = _tracker.createInstance<Column_name_list_with_orderContext>(_ctx, getState());
  enterRule(_localctx, 394, TSqlParser::RuleColumn_name_list_with_order);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3634);
    id_();
    setState(3636);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::ASC

    || _la == TSqlParser::DESC) {
      setState(3635);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::ASC

      || _la == TSqlParser::DESC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3645);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3638);
      match(TSqlParser::COMMA);
      setState(3639);
      id_();
      setState(3641);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::ASC

      || _la == TSqlParser::DESC) {
        setState(3640);
        _la = _input->LA(1);
        if (!(_la == TSqlParser::ASC

        || _la == TSqlParser::DESC)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(3647);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_name_listContext ------------------------------------------------------------------

TSqlParser::Insert_column_name_listContext::Insert_column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Insert_column_idContext *> TSqlParser::Insert_column_name_listContext::insert_column_id() {
  return getRuleContexts<TSqlParser::Insert_column_idContext>();
}

TSqlParser::Insert_column_idContext* TSqlParser::Insert_column_name_listContext::insert_column_id(size_t i) {
  return getRuleContext<TSqlParser::Insert_column_idContext>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Insert_column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Insert_column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_column_name_list;
}

void TSqlParser::Insert_column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_column_name_list(this);
}

void TSqlParser::Insert_column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_column_name_list(this);
}

TSqlParser::Insert_column_name_listContext* TSqlParser::insert_column_name_list() {
  Insert_column_name_listContext *_localctx = _tracker.createInstance<Insert_column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 396, TSqlParser::RuleInsert_column_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3648);
    antlrcpp::downCast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext = insert_column_id();
    antlrcpp::downCast<Insert_column_name_listContext *>(_localctx)->col.push_back(antlrcpp::downCast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext);
    setState(3653);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3649);
      match(TSqlParser::COMMA);
      setState(3650);
      antlrcpp::downCast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext = insert_column_id();
      antlrcpp::downCast<Insert_column_name_listContext *>(_localctx)->col.push_back(antlrcpp::downCast<Insert_column_name_listContext *>(_localctx)->insert_column_idContext);
      setState(3655);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_idContext ------------------------------------------------------------------

TSqlParser::Insert_column_idContext::Insert_column_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Insert_column_idContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Insert_column_idContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Insert_column_idContext::DOT() {
  return getTokens(TSqlParser::DOT);
}

tree::TerminalNode* TSqlParser::Insert_column_idContext::DOT(size_t i) {
  return getToken(TSqlParser::DOT, i);
}


size_t TSqlParser::Insert_column_idContext::getRuleIndex() const {
  return TSqlParser::RuleInsert_column_id;
}

void TSqlParser::Insert_column_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_column_id(this);
}

void TSqlParser::Insert_column_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_column_id(this);
}

TSqlParser::Insert_column_idContext* TSqlParser::insert_column_id() {
  Insert_column_idContext *_localctx = _tracker.createInstance<Insert_column_idContext>(_ctx, getState());
  enterRule(_localctx, 398, TSqlParser::RuleInsert_column_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3662);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 531, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3657);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 378)) & 9727679) != 0)) {
          setState(3656);
          antlrcpp::downCast<Insert_column_idContext *>(_localctx)->id_Context = id_();
          antlrcpp::downCast<Insert_column_idContext *>(_localctx)->ignore.push_back(antlrcpp::downCast<Insert_column_idContext *>(_localctx)->id_Context);
        }
        setState(3659);
        match(TSqlParser::DOT); 
      }
      setState(3664);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 531, _ctx);
    }
    setState(3665);
    id_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_listContext ------------------------------------------------------------------

TSqlParser::Column_name_listContext::Column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<TSqlParser::Id_Context *> TSqlParser::Column_name_listContext::id_() {
  return getRuleContexts<TSqlParser::Id_Context>();
}

TSqlParser::Id_Context* TSqlParser::Column_name_listContext::id_(size_t i) {
  return getRuleContext<TSqlParser::Id_Context>(i);
}

std::vector<tree::TerminalNode *> TSqlParser::Column_name_listContext::COMMA() {
  return getTokens(TSqlParser::COMMA);
}

tree::TerminalNode* TSqlParser::Column_name_listContext::COMMA(size_t i) {
  return getToken(TSqlParser::COMMA, i);
}


size_t TSqlParser::Column_name_listContext::getRuleIndex() const {
  return TSqlParser::RuleColumn_name_list;
}

void TSqlParser::Column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list(this);
}

void TSqlParser::Column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list(this);
}

TSqlParser::Column_name_listContext* TSqlParser::column_name_list() {
  Column_name_listContext *_localctx = _tracker.createInstance<Column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 400, TSqlParser::RuleColumn_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3667);
    antlrcpp::downCast<Column_name_listContext *>(_localctx)->id_Context = id_();
    antlrcpp::downCast<Column_name_listContext *>(_localctx)->col.push_back(antlrcpp::downCast<Column_name_listContext *>(_localctx)->id_Context);
    setState(3672);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == TSqlParser::COMMA) {
      setState(3668);
      match(TSqlParser::COMMA);
      setState(3669);
      antlrcpp::downCast<Column_name_listContext *>(_localctx)->id_Context = id_();
      antlrcpp::downCast<Column_name_listContext *>(_localctx)->col.push_back(antlrcpp::downCast<Column_name_listContext *>(_localctx)->id_Context);
      setState(3674);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_nameContext ------------------------------------------------------------------

TSqlParser::Cursor_nameContext::Cursor_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Cursor_nameContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Cursor_nameContext::LOCAL_ID() {
  return getToken(TSqlParser::LOCAL_ID, 0);
}


size_t TSqlParser::Cursor_nameContext::getRuleIndex() const {
  return TSqlParser::RuleCursor_name;
}

void TSqlParser::Cursor_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_name(this);
}

void TSqlParser::Cursor_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_name(this);
}

TSqlParser::Cursor_nameContext* TSqlParser::cursor_name() {
  Cursor_nameContext *_localctx = _tracker.createInstance<Cursor_nameContext>(_ctx, getState());
  enterRule(_localctx, 402, TSqlParser::RuleCursor_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3677);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3675);
        id_();
        break;
      }

      case TSqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3676);
        match(TSqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_offContext ------------------------------------------------------------------

TSqlParser::On_offContext::On_offContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::On_offContext::ON() {
  return getToken(TSqlParser::ON, 0);
}

tree::TerminalNode* TSqlParser::On_offContext::OFF() {
  return getToken(TSqlParser::OFF, 0);
}


size_t TSqlParser::On_offContext::getRuleIndex() const {
  return TSqlParser::RuleOn_off;
}

void TSqlParser::On_offContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOn_off(this);
}

void TSqlParser::On_offContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOn_off(this);
}

TSqlParser::On_offContext* TSqlParser::on_off() {
  On_offContext *_localctx = _tracker.createInstance<On_offContext>(_ctx, getState());
  enterRule(_localctx, 404, TSqlParser::RuleOn_off);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3679);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::OFF

    || _la == TSqlParser::ON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_notnullContext ------------------------------------------------------------------

TSqlParser::Null_notnullContext::Null_notnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Null_notnullContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Null_notnullContext::NOT() {
  return getToken(TSqlParser::NOT, 0);
}


size_t TSqlParser::Null_notnullContext::getRuleIndex() const {
  return TSqlParser::RuleNull_notnull;
}

void TSqlParser::Null_notnullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_notnull(this);
}

void TSqlParser::Null_notnullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_notnull(this);
}

TSqlParser::Null_notnullContext* TSqlParser::null_notnull() {
  Null_notnullContext *_localctx = _tracker.createInstance<Null_notnullContext>(_ctx, getState());
  enterRule(_localctx, 406, TSqlParser::RuleNull_notnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == TSqlParser::NOT) {
      setState(3681);
      match(TSqlParser::NOT);
    }
    setState(3684);
    match(TSqlParser::NULL_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_or_defaultContext ------------------------------------------------------------------

TSqlParser::Null_or_defaultContext::Null_or_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Null_notnullContext* TSqlParser::Null_or_defaultContext::null_notnull() {
  return getRuleContext<TSqlParser::Null_notnullContext>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

TSqlParser::Constant_expressionContext* TSqlParser::Null_or_defaultContext::constant_expression() {
  return getRuleContext<TSqlParser::Constant_expressionContext>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::COLLATE() {
  return getToken(TSqlParser::COLLATE, 0);
}

TSqlParser::Id_Context* TSqlParser::Null_or_defaultContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::WITH() {
  return getToken(TSqlParser::WITH, 0);
}

tree::TerminalNode* TSqlParser::Null_or_defaultContext::VALUES() {
  return getToken(TSqlParser::VALUES, 0);
}


size_t TSqlParser::Null_or_defaultContext::getRuleIndex() const {
  return TSqlParser::RuleNull_or_default;
}

void TSqlParser::Null_or_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_or_default(this);
}

void TSqlParser::Null_or_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_or_default(this);
}

TSqlParser::Null_or_defaultContext* TSqlParser::null_or_default() {
  Null_or_defaultContext *_localctx = _tracker.createInstance<Null_or_defaultContext>(_ctx, getState());
  enterRule(_localctx, 408, TSqlParser::RuleNull_or_default);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3697);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NOT:
      case TSqlParser::NULL_: {
        setState(3686);
        null_notnull();
        break;
      }

      case TSqlParser::DEFAULT: {
        setState(3687);
        match(TSqlParser::DEFAULT);
        setState(3688);
        constant_expression();
        setState(3691);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == TSqlParser::COLLATE) {
          setState(3689);
          match(TSqlParser::COLLATE);
          setState(3690);
          id_();
        }
        setState(3695);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 536, _ctx)) {
        case 1: {
          setState(3693);
          match(TSqlParser::WITH);
          setState(3694);
          match(TSqlParser::VALUES);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_function_nameContext ------------------------------------------------------------------

TSqlParser::Scalar_function_nameContext::Scalar_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Func_proc_name_server_database_schemaContext* TSqlParser::Scalar_function_nameContext::func_proc_name_server_database_schema() {
  return getRuleContext<TSqlParser::Func_proc_name_server_database_schemaContext>(0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RIGHT() {
  return getToken(TSqlParser::RIGHT, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LEFT() {
  return getToken(TSqlParser::LEFT, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ABS() {
  return getToken(TSqlParser::ABS, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ASCII() {
  return getToken(TSqlParser::ASCII, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CEILING() {
  return getToken(TSqlParser::CEILING, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHAR() {
  return getToken(TSqlParser::CHAR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::CHARINDEX() {
  return getToken(TSqlParser::CHARINDEX, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::DATALENGTH() {
  return getToken(TSqlParser::DATALENGTH, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::DAY() {
  return getToken(TSqlParser::DAY, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::FLOOR() {
  return getToken(TSqlParser::FLOOR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ISDATE() {
  return getToken(TSqlParser::ISDATE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ISNUMERIC() {
  return getToken(TSqlParser::ISNUMERIC, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LEN() {
  return getToken(TSqlParser::LEN, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LOWER() {
  return getToken(TSqlParser::LOWER, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::LTRIM() {
  return getToken(TSqlParser::LTRIM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::MONTH() {
  return getToken(TSqlParser::MONTH, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::NCHAR() {
  return getToken(TSqlParser::NCHAR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::PATINDEX() {
  return getToken(TSqlParser::PATINDEX, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RAND() {
  return getToken(TSqlParser::RAND, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::REPLACE() {
  return getToken(TSqlParser::REPLACE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::ROUND() {
  return getToken(TSqlParser::ROUND, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::RTRIM() {
  return getToken(TSqlParser::RTRIM, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SIGN() {
  return getToken(TSqlParser::SIGN, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SPACE() {
  return getToken(TSqlParser::SPACE, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::STR() {
  return getToken(TSqlParser::STR, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::SUBSTRING() {
  return getToken(TSqlParser::SUBSTRING, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::UPPER() {
  return getToken(TSqlParser::UPPER, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::USER_NAME() {
  return getToken(TSqlParser::USER_NAME, 0);
}

tree::TerminalNode* TSqlParser::Scalar_function_nameContext::YEAR() {
  return getToken(TSqlParser::YEAR, 0);
}


size_t TSqlParser::Scalar_function_nameContext::getRuleIndex() const {
  return TSqlParser::RuleScalar_function_name;
}

void TSqlParser::Scalar_function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_function_name(this);
}

void TSqlParser::Scalar_function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_function_name(this);
}

TSqlParser::Scalar_function_nameContext* TSqlParser::scalar_function_name() {
  Scalar_function_nameContext *_localctx = _tracker.createInstance<Scalar_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 410, TSqlParser::RuleScalar_function_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 538, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3699);
      func_proc_name_server_database_schema();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3700);
      match(TSqlParser::RIGHT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3701);
      match(TSqlParser::LEFT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3702);
      match(TSqlParser::BINARY_CHECKSUM);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3703);
      match(TSqlParser::CHECKSUM);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3704);
      match(TSqlParser::ABS);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3705);
      match(TSqlParser::ASCII);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3706);
      match(TSqlParser::CEILING);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3707);
      match(TSqlParser::CHAR);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3708);
      match(TSqlParser::CHARINDEX);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3709);
      match(TSqlParser::DATALENGTH);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3710);
      match(TSqlParser::DAY);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3711);
      match(TSqlParser::FLOOR);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3712);
      match(TSqlParser::ISDATE);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3713);
      match(TSqlParser::ISNUMERIC);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(3714);
      match(TSqlParser::LEN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(3715);
      match(TSqlParser::LOWER);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(3716);
      match(TSqlParser::LTRIM);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(3717);
      match(TSqlParser::MONTH);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(3718);
      match(TSqlParser::NCHAR);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(3719);
      match(TSqlParser::PATINDEX);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(3720);
      match(TSqlParser::RAND);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(3721);
      match(TSqlParser::REPLACE);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(3722);
      match(TSqlParser::ROUND);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(3723);
      match(TSqlParser::RTRIM);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(3724);
      match(TSqlParser::SIGN);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(3725);
      match(TSqlParser::SPACE);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(3726);
      match(TSqlParser::STR);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(3727);
      match(TSqlParser::SUBSTRING);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(3728);
      match(TSqlParser::UPPER);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(3729);
      match(TSqlParser::USER_NAME);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(3730);
      match(TSqlParser::YEAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_typeContext ------------------------------------------------------------------

TSqlParser::Data_typeContext::Data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Data_typeContext::LR_BRACKET() {
  return getToken(TSqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::RR_BRACKET() {
  return getToken(TSqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::NTEXT() {
  return getToken(TSqlParser::NTEXT, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::TEXT() {
  return getToken(TSqlParser::TEXT, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::NCHAR() {
  return getToken(TSqlParser::NCHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::CHAR() {
  return getToken(TSqlParser::CHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::VARCHAR() {
  return getToken(TSqlParser::VARCHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::NVARCHAR() {
  return getToken(TSqlParser::NVARCHAR, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::BINARY_KEYWORD() {
  return getToken(TSqlParser::BINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::VARBINARY_KEYWORD() {
  return getToken(TSqlParser::VARBINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::COMMA() {
  return getToken(TSqlParser::COMMA, 0);
}

TSqlParser::Id_Context* TSqlParser::Data_typeContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

std::vector<tree::TerminalNode *> TSqlParser::Data_typeContext::DECIMAL() {
  return getTokens(TSqlParser::DECIMAL);
}

tree::TerminalNode* TSqlParser::Data_typeContext::DECIMAL(size_t i) {
  return getToken(TSqlParser::DECIMAL, i);
}

tree::TerminalNode* TSqlParser::Data_typeContext::IDENTITY() {
  return getToken(TSqlParser::IDENTITY, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::DOUBLE() {
  return getToken(TSqlParser::DOUBLE, 0);
}

tree::TerminalNode* TSqlParser::Data_typeContext::PRECISION() {
  return getToken(TSqlParser::PRECISION, 0);
}


size_t TSqlParser::Data_typeContext::getRuleIndex() const {
  return TSqlParser::RuleData_type;
}

void TSqlParser::Data_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_type(this);
}

void TSqlParser::Data_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_type(this);
}

TSqlParser::Data_typeContext* TSqlParser::data_type() {
  Data_typeContext *_localctx = _tracker.createInstance<Data_typeContext>(_ctx, getState());
  enterRule(_localctx, 412, TSqlParser::RuleData_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3763);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 541, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3733);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->scaled = _input->LT(1);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 805339152) != 0) || _la == TSqlParser::BINARY_KEYWORD || ((((_la - 352) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 352)) & 1649267441665) != 0))) {
        antlrcpp::downCast<Data_typeContext *>(_localctx)->scaled = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3734);
      match(TSqlParser::LR_BRACKET);
      setState(3735);
      match(TSqlParser::MAX);
      setState(3736);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3737);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->ext_type = id_();
      setState(3738);
      match(TSqlParser::LR_BRACKET);
      setState(3739);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->scale = match(TSqlParser::DECIMAL);
      setState(3740);
      match(TSqlParser::COMMA);
      setState(3741);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->prec = match(TSqlParser::DECIMAL);
      setState(3742);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3744);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->ext_type = id_();
      setState(3745);
      match(TSqlParser::LR_BRACKET);
      setState(3746);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->scale = match(TSqlParser::DECIMAL);
      setState(3747);
      match(TSqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3749);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->ext_type = id_();
      setState(3750);
      match(TSqlParser::IDENTITY);
      setState(3756);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 539, _ctx)) {
      case 1: {
        setState(3751);
        match(TSqlParser::LR_BRACKET);
        setState(3752);
        antlrcpp::downCast<Data_typeContext *>(_localctx)->seed = match(TSqlParser::DECIMAL);
        setState(3753);
        match(TSqlParser::COMMA);
        setState(3754);
        antlrcpp::downCast<Data_typeContext *>(_localctx)->inc = match(TSqlParser::DECIMAL);
        setState(3755);
        match(TSqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3758);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->double_prec = match(TSqlParser::DOUBLE);
      setState(3760);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 540, _ctx)) {
      case 1: {
        setState(3759);
        match(TSqlParser::PRECISION);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3762);
      antlrcpp::downCast<Data_typeContext *>(_localctx)->unscaled_type = id_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_valueContext ------------------------------------------------------------------

TSqlParser::Default_valueContext::Default_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Default_valueContext::NULL_() {
  return getToken(TSqlParser::NULL_, 0);
}

tree::TerminalNode* TSqlParser::Default_valueContext::DEFAULT() {
  return getToken(TSqlParser::DEFAULT, 0);
}

TSqlParser::ConstantContext* TSqlParser::Default_valueContext::constant() {
  return getRuleContext<TSqlParser::ConstantContext>(0);
}


size_t TSqlParser::Default_valueContext::getRuleIndex() const {
  return TSqlParser::RuleDefault_value;
}

void TSqlParser::Default_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_value(this);
}

void TSqlParser::Default_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_value(this);
}

TSqlParser::Default_valueContext* TSqlParser::default_value() {
  Default_valueContext *_localctx = _tracker.createInstance<Default_valueContext>(_ctx, getState());
  enterRule(_localctx, 414, TSqlParser::RuleDefault_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3768);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(3765);
        match(TSqlParser::NULL_);
        break;
      }

      case TSqlParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(3766);
        match(TSqlParser::DEFAULT);
        break;
      }

      case TSqlParser::DECIMAL:
      case TSqlParser::STRING:
      case TSqlParser::BINARY:
      case TSqlParser::FLOAT:
      case TSqlParser::REAL:
      case TSqlParser::DOLLAR:
      case TSqlParser::PLUS:
      case TSqlParser::MINUS: {
        enterOuterAlt(_localctx, 3);
        setState(3767);
        constant();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

TSqlParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::ConstantContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::BINARY() {
  return getToken(TSqlParser::BINARY, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::DECIMAL() {
  return getToken(TSqlParser::DECIMAL, 0);
}

TSqlParser::SignContext* TSqlParser::ConstantContext::sign() {
  return getRuleContext<TSqlParser::SignContext>(0);
}

tree::TerminalNode* TSqlParser::ConstantContext::REAL() {
  return getToken(TSqlParser::REAL, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::FLOAT() {
  return getToken(TSqlParser::FLOAT, 0);
}

tree::TerminalNode* TSqlParser::ConstantContext::DOLLAR() {
  return getToken(TSqlParser::DOLLAR, 0);
}


size_t TSqlParser::ConstantContext::getRuleIndex() const {
  return TSqlParser::RuleConstant;
}

void TSqlParser::ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant(this);
}

void TSqlParser::ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant(this);
}

TSqlParser::ConstantContext* TSqlParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 416, TSqlParser::RuleConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 546, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3770);
      match(TSqlParser::STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3771);
      match(TSqlParser::BINARY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3773);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(3772);
        sign();
      }
      setState(3775);
      match(TSqlParser::DECIMAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3777);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(3776);
        sign();
      }
      setState(3779);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::FLOAT

      || _la == TSqlParser::REAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3781);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == TSqlParser::PLUS

      || _la == TSqlParser::MINUS) {
        setState(3780);
        sign();
      }
      setState(3783);
      antlrcpp::downCast<ConstantContext *>(_localctx)->dollar = match(TSqlParser::DOLLAR);
      setState(3784);
      _la = _input->LA(1);
      if (!(_la == TSqlParser::DECIMAL

      || _la == TSqlParser::FLOAT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignContext ------------------------------------------------------------------

TSqlParser::SignContext::SignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::SignContext::PLUS() {
  return getToken(TSqlParser::PLUS, 0);
}

tree::TerminalNode* TSqlParser::SignContext::MINUS() {
  return getToken(TSqlParser::MINUS, 0);
}


size_t TSqlParser::SignContext::getRuleIndex() const {
  return TSqlParser::RuleSign;
}

void TSqlParser::SignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSign(this);
}

void TSqlParser::SignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSign(this);
}

TSqlParser::SignContext* TSqlParser::sign() {
  SignContext *_localctx = _tracker.createInstance<SignContext>(_ctx, getState());
  enterRule(_localctx, 418, TSqlParser::RuleSign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3787);
    _la = _input->LA(1);
    if (!(_la == TSqlParser::PLUS

    || _la == TSqlParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

TSqlParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::KeywordContext::ABSOLUTE() {
  return getToken(TSqlParser::ABSOLUTE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ACTION() {
  return getToken(TSqlParser::ACTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AES_128() {
  return getToken(TSqlParser::AES_128, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AES_192() {
  return getToken(TSqlParser::AES_192, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AES_256() {
  return getToken(TSqlParser::AES_256, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ALGORITHM() {
  return getToken(TSqlParser::ALGORITHM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ANSI_NULLS() {
  return getToken(TSqlParser::ANSI_NULLS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ANSI_PADDING() {
  return getToken(TSqlParser::ANSI_PADDING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ANSI_WARNINGS() {
  return getToken(TSqlParser::ANSI_WARNINGS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::APPLY() {
  return getToken(TSqlParser::APPLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ARITHABORT() {
  return getToken(TSqlParser::ARITHABORT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AT_KEYWORD() {
  return getToken(TSqlParser::AT_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AUTO() {
  return getToken(TSqlParser::AUTO, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::AVG() {
  return getToken(TSqlParser::AVG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BIGINT() {
  return getToken(TSqlParser::BIGINT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BINARY_BASE64() {
  return getToken(TSqlParser::BINARY_BASE64, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BINARY_CHECKSUM() {
  return getToken(TSqlParser::BINARY_CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CALLER() {
  return getToken(TSqlParser::CALLER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CAST() {
  return getToken(TSqlParser::CAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CATCH() {
  return getToken(TSqlParser::CATCH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHECKSUM() {
  return getToken(TSqlParser::CHECKSUM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHECKSUM_AGG() {
  return getToken(TSqlParser::CHECKSUM_AGG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::COMMITTED() {
  return getToken(TSqlParser::COMMITTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CONCAT() {
  return getToken(TSqlParser::CONCAT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CONCAT_NULL_YIELDS_NULL() {
  return getToken(TSqlParser::CONCAT_NULL_YIELDS_NULL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::COUNT() {
  return getToken(TSqlParser::COUNT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::COUNT_BIG() {
  return getToken(TSqlParser::COUNT_BIG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CURSOR_CLOSE_ON_COMMIT() {
  return getToken(TSqlParser::CURSOR_CLOSE_ON_COMMIT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CURSOR_DEFAULT() {
  return getToken(TSqlParser::CURSOR_DEFAULT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATA() {
  return getToken(TSqlParser::DATA, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATEADD() {
  return getToken(TSqlParser::DATEADD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATEDIFF() {
  return getToken(TSqlParser::DATEDIFF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATENAME() {
  return getToken(TSqlParser::DATENAME, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATEPART() {
  return getToken(TSqlParser::DATEPART, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DAYS() {
  return getToken(TSqlParser::DAYS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DEFAULT_DOUBLE_QUOTE() {
  return getToken(TSqlParser::DEFAULT_DOUBLE_QUOTE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DELAY() {
  return getToken(TSqlParser::DELAY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DELAYED_DURABILITY() {
  return getToken(TSqlParser::DELAYED_DURABILITY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DELETED() {
  return getToken(TSqlParser::DELETED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DENSE_RANK() {
  return getToken(TSqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DES() {
  return getToken(TSqlParser::DES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DESCRIPTION() {
  return getToken(TSqlParser::DESCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DESX() {
  return getToken(TSqlParser::DESX, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DISABLE() {
  return getToken(TSqlParser::DISABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DYNAMIC() {
  return getToken(TSqlParser::DYNAMIC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ELEMENTS() {
  return getToken(TSqlParser::ELEMENTS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::EMPTY() {
  return getToken(TSqlParser::EMPTY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ENCRYPTION() {
  return getToken(TSqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::EXCLUSIVE() {
  return getToken(TSqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FAST() {
  return getToken(TSqlParser::FAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FAST_FORWARD() {
  return getToken(TSqlParser::FAST_FORWARD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FIRST() {
  return getToken(TSqlParser::FIRST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FIRST_VALUE() {
  return getToken(TSqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FOLLOWING() {
  return getToken(TSqlParser::FOLLOWING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORCE() {
  return getToken(TSqlParser::FORCE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORCED() {
  return getToken(TSqlParser::FORCED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORWARD_ONLY() {
  return getToken(TSqlParser::FORWARD_ONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GETDATE() {
  return getToken(TSqlParser::GETDATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GETUTCDATE() {
  return getToken(TSqlParser::GETUTCDATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GLOBAL() {
  return getToken(TSqlParser::GLOBAL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GO() {
  return getToken(TSqlParser::GO, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GO_BATCH() {
  return getToken(TSqlParser::GO_BATCH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GROUPING() {
  return getToken(TSqlParser::GROUPING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::GROUPING_ID() {
  return getToken(TSqlParser::GROUPING_ID, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::HASH() {
  return getToken(TSqlParser::HASH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::HIGH() {
  return getToken(TSqlParser::HIGH, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::HOURS() {
  return getToken(TSqlParser::HOURS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::IDENTITY_VALUE() {
  return getToken(TSqlParser::IDENTITY_VALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INCLUDE_NULL_VALUES() {
  return getToken(TSqlParser::INCLUDE_NULL_VALUES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INPUT() {
  return getToken(TSqlParser::INPUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INSENSITIVE() {
  return getToken(TSqlParser::INSENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INSERTED() {
  return getToken(TSqlParser::INSERTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INT() {
  return getToken(TSqlParser::INT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ISOLATION() {
  return getToken(TSqlParser::ISOLATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::KEEP() {
  return getToken(TSqlParser::KEEP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::KEEPFIXED() {
  return getToken(TSqlParser::KEEPFIXED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::KEYSET() {
  return getToken(TSqlParser::KEYSET, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LAG() {
  return getToken(TSqlParser::LAG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LAST() {
  return getToken(TSqlParser::LAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LAST_VALUE() {
  return getToken(TSqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LEAD() {
  return getToken(TSqlParser::LEAD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LEVEL() {
  return getToken(TSqlParser::LEVEL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCAL() {
  return getToken(TSqlParser::LOCAL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCATION() {
  return getToken(TSqlParser::LOCATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCK() {
  return getToken(TSqlParser::LOCK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOCK_ESCALATION() {
  return getToken(TSqlParser::LOCK_ESCALATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOOP() {
  return getToken(TSqlParser::LOOP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOW() {
  return getToken(TSqlParser::LOW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MANUAL() {
  return getToken(TSqlParser::MANUAL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MARK() {
  return getToken(TSqlParser::MARK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAX() {
  return getToken(TSqlParser::MAX, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAXDOP() {
  return getToken(TSqlParser::MAXDOP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAXRECURSION() {
  return getToken(TSqlParser::MAXRECURSION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MIN() {
  return getToken(TSqlParser::MIN, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MINUTES() {
  return getToken(TSqlParser::MINUTES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MODE() {
  return getToken(TSqlParser::MODE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NEXT() {
  return getToken(TSqlParser::NEXT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NO() {
  return getToken(TSqlParser::NO, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOCOUNT() {
  return getToken(TSqlParser::NOCOUNT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NODES() {
  return getToken(TSqlParser::NODES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOEXPAND() {
  return getToken(TSqlParser::NOEXPAND, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOWAIT() {
  return getToken(TSqlParser::NOWAIT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NTILE() {
  return getToken(TSqlParser::NTILE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NUMANODE() {
  return getToken(TSqlParser::NUMANODE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NUMERIC_ROUNDABORT() {
  return getToken(TSqlParser::NUMERIC_ROUNDABORT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OBJECT() {
  return getToken(TSqlParser::OBJECT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OFFSET() {
  return getToken(TSqlParser::OFFSET, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ONLINE() {
  return getToken(TSqlParser::ONLINE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ONLY() {
  return getToken(TSqlParser::ONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OPTIMISTIC() {
  return getToken(TSqlParser::OPTIMISTIC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OPTIMIZE() {
  return getToken(TSqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OUT() {
  return getToken(TSqlParser::OUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OUTPUT() {
  return getToken(TSqlParser::OUTPUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::OWNER() {
  return getToken(TSqlParser::OWNER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PARAMETERIZATION() {
  return getToken(TSqlParser::PARAMETERIZATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PARTITION() {
  return getToken(TSqlParser::PARTITION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PARTITIONS() {
  return getToken(TSqlParser::PARTITIONS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PRECEDING() {
  return getToken(TSqlParser::PRECEDING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PRIOR() {
  return getToken(TSqlParser::PRIOR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::QUERY() {
  return getToken(TSqlParser::QUERY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::QUOTED_IDENTIFIER() {
  return getToken(TSqlParser::QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RANGE() {
  return getToken(TSqlParser::RANGE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RANK() {
  return getToken(TSqlParser::RANK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RC2() {
  return getToken(TSqlParser::RC2, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RC4() {
  return getToken(TSqlParser::RC4, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RC4_128() {
  return getToken(TSqlParser::RC4_128, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::READ_ONLY() {
  return getToken(TSqlParser::READ_ONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::READONLY() {
  return getToken(TSqlParser::READONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::REBUILD() {
  return getToken(TSqlParser::REBUILD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RECOMPILE() {
  return getToken(TSqlParser::RECOMPILE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RELATIVE() {
  return getToken(TSqlParser::RELATIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::REMOTE() {
  return getToken(TSqlParser::REMOTE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::REPEATABLE() {
  return getToken(TSqlParser::REPEATABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROBUST() {
  return getToken(TSqlParser::ROBUST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROW() {
  return getToken(TSqlParser::ROW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROW_NUMBER() {
  return getToken(TSqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROWGUID() {
  return getToken(TSqlParser::ROWGUID, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ROWS() {
  return getToken(TSqlParser::ROWS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SCHEMABINDING() {
  return getToken(TSqlParser::SCHEMABINDING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SCROLL() {
  return getToken(TSqlParser::SCROLL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SCROLL_LOCKS() {
  return getToken(TSqlParser::SCROLL_LOCKS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SECONDS() {
  return getToken(TSqlParser::SECONDS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SELF() {
  return getToken(TSqlParser::SELF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SEMI_SENSITIVE() {
  return getToken(TSqlParser::SEMI_SENSITIVE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SEQUENCE() {
  return getToken(TSqlParser::SEQUENCE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SERIALIZABLE() {
  return getToken(TSqlParser::SERIALIZABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SETERROR() {
  return getToken(TSqlParser::SETERROR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SHARE() {
  return getToken(TSqlParser::SHARE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SIMPLE() {
  return getToken(TSqlParser::SIMPLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SIZE() {
  return getToken(TSqlParser::SIZE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SMALLINT() {
  return getToken(TSqlParser::SMALLINT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SNAPSHOT() {
  return getToken(TSqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SPATIAL_WINDOW_MAX_CELLS() {
  return getToken(TSqlParser::SPATIAL_WINDOW_MAX_CELLS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STATIC() {
  return getToken(TSqlParser::STATIC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STATUSONLY() {
  return getToken(TSqlParser::STATUSONLY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STDEV() {
  return getToken(TSqlParser::STDEV, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STDEVP() {
  return getToken(TSqlParser::STDEVP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STRING_AGG() {
  return getToken(TSqlParser::STRING_AGG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STUFF() {
  return getToken(TSqlParser::STUFF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SUBSCRIPTION() {
  return getToken(TSqlParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SUM() {
  return getToken(TSqlParser::SUM, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TEXTIMAGE_ON() {
  return getToken(TSqlParser::TEXTIMAGE_ON, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::THROW() {
  return getToken(TSqlParser::THROW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TIES() {
  return getToken(TSqlParser::TIES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TIME() {
  return getToken(TSqlParser::TIME, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TIMEOUT() {
  return getToken(TSqlParser::TIMEOUT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TINYINT() {
  return getToken(TSqlParser::TINYINT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRIPLE_DES() {
  return getToken(TSqlParser::TRIPLE_DES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRIPLE_DES_3KEY() {
  return getToken(TSqlParser::TRIPLE_DES_3KEY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRY() {
  return getToken(TSqlParser::TRY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TWO_DIGIT_YEAR_CUTOFF() {
  return getToken(TSqlParser::TWO_DIGIT_YEAR_CUTOFF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TYPE() {
  return getToken(TSqlParser::TYPE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TYPE_WARNING() {
  return getToken(TSqlParser::TYPE_WARNING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UNBOUNDED() {
  return getToken(TSqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UNCOMMITTED() {
  return getToken(TSqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UNKNOWN() {
  return getToken(TSqlParser::UNKNOWN, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::UOW() {
  return getToken(TSqlParser::UOW, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::USING() {
  return getToken(TSqlParser::USING, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VAR() {
  return getToken(TSqlParser::VAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VARP() {
  return getToken(TSqlParser::VARP, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::WAIT() {
  return getToken(TSqlParser::WAIT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::WORK() {
  return getToken(TSqlParser::WORK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BLOCKING_HIERARCHY() {
  return getToken(TSqlParser::BLOCKING_HIERARCHY, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CACHE() {
  return getToken(TSqlParser::CACHE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CALLED() {
  return getToken(TSqlParser::CALLED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHANGETABLE() {
  return getToken(TSqlParser::CHANGETABLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHANGES() {
  return getToken(TSqlParser::CHANGES, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CUME_DIST() {
  return getToken(TSqlParser::CUME_DIST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CYCLE() {
  return getToken(TSqlParser::CYCLE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::DATA_COMPRESSION() {
  return getToken(TSqlParser::DATA_COMPRESSION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ERROR() {
  return getToken(TSqlParser::ERROR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::FORCESEEK() {
  return getToken(TSqlParser::FORCESEEK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::IIF() {
  return getToken(TSqlParser::IIF, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::INCREMENT() {
  return getToken(TSqlParser::INCREMENT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ISNULL() {
  return getToken(TSqlParser::ISNULL, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::LOG() {
  return getToken(TSqlParser::LOG, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MATCHED() {
  return getToken(TSqlParser::MATCHED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MAXVALUE() {
  return getToken(TSqlParser::MAXVALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::MINVALUE() {
  return getToken(TSqlParser::MINVALUE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NOTIFICATION() {
  return getToken(TSqlParser::NOTIFICATION, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERCENTILE_CONT() {
  return getToken(TSqlParser::PERCENTILE_CONT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERCENTILE_DISC() {
  return getToken(TSqlParser::PERCENTILE_DISC, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERCENT_RANK() {
  return getToken(TSqlParser::PERCENT_RANK, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PERSISTED() {
  return getToken(TSqlParser::PERSISTED, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PREDICATE() {
  return getToken(TSqlParser::PREDICATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RESTART() {
  return getToken(TSqlParser::RESTART, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::RETURNS() {
  return getToken(TSqlParser::RETURNS, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::SOURCE() {
  return getToken(TSqlParser::SOURCE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::STATE() {
  return getToken(TSqlParser::STATE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::START() {
  return getToken(TSqlParser::START, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TARGET() {
  return getToken(TSqlParser::TARGET, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TRY_CAST() {
  return getToken(TSqlParser::TRY_CAST, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::ZONE() {
  return getToken(TSqlParser::ZONE, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::TEXT() {
  return getToken(TSqlParser::TEXT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NTEXT() {
  return getToken(TSqlParser::NTEXT, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::CHAR() {
  return getToken(TSqlParser::CHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NCHAR() {
  return getToken(TSqlParser::NCHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VARCHAR() {
  return getToken(TSqlParser::VARCHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::NVARCHAR() {
  return getToken(TSqlParser::NVARCHAR, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::BINARY_KEYWORD() {
  return getToken(TSqlParser::BINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::VARBINARY_KEYWORD() {
  return getToken(TSqlParser::VARBINARY_KEYWORD, 0);
}

tree::TerminalNode* TSqlParser::KeywordContext::PRECISION() {
  return getToken(TSqlParser::PRECISION, 0);
}


size_t TSqlParser::KeywordContext::getRuleIndex() const {
  return TSqlParser::RuleKeyword;
}

void TSqlParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void TSqlParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}

TSqlParser::KeywordContext* TSqlParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 420, TSqlParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3789);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 805339152) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & -17592186044415) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & -1) != 0) || ((((_la - 250) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 250)) & -8193) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & -93469483477237761) != 0) || ((((_la - 378) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 378)) & 28351) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Id_Context ------------------------------------------------------------------

TSqlParser::Id_Context::Id_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Id_Context::ID() {
  return getToken(TSqlParser::ID, 0);
}

tree::TerminalNode* TSqlParser::Id_Context::DOUBLE_QUOTE_ID() {
  return getToken(TSqlParser::DOUBLE_QUOTE_ID, 0);
}

tree::TerminalNode* TSqlParser::Id_Context::SQUARE_BRACKET_ID() {
  return getToken(TSqlParser::SQUARE_BRACKET_ID, 0);
}

TSqlParser::KeywordContext* TSqlParser::Id_Context::keyword() {
  return getRuleContext<TSqlParser::KeywordContext>(0);
}


size_t TSqlParser::Id_Context::getRuleIndex() const {
  return TSqlParser::RuleId_;
}

void TSqlParser::Id_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterId_(this);
}

void TSqlParser::Id_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitId_(this);
}

TSqlParser::Id_Context* TSqlParser::id_() {
  Id_Context *_localctx = _tracker.createInstance<Id_Context>(_ctx, getState());
  enterRule(_localctx, 422, TSqlParser::RuleId_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3795);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3791);
        match(TSqlParser::ID);
        break;
      }

      case TSqlParser::DOUBLE_QUOTE_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3792);
        match(TSqlParser::DOUBLE_QUOTE_ID);
        break;
      }

      case TSqlParser::SQUARE_BRACKET_ID: {
        enterOuterAlt(_localctx, 3);
        setState(3793);
        match(TSqlParser::SQUARE_BRACKET_ID);
        break;
      }

      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR: {
        enterOuterAlt(_localctx, 4);
        setState(3794);
        keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_idContext ------------------------------------------------------------------

TSqlParser::Simple_idContext::Simple_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Simple_idContext::ID() {
  return getToken(TSqlParser::ID, 0);
}


size_t TSqlParser::Simple_idContext::getRuleIndex() const {
  return TSqlParser::RuleSimple_id;
}

void TSqlParser::Simple_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_id(this);
}

void TSqlParser::Simple_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_id(this);
}

TSqlParser::Simple_idContext* TSqlParser::simple_id() {
  Simple_idContext *_localctx = _tracker.createInstance<Simple_idContext>(_ctx, getState());
  enterRule(_localctx, 424, TSqlParser::RuleSimple_id);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3797);
    match(TSqlParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Id_or_stringContext ------------------------------------------------------------------

TSqlParser::Id_or_stringContext::Id_or_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

TSqlParser::Id_Context* TSqlParser::Id_or_stringContext::id_() {
  return getRuleContext<TSqlParser::Id_Context>(0);
}

tree::TerminalNode* TSqlParser::Id_or_stringContext::STRING() {
  return getToken(TSqlParser::STRING, 0);
}


size_t TSqlParser::Id_or_stringContext::getRuleIndex() const {
  return TSqlParser::RuleId_or_string;
}

void TSqlParser::Id_or_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterId_or_string(this);
}

void TSqlParser::Id_or_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitId_or_string(this);
}

TSqlParser::Id_or_stringContext* TSqlParser::id_or_string() {
  Id_or_stringContext *_localctx = _tracker.createInstance<Id_or_stringContext>(_ctx, getState());
  enterRule(_localctx, 426, TSqlParser::RuleId_or_string);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3801);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case TSqlParser::CHAR:
      case TSqlParser::NCHAR:
      case TSqlParser::TEXT:
      case TSqlParser::NTEXT:
      case TSqlParser::PRECISION:
      case TSqlParser::ABSOLUTE:
      case TSqlParser::AT_KEYWORD:
      case TSqlParser::ACTION:
      case TSqlParser::AES_128:
      case TSqlParser::AES_192:
      case TSqlParser::AES_256:
      case TSqlParser::ALGORITHM:
      case TSqlParser::ANSI_NULLS:
      case TSqlParser::ANSI_PADDING:
      case TSqlParser::ANSI_WARNINGS:
      case TSqlParser::APPLY:
      case TSqlParser::ARITHABORT:
      case TSqlParser::AUTO:
      case TSqlParser::AVG:
      case TSqlParser::BIGINT:
      case TSqlParser::BINARY_KEYWORD:
      case TSqlParser::BINARY_BASE64:
      case TSqlParser::BINARY_CHECKSUM:
      case TSqlParser::CALLER:
      case TSqlParser::CAST:
      case TSqlParser::TRY_CAST:
      case TSqlParser::CATCH:
      case TSqlParser::CHECKSUM:
      case TSqlParser::CHECKSUM_AGG:
      case TSqlParser::COMMITTED:
      case TSqlParser::CONCAT:
      case TSqlParser::CONCAT_NULL_YIELDS_NULL:
      case TSqlParser::COUNT:
      case TSqlParser::COUNT_BIG:
      case TSqlParser::CUME_DIST:
      case TSqlParser::CURSOR_CLOSE_ON_COMMIT:
      case TSqlParser::CURSOR_DEFAULT:
      case TSqlParser::DATA:
      case TSqlParser::DATEADD:
      case TSqlParser::DATEDIFF:
      case TSqlParser::DATENAME:
      case TSqlParser::DATEPART:
      case TSqlParser::DAYS:
      case TSqlParser::DEFAULT_DOUBLE_QUOTE:
      case TSqlParser::DELAY:
      case TSqlParser::DELAYED_DURABILITY:
      case TSqlParser::DELETED:
      case TSqlParser::DENSE_RANK:
      case TSqlParser::DES:
      case TSqlParser::DESCRIPTION:
      case TSqlParser::DESX:
      case TSqlParser::DISABLE:
      case TSqlParser::DYNAMIC:
      case TSqlParser::ELEMENTS:
      case TSqlParser::EMPTY:
      case TSqlParser::ENCRYPTION:
      case TSqlParser::EXCLUSIVE:
      case TSqlParser::FAST:
      case TSqlParser::FAST_FORWARD:
      case TSqlParser::FIRST:
      case TSqlParser::FIRST_VALUE:
      case TSqlParser::FOLLOWING:
      case TSqlParser::FORCE:
      case TSqlParser::FORCED:
      case TSqlParser::FORWARD_ONLY:
      case TSqlParser::GETDATE:
      case TSqlParser::GETUTCDATE:
      case TSqlParser::GLOBAL:
      case TSqlParser::GO_BATCH:
      case TSqlParser::GO:
      case TSqlParser::GROUPING:
      case TSqlParser::GROUPING_ID:
      case TSqlParser::HASH:
      case TSqlParser::HIGH:
      case TSqlParser::HOURS:
      case TSqlParser::IDENTITY_VALUE:
      case TSqlParser::INCLUDE_NULL_VALUES:
      case TSqlParser::INPUT:
      case TSqlParser::INSENSITIVE:
      case TSqlParser::INSERTED:
      case TSqlParser::INT:
      case TSqlParser::ISOLATION:
      case TSqlParser::KEEP:
      case TSqlParser::KEEPFIXED:
      case TSqlParser::KEYSET:
      case TSqlParser::LAG:
      case TSqlParser::LAST:
      case TSqlParser::LAST_VALUE:
      case TSqlParser::LEAD:
      case TSqlParser::LEVEL:
      case TSqlParser::LOCAL:
      case TSqlParser::LOCATION:
      case TSqlParser::LOCK:
      case TSqlParser::LOCK_ESCALATION:
      case TSqlParser::LOOP:
      case TSqlParser::LOW:
      case TSqlParser::MANUAL:
      case TSqlParser::MARK:
      case TSqlParser::MAX:
      case TSqlParser::MAXDOP:
      case TSqlParser::MAXRECURSION:
      case TSqlParser::MIN:
      case TSqlParser::MINUTES:
      case TSqlParser::MODE:
      case TSqlParser::NEXT:
      case TSqlParser::NO:
      case TSqlParser::NOCOUNT:
      case TSqlParser::NODES:
      case TSqlParser::NOEXPAND:
      case TSqlParser::NOWAIT:
      case TSqlParser::NTILE:
      case TSqlParser::NUMANODE:
      case TSqlParser::NUMERIC_ROUNDABORT:
      case TSqlParser::OBJECT:
      case TSqlParser::OFFSET:
      case TSqlParser::ONLINE:
      case TSqlParser::ONLY:
      case TSqlParser::OPTIMISTIC:
      case TSqlParser::OPTIMIZE:
      case TSqlParser::OUT:
      case TSqlParser::OUTPUT:
      case TSqlParser::OWNER:
      case TSqlParser::PARAMETERIZATION:
      case TSqlParser::PARTITION:
      case TSqlParser::PARTITIONS:
      case TSqlParser::PERCENT_RANK:
      case TSqlParser::PERCENTILE_CONT:
      case TSqlParser::PERCENTILE_DISC:
      case TSqlParser::PRECEDING:
      case TSqlParser::PRIOR:
      case TSqlParser::QUERY:
      case TSqlParser::QUOTED_IDENTIFIER:
      case TSqlParser::RANGE:
      case TSqlParser::RANK:
      case TSqlParser::RC2:
      case TSqlParser::RC4:
      case TSqlParser::RC4_128:
      case TSqlParser::READ_ONLY:
      case TSqlParser::READONLY:
      case TSqlParser::REBUILD:
      case TSqlParser::RECOMPILE:
      case TSqlParser::RELATIVE:
      case TSqlParser::REMOTE:
      case TSqlParser::REPEATABLE:
      case TSqlParser::ROBUST:
      case TSqlParser::ROW:
      case TSqlParser::ROW_NUMBER:
      case TSqlParser::ROWGUID:
      case TSqlParser::ROWS:
      case TSqlParser::SCHEMABINDING:
      case TSqlParser::SCROLL:
      case TSqlParser::SCROLL_LOCKS:
      case TSqlParser::SECONDS:
      case TSqlParser::SELF:
      case TSqlParser::SEMI_SENSITIVE:
      case TSqlParser::SEQUENCE:
      case TSqlParser::SERIALIZABLE:
      case TSqlParser::SETERROR:
      case TSqlParser::SHARE:
      case TSqlParser::SIMPLE:
      case TSqlParser::SIZE:
      case TSqlParser::SMALLINT:
      case TSqlParser::SNAPSHOT:
      case TSqlParser::SPATIAL_WINDOW_MAX_CELLS:
      case TSqlParser::STATIC:
      case TSqlParser::STATUSONLY:
      case TSqlParser::STDEV:
      case TSqlParser::STDEVP:
      case TSqlParser::STRING_AGG:
      case TSqlParser::STUFF:
      case TSqlParser::SUBSCRIPTION:
      case TSqlParser::SUM:
      case TSqlParser::TEXTIMAGE_ON:
      case TSqlParser::THROW:
      case TSqlParser::TIES:
      case TSqlParser::TIME:
      case TSqlParser::TIMEOUT:
      case TSqlParser::TINYINT:
      case TSqlParser::TRIPLE_DES:
      case TSqlParser::TRIPLE_DES_3KEY:
      case TSqlParser::TRY:
      case TSqlParser::TWO_DIGIT_YEAR_CUTOFF:
      case TSqlParser::TYPE:
      case TSqlParser::TYPE_WARNING:
      case TSqlParser::UNBOUNDED:
      case TSqlParser::UNCOMMITTED:
      case TSqlParser::UNKNOWN:
      case TSqlParser::UOW:
      case TSqlParser::USING:
      case TSqlParser::VAR:
      case TSqlParser::VARBINARY_KEYWORD:
      case TSqlParser::VARP:
      case TSqlParser::WAIT:
      case TSqlParser::WORK:
      case TSqlParser::ZONE:
      case TSqlParser::BLOCKING_HIERARCHY:
      case TSqlParser::CACHE:
      case TSqlParser::CALLED:
      case TSqlParser::CHANGETABLE:
      case TSqlParser::CHANGES:
      case TSqlParser::CYCLE:
      case TSqlParser::DATA_COMPRESSION:
      case TSqlParser::ERROR:
      case TSqlParser::FORCESEEK:
      case TSqlParser::IIF:
      case TSqlParser::INCREMENT:
      case TSqlParser::ISNULL:
      case TSqlParser::LOG:
      case TSqlParser::MATCHED:
      case TSqlParser::MAXVALUE:
      case TSqlParser::MINVALUE:
      case TSqlParser::NOTIFICATION:
      case TSqlParser::PERSISTED:
      case TSqlParser::PREDICATE:
      case TSqlParser::RESTART:
      case TSqlParser::RETURNS:
      case TSqlParser::SOURCE:
      case TSqlParser::STATE:
      case TSqlParser::START:
      case TSqlParser::TARGET:
      case TSqlParser::VARCHAR:
      case TSqlParser::NVARCHAR:
      case TSqlParser::DOUBLE_QUOTE_ID:
      case TSqlParser::SQUARE_BRACKET_ID:
      case TSqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3799);
        id_();
        break;
      }

      case TSqlParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(3800);
        match(TSqlParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comparison_operatorContext ------------------------------------------------------------------

TSqlParser::Comparison_operatorContext::Comparison_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::EQUAL() {
  return getToken(TSqlParser::EQUAL, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::GREATER() {
  return getToken(TSqlParser::GREATER, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::LESS() {
  return getToken(TSqlParser::LESS, 0);
}

tree::TerminalNode* TSqlParser::Comparison_operatorContext::EXCLAMATION() {
  return getToken(TSqlParser::EXCLAMATION, 0);
}


size_t TSqlParser::Comparison_operatorContext::getRuleIndex() const {
  return TSqlParser::RuleComparison_operator;
}

void TSqlParser::Comparison_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison_operator(this);
}

void TSqlParser::Comparison_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison_operator(this);
}

TSqlParser::Comparison_operatorContext* TSqlParser::comparison_operator() {
  Comparison_operatorContext *_localctx = _tracker.createInstance<Comparison_operatorContext>(_ctx, getState());
  enterRule(_localctx, 428, TSqlParser::RuleComparison_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3818);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 549, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3803);
      match(TSqlParser::EQUAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3804);
      match(TSqlParser::GREATER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3805);
      match(TSqlParser::LESS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3806);
      match(TSqlParser::LESS);
      setState(3807);
      match(TSqlParser::EQUAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3808);
      match(TSqlParser::GREATER);
      setState(3809);
      match(TSqlParser::EQUAL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3810);
      match(TSqlParser::LESS);
      setState(3811);
      match(TSqlParser::GREATER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3812);
      match(TSqlParser::EXCLAMATION);
      setState(3813);
      match(TSqlParser::EQUAL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3814);
      match(TSqlParser::EXCLAMATION);
      setState(3815);
      match(TSqlParser::GREATER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3816);
      match(TSqlParser::EXCLAMATION);
      setState(3817);
      match(TSqlParser::LESS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_operatorContext ------------------------------------------------------------------

TSqlParser::Assignment_operatorContext::Assignment_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::PLUS_ASSIGN() {
  return getToken(TSqlParser::PLUS_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MINUS_ASSIGN() {
  return getToken(TSqlParser::MINUS_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MULT_ASSIGN() {
  return getToken(TSqlParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::DIV_ASSIGN() {
  return getToken(TSqlParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::MOD_ASSIGN() {
  return getToken(TSqlParser::MOD_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::AND_ASSIGN() {
  return getToken(TSqlParser::AND_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::XOR_ASSIGN() {
  return getToken(TSqlParser::XOR_ASSIGN, 0);
}

tree::TerminalNode* TSqlParser::Assignment_operatorContext::OR_ASSIGN() {
  return getToken(TSqlParser::OR_ASSIGN, 0);
}


size_t TSqlParser::Assignment_operatorContext::getRuleIndex() const {
  return TSqlParser::RuleAssignment_operator;
}

void TSqlParser::Assignment_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_operator(this);
}

void TSqlParser::Assignment_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<TSqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_operator(this);
}

TSqlParser::Assignment_operatorContext* TSqlParser::assignment_operator() {
  Assignment_operatorContext *_localctx = _tracker.createInstance<Assignment_operatorContext>(_ctx, getState());
  enterRule(_localctx, 430, TSqlParser::RuleAssignment_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3820);
    _la = _input->LA(1);
    if (!(((((_la - 410) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 410)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool TSqlParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 105: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 117: return search_conditionSempred(antlrcpp::downCast<Search_conditionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool TSqlParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 5);
    case 1: return precpred(_ctx, 4);
    case 2: return precpred(_ctx, 10);
    case 3: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool TSqlParser::search_conditionSempred(Search_conditionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void TSqlParser::initialize() {
  ::antlr4::internal::call_once(tsqlparserParserOnceFlag, tsqlparserParserInitialize);
}
